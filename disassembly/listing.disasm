Disassembly Listing for Rosmeter
Generated From:
D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/dist/default/debug/Rosmeter.X.debug.elf
26-lug-2013 12.34.23

---  D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/vincent.c  ------------------------------------
1:                 #include "vincent.h"
2:                 
3:                 const char vincentData[][8] = {
4:                   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
5:                   { 0x00, 0x3E, 0x41, 0x55, 0x41, 0x55, 0x49, 0x3E },
6:                   { 0x00, 0x3E, 0x7F, 0x6B, 0x7F, 0x6B, 0x77, 0x3E },
7:                   { 0x00, 0x22, 0x77, 0x7F, 0x7F, 0x3E, 0x1C, 0x08 },
8:                   { 0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08 },
9:                   { 0x00, 0x08, 0x1C, 0x2A, 0x7F, 0x2A, 0x08, 0x1C },
10:                  { 0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x08, 0x1C },
11:                  { 0x00, 0x00, 0x1C, 0x3E, 0x3E, 0x3E, 0x1C, 0x00 },
12:                  { 0xFF, 0xFF, 0xE3, 0xC1, 0xC1, 0xC1, 0xE3, 0xFF },
13:                  { 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00 },
14:                  { 0xFF, 0xFF, 0xE3, 0xDD, 0xDD, 0xDD, 0xE3, 0xFF },
15:                  { 0x00, 0x0F, 0x03, 0x05, 0x39, 0x48, 0x48, 0x30 },
16:                  { 0x00, 0x08, 0x3E, 0x08, 0x1C, 0x22, 0x22, 0x1C },
17:                  { 0x00, 0x18, 0x14, 0x10, 0x10, 0x30, 0x70, 0x60 },
18:                  { 0x00, 0x0F, 0x19, 0x11, 0x13, 0x37, 0x76, 0x60 },
19:                  { 0x00, 0x08, 0x2A, 0x1C, 0x77, 0x1C, 0x2A, 0x08 },
20:                  { 0x00, 0x60, 0x78, 0x7E, 0x7F, 0x7E, 0x78, 0x60 },
21:                  { 0x00, 0x03, 0x0F, 0x3F, 0x7F, 0x3F, 0x0F, 0x03 },
22:                  { 0x00, 0x08, 0x1C, 0x2A, 0x08, 0x2A, 0x1C, 0x08 },
23:                  { 0x00, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66 },
24:                  { 0x00, 0x3F, 0x65, 0x65, 0x3D, 0x05, 0x05, 0x05 },
25:                  { 0x00, 0x0C, 0x32, 0x48, 0x24, 0x12, 0x4C, 0x30 },
26:                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x7F },
27:                  { 0x00, 0x08, 0x1C, 0x2A, 0x08, 0x2A, 0x1C, 0x3E },
28:                  { 0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x1C, 0x1C, 0x1C },
29:                  { 0x00, 0x1C, 0x1C, 0x1C, 0x7F, 0x3E, 0x1C, 0x08 },
30:                  { 0x00, 0x08, 0x0C, 0x7E, 0x7F, 0x7E, 0x0C, 0x08 },
31:                  { 0x00, 0x08, 0x18, 0x3F, 0x7F, 0x3F, 0x18, 0x08 },
32:                  { 0x00, 0x00, 0x00, 0x70, 0x70, 0x70, 0x7F, 0x7F },
33:                  { 0x00, 0x00, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x00 },
34:                  { 0x00, 0x08, 0x1C, 0x1C, 0x3E, 0x3E, 0x7F, 0x7F },
35:                  { 0x00, 0x7F, 0x7F, 0x3E, 0x3E, 0x1C, 0x1C, 0x08 },
36:                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
37:                  { 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18 },
38:                  { 0x00, 0x36, 0x36, 0x14, 0x00, 0x00, 0x00, 0x00 },
39:                  { 0x00, 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36 },
40:                  { 0x00, 0x08, 0x1E, 0x20, 0x1C, 0x02, 0x3C, 0x08 },
41:                  { 0x00, 0x60, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x06 },
42:                  { 0x00, 0x3C, 0x66, 0x3C, 0x28, 0x65, 0x66, 0x3F },
43:                  { 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00 },
44:                  { 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60 },
45:                  { 0x00, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06 },
46:                  { 0x00, 0x00, 0x36, 0x1C, 0x7F, 0x1C, 0x36, 0x00 },
47:                  { 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00 },
48:                  { 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60 },
49:                  { 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00 },
50:                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60 },
51:                  { 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00 },
52:                  { 0x00, 0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C },
53:                  { 0x00, 0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E },
54:                  { 0x00, 0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E },
55:                  { 0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C },
56:                  { 0x00, 0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x0C },
57:                  { 0x00, 0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C },
58:                  { 0x00, 0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C },
59:                  { 0x00, 0x7E, 0x66, 0x0C, 0x0C, 0x18, 0x18, 0x18 },
60:                  { 0x00, 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C },
61:                  { 0x00, 0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C },
62:                  { 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00 },
63:                  { 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30 },
64:                  { 0x00, 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06 },
65:                  { 0x00, 0x00, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x00 },
66:                  { 0x00, 0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60 },
67:                  { 0x00, 0x3C, 0x66, 0x06, 0x1C, 0x18, 0x00, 0x18 },
68:                  { 0x00, 0x38, 0x44, 0x5C, 0x58, 0x42, 0x3C, 0x00 },
69:                  { 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66 },
70:                  { 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C },
71:                  { 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C },
72:                  { 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C },
73:                  { 0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E },
74:                  { 0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60 },
75:                  { 0x00, 0x3C, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x3C },
76:                  { 0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66 },
77:                  { 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C },
78:                  { 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38 },
79:                  { 0x00, 0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66 },
80:                  { 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E },
81:                  { 0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63 },
82:                  { 0x00, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x63, 0x63 },
83:                  { 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C },
84:                  { 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60 },
85:                  { 0x00, 0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x06 },
86:                  { 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66 },
87:                  { 0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C },
88:                  { 0x00, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18 },
89:                  { 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E },
90:                  { 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18 },
91:                  { 0x00, 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63 },
92:                  { 0x00, 0x63, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x63 },
93:                  { 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18 },
94:                  { 0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E },
95:                  { 0x00, 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E },
96:                  { 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00 },
97:                  { 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78 },
98:                  { 0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00 },
99:                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F },
100:                 { 0x00, 0x0C, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00 },
101:                 { 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E },
102:                 { 0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C },
103:                 { 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C },
104:                 { 0x00, 0x06, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3E },
105:                 { 0x00, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C },
106:                 { 0x00, 0x1C, 0x36, 0x30, 0x30, 0x7C, 0x30, 0x30 },
107:                 { 0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C },
108:                 { 0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66 },
109:                 { 0x00, 0x00, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C },
110:                 { 0x00, 0x0C, 0x00, 0x0C, 0x0C, 0x6C, 0x6C, 0x38 },
111:                 { 0x00, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66 },
112:                 { 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 },
113:                 { 0x00, 0x00, 0x00, 0x63, 0x77, 0x7F, 0x6B, 0x6B },
114:                 { 0x00, 0x00, 0x00, 0x7C, 0x7E, 0x66, 0x66, 0x66 },
115:                 { 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C },
116:                 { 0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60 },
117:                 { 0x00, 0x00, 0x3C, 0x6C, 0x6C, 0x3C, 0x0D, 0x0F },
118:                 { 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x60, 0x60 },
119:                 { 0x00, 0x00, 0x00, 0x3E, 0x40, 0x3C, 0x02, 0x7C },
120:                 { 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18 },
121:                 { 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E },
122:                 { 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18 },
123:                 { 0x00, 0x00, 0x00, 0x63, 0x6B, 0x6B, 0x6B, 0x3E },
124:                 { 0x00, 0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66 },
125:                 { 0x00, 0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x3C },
126:                 { 0x00, 0x00, 0x00, 0x3C, 0x0C, 0x18, 0x30, 0x3C },
127:                 { 0x00, 0x0E, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0E },
128:                 { 0x00, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18 },
129:                 { 0x00, 0x70, 0x18, 0x18, 0x0C, 0x18, 0x18, 0x70 },
130:                 { 0x00, 0x00, 0x00, 0x3A, 0x6C, 0x00, 0x00, 0x00 },
131:                 { 0x00, 0x08, 0x1C, 0x36, 0x63, 0x41, 0x41, 0x7F }
132:               };
133:               
134:               vincentChar getCharVincent (char code)
135:               {
00C500  FA004C     LNK #0x4C
00C502  98CF21     MOV.B W1, [W14+74]
136:               char *act;
137:               vincentChar ris;
138:               int i,j;
139:               
140:                   act = vincentData[code];
00C504  2CE462     MOV #0xCE46, W2
00C506  90C8AE     MOV.B [W14+74], W1
00C508  FB0081     SE W1, W1
00C50A  DD08C3     SL W1, #3, W1
00C50C  410081     ADD W2, W1, W1
00C50E  980721     MOV W1, [W14+4]
141:               
142:                   for (i = 0; i < CHAR_HEIGHT; i++)
00C510  EB0080     CLR W1
00C512  780F01     MOV W1, [W14]
00C514  37002C     BRA 0xC56E
00C56C  E80F1E     INC [W14], [W14]
00C56E  78009E     MOV [W14], W1
00C570  508FE7     SUB W1, #0x7, [W15]
00C572  34FFD1     BRA LE, 0xC516
143:                   {
144:                       for (j = 0; j < CHAR_WIDTH; j++)
00C516  EB0080     CLR W1
00C518  980711     MOV W1, [W14+2]
00C51A  370025     BRA 0xC566
00C560  90009E     MOV [W14+2], W1
00C562  E80081     INC W1, W1
00C564  980711     MOV W1, [W14+2]
00C566  90009E     MOV [W14+2], W1
00C568  508FE7     SUB W1, #0x7, [W15]
00C56A  34FFD8     BRA LE, 0xC51C
145:                       {
146:                       char mask = 0x01, actChar = act[i], maskResult, offset = CHAR_WIDTH - j - 1;
00C51C  B3C011     MOV #0x1, W1
00C51E  984761     MOV.B W1, [W14+6]
00C520  78009E     MOV [W14], W1
00C522  90012E     MOV [W14+4], W2
00C524  410081     ADD W2, W1, W1
00C526  784111     MOV.B [W1], W2
00C528  984772     MOV.B W2, [W14+7]
00C52A  90009E     MOV [W14+2], W1
00C52C  784081     MOV.B W1, W1
00C52E  B3C072     MOV #0x7, W2
00C530  514081     SUB.B W2, W1, W1
00C532  984F01     MOV.B W1, [W14+8]
147:               
148:                           mask = mask << offset;
00C534  9040EE     MOV.B [W14+6], W1
00C536  FB0101     SE W1, W2
00C538  90488E     MOV.B [W14+8], W1
00C53A  FB0081     SE W1, W1
00C53C  DD1081     SL W2, W1, W1
00C53E  984761     MOV.B W1, [W14+6]
149:               
150:                           maskResult = (actChar & mask) >> offset;
00C540  90417E     MOV.B [W14+7], W2
00C542  9040EE     MOV.B [W14+6], W1
00C544  614081     AND.B W2, W1, W1
00C546  FB0101     SE W1, W2
00C548  90488E     MOV.B [W14+8], W1
00C54A  FB0081     SE W1, W1
00C54C  DE9081     ASR W2, W1, W1
00C54E  984F11     MOV.B W1, [W14+9]
151:               
152:                           ris.pixelMatrix[i][j] = maskResult;
00C550  78009E     MOV [W14], W1
00C552  DD08C3     SL W1, #3, W1
00C554  470101     ADD W14, W1, W2
00C556  90009E     MOV [W14+2], W1
00C558  410081     ADD W2, W1, W1
00C55A  4080EA     ADD W1, #0xA, W1
00C55C  90491E     MOV.B [W14+9], W2
00C55E  784882     MOV.B W2, [W1]
153:                       }
154:                   }
155:               
156:                   return ris;
00C574  78008E     MOV W14, W1
00C576  B000A1     ADD #0xA, W1
00C578  09003F     REPEAT #0x3F
00C57A  785831     MOV.B [W1++], [W0++]
00C57C  B10400     SUB #0x40, W0
157:               }
00C57E  FA8000     ULNK
00C580  060000     RETURN
---  D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/main.c  ---------------------------------------
1:                 
2:                 #include "config.h"
3:                 
4:                 #include "globalPinout.h"
5:                 
6:                 #include "controls.h"
7:                 
8:                 #include <xc.h>
9:                 #include <p33fj128mc802.h>
10:                #include <stdlib.h>
11:                #include <math.h>
12:                
13:                #include "rampControl.h"
14:                #include "rosmeterControl.h"
15:                
16:                #include "timeMeasurement.h"
17:                
18:                #include "display.h"
19:                #include "SPIDisplay.h"
20:                #include "consoleLike.h"
21:                #include <stdio.h>
22:                #include "Graphics/GOL.h"
23:                #include "Graphics/Primitive.h"
24:                #include "Graphics/Button.h"
25:                #include "MyGraph.h"
26:                #include "ClockControl.h"
27:                #include "timer1.h"
28:                #include "Graphics/StaticText.h"
29:                #include "ADC1Control.h"
30:                #include "timers.h"
31:                #include "addressableBits.h"
32:                #include "OC1Control.h"
33:                #include "timer3.h"
34:                #include "timer4.h"
35:                
36:                #include "string.h"
37:                
38:                #include "errorControl.h"
39:                
40:                #include "quantities.h"
41:                
42:                // TODO clean code
43:                
44:                #define GP(x,y) getPointSPIDisplay(x,y)
45:                
46:                #define ERROR_DELAY_CYCLES 1000000
47:                #define MAX_ERROR_LEN 400
48:                
49:                #define ERROR_ID 4
50:                
51:                void drawGraph (int *num);
52:                
53:                void updateScreen ();
54:                
55:                void slaveSel (int active);
56:                
57:                void lampeggia ();
58:                
59:                
60:                void mainLoop ();
61:                void initGOLObjects ();
62:                void initHW ();
63:                
64:                void tryTMR3 ();
65:                void tryABITS();
66:                
67:                static MYGRAPH *gr;
68:                static STATICTEXT *time;
69:                static STATICTEXT *errors;
70:                
71:                static int dataSerie [128];
72:                
73:                /*
74:                 * Visualizza gli errori accaduti e svuota la coda
75:                 */
76:                static void errorDisplay ();
77:                
78:                void __attribute__((__interrupt__, __auto_psv__))  _MathError (void)
79:                {
00058E  F80034     PUSH PSVPAG
000590  781F88     MOV W8, [W15++]
000592  200008     MOV #0x0, W8
000594  8801A8     MOV W8, PSVPAG
000596  78044F     MOV [--W15], W8
000598  FA0000     LNK #0x0
80:                    IFS0bits.T3IF = 0;
00059A  A90085     BCLR 0x85, #0
81:                }
00059C  FA8000     ULNK
00059E  F90034     POP PSVPAG
0005A0  064000     RETFIE
82:                
83:                void __attribute__((__interrupt__, __auto_psv__))  _StackError (void)
84:                {
0005A2  F80034     PUSH PSVPAG
0005A4  781F88     MOV W8, [W15++]
0005A6  200008     MOV #0x0, W8
0005A8  8801A8     MOV W8, PSVPAG
0005AA  78044F     MOV [--W15], W8
0005AC  FA0000     LNK #0x0
85:                    IFS0bits.T3IF = 0;
0005AE  A90085     BCLR 0x85, #0
86:                }
0005B0  FA8000     ULNK
0005B2  F90034     POP PSVPAG
0005B4  064000     RETFIE
87:                
88:                void __attribute__((__interrupt__, __auto_psv__))  _AddressError (void)
89:                {
0005B6  F80034     PUSH PSVPAG
0005B8  781F88     MOV W8, [W15++]
0005BA  200008     MOV #0x0, W8
0005BC  8801A8     MOV W8, PSVPAG
0005BE  78044F     MOV [--W15], W8
0005C0  FA0000     LNK #0x0
90:                    IFS0bits.T3IF = 0;
0005C2  A90085     BCLR 0x85, #0
91:                }
0005C4  FA8000     ULNK
0005C6  F90034     POP PSVPAG
0005C8  064000     RETFIE
92:                
93:                int main()
94:                {
0005CA  FA0000     LNK #0x0
95:                    //tryABITS();
96:                
97:                    initHW();
0005CC  0700BA     RCALL initHW
98:                 
99:                    initGOLObjects();
0005CE  0700FF     RCALL initGOLObjects
100:               
101:                   //tryTMR3();
102:               
103:                   mainLoop();
0005D0  070164     RCALL mainLoop
104:               
105:                   return 0;
0005D2  EB0000     CLR W0
106:               }
0005D4  FA8000     ULNK
0005D6  060000     RETURN
107:               
108:               void updateScreen ()
109:               {
0005D8  FA0000     LNK #0x0
110:                   static int i = 0;
111:               
112:                   if (i == 0)
0005DA  807B90     MOV i, W0
0005DC  500FE0     SUB W0, #0x0, [W15]
0005DE  3A0002     BRA NZ, 0x5E4
113:                       PORTAbits.RA0 = 1;
0005E0  A802C2     BSET PORTA, #0
0005E2  370001     BRA 0x5E6
114:                   else
115:                       PORTAbits.RA0 = 0;
0005E4  A902C2     BCLR PORTA, #0
116:               
117:                   LATBbits.LATB8 = i==0?0:1;//
0005E6  807B90     MOV i, W0
0005E8  EA0080     NEG W0, W1
0005EA  708000     IOR W1, W0, W0
0005EC  DE004F     LSR W0, #15, W0
0005EE  784000     MOV.B W0, W0
0005F0  FB8000     ZE W0, W0
0005F2  600061     AND W0, #0x1, W0
0005F4  DD0048     SL W0, #8, W0
0005F6  801662     MOV LATB, W2
0005F8  2FEFF1     MOV #0xFEFF, W1
0005FA  610081     AND W2, W1, W1
0005FC  708000     IOR W1, W0, W0
0005FE  881660     MOV W0, LATB
118:                   LATBbits.LATB9 = i==1?0:1;
000600  807B90     MOV i, W0
000602  A20000     BTG W0, #0
000604  EA0080     NEG W0, W1
000606  708000     IOR W1, W0, W0
000608  DE004F     LSR W0, #15, W0
00060A  784000     MOV.B W0, W0
00060C  FB8000     ZE W0, W0
00060E  600061     AND W0, #0x1, W0
000610  DD0049     SL W0, #9, W0
000612  801662     MOV LATB, W2
000614  2FDFF1     MOV #0xFDFF, W1
000616  610081     AND W2, W1, W1
000618  708000     IOR W1, W0, W0
00061A  881660     MOV W0, LATB
119:                   LATBbits.LATB2 = i==2?0:1;//
00061C  807B90     MOV i, W0
00061E  A21000     BTG W0, #1
000620  EA0080     NEG W0, W1
000622  708000     IOR W1, W0, W0
000624  DE004F     LSR W0, #15, W0
000626  784000     MOV.B W0, W0
000628  FB8000     ZE W0, W0
00062A  600061     AND W0, #0x1, W0
00062C  DD0042     SL W0, #2, W0
00062E  801662     MOV LATB, W2
000630  2FFFB1     MOV #0xFFFB, W1
000632  610081     AND W2, W1, W1
000634  708000     IOR W1, W0, W0
000636  881660     MOV W0, LATB
120:                   LATBbits.LATB3 = i==3?0:1;
000638  807B90     MOV i, W0
00063A  680063     XOR W0, #0x3, W0
00063C  EA0080     NEG W0, W1
00063E  708000     IOR W1, W0, W0
000640  DE004F     LSR W0, #15, W0
000642  784000     MOV.B W0, W0
000644  FB8000     ZE W0, W0
000646  600061     AND W0, #0x1, W0
000648  DD0043     SL W0, #3, W0
00064A  801662     MOV LATB, W2
00064C  2FFF71     MOV #0xFFF7, W1
00064E  610081     AND W2, W1, W1
000650  708000     IOR W1, W0, W0
000652  881660     MOV W0, LATB
121:                   LATBbits.LATB4 = i==4?0:1;//
000654  807B90     MOV i, W0
000656  A22000     BTG W0, #2
000658  EA0080     NEG W0, W1
00065A  708000     IOR W1, W0, W0
00065C  DE004F     LSR W0, #15, W0
00065E  784000     MOV.B W0, W0
000660  FB8000     ZE W0, W0
000662  600061     AND W0, #0x1, W0
000664  DD0044     SL W0, #4, W0
000666  801662     MOV LATB, W2
000668  2FFEF1     MOV #0xFFEF, W1
00066A  610081     AND W2, W1, W1
00066C  708000     IOR W1, W0, W0
00066E  881660     MOV W0, LATB
122:                   LATBbits.LATB5 = i==5?0:1;
000670  807B90     MOV i, W0
000672  680065     XOR W0, #0x5, W0
000674  EA0080     NEG W0, W1
000676  708000     IOR W1, W0, W0
000678  DE004F     LSR W0, #15, W0
00067A  784000     MOV.B W0, W0
00067C  FB8000     ZE W0, W0
00067E  600061     AND W0, #0x1, W0
000680  DD0045     SL W0, #5, W0
000682  801662     MOV LATB, W2
000684  2FFDF1     MOV #0xFFDF, W1
000686  610081     AND W2, W1, W1
000688  708000     IOR W1, W0, W0
00068A  881660     MOV W0, LATB
123:                   LATBbits.LATB6 = i==6?0:1;//
00068C  807B90     MOV i, W0
00068E  680066     XOR W0, #0x6, W0
000690  EA0080     NEG W0, W1
000692  708000     IOR W1, W0, W0
000694  DE004F     LSR W0, #15, W0
000696  784000     MOV.B W0, W0
000698  FB8000     ZE W0, W0
00069A  600061     AND W0, #0x1, W0
00069C  DD0046     SL W0, #6, W0
00069E  801662     MOV LATB, W2
0006A0  2FFBF1     MOV #0xFFBF, W1
0006A2  610081     AND W2, W1, W1
0006A4  708000     IOR W1, W0, W0
0006A6  881660     MOV W0, LATB
124:                   LATBbits.LATB7 = i==7?0:1;
0006A8  807B90     MOV i, W0
0006AA  680067     XOR W0, #0x7, W0
0006AC  EA0080     NEG W0, W1
0006AE  708000     IOR W1, W0, W0
0006B0  DE004F     LSR W0, #15, W0
0006B2  784000     MOV.B W0, W0
0006B4  FB8000     ZE W0, W0
0006B6  600061     AND W0, #0x1, W0
0006B8  DD0047     SL W0, #7, W0
0006BA  801662     MOV LATB, W2
0006BC  2FF7F1     MOV #0xFF7F, W1
0006BE  610081     AND W2, W1, W1
0006C0  708000     IOR W1, W0, W0
0006C2  881660     MOV W0, LATB
125:               
126:               
127:               
128:                   i++;
0006C4  807B90     MOV i, W0
0006C6  E80000     INC W0, W0
0006C8  887B90     MOV W0, i
129:                   i%=8;
0006CA  807B91     MOV i, W1
0006CC  200080     MOV #0x8, W0
0006CE  780100     MOV W0, W2
0006D0  090011     REPEAT #0x11
0006D2  D80082     DIV.SW W1, W2
0006D4  FD0080     EXCH W0, W1
0006D6  887B90     MOV W0, i
130:               }
0006D8  FA8000     ULNK
0006DA  060000     RETURN
131:               
132:               void slaveSel (int active)
133:               {
0006DC  FA0002     LNK #0x2
0006DE  780F00     MOV W0, [W14]
134:                   if (active)
0006E0  78001E     MOV [W14], W0
0006E2  500FE0     SUB W0, #0x0, [W15]
0006E4  320002     BRA Z, 0x6EA
135:                   {
136:                       LATBbits.LATB11 = 1;
0006E6  A862CD     BSET 0x2CD, #3
0006E8  370001     BRA 0x6EC
137:                   }
138:                   else
139:                   {
140:                       LATBbits.LATB11 = 1;
0006EA  A862CD     BSET 0x2CD, #3
141:                   }
142:               }
0006EC  FA8000     ULNK
0006EE  060000     RETURN
143:               
144:               void drawGraph (int *num)
145:               {
0006F0  FA000C     LNK #0xC
0006F2  980750     MOV W0, [W14+10]
146:               int x;
147:               
148:                   for (x = 0; x < maxXSPIDisplay(); x++)
0006F4  EB0000     CLR W0
0006F6  780F00     MOV W0, [W14]
0006F8  370015     BRA 0x724
000722  E80F1E     INC [W14], [W14]
000724  0750B9     RCALL maxXSPIDisplay
000726  500F9E     SUB W0, [W14], [W15]
000728  3CFFE8     BRA GT, 0x6FA
149:                   {
150:                       drawLineSPIDisplay(GP(x, 63), GP(x, 63 - num[x]));
0006FA  78001E     MOV [W14], W0
0006FC  400000     ADD W0, W0, W0
0006FE  9000DE     MOV [W14+10], W1
000700  408000     ADD W1, W0, W0
000702  780010     MOV [W0], W0
000704  2003F1     MOV #0x3F, W1
000706  508080     SUB W1, W0, W1
000708  470066     ADD W14, #0x6, W0
00070A  780101     MOV W1, W2
00070C  78009E     MOV [W14], W1
00070E  0750B9     RCALL getPointSPIDisplay
000710  E8800E     INC2 W14, W0
000712  2003F2     MOV #0x3F, W2
000714  78009E     MOV [W14], W1
000716  0750B5     RCALL getPointSPIDisplay
000718  90013E     MOV [W14+6], W2
00071A  9001CE     MOV [W14+8], W3
00071C  90001E     MOV [W14+2], W0
00071E  9000AE     MOV [W14+4], W1
000720  075008     RCALL drawLineSPIDisplay
151:                   }
152:               }
00072A  FA8000     ULNK
00072C  060000     RETURN
153:               
154:               void lampeggia ()
155:               {
00072E  FA0000     LNK #0x0
156:                   if (LATAbits.LATA0 == 0)
000730  801620     MOV LATA, W0
000732  600061     AND W0, #0x1, W0
000734  500FE0     SUB W0, #0x0, [W15]
000736  3A0002     BRA NZ, 0x73C
157:                       PORTAbits.RA0 = 1;
000738  A802C2     BSET PORTA, #0
00073A  370001     BRA 0x73E
158:                   else
159:                       PORTAbits.RA0 = 0;
00073C  A902C2     BCLR PORTA, #0
160:               }
00073E  FA8000     ULNK
000740  060000     RETURN
161:               
162:               void initHW ()
163:               {
000742  FA0004     LNK #0x4
164:               long int realFreq;
165:               
166:                   CLKDIVbits.PLLPRE = 0;
000744  803A21     MOV CLKDIV, W1
000746  2FFE00     MOV #0xFFE0, W0
000748  608000     AND W1, W0, W0
00074A  883A20     MOV W0, CLKDIV
167:                   PLLFBDbits.PLLDIV = 20;
00074C  803A31     MOV PLLFBD, W1
00074E  2FE000     MOV #0xFE00, W0
000750  608000     AND W1, W0, W0
000752  B30140     IOR #0x14, W0
000754  883A30     MOV W0, PLLFBD
168:                   CLKDIVbits.PLLPOST = 0;
000756  803A21     MOV CLKDIV, W1
000758  2FF3F0     MOV #0xFF3F, W0
00075A  608000     AND W1, W0, W0
00075C  883A20     MOV W0, CLKDIV
169:               
170:                   PORTAbits.RA0 = 1;
00075E  A802C2     BSET PORTA, #0
171:               
172:                   realFreq = setClockFreq (16000000L, PRIMARY, 16000000);
000760  224004     MOV #0x2400, W4
000762  200F45     MOV #0xF4, W5
000764  200012     MOV #0x1, W2
000766  224000     MOV #0x2400, W0
000768  200F41     MOV #0xF4, W1
00076A  075949     RCALL setClockFreq
00076C  BE8F00     MOV.D W0, [W14]
173:               
174:                   initGlobalPinout();
00076E  075E80     RCALL initGlobalPinout
175:               
176:                   IEC0bits.INT0IE = 0;
000770  A90094     BCLR IEC0, #0
177:                   IPC0bits.INT0IP = 0;
000772  800521     MOV IPC0, W1
000774  2FFF80     MOV #0xFFF8, W0
000776  608000     AND W1, W0, W0
000778  880520     MOV W0, IPC0
178:               
179:                   
180:               
181:                   timersInit();
00077A  075BC0     RCALL timersInit
182:               
183:                   timer1Init (TIMER_AS_COUNTER, TIMER_GATE_OFF, TIMER_SYNC_OFF);
00077C  EB0100     CLR W2
00077E  EB0080     CLR W1
000780  200010     MOV #0x1, W0
000782  070182     RCALL timer1Init
184:               
185:                   timer3Init();
000784  07044D     RCALL timer3Init
186:               
187:                   timer4Init();
000786  070615     RCALL timer4Init
188:               
189:                   OC1init (TIMER2, OC1_PWM);
000788  200061     MOV #0x6, W1
00078A  200010     MOV #0x1, W0
00078C  075B12     RCALL OC1init
190:               
191:                   initADC1 (4, ADC1_AVDD_AVSS, 35, 10, ADC1_INTEGER, 1, NULL, 0, 3.0);
00078E  200000     MOV #0x0, W0
000790  240401     MOV #0x4040, W1
000792  BE9F80     MOV.D W0, [W15++]
000794  B80060     MUL.UU W0, #0, W0
000796  BE9F80     MOV.D W0, [W15++]
000798  EB0300     CLR W6
00079A  200015     MOV #0x1, W5
00079C  EB0200     CLR W4
00079E  2000A3     MOV #0xA, W3
0007A0  200232     MOV #0x23, W2
0007A2  EB0080     CLR W1
0007A4  200040     MOV #0x4, W0
0007A6  07FDEA     RCALL initADC1
0007A8  5787E8     SUB W15, #0x8, W15
192:               
193:                   initRamp (128, 3.0, 30.0);
0007AA  200004     MOV #0x0, W4
0007AC  241F05     MOV #0x41F0, W5
0007AE  200002     MOV #0x0, W2
0007B0  240403     MOV #0x4040, W3
0007B2  200800     MOV #0x80, W0
0007B4  075117     RCALL initRamp
194:                   initRosmeterControl (128);
0007B6  200800     MOV #0x80, W0
0007B8  075E08     RCALL initRosmeterControl
195:               
196:                   initTimeMeasurement();
0007BA  075A3F     RCALL initTimeMeasurement
197:               
198:                   initErrorControl();
0007BC  075DB3     RCALL initErrorControl
199:               
200:                   SRbits.IPL = 6;
0007BE  800211     MOV SR, W1
0007C0  2FF1F0     MOV #0xFF1F, W0
0007C2  608080     AND W1, W0, W1
0007C4  200C00     MOV #0xC0, W0
0007C6  708000     IOR W1, W0, W0
0007C8  880210     MOV W0, SR
201:               }
0007CA  FA8000     ULNK
0007CC  060000     RETURN
202:               
203:               void initGOLObjects ()
204:               {
0007CE  FA0006     LNK #0x6
205:               GOL_SCHEME *pScheme;
206:               WORD state;
207:               int i;
208:               
209:               
210:                   GOLInit();
0007D0  073EA3     RCALL GOLInit
211:               
212:                   pScheme = GOLCreateScheme();
0007D2  073E94     RCALL GOLCreateScheme
0007D4  980710     MOV W0, [W14+2]
213:               
214:                   pScheme ->Color0 = 0x00;
0007D6  90009E     MOV [W14+2], W1
0007D8  EB4000     CLR.B W0
0007DA  9840D0     MOV.B W0, [W1+5]
215:                   pScheme ->Color1 = 0x01;
0007DC  90009E     MOV [W14+2], W1
0007DE  B3C010     MOV #0x1, W0
0007E0  9840E0     MOV.B W0, [W1+6]
216:               
217:                   pScheme ->CommonBkColor = 0x01;
0007E2  90009E     MOV [W14+2], W1
0007E4  B3C010     MOV #0x1, W0
0007E6  984880     MOV.B W0, [W1+8]
218:               
219:                   pScheme ->EmbossDkColor = 0x00;
0007E8  90009E     MOV [W14+2], W1
0007EA  EB4000     CLR.B W0
0007EC  784880     MOV.B W0, [W1]
220:                   pScheme ->EmbossLtColor = 0x01;
0007EE  90009E     MOV [W14+2], W1
0007F0  B3C010     MOV #0x1, W0
0007F2  984090     MOV.B W0, [W1+1]
221:               
222:                   pScheme ->TextColor0 = 0x00;
0007F4  90009E     MOV [W14+2], W1
0007F6  EB4000     CLR.B W0
0007F8  9840A0     MOV.B W0, [W1+2]
223:                   pScheme ->TextColor1 = 0x00;
0007FA  90009E     MOV [W14+2], W1
0007FC  EB4000     CLR.B W0
0007FE  9840B0     MOV.B W0, [W1+3]
224:               
225:               
226:               
227:               
228:                   for (i = 0; i < 128; i++)
000800  EB0000     CLR W0
000802  780F00     MOV W0, [W14]
000804  37000D     BRA 0x820
00081E  E80F1E     INC [W14], [W14]
000820  2007F0     MOV #0x7F, W0
000822  78009E     MOV [W14], W1
000824  508F80     SUB W1, W0, [W15]
000826  34FFEF     BRA LE, 0x806
229:                   {
230:                       dataSerie[i] = rand()%64;
000806  070C83     RCALL _rand
000808  200401     MOV #0x40, W1
00080A  780101     MOV W1, W2
00080C  090011     REPEAT #0x11
00080E  D80002     DIV.SW W0, W2
000810  FD0080     EXCH W0, W1
000812  780080     MOV W0, W1
000814  78001E     MOV [W14], W0
000816  400100     ADD W0, W0, W2
000818  20E720     MOV #0xE72, W0
00081A  410000     ADD W2, W0, W0
00081C  780801     MOV W1, [W0]
231:                   }
232:               
233:                   
234:               
235:                   state = MYGR_DRAW | MYGR_OPTIMIZED;
000828  2FC010     MOV #0xFC01, W0
00082A  980720     MOV W0, [W14+4]
236:                   gr = MygrCreate (3, 0, 0, 127, 63, state, dataSerie, sizeof(dataSerie)/sizeof(int), 0, 128, 0, 64, 0, 0, 128, 8,  pScheme);
00082C  90001E     MOV [W14+2], W0
00082E  781F80     MOV W0, [W15++]
000830  200080     MOV #0x8, W0
000832  781F80     MOV W0, [W15++]
000834  200800     MOV #0x80, W0
000836  781F80     MOV W0, [W15++]
000838  EB0000     CLR W0
00083A  781F80     MOV W0, [W15++]
00083C  EB0000     CLR W0
00083E  781F80     MOV W0, [W15++]
000840  200400     MOV #0x40, W0
000842  781F80     MOV W0, [W15++]
000844  EB0000     CLR W0
000846  781F80     MOV W0, [W15++]
000848  200800     MOV #0x80, W0
00084A  781F80     MOV W0, [W15++]
00084C  EB0000     CLR W0
00084E  781F80     MOV W0, [W15++]
000850  200807     MOV #0x80, W7
000852  20E726     MOV #0xE72, W6
000854  9002AE     MOV [W14+4], W5
000856  2003F4     MOV #0x3F, W4
000858  2007F3     MOV #0x7F, W3
00085A  EB0100     CLR W2
00085C  EB0080     CLR W1
00085E  200030     MOV #0x3, W0
000860  0748D0     RCALL MygrCreate
000862  5787F2     SUB W15, #0x12, W15
000864  887360     MOV W0, gr
237:               
238:                   state = ST_DRAW;
000866  240000     MOV #0x4000, W0
000868  980720     MOV W0, [W14+4]
239:                   time = StCreate (2, 0, 0, 128, 8, state, "Dio Sauro", pScheme);
00086A  90039E     MOV [W14+2], W7
00086C  2D42A6     MOV #0xD42A, W6
00086E  9002AE     MOV [W14+4], W5
000870  200084     MOV #0x8, W4
000872  200803     MOV #0x80, W3
000874  EB0100     CLR W2
000876  EB0080     CLR W1
000878  200020     MOV #0x2, W0
00087A  0752F8     RCALL StCreate
00087C  887370     MOV W0, time
240:               
241:                   state = ST_CENTER_ALIGN;
00087E  200080     MOV #0x8, W0
000880  980720     MOV W0, [W14+4]
242:                   errors = StCreate (ERROR_ID, 0, 16, 128, 48, state, "NESSUN ERRORE!", pScheme);
000882  90039E     MOV [W14+2], W7
000884  2D4346     MOV #0xD434, W6
000886  9002AE     MOV [W14+4], W5
000888  200304     MOV #0x30, W4
00088A  200803     MOV #0x80, W3
00088C  200102     MOV #0x10, W2
00088E  EB0080     CLR W1
000890  200040     MOV #0x4, W0
000892  0752EC     RCALL StCreate
000894  887380     MOV W0, errors
243:               
244:               }
000896  FA8000     ULNK
000898  060000     RETURN
245:               
246:               void mainLoop ()
247:               {
00089A  FA0012     LNK #0x12
248:               timeMeasurementID_t cycleLenID;
249:               timeUS_t cycleLen;
250:               
251:               long int a = 1000000, b = 2000, c;
00089C  242400     MOV #0x4240, W0
00089E  2000F1     MOV #0xF, W1
0008A0  BE8F00     MOV.D W0, [W14]
0008A2  207D00     MOV #0x7D0, W0
0008A4  200001     MOV #0x0, W1
0008A6  980720     MOV W0, [W14+4]
0008A8  980731     MOV W1, [W14+6]
252:               
253:               
254:                   c = a/b;
0008AA  90012E     MOV [W14+4], W2
0008AC  9001BE     MOV [W14+6], W3
0008AE  BE001E     MOV.D [W14], W0
0008B0  070818     RCALL ___divsi3
0008B2  980740     MOV W0, [W14+8]
0008B4  980751     MOV W1, [W14+10]
255:               
256:                   beginSamplingADC1();
0008B6  07FDFF     RCALL beginSamplingADC1
257:               
258:                   setOC1PWM (2000, 50);
0008B8  200322     MOV #0x32, W2
0008BA  200003     MOV #0x0, W3
0008BC  207D00     MOV #0x7D0, W0
0008BE  200001     MOV #0x0, W1
0008C0  075ACB     RCALL setOC1PWM
259:               
260:                   SRbits.IPL = 0;
0008C2  800211     MOV SR, W1
0008C4  2FF1F0     MOV #0xFF1F, W0
0008C6  608000     AND W1, W0, W0
0008C8  880210     MOV W0, SR
261:               
262:                   //OC1Start();
263:               
264:                   setTimer3IntervalNS(1000000L);
0008CA  242400     MOV #0x4240, W0
0008CC  2000F1     MOV #0xF, W1
0008CE  0703D9     RCALL setTimer3IntervalNS
265:                   TIMER3_INSTANT_START;
0008D0  A8E113     BSET 0x113, #7
266:               
267:                   setBarPos (gr, 64);
0008D2  807360     MOV gr, W0
0008D4  200401     MOV #0x40, W1
0008D6  0749BF     RCALL setBarPos
268:               
269:                   setActQuantity (ROS_QID);
0008D8  EB0000     CLR W0
0008DA  075EC9     RCALL setActQuantity
270:               
271:                   getActQuantity() -> init();
0008DC  075EC0     RCALL getActQuantity
0008DE  900050     MOV [W0+10], W0
0008E0  010000     CALL W0
272:               
273:                   cycleLenID = startTimeMeasurement();
0008E2  0759C1     RCALL startTimeMeasurement
0008E4  980760     MOV W0, [W14+12]
274:               
275:                   while (1)
276:                   {
277:                       restartMeasurement (cycleLenID);
0008E6  90006E     MOV [W14+12], W0
0008E8  0759D5     RCALL restartMeasurement
278:               
279:                       getActQuantity() -> mainMeasurementLoop();
0008EA  075EB9     RCALL getActQuantity
0008EC  900040     MOV [W0+8], W0
0008EE  010000     CALL W0
280:               
281:                       errorDisplay(); // TODO lasciare!
0008F0  07003C     RCALL _errorDisplay
282:               
283:                       if (getPressedKey() == CONTROLS_T4)
0008F2  075E47     RCALL getPressedKey
0008F4  500FE4     SUB W0, #0x4, [W15]
0008F6  3A0001     BRA NZ, 0x8FA
284:                           goToNextQuantity();
0008F8  075ED0     RCALL goToNextQuantity
285:                       if (getPressedKey() == CONTROLS_T3)
0008FA  075E43     RCALL getPressedKey
0008FC  500FE3     SUB W0, #0x3, [W15]
0008FE  3A0001     BRA NZ, 0x902
286:                           goToPreviousQuantity();
000900  075ED3     RCALL goToPreviousQuantity
287:               
288:                       cycleLen = getElaspedTime (cycleLenID);
000902  90006E     MOV [W14+12], W0
000904  0759BC     RCALL getElaspedTime
000906  980770     MOV W0, [W14+14]
000908  980F01     MOV W1, [W14+16]
289:                   }
00090A  37FFED     BRA 0x8E6
290:               }
291:               
292:               void tryTMR3 ()
293:               {
00090C  FA0004     LNK #0x4
294:               long int i;
295:               
296:                   setTimer3IntervalNS(1000000L);
00090E  242400     MOV #0x4240, W0
000910  2000F1     MOV #0xF, W1
000912  0703B7     RCALL setTimer3IntervalNS
297:                   TIMER3_INSTANT_START;
000914  A8E113     BSET 0x113, #7
298:               
299:                   for(i = 0; i < 128000; i++)
000916  B80060     MUL.UU W0, #0, W0
000918  BE8F00     MOV.D W0, [W14]
00091A  370010     BRA 0x93C
000934  200010     MOV #0x1, W0
000936  200001     MOV #0x0, W1
000938  400F1E     ADD W0, [W14], [W14]
00093A  48975E     ADDC W1, [++W14], [W14--]
00093C  2F3FF0     MOV #0xF3FF, W0
00093E  200011     MOV #0x1, W1
000940  BE011E     MOV.D [W14], W2
000942  510F80     SUB W2, W0, [W15]
000944  598F81     SUBB W3, W1, [W15]
000946  34FFEA     BRA LE, 0x91C
300:                   {
301:                       PORTAbits.RA0 = ~LATAbits.LATA0;
00091C  801620     MOV LATA, W0
00091E  784000     MOV.B W0, W0
000920  604061     AND.B W0, #0x1, W0
000922  EAC000     COM.B W0, W0
000924  604061     AND.B W0, #0x1, W0
000926  FB8000     ZE W0, W0
000928  600061     AND W0, #0x1, W0
00092A  801612     MOV PORTA, W2
00092C  2FFFE1     MOV #0xFFFE, W1
00092E  610081     AND W2, W1, W1
000930  708000     IOR W1, W0, W0
000932  881610     MOV W0, PORTA
302:               
303:                       //TIMER3_INSTANT_WAIT;
304:                   }
305:               }
000948  FA8000     ULNK
00094A  060000     RETURN
306:               
307:               void tryABITS()
308:               {
00094C  FA0008     LNK #0x8
309:               volatile unsigned int try = 0xffff;
00094E  EB8000     SETM W0
000950  780F00     MOV W0, [W14]
310:               addressableBit abt;
311:               
312:                   abt = getAddressableBit(&try, 2, 8);
000952  E8800E     INC2 W14, W0
000954  200083     MOV #0x8, W3
000956  200022     MOV #0x2, W2
000958  78008E     MOV W14, W1
00095A  075B4D     RCALL getAddressableBit
313:               
314:                   setBit (abt, 0x0f);
00095C  2000F3     MOV #0xF, W3
00095E  90001E     MOV [W14+2], W0
000960  9000AE     MOV [W14+4], W1
000962  90013E     MOV [W14+6], W2
000964  075B58     RCALL setBit
315:               }
000966  FA8000     ULNK
000968  060000     RETURN
316:               
317:               static void errorDisplay ()
318:               {
00096A  FA01AA     LNK #0x1AA
319:               error_t *actError;
320:               char errorStr [MAX_ERROR_LEN], err[] = "ERRORE", warn[] = "WARNING";
00096C  2019A0     MOV #0x19A, W0
00096E  40000E     ADD W0, W14, W0
000970  252452     MOV #0x5245, W2
000972  24F523     MOV #0x4F52, W3
000974  BE8802     MOV.D W2, [W0]
000976  400064     ADD W0, #0x4, W0
000978  245521     MOV #0x4552, W1
00097A  780801     MOV W1, [W0]
00097C  E88000     INC2 W0, W0
00097E  EB4080     CLR.B W1
000980  784801     MOV.B W1, [W0]
000982  E80000     INC W0, W0
000984  78000E     MOV W14, W0
000986  B01A10     ADD #0x1A1, W0
000988  2D44A1     MOV #0xD44A, W1
00098A  090007     REPEAT #0x7
00098C  785831     MOV.B [W1++], [W0++]
321:               long int i;
322:               GOL_SCHEME *pScheme;
323:               WORD state;
324:               
325:                   if (getError() != NULL)
00098E  075D02     RCALL getError
000990  500FE0     SUB W0, #0x0, [W15]
000992  320061     BRA Z, 0xA56
326:                   {
327:                       pScheme = GOLCreateScheme();
000994  073DB3     RCALL GOLCreateScheme
000996  980720     MOV W0, [W14+4]
328:               
329:                       pScheme ->Color0 = 0x00;
000998  9000AE     MOV [W14+4], W1
00099A  EB4000     CLR.B W0
00099C  9840D0     MOV.B W0, [W1+5]
330:                       pScheme ->Color1 = 0x01;
00099E  9000AE     MOV [W14+4], W1
0009A0  B3C010     MOV #0x1, W0
0009A2  9840E0     MOV.B W0, [W1+6]
331:               
332:                       pScheme ->CommonBkColor = 0x01;
0009A4  9000AE     MOV [W14+4], W1
0009A6  B3C010     MOV #0x1, W0
0009A8  984880     MOV.B W0, [W1+8]
333:               
334:                       pScheme ->EmbossDkColor = 0x00;
0009AA  9000AE     MOV [W14+4], W1
0009AC  EB4000     CLR.B W0
0009AE  784880     MOV.B W0, [W1]
335:                       pScheme ->EmbossLtColor = 0x01;
0009B0  9000AE     MOV [W14+4], W1
0009B2  B3C010     MOV #0x1, W0
0009B4  984090     MOV.B W0, [W1+1]
336:               
337:                       pScheme ->TextColor0 = 0x00;
0009B6  9000AE     MOV [W14+4], W1
0009B8  EB4000     CLR.B W0
0009BA  9840A0     MOV.B W0, [W1+2]
338:                       pScheme ->TextColor1 = 0x00;
0009BC  9000AE     MOV [W14+4], W1
0009BE  EB4000     CLR.B W0
0009C0  9840B0     MOV.B W0, [W1+3]
339:               
340:                       GOLDeleteObjectByID (ERROR_ID);
0009C2  200040     MOV #0x4, W0
0009C4  073E04     RCALL GOLDeleteObjectByID
341:               
342:                       state = ST_CENTER_ALIGN;
0009C6  200080     MOV #0x8, W0
0009C8  980730     MOV W0, [W14+6]
343:                       errors = StCreate (ERROR_ID, 0, 16, 128, 48, state, "NESSUN ERRORE!", pScheme);
0009CA  9003AE     MOV [W14+4], W7
0009CC  2D4346     MOV #0xD434, W6
0009CE  9002BE     MOV [W14+6], W5
0009D0  200304     MOV #0x30, W4
0009D2  200803     MOV #0x80, W3
0009D4  200102     MOV #0x10, W2
0009D6  EB0080     CLR W1
0009D8  200040     MOV #0x4, W0
0009DA  075248     RCALL StCreate
0009DC  887380     MOV W0, errors
344:               
345:                       while ((actError = getError()) != NULL)
0009DE  370034     BRA 0xA48
000A48  075CA5     RCALL getError
000A4A  980740     MOV W0, [W14+8]
000A4C  90004E     MOV [W14+8], W0
000A4E  500FE0     SUB W0, #0x0, [W15]
000A50  3AFFC7     BRA NZ, 0x9E0
346:                       {
347:                           sprintf (errorStr, "%s: ", actError->errorType == ERROR?err:warn);
0009E0  90004E     MOV [W14+8], W0
0009E2  903840     MOV [W0+120], W0
0009E4  500FE0     SUB W0, #0x0, [W15]
0009E6  3A0003     BRA NZ, 0x9EE
0009E8  2019A0     MOV #0x19A, W0
0009EA  40000E     ADD W0, W14, W0
0009EC  370002     BRA 0x9F2
0009EE  201A10     MOV #0x1A1, W0
0009F0  40000E     ADD W0, W14, W0
0009F2  4700EA     ADD W14, #0xA, W1
0009F4  781F80     MOV W0, [W15++]
0009F6  2D4430     MOV #0xD443, W0
0009F8  781F80     MOV W0, [W15++]
0009FA  780001     MOV W1, W0
0009FC  070BB4     RCALL __sprintf_cdfFnopuxX
0009FE  5787E4     SUB W15, #0x4, W15
348:               
349:                           strcat (errorStr, actError->name);
000A00  9000CE     MOV [W14+8], W1
000A02  47006A     ADD W14, #0xA, W0
000A04  070B98     RCALL _strcat
350:                           strcat (errorStr, "\n");
000A06  47006A     ADD W14, #0xA, W0
000A08  070BA7     RCALL _strlen
000A0A  4700EA     ADD W14, #0xA, W1
000A0C  408000     ADD W1, W0, W0
000A0E  200022     MOV #0x2, W2
000A10  2D4481     MOV #0xD448, W1
000A12  070B6E     RCALL _memcpy
351:                           strcat (errorStr, actError->description);
000A14  90004E     MOV [W14+8], W0
000A16  4000F4     ADD W0, #0x14, W1
000A18  47006A     ADD W14, #0xA, W0
000A1A  070B8D     RCALL _strcat
352:               
353:                           StSetText (errors, errorStr);
000A1C  807380     MOV errors, W0
000A1E  4700EA     ADD W14, #0xA, W1
000A20  07527B     RCALL StSetText
354:               
355:                           errors->hdr.state = ST_DRAW | ST_CENTER_ALIGN;
000A22  807380     MOV errors, W0
000A24  240081     MOV #0x4008, W1
000A26  980031     MOV W1, [W0+6]
356:                           GOLDraw();
000A28  073E0F     RCALL GOLDraw
357:                           refreshSPIDisplay();
000A2A  074E1D     RCALL refreshSPIDisplay
358:               
359:                           for (i = 0; i < ERROR_DELAY_CYCLES; i++);
000A2C  B80060     MUL.UU W0, #0, W0
000A2E  BE8F00     MOV.D W0, [W14]
000A30  370004     BRA 0xA3A
000A32  200010     MOV #0x1, W0
000A34  200001     MOV #0x0, W1
000A36  400F1E     ADD W0, [W14], [W14]
000A38  48975E     ADDC W1, [++W14], [W14--]
000A3A  2423F0     MOV #0x423F, W0
000A3C  2000F1     MOV #0xF, W1
000A3E  BE011E     MOV.D [W14], W2
000A40  510F80     SUB W2, W0, [W15]
000A42  598F81     SUBB W3, W1, [W15]
000A44  34FFF6     BRA LE, 0xA32
360:               
361:                           deleteError();
000A46  075CAF     RCALL deleteError
362:                       }
363:               
364:                       GOLDeleteObjectByID (ERROR_ID);
000A52  200040     MOV #0x4, W0
000A54  073DBC     RCALL GOLDeleteObjectByID
365:                   }
366:               }
000A56  FA8000     ULNK
000A58  060000     RETURN
---  D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/display.c  ------------------------------------
1:                 #include <p33fj128mc802.h>
2:                 #include "display.h"
3:                 
4:                 #define DISP0_SELECT LATBbits.LATB12
5:                 #define DISP1_SELECT LATBbits.LATB13
6:                 #define DISP2_SELECT LATBbits.LATB15
7:                 
8:                 #define SEG_A   LATBbits.LATB8
9:                 #define SEG_B   LATBbits.LATB7
10:                #define SEG_C   LATBbits.LATB4
11:                #define SEG_D   LATBbits.LATB3
12:                #define SEG_E   LATBbits.LATB9
13:                #define SEG_F   LATBbits.LATB5
14:                #define SEG_G   LATBbits.LATB6
15:                #define SEG_DP  LATBbits.LATB2
16:                
17:                #define SEG_ON  0
18:                #define SEG_OFF 1
19:                
20:                #define DISPLAY_NUM 3
21:                
22:                int aNum = 0;
23:                int aBase = 10;
24:                
25:                /*
26:                 * Makes all the work necessary to make the display work.
27:                 */
28:                void initDisplay()
29:                {
00A05E  FA0000     LNK #0x0
30:                    AD1PCFGL = 0xFFFF;
00A060  EB8000     SETM W0
00A062  881960     MOV W0, AD1PCFGL
31:                
32:                    TRISBbits.TRISB2 = 0;
00A064  A942C8     BCLR TRISB, #2
33:                    TRISBbits.TRISB3 = 0;
00A066  A962C8     BCLR TRISB, #3
34:                    TRISBbits.TRISB4 = 0;
00A068  A982C8     BCLR TRISB, #4
35:                    TRISBbits.TRISB5 = 0;
00A06A  A9A2C8     BCLR TRISB, #5
36:                    TRISBbits.TRISB6 = 0;
00A06C  A9C2C8     BCLR TRISB, #6
37:                    TRISBbits.TRISB7 = 0;
00A06E  A9E2C8     BCLR TRISB, #7
38:                    TRISBbits.TRISB8 = 0;
00A070  A902C9     BCLR 0x2C9, #0
39:                    TRISBbits.TRISB9 = 0;
00A072  A922C9     BCLR 0x2C9, #1
40:                    TRISBbits.TRISB12 = 0;
00A074  A982C9     BCLR 0x2C9, #4
41:                    TRISBbits.TRISB13 = 0;
00A076  A9A2C9     BCLR 0x2C9, #5
42:                    TRISBbits.TRISB15 = 0;
00A078  A9E2C9     BCLR 0x2C9, #7
43:                
44:                    DISP0_SELECT = 0;
00A07A  A982CD     BCLR 0x2CD, #4
45:                    DISP0_SELECT = 0;
00A07C  A982CD     BCLR 0x2CD, #4
46:                    DISP0_SELECT = 0;
00A07E  A982CD     BCLR 0x2CD, #4
47:                
48:                    SEG_A = SEG_OFF;
00A080  A802CD     BSET 0x2CD, #0
49:                    SEG_B = SEG_OFF;
00A082  A8E2CC     BSET LATB, #7
50:                    SEG_C = SEG_OFF;
00A084  A882CC     BSET LATB, #4
51:                    SEG_D = SEG_OFF;
00A086  A862CC     BSET LATB, #3
52:                    SEG_E = SEG_OFF;
00A088  A822CD     BSET 0x2CD, #1
53:                    SEG_F = SEG_OFF;
00A08A  A8A2CC     BSET LATB, #5
54:                    SEG_G = SEG_OFF;
00A08C  A8C2CC     BSET LATB, #6
55:                    SEG_DP = SEG_OFF;
00A08E  A842CC     BSET LATB, #2
56:                }
00A090  FA8000     ULNK
00A092  060000     RETURN
57:                
58:                /*
59:                 * Enables all the displays and turn all the lamps on.
60:                 */
61:                void lampTest ()
62:                {
00A094  FA0000     LNK #0x0
63:                    DISP0_SELECT = 1;
00A096  A882CD     BSET 0x2CD, #4
64:                    DISP1_SELECT = 1;
00A098  A8A2CD     BSET 0x2CD, #5
65:                    DISP2_SELECT = 1;
00A09A  A8E2CD     BSET 0x2CD, #7
66:                
67:                    SEG_A = SEG_ON;
00A09C  A902CD     BCLR 0x2CD, #0
68:                    SEG_B = SEG_ON;
00A09E  A9E2CC     BCLR LATB, #7
69:                    SEG_C = SEG_ON;
00A0A0  A982CC     BCLR LATB, #4
70:                    SEG_D = SEG_ON;
00A0A2  A962CC     BCLR LATB, #3
71:                    SEG_E = SEG_ON;
00A0A4  A922CD     BCLR 0x2CD, #1
72:                    SEG_F = SEG_ON;
00A0A6  A9A2CC     BCLR LATB, #5
73:                    SEG_G = SEG_ON;
00A0A8  A9C2CC     BCLR LATB, #6
74:                    SEG_DP = SEG_ON;
00A0AA  A942CC     BCLR LATB, #2
75:                }
00A0AC  FA8000     ULNK
00A0AE  060000     RETURN
76:                
77:                /*
78:                 * Rurn on one of the three display.
79:                 * The input number is the id of the display (0-2).
80:                 * If the input is out if the range 0-2 all displays are turned off.
81:                 */
82:                void selectDisplay (char dispNum)
83:                {
00A0B0  FA0002     LNK #0x2
00A0B2  784F00     MOV.B W0, [W14]
84:                    clearDisplay();
00A0B4  070145     RCALL clearDisplay
85:                    
86:                    switch (dispNum)
00A0B6  FB001E     SE [W14], W0
00A0B8  500FE1     SUB W0, #0x1, [W15]
00A0BA  320008     BRA Z, 0xA0CC
00A0BC  500FE2     SUB W0, #0x2, [W15]
00A0BE  32000A     BRA Z, 0xA0D4
00A0C0  500FE0     SUB W0, #0x0, [W15]
00A0C2  3A000C     BRA NZ, 0xA0DC
87:                    {
88:                        case 0:
89:                            DISP0_SELECT = 1;
00A0C4  A882CD     BSET 0x2CD, #4
90:                            DISP1_SELECT = 0;
00A0C6  A9A2CD     BCLR 0x2CD, #5
91:                            DISP2_SELECT = 0;
00A0C8  A9E2CD     BCLR 0x2CD, #7
92:                            break;
00A0CA  37000C     BRA 0xA0E4
93:                        case 1:
94:                            DISP0_SELECT = 0;
00A0CC  A982CD     BCLR 0x2CD, #4
95:                            DISP1_SELECT = 1;
00A0CE  A8A2CD     BSET 0x2CD, #5
96:                            DISP2_SELECT = 0;
00A0D0  A9E2CD     BCLR 0x2CD, #7
97:                            break;
00A0D2  370008     BRA 0xA0E4
98:                        case 2:
99:                            DISP0_SELECT = 0;
00A0D4  A982CD     BCLR 0x2CD, #4
100:                           DISP1_SELECT = 0;
00A0D6  A9A2CD     BCLR 0x2CD, #5
101:                           DISP2_SELECT = 1;
00A0D8  A8E2CD     BSET 0x2CD, #7
102:                           break;
00A0DA  370004     BRA 0xA0E4
103:                       default:
104:                           DISP0_SELECT = 0;
00A0DC  A982CD     BCLR 0x2CD, #4
105:                           DISP1_SELECT = 0;
00A0DE  A9A2CD     BCLR 0x2CD, #5
106:                           DISP2_SELECT = 0;
00A0E0  A9E2CD     BCLR 0x2CD, #7
107:                           break;
00A0E2  000000     NOP
108:                   }
109:               }
00A0E4  FA8000     ULNK
00A0E6  060000     RETURN
110:               void setSegment (char segment)
111:               {
00A0E8  FA0002     LNK #0x2
00A0EA  784F00     MOV.B W0, [W14]
112:                   switch (segment)
00A0EC  FB001E     SE [W14], W0
00A0EE  B90161     MUL.SU W0, #1, W2
00A0F0  2FF9F0     MOV #0xFF9F, W0
00A0F2  2FFFF1     MOV #0xFFFF, W1
00A0F4  400002     ADD W0, W2, W0
00A0F6  488083     ADDC W1, W3, W1
00A0F8  2000F2     MOV #0xF, W2
00A0FA  200003     MOV #0x0, W3
00A0FC  500F82     SUB W0, W2, [W15]
00A0FE  588F83     SUBB W1, W3, [W15]
00A100  3E0021     BRA GTU, 0xA144
00A102  016000     BRA W0
00A104  37000F     BRA 0xA124
00A106  370010     BRA 0xA128
00A108  370011     BRA 0xA12C
00A10A  370012     BRA 0xA130
00A10C  370013     BRA 0xA134
00A10E  370014     BRA 0xA138
00A110  370015     BRA 0xA13C
00A112  370018     BRA 0xA144
00A114  370017     BRA 0xA144
00A116  370016     BRA 0xA144
00A118  370015     BRA 0xA144
00A11A  370014     BRA 0xA144
00A11C  370013     BRA 0xA144
00A11E  370012     BRA 0xA144
00A120  370011     BRA 0xA144
00A122  37000E     BRA 0xA140
113:                   {
114:                       case 'a':
115:                           SEG_A = SEG_ON;
00A124  A902CD     BCLR 0x2CD, #0
116:                           break;
00A126  37000E     BRA 0xA144
117:                       case 'b':
118:                           SEG_B = SEG_ON;
00A128  A9E2CC     BCLR LATB, #7
119:                           break;
00A12A  37000C     BRA 0xA144
120:                       case 'c':
121:                           SEG_C = SEG_ON;
00A12C  A982CC     BCLR LATB, #4
122:                           break;
00A12E  37000A     BRA 0xA144
123:                       case 'd':
124:                           SEG_D = SEG_ON;
00A130  A962CC     BCLR LATB, #3
125:                           break;
00A132  370008     BRA 0xA144
126:                       case 'e':
127:                           SEG_E = SEG_ON;
00A134  A922CD     BCLR 0x2CD, #1
128:                           break;
00A136  370006     BRA 0xA144
129:                       case 'f':
130:                           SEG_F = SEG_ON;
00A138  A9A2CC     BCLR LATB, #5
131:                           break;
00A13A  370004     BRA 0xA144
132:                       case 'g':
133:                           SEG_G = SEG_ON;
00A13C  A9C2CC     BCLR LATB, #6
134:                           break;
00A13E  370002     BRA 0xA144
135:                       case 'p':
136:                           SEG_DP = SEG_ON;
00A140  A942CC     BCLR LATB, #2
137:                           break;
00A142  000000     NOP
138:                   }
139:               }
00A144  FA8000     ULNK
00A146  060000     RETURN
140:               
141:               void clearSegment (char segment)
142:               {
00A148  FA0002     LNK #0x2
00A14A  784F00     MOV.B W0, [W14]
143:                   switch (segment)
00A14C  FB001E     SE [W14], W0
00A14E  B90161     MUL.SU W0, #1, W2
00A150  2FF9F0     MOV #0xFF9F, W0
00A152  2FFFF1     MOV #0xFFFF, W1
00A154  400002     ADD W0, W2, W0
00A156  488083     ADDC W1, W3, W1
00A158  2000F2     MOV #0xF, W2
00A15A  200003     MOV #0x0, W3
00A15C  500F82     SUB W0, W2, [W15]
00A15E  588F83     SUBB W1, W3, [W15]
00A160  3E0021     BRA GTU, 0xA1A4
00A162  016000     BRA W0
00A164  37000F     BRA 0xA184
00A166  370010     BRA 0xA188
00A168  370011     BRA 0xA18C
00A16A  370012     BRA 0xA190
00A16C  370013     BRA 0xA194
00A16E  370014     BRA 0xA198
00A170  370015     BRA 0xA19C
00A172  370018     BRA 0xA1A4
00A174  370017     BRA 0xA1A4
00A176  370016     BRA 0xA1A4
00A178  370015     BRA 0xA1A4
00A17A  370014     BRA 0xA1A4
00A17C  370013     BRA 0xA1A4
00A17E  370012     BRA 0xA1A4
00A180  370011     BRA 0xA1A4
00A182  37000E     BRA 0xA1A0
144:                   {
145:                       case 'a':
146:                           SEG_A = SEG_OFF;
00A184  A802CD     BSET 0x2CD, #0
147:                           break;
00A186  37000E     BRA 0xA1A4
148:                       case 'b':
149:                           SEG_B = SEG_OFF;
00A188  A8E2CC     BSET LATB, #7
150:                           break;
00A18A  37000C     BRA 0xA1A4
151:                       case 'c':
152:                           SEG_C = SEG_OFF;
00A18C  A882CC     BSET LATB, #4
153:                           break;
00A18E  37000A     BRA 0xA1A4
154:                       case 'd':
155:                           SEG_D = SEG_OFF;
00A190  A862CC     BSET LATB, #3
156:                           break;
00A192  370008     BRA 0xA1A4
157:                       case 'e':
158:                           SEG_E = SEG_OFF;
00A194  A822CD     BSET 0x2CD, #1
159:                           break;
00A196  370006     BRA 0xA1A4
160:                       case 'f':
161:                           SEG_F = SEG_OFF;
00A198  A8A2CC     BSET LATB, #5
162:                           break;
00A19A  370004     BRA 0xA1A4
163:                       case 'g':
164:                           SEG_G = SEG_OFF;
00A19C  A8C2CC     BSET LATB, #6
165:                           break;
00A19E  370002     BRA 0xA1A4
166:                       case 'p':
167:                           SEG_DP = SEG_OFF;
00A1A0  A842CC     BSET LATB, #2
168:                           break;
00A1A2  000000     NOP
169:                   }   
170:               }
00A1A4  FA8000     ULNK
00A1A6  060000     RETURN
171:               
172:               void writeDigit (unsigned char digit)
173:               {
00A1A8  FA0002     LNK #0x2
00A1AA  784F00     MOV.B W0, [W14]
174:               int j;
175:               
176:                   clearDisplay();
00A1AC  0700C9     RCALL clearDisplay
177:               
178:                   switch (digit)
00A1AE  78409E     MOV.B [W14], W1
00A1B0  FB8001     ZE W1, W0
00A1B2  DE80CF     ASR W0, #15, W1
00A1B4  2000F2     MOV #0xF, W2
00A1B6  200003     MOV #0x0, W3
00A1B8  500F82     SUB W0, W2, [W15]
00A1BA  588F83     SUBB W1, W3, [W15]
00A1BC  3E00BD     BRA GTU, 0xA338
00A1BE  016000     BRA W0
00A1C0  37000F     BRA 0xA1E0
00A1C2  37001B     BRA 0xA1FA
00A1C4  37001F     BRA 0xA204
00A1C6  370029     BRA 0xA21A
00A1C8  370033     BRA 0xA230
00A1CA  37003B     BRA 0xA242
00A1CC  370045     BRA 0xA258
00A1CE  370051     BRA 0xA272
00A1D0  370057     BRA 0xA280
00A1D2  370065     BRA 0xA29E
00A1D4  370071     BRA 0xA2B8
00A1D6  37007D     BRA 0xA2D2
00A1D8  370087     BRA 0xA2E8
00A1DA  37008F     BRA 0xA2FA
00A1DC  370099     BRA 0xA310
00A1DE  3700A3     BRA 0xA326
179:                   {
180:                      case 0x0:
181:                           setSegment('a');
00A1E0  B3C610     MOV #0x61, W0
00A1E2  07FF82     RCALL setSegment
182:                           setSegment('b');
00A1E4  B3C620     MOV #0x62, W0
00A1E6  07FF80     RCALL setSegment
183:                           setSegment('c');
00A1E8  B3C630     MOV #0x63, W0
00A1EA  07FF7E     RCALL setSegment
184:                           setSegment('d');
00A1EC  B3C640     MOV #0x64, W0
00A1EE  07FF7C     RCALL setSegment
185:                           setSegment('e');
00A1F0  B3C650     MOV #0x65, W0
00A1F2  07FF7A     RCALL setSegment
186:                           setSegment('f');
00A1F4  B3C660     MOV #0x66, W0
00A1F6  07FF78     RCALL setSegment
187:                           break;
00A1F8  3700A1     BRA 0xA33C
188:                      case 0x1:
189:                           setSegment('b');
00A1FA  B3C620     MOV #0x62, W0
00A1FC  07FF75     RCALL setSegment
190:                           setSegment('c');
00A1FE  B3C630     MOV #0x63, W0
00A200  07FF73     RCALL setSegment
191:                           break;
00A202  37009C     BRA 0xA33C
192:                      case 0x2:
193:                           setSegment('a');
00A204  B3C610     MOV #0x61, W0
00A206  07FF70     RCALL setSegment
194:                           setSegment('b');
00A208  B3C620     MOV #0x62, W0
00A20A  07FF6E     RCALL setSegment
195:                           setSegment('g');
00A20C  B3C670     MOV #0x67, W0
00A20E  07FF6C     RCALL setSegment
196:                           setSegment('e');
00A210  B3C650     MOV #0x65, W0
00A212  07FF6A     RCALL setSegment
197:                           setSegment('d');
00A214  B3C640     MOV #0x64, W0
00A216  07FF68     RCALL setSegment
198:                           break;
00A218  370091     BRA 0xA33C
199:                      case 0x3:
200:                           setSegment('a');
00A21A  B3C610     MOV #0x61, W0
00A21C  07FF65     RCALL setSegment
201:                           setSegment('b');
00A21E  B3C620     MOV #0x62, W0
00A220  07FF63     RCALL setSegment
202:                           setSegment('g');
00A222  B3C670     MOV #0x67, W0
00A224  07FF61     RCALL setSegment
203:                           setSegment('c');
00A226  B3C630     MOV #0x63, W0
00A228  07FF5F     RCALL setSegment
204:                           setSegment('d');
00A22A  B3C640     MOV #0x64, W0
00A22C  07FF5D     RCALL setSegment
205:                           break;
00A22E  370086     BRA 0xA33C
206:                      case 0x4:
207:                           setSegment('f');
00A230  B3C660     MOV #0x66, W0
00A232  07FF5A     RCALL setSegment
208:                           setSegment('g');
00A234  B3C670     MOV #0x67, W0
00A236  07FF58     RCALL setSegment
209:                           setSegment('b');
00A238  B3C620     MOV #0x62, W0
00A23A  07FF56     RCALL setSegment
210:                           setSegment('c');
00A23C  B3C630     MOV #0x63, W0
00A23E  07FF54     RCALL setSegment
211:                           break;
00A240  37007D     BRA 0xA33C
212:                      case 0x5:
213:                           setSegment('a');
00A242  B3C610     MOV #0x61, W0
00A244  07FF51     RCALL setSegment
214:                           setSegment('f');
00A246  B3C660     MOV #0x66, W0
00A248  07FF4F     RCALL setSegment
215:                           setSegment('g');
00A24A  B3C670     MOV #0x67, W0
00A24C  07FF4D     RCALL setSegment
216:                           setSegment('c');
00A24E  B3C630     MOV #0x63, W0
00A250  07FF4B     RCALL setSegment
217:                           setSegment('d');
00A252  B3C640     MOV #0x64, W0
00A254  07FF49     RCALL setSegment
218:                           break;
00A256  370072     BRA 0xA33C
219:                      case 0x6:
220:                           setSegment('a');
00A258  B3C610     MOV #0x61, W0
00A25A  07FF46     RCALL setSegment
221:                           setSegment('f');
00A25C  B3C660     MOV #0x66, W0
00A25E  07FF44     RCALL setSegment
222:                           setSegment('e');
00A260  B3C650     MOV #0x65, W0
00A262  07FF42     RCALL setSegment
223:                           setSegment('d');
00A264  B3C640     MOV #0x64, W0
00A266  07FF40     RCALL setSegment
224:                           setSegment('c');
00A268  B3C630     MOV #0x63, W0
00A26A  07FF3E     RCALL setSegment
225:                           setSegment('g');
00A26C  B3C670     MOV #0x67, W0
00A26E  07FF3C     RCALL setSegment
226:                           break;
00A270  370065     BRA 0xA33C
227:                      case 0x7:
228:                           setSegment('a');
00A272  B3C610     MOV #0x61, W0
00A274  07FF39     RCALL setSegment
229:                           setSegment('b');
00A276  B3C620     MOV #0x62, W0
00A278  07FF37     RCALL setSegment
230:                           setSegment('c');
00A27A  B3C630     MOV #0x63, W0
00A27C  07FF35     RCALL setSegment
231:                           break;
00A27E  37005E     BRA 0xA33C
232:                      case 0x8:
233:                           setSegment('a');
00A280  B3C610     MOV #0x61, W0
00A282  07FF32     RCALL setSegment
234:                           setSegment('b');
00A284  B3C620     MOV #0x62, W0
00A286  07FF30     RCALL setSegment
235:                           setSegment('c');
00A288  B3C630     MOV #0x63, W0
00A28A  07FF2E     RCALL setSegment
236:                           setSegment('d');
00A28C  B3C640     MOV #0x64, W0
00A28E  07FF2C     RCALL setSegment
237:                           setSegment('e');
00A290  B3C650     MOV #0x65, W0
00A292  07FF2A     RCALL setSegment
238:                           setSegment('f');
00A294  B3C660     MOV #0x66, W0
00A296  07FF28     RCALL setSegment
239:                           setSegment('g');
00A298  B3C670     MOV #0x67, W0
00A29A  07FF26     RCALL setSegment
240:                           break;
00A29C  37004F     BRA 0xA33C
241:                      case 0x9:
242:                           setSegment('a');
00A29E  B3C610     MOV #0x61, W0
00A2A0  07FF23     RCALL setSegment
243:                           setSegment('b');
00A2A2  B3C620     MOV #0x62, W0
00A2A4  07FF21     RCALL setSegment
244:                           setSegment('c');
00A2A6  B3C630     MOV #0x63, W0
00A2A8  07FF1F     RCALL setSegment
245:                           setSegment('d');
00A2AA  B3C640     MOV #0x64, W0
00A2AC  07FF1D     RCALL setSegment
246:                           setSegment('f');
00A2AE  B3C660     MOV #0x66, W0
00A2B0  07FF1B     RCALL setSegment
247:                           setSegment('g');
00A2B2  B3C670     MOV #0x67, W0
00A2B4  07FF19     RCALL setSegment
248:                           break;
00A2B6  370042     BRA 0xA33C
249:                      case 0xA:
250:                           setSegment('e');
00A2B8  B3C650     MOV #0x65, W0
00A2BA  07FF16     RCALL setSegment
251:                           setSegment('f');
00A2BC  B3C660     MOV #0x66, W0
00A2BE  07FF14     RCALL setSegment
252:                           setSegment('a');
00A2C0  B3C610     MOV #0x61, W0
00A2C2  07FF12     RCALL setSegment
253:                           setSegment('b');
00A2C4  B3C620     MOV #0x62, W0
00A2C6  07FF10     RCALL setSegment
254:                           setSegment('c');
00A2C8  B3C630     MOV #0x63, W0
00A2CA  07FF0E     RCALL setSegment
255:                           setSegment('g');
00A2CC  B3C670     MOV #0x67, W0
00A2CE  07FF0C     RCALL setSegment
256:                           break;
00A2D0  370035     BRA 0xA33C
257:                      case 0xB:
258:                           setSegment('f');
00A2D2  B3C660     MOV #0x66, W0
00A2D4  07FF09     RCALL setSegment
259:                           setSegment('e');
00A2D6  B3C650     MOV #0x65, W0
00A2D8  07FF07     RCALL setSegment
260:                           setSegment('d');
00A2DA  B3C640     MOV #0x64, W0
00A2DC  07FF05     RCALL setSegment
261:                           setSegment('c');
00A2DE  B3C630     MOV #0x63, W0
00A2E0  07FF03     RCALL setSegment
262:                           setSegment('g');
00A2E2  B3C670     MOV #0x67, W0
00A2E4  07FF01     RCALL setSegment
263:                           break;
00A2E6  37002A     BRA 0xA33C
264:                      case 0xC:
265:                           setSegment('a');
00A2E8  B3C610     MOV #0x61, W0
00A2EA  07FEFE     RCALL setSegment
266:                           setSegment('f');
00A2EC  B3C660     MOV #0x66, W0
00A2EE  07FEFC     RCALL setSegment
267:                           setSegment('e');
00A2F0  B3C650     MOV #0x65, W0
00A2F2  07FEFA     RCALL setSegment
268:                           setSegment('d');
00A2F4  B3C640     MOV #0x64, W0
00A2F6  07FEF8     RCALL setSegment
269:                           break;
00A2F8  370021     BRA 0xA33C
270:                      case 0xD:
271:                           setSegment('b');
00A2FA  B3C620     MOV #0x62, W0
00A2FC  07FEF5     RCALL setSegment
272:                           setSegment('c');
00A2FE  B3C630     MOV #0x63, W0
00A300  07FEF3     RCALL setSegment
273:                           setSegment('d');
00A302  B3C640     MOV #0x64, W0
00A304  07FEF1     RCALL setSegment
274:                           setSegment('e');
00A306  B3C650     MOV #0x65, W0
00A308  07FEEF     RCALL setSegment
275:                           setSegment('g');
00A30A  B3C670     MOV #0x67, W0
00A30C  07FEED     RCALL setSegment
276:                           break;
00A30E  370016     BRA 0xA33C
277:                      case 0xE:
278:                           setSegment('a');
00A310  B3C610     MOV #0x61, W0
00A312  07FEEA     RCALL setSegment
279:                           setSegment('f');
00A314  B3C660     MOV #0x66, W0
00A316  07FEE8     RCALL setSegment
280:                           setSegment('e');
00A318  B3C650     MOV #0x65, W0
00A31A  07FEE6     RCALL setSegment
281:                           setSegment('d');
00A31C  B3C640     MOV #0x64, W0
00A31E  07FEE4     RCALL setSegment
282:                           setSegment('g');
00A320  B3C670     MOV #0x67, W0
00A322  07FEE2     RCALL setSegment
283:                           break;
00A324  37000B     BRA 0xA33C
284:                      case 0xF:
285:                           setSegment('a');
00A326  B3C610     MOV #0x61, W0
00A328  07FEDF     RCALL setSegment
286:                           setSegment('f');
00A32A  B3C660     MOV #0x66, W0
00A32C  07FEDD     RCALL setSegment
287:                           setSegment('e');
00A32E  B3C650     MOV #0x65, W0
00A330  07FEDB     RCALL setSegment
288:                           setSegment('g');
00A332  B3C670     MOV #0x67, W0
00A334  07FED9     RCALL setSegment
289:                           break;
00A336  370002     BRA 0xA33C
290:                      default:
291:                           clearDisplay();
00A338  070003     RCALL clearDisplay
292:                           break;
00A33A  000000     NOP
293:                   }
294:               }
00A33C  FA8000     ULNK
00A33E  060000     RETURN
295:               
296:               void clearDisplay ()
297:               {
00A340  FA0000     LNK #0x0
298:                   LATBbits.LATB0 = 1;
00A342  A802CC     BSET LATB, #0
299:                    SEG_A = SEG_OFF;
00A344  A802CD     BSET 0x2CD, #0
300:                    SEG_B = SEG_OFF;
00A346  A8E2CC     BSET LATB, #7
301:                    SEG_C = SEG_OFF;
00A348  A882CC     BSET LATB, #4
302:                    SEG_D = SEG_OFF;
00A34A  A862CC     BSET LATB, #3
303:                    SEG_E = SEG_OFF;
00A34C  A822CD     BSET 0x2CD, #1
304:                    SEG_F = SEG_OFF;
00A34E  A8A2CC     BSET LATB, #5
305:                    SEG_G = SEG_OFF;
00A350  A8C2CC     BSET LATB, #6
306:                    SEG_DP = SEG_OFF;
00A352  A842CC     BSET LATB, #2
307:               }
00A354  FA8000     ULNK
00A356  060000     RETURN
308:               
309:               void writeNumber (int num, int b)
310:               {
00A358  FA0006     LNK #0x6
00A35A  980710     MOV W0, [W14+2]
00A35C  980721     MOV W1, [W14+4]
311:               int i;
312:               
313:                   clearDisplay();
00A35E  07FFF0     RCALL clearDisplay
314:                   selectDisplay(DISPLAY_NUM);
00A360  B3C030     MOV #0x3, W0
00A362  07FEA6     RCALL selectDisplay
315:               
316:                   for (i = 0; i < DISPLAY_NUM; i++)
00A364  EB0000     CLR W0
00A366  780F00     MOV W0, [W14]
00A368  370016     BRA 0xA396
00A394  E80F1E     INC [W14], [W14]
00A396  78001E     MOV [W14], W0
00A398  500FE2     SUB W0, #0x2, [W15]
00A39A  34FFE7     BRA LE, 0xA36A
00A39C  370001     BRA 0xA3A0
317:                   {
318:                       
319:                       selectDisplay(i);
00A36A  78001E     MOV [W14], W0
00A36C  784000     MOV.B W0, W0
00A36E  07FEA0     RCALL selectDisplay
320:                       clearDisplay();
00A370  07FFE7     RCALL clearDisplay
321:                       writeDigit (num%b);
00A372  90009E     MOV [W14+2], W1
00A374  90002E     MOV [W14+4], W0
00A376  780100     MOV W0, W2
00A378  090011     REPEAT #0x11
00A37A  D80082     DIV.SW W1, W2
00A37C  FD0080     EXCH W0, W1
00A37E  784000     MOV.B W0, W0
00A380  07FF13     RCALL writeDigit
322:                       num /= b;
00A382  90009E     MOV [W14+2], W1
00A384  90002E     MOV [W14+4], W0
00A386  780100     MOV W0, W2
00A388  090011     REPEAT #0x11
00A38A  D80082     DIV.SW W1, W2
00A38C  980710     MOV W0, [W14+2]
323:                       if (num == 0) break;
00A38E  90001E     MOV [W14+2], W0
00A390  500FE0     SUB W0, #0x0, [W15]
00A392  320005     BRA Z, 0xA39E
00A39E  000000     NOP
324:                   }
325:               
326:                   
327:               
328:                   clearDisplay();
00A3A0  07FFCF     RCALL clearDisplay
329:                   selectDisplay(DISPLAY_NUM);
00A3A2  B3C030     MOV #0x3, W0
00A3A4  07FE85     RCALL selectDisplay
330:               }
00A3A6  FA8000     ULNK
00A3A8  060000     RETURN
331:               
332:               void writeFloatNumber (double num)
333:               {
00A3AA  FA0018     LNK #0x18
00A3AC  781F88     MOV W8, [W15++]
00A3AE  980F20     MOV W0, [W14+20]
00A3B0  980F31     MOV W1, [W14+22]
334:               int i, dpPos, pow = 1, j, intNum = num, stop = 0, b = 10;
00A3B2  200010     MOV #0x1, W0
00A3B4  980710     MOV W0, [W14+2]
00A3B6  90082E     MOV [W14+20], W0
00A3B8  9008BE     MOV [W14+22], W1
00A3BA  07BAA4     RCALL ___fixsfsi
00A3BC  980730     MOV W0, [W14+6]
00A3BE  EB0000     CLR W0
00A3C0  980740     MOV W0, [W14+8]
00A3C2  2000A0     MOV #0xA, W0
00A3C4  980770     MOV W0, [W14+14]
335:               double dNum = num - intNum;
00A3C6  90003E     MOV [W14+6], W0
00A3C8  DE80CF     ASR W0, #15, W1
00A3CA  07BAD8     RCALL ___floatsisf
00A3CC  BE0100     MOV.D W0, W2
00A3CE  90082E     MOV [W14+20], W0
00A3D0  9008BE     MOV [W14+22], W1
00A3D2  07B9E7     RCALL ___subsf3
00A3D4  980750     MOV W0, [W14+10]
00A3D6  980761     MOV W1, [W14+12]
336:               
337:                   for ( i = 0; i <= DISPLAY_NUM && !stop; i++)
00A3D8  EB0000     CLR W0
00A3DA  780F00     MOV W0, [W14]
00A3DC  370014     BRA 0xA406
00A404  E80F1E     INC [W14], [W14]
00A406  78001E     MOV [W14], W0
00A408  500FE3     SUB W0, #0x3, [W15]
00A40A  3C0003     BRA GT, 0xA412
00A40C  90004E     MOV [W14+8], W0
00A40E  500FE0     SUB W0, #0x0, [W15]
00A410  32FFE6     BRA Z, 0xA3DE
338:                   {
339:                       if (num < pow) stop = 1;
00A3DE  90001E     MOV [W14+2], W0
00A3E0  DE80CF     ASR W0, #15, W1
00A3E2  07BACC     RCALL ___floatsisf
00A3E4  B3C018     MOV #0x1, W8
00A3E6  90092E     MOV [W14+20], W2
00A3E8  9009BE     MOV [W14+22], W3
00A3EA  07BA8A     RCALL ___gtsf2
00A3EC  500FE0     SUB W0, #0x0, [W15]
00A3EE  3C0001     BRA GT, 0xA3F2
00A3F0  EB4400     CLR.B W8
00A3F2  544FE0     SUB.B W8, #0x0, [W15]
00A3F4  320002     BRA Z, 0xA3FA
00A3F6  200010     MOV #0x1, W0
00A3F8  980740     MOV W0, [W14+8]
340:                       pow *= b;
00A3FA  90009E     MOV [W14+2], W1
00A3FC  90007E     MOV [W14+14], W0
00A3FE  B98800     MUL.SS W1, W0, W0
00A400  780000     MOV W0, W0
00A402  980710     MOV W0, [W14+2]
341:                   }
342:               
343:                   i--;
00A412  E90F1E     DEC [W14], [W14]
344:               
345:                   dpPos = i>0?i:1;
00A414  78001E     MOV [W14], W0
00A416  500FE0     SUB W0, #0x0, [W15]
00A418  3C0001     BRA GT, 0xA41C
00A41A  200010     MOV #0x1, W0
00A41C  980F00     MOV W0, [W14+16]
346:               
347:                   dpPos = DISPLAY_NUM - dpPos;
00A41E  90080E     MOV [W14+16], W0
00A420  100063     SUBR W0, #0x3, W0
00A422  980F00     MOV W0, [W14+16]
348:               
349:                   selectDisplay(dpPos);
00A424  90080E     MOV [W14+16], W0
00A426  784000     MOV.B W0, W0
00A428  07FE43     RCALL selectDisplay
350:                   setSegment ('p');
00A42A  B3C700     MOV #0x70, W0
00A42C  07FE5D     RCALL setSegment
351:               
352:                   for (i = 0; i < 40; i++);
00A42E  EB0000     CLR W0
00A430  780F00     MOV W0, [W14]
00A432  370001     BRA 0xA436
00A434  E80F1E     INC [W14], [W14]
00A436  200270     MOV #0x27, W0
00A438  78009E     MOV [W14], W1
00A43A  508F80     SUB W1, W0, [W15]
00A43C  34FFFB     BRA LE, 0xA434
353:               
354:                   for (i = dpPos; i < DISPLAY_NUM; i++)
00A43E  90080E     MOV [W14+16], W0
00A440  780F00     MOV W0, [W14]
00A442  370015     BRA 0xA46E
00A46C  E80F1E     INC [W14], [W14]
00A46E  78001E     MOV [W14], W0
00A470  500FE2     SUB W0, #0x2, [W15]
00A472  34FFE8     BRA LE, 0xA444
00A474  370001     BRA 0xA478
355:                   {
356:                       selectDisplay(i);
00A444  78001E     MOV [W14], W0
00A446  784000     MOV.B W0, W0
00A448  07FE33     RCALL selectDisplay
357:                       writeDigit (intNum%b);
00A44A  9000BE     MOV [W14+6], W1
00A44C  90007E     MOV [W14+14], W0
00A44E  780100     MOV W0, W2
00A450  090011     REPEAT #0x11
00A452  D80082     DIV.SW W1, W2
00A454  FD0080     EXCH W0, W1
00A456  784000     MOV.B W0, W0
00A458  07FEA7     RCALL writeDigit
358:               
359:                       intNum /= b;
00A45A  9000BE     MOV [W14+6], W1
00A45C  90007E     MOV [W14+14], W0
00A45E  780100     MOV W0, W2
00A460  090011     REPEAT #0x11
00A462  D80082     DIV.SW W1, W2
00A464  980730     MOV W0, [W14+6]
360:               
361:                       if (intNum == 0) break;
00A466  90003E     MOV [W14+6], W0
00A468  500FE0     SUB W0, #0x0, [W15]
00A46A  320005     BRA Z, 0xA476
00A476  000000     NOP
362:                   }
363:               
364:                   for (i = dpPos - 1; i >= 0; i--)
00A478  90080E     MOV [W14+16], W0
00A47A  E90F00     DEC W0, [W14]
00A47C  370026     BRA 0xA4CA
00A4C8  E90F1E     DEC [W14], [W14]
00A4CA  78001E     MOV [W14], W0
00A4CC  500FE0     SUB W0, #0x0, [W15]
00A4CE  3DFFD7     BRA GE, 0xA47E
365:                   {
366:                   int digit;
367:               
368:                       selectDisplay(i);
00A47E  78001E     MOV [W14], W0
00A480  784000     MOV.B W0, W0
00A482  07FE16     RCALL selectDisplay
369:               
370:                       digit = (dNum *= b);
00A484  90007E     MOV [W14+14], W0
00A486  DE80CF     ASR W0, #15, W1
00A488  07BA79     RCALL ___floatsisf
00A48A  BE0100     MOV.D W0, W2
00A48C  90005E     MOV [W14+10], W0
00A48E  9000EE     MOV [W14+12], W1
00A490  07BACD     RCALL ___mulsf3
00A492  980750     MOV W0, [W14+10]
00A494  980761     MOV W1, [W14+12]
00A496  90005E     MOV [W14+10], W0
00A498  9000EE     MOV [W14+12], W1
00A49A  07BA34     RCALL ___fixsfsi
00A49C  980F10     MOV W0, [W14+18]
371:                       writeDigit (digit);
00A49E  90081E     MOV [W14+18], W0
00A4A0  784000     MOV.B W0, W0
00A4A2  07FE82     RCALL writeDigit
372:                       dNum -= digit;
00A4A4  90081E     MOV [W14+18], W0
00A4A6  DE80CF     ASR W0, #15, W1
00A4A8  07BA69     RCALL ___floatsisf
00A4AA  BE0100     MOV.D W0, W2
00A4AC  90005E     MOV [W14+10], W0
00A4AE  9000EE     MOV [W14+12], W1
00A4B0  07B978     RCALL ___subsf3
00A4B2  980750     MOV W0, [W14+10]
00A4B4  980761     MOV W1, [W14+12]
373:                       for (j = 0; j < 30; j++);
00A4B6  EB0000     CLR W0
00A4B8  980720     MOV W0, [W14+4]
00A4BA  370003     BRA 0xA4C2
00A4BC  90002E     MOV [W14+4], W0
00A4BE  E80000     INC W0, W0
00A4C0  980720     MOV W0, [W14+4]
00A4C2  90002E     MOV [W14+4], W0
00A4C4  500FFD     SUB W0, #0x1D, [W15]
00A4C6  34FFFA     BRA LE, 0xA4BC
374:                   }
375:               
376:                   selectDisplay (DISPLAY_NUM);
00A4D0  B3C030     MOV #0x3, W0
00A4D2  07FDEE     RCALL selectDisplay
377:               }
00A4D4  78044F     MOV [--W15], W8
00A4D6  FA8000     ULNK
00A4D8  060000     RETURN
378:               
379:               /*
380:                * Makes it possible to asynchronously write a number on the display. It will be
381:                * really written only during the refresh routine.
382:                */
383:               void asyncWriteNumber (int num, int b)
384:               {
00A4DA  FA0004     LNK #0x4
00A4DC  780F00     MOV W0, [W14]
00A4DE  980711     MOV W1, [W14+2]
385:                   aNum = num;
00A4E0  78001E     MOV [W14], W0
00A4E2  888BE0     MOV W0, 0x117C
386:                   aBase = b;
00A4E4  90001E     MOV [W14+2], W0
00A4E6  888BF0     MOV W0, 0x117E
387:               }
00A4E8  FA8000     ULNK
00A4EA  060000     RETURN
388:               
389:               /*
390:                * Refreshes the display.
391:                */
392:               void refreshDisplay ()
393:               {
00A4EC  FA0000     LNK #0x0
394:               static int i = 0, num;
395:               
396:                   if (num == 0 || i == DISPLAY_NUM)
00A4EE  808C00     MOV num, W0
00A4F0  500FE0     SUB W0, #0x0, [W15]
00A4F2  320003     BRA Z, 0xA4FA
00A4F4  808C10     MOV i, W0
00A4F6  500FE3     SUB W0, #0x3, [W15]
00A4F8  3A0004     BRA NZ, 0xA502
397:                   {
398:                       num = aNum;
00A4FA  808BE0     MOV 0x117C, W0
00A4FC  888C00     MOV W0, num
399:                       i = 0;
00A4FE  EB0000     CLR W0
00A500  888C10     MOV W0, i
400:                   }
401:               
402:                   selectDisplay(i);
00A502  808C10     MOV i, W0
00A504  784000     MOV.B W0, W0
00A506  07FDD4     RCALL selectDisplay
403:                   clearDisplay();
00A508  07FF1B     RCALL clearDisplay
404:                   writeDigit (num%aBase);
00A50A  808C01     MOV num, W1
00A50C  808BF0     MOV 0x117E, W0
00A50E  780100     MOV W0, W2
00A510  090011     REPEAT #0x11
00A512  D80082     DIV.SW W1, W2
00A514  FD0080     EXCH W0, W1
00A516  784000     MOV.B W0, W0
00A518  07FE47     RCALL writeDigit
405:                   num /= aBase;
00A51A  808C01     MOV num, W1
00A51C  808BF0     MOV 0x117E, W0
00A51E  780100     MOV W0, W2
00A520  090011     REPEAT #0x11
00A522  D80082     DIV.SW W1, W2
00A524  888C00     MOV W0, num
406:                   i++;
00A526  808C10     MOV i, W0
00A528  E80000     INC W0, W0
00A52A  888C10     MOV W0, i
407:                   
408:               }
00A52C  FA8000     ULNK
00A52E  060000     RETURN
---  D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/consoleLike.c  --------------------------------
1:                 #include "consoleLike.h"
2:                 #include "SPIDisplay.h"
3:                 #include "vincent.h"
4:                 
5:                 #define STDIN   0
6:                 #define STDOUT  1
7:                 #define STDERR  2
8:                 #define LF   '\n'
9:                 #define CR   '\r'
10:                
11:                int iX = 0, iY = 0, actX = 0, actY = 0;
12:                
13:                void drawGraph (int *num);
14:                
15:                void moveCurConsoleLike (int x, int y)
16:                {
00C5EE  FA0004     LNK #0x4
00C5F0  780F00     MOV W0, [W14]
00C5F2  980711     MOV W1, [W14+2]
17:                    iX = x;
00C5F4  78001E     MOV [W14], W0
00C5F6  888AF0     MOV W0, 0x115E
18:                    iY = y;
00C5F8  90001E     MOV [W14+2], W0
00C5FA  888B00     MOV W0, 0x1160
19:                    resetConsoleLike();
00C5FC  070002     RCALL resetConsoleLike
20:                }
00C5FE  FA8000     ULNK
00C600  060000     RETURN
21:                
22:                void resetConsoleLike ()
23:                {
00C602  FA0000     LNK #0x0
24:                    actX = iX;
00C604  808AF0     MOV 0x115E, W0
00C606  888B10     MOV W0, 0x1162
25:                    actY = iY;
00C608  808B00     MOV 0x1160, W0
00C60A  888B20     MOV W0, 0x1164
26:                }
00C60C  FA8000     ULNK
00C60E  060000     RETURN
27:                
28:                void putch (char c)
29:                {
00C610  FA0002     LNK #0x2
00C612  781F88     MOV W8, [W15++]
00C614  784F00     MOV.B W0, [W14]
30:                    if (c != '\n')
00C616  78401E     MOV.B [W14], W0
00C618  504FEA     SUB.B W0, #0xA, [W15]
00C61A  320014     BRA Z, 0xC644
31:                    {
32:                        printCharSPIDisplay ((char)c, actX, actY);
00C61C  808B21     MOV 0x1164, W1
00C61E  808B10     MOV 0x1162, W0
00C620  780101     MOV W1, W2
00C622  780080     MOV W0, W1
00C624  78401E     MOV.B [W14], W0
00C626  07F140     RCALL printCharSPIDisplay
33:                
34:                        actX += CHAR_WIDTH;
00C628  808B10     MOV 0x1162, W0
00C62A  400068     ADD W0, #0x8, W0
00C62C  888B10     MOV W0, 0x1162
35:                
36:                        if (actX+CHAR_WIDTH - 1 >= maxXSPIDisplay())
00C62E  808B10     MOV 0x1162, W0
00C630  400467     ADD W0, #0x7, W8
00C632  07F132     RCALL maxXSPIDisplay
00C634  540F80     SUB W8, W0, [W15]
00C636  35000B     BRA LT, 0xC64E
37:                        {
38:                            actX = iX;
00C638  808AF0     MOV 0x115E, W0
00C63A  888B10     MOV W0, 0x1162
39:                            actY += CHAR_HEIGHT;
00C63C  808B20     MOV 0x1164, W0
00C63E  400068     ADD W0, #0x8, W0
00C640  888B20     MOV W0, 0x1164
00C642  370005     BRA 0xC64E
40:                        }
41:                    }
42:                    else
43:                    {
44:                        actX = iX;
00C644  808AF0     MOV 0x115E, W0
00C646  888B10     MOV W0, 0x1162
45:                        actY += CHAR_HEIGHT;
00C648  808B20     MOV 0x1164, W0
00C64A  400068     ADD W0, #0x8, W0
00C64C  888B20     MOV W0, 0x1164
46:                    }
47:                }
00C64E  78044F     MOV [--W15], W8
00C650  FA8000     ULNK
00C652  060000     RETURN
48:                
49:                
50:                void    mon_putc(char ch);
51:                
52:                int __attribute__((__weak__, __section__(".libc")))
53:                write(int handle, void * buffer, unsigned int len)
54:                {
001770  FA0008     LNK #0x8
001772  980710     MOV W0, [W14+2]
001774  980721     MOV W1, [W14+4]
001776  980732     MOV W2, [W14+6]
55:                    int i = 0;
001778  EB0000     CLR W0
00177A  780F00     MOV W0, [W14]
56:                    switch (handle)
00177C  90001E     MOV [W14+2], W0
00177E  E90000     DEC W0, W0
001780  500FE1     SUB W0, #0x1, [W15]
001782  3E000C     BRA GTU, 0x179C
57:                    {
58:                        case STDOUT:
59:                        case STDERR:    while (i < len)
001784  370006     BRA 0x1792
001792  78009E     MOV [W14], W1
001794  90003E     MOV [W14+6], W0
001796  508F80     SUB W1, W0, [W15]
001798  39FFF6     BRA NC, 0x1786
60:                                            putch(((char*)buffer)[i++]);
001786  9000AE     MOV [W14+4], W1
001788  78001E     MOV [W14], W0
00178A  408000     ADD W1, W0, W0
00178C  784010     MOV.B [W0], W0
00178E  E80F1E     INC [W14], [W14]
001790  07573F     RCALL putch
61:                                        break;
00179A  000000     NOP
62:                    }
63:                    return (len);  // number of characters written
00179C  90003E     MOV [W14+6], W0
64:                }
00179E  FA8000     ULNK
0017A0  060000     RETURN
65:                
---  D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/SPIDisplay.c  ---------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include "globalPinout.h"
4:                 
5:                 #include "SPIDisplay.h"
6:                 #include "SPIControl.h"
7:                 #include "vincent.h"
8:                 #include "timer1.h"
9:                 
10:                #define SET_A0_COMMAND A0_LAT = 0
11:                #define SET_A0_DATA A0_LAT = 1
12:                
13:                #define INSTANTANEOUS_SEND_DEFAULT 0
14:                
15:                #define MAXX 128
16:                #define MAXY 64
17:                
18:                #define PAGE_NUM 8
19:                
20:                //---Variabili globali
21:                
22:                //Invia subito un pixel appena modificato
23:                int instantaneousSend;
24:                
25:                //Buffer grafico: contiene lo stato attuale di tutti i pixel del display
26:                static char displayMtrx [PAGE_NUM][MAXX];
27:                
28:                //---Procedure private
29:                
30:                //Attiva o disattiva il pin per selezionare il display
31:                static void slaveSel (int active);
32:                
33:                //Invia un comando al display
34:                static inline void sendCommand (char command);
35:                
36:                //Invia un dato alla memoria grafica del display
37:                static inline void sendData (char data);
38:                
39:                //Imposta la posizione del cursore grafico sul display
40:                static inline void setPosition (char x, char y);
41:                
42:                //Aspetta del tempo
43:                static void delay(int cycles);
44:                
45:                //Inizializza il buffer grafico
46:                static void initMtrx();
47:                
48:                //Disegna una linea verticale sul display
49:                static void drawVLine (int x, int y1, int y2);
50:                
51:                void initSPIDisplay ()
52:                {
00A530  FA0000     LNK #0x0
53:                    initSPI(3, 7, 0, 1);
00A532  200013     MOV #0x1, W3
00A534  EB0100     CLR W2
00A536  200071     MOV #0x7, W1
00A538  200030     MOV #0x3, W0
00A53A  070DCB     RCALL initSPI
54:                    setSlaveSelectSPI (slaveSel);
00A53C  2A5B20     MOV #0xA5B2, W0
00A53E  070E0F     RCALL setSlaveSelectSPI
55:                
56:                    PS_LAT = 0;
00A540  A9E2CC     BCLR LATB, #7
57:                
58:                    RES_LAT = 0;
00A542  A9C2CD     BCLR 0x2CD, #6
59:                    delay (20000);
00A544  24E200     MOV #0x4E20, W0
00A546  07003F     RCALL delay
60:                    RES_LAT = 1;
00A548  A8C2CD     BSET 0x2CD, #6
61:                
62:                    delay (20000);
00A54A  24E200     MOV #0x4E20, W0
00A54C  07003C     RCALL delay
63:                    sendCommand (0xA2);
00A54E  B3CA20     MOV #0xA2, W0
00A550  070046     RCALL _sendCommand
64:                    delay (20000);
00A552  24E200     MOV #0x4E20, W0
00A554  070038     RCALL delay
65:                    sendCommand (0xA0);
00A556  B3CA00     MOV #0xA0, W0
00A558  070042     RCALL _sendCommand
66:                    delay (20000);
00A55A  24E200     MOV #0x4E20, W0
00A55C  070034     RCALL delay
67:                    sendCommand (0xC8);
00A55E  B3CC80     MOV #0xC8, W0
00A560  07003E     RCALL _sendCommand
68:                    delay (20000);
00A562  24E200     MOV #0x4E20, W0
00A564  070030     RCALL delay
69:                    sendCommand (0xA4);
00A566  B3CA40     MOV #0xA4, W0
00A568  07003A     RCALL _sendCommand
70:                    delay (20000);
00A56A  24E200     MOV #0x4E20, W0
00A56C  07002C     RCALL delay
71:                    sendCommand (0x40);
00A56E  B3C400     MOV #0x40, W0
00A570  070036     RCALL _sendCommand
72:                    delay (20000);
00A572  24E200     MOV #0x4E20, W0
00A574  070028     RCALL delay
73:                    sendCommand (0x25);
00A576  B3C250     MOV #0x25, W0
00A578  070032     RCALL _sendCommand
74:                    delay (20000);
00A57A  24E200     MOV #0x4E20, W0
00A57C  070024     RCALL delay
75:                    sendCommand (0x81);
00A57E  B3C810     MOV #0x81, W0
00A580  07002E     RCALL _sendCommand
76:                    delay (20000);
00A582  24E200     MOV #0x4E20, W0
00A584  070020     RCALL delay
77:                    sendCommand (0x13);
00A586  B3C130     MOV #0x13, W0
00A588  07002A     RCALL _sendCommand
78:                    delay (20000);
00A58A  24E200     MOV #0x4E20, W0
00A58C  07001C     RCALL delay
79:                    sendCommand (0x2F);
00A58E  B3C2F0     MOV #0x2F, W0
00A590  070026     RCALL _sendCommand
80:                    delay (20000);
00A592  24E200     MOV #0x4E20, W0
00A594  070018     RCALL delay
81:                    sendCommand (0xAF);
00A596  B3CAF0     MOV #0xAF, W0
00A598  070022     RCALL _sendCommand
82:                    delay (20000);
00A59A  24E200     MOV #0x4E20, W0
00A59C  070014     RCALL delay
83:                    sendCommand(0xA3);
00A59E  B3CA30     MOV #0xA3, W0
00A5A0  07001E     RCALL _sendCommand
84:                    delay (20000);
00A5A2  24E200     MOV #0x4E20, W0
00A5A4  070010     RCALL delay
85:                    //sendCommand (0xF8);
86:                    //sendCommand (0x03);
87:                
88:                    instantaneousSend = INSTANTANEOUS_SEND_DEFAULT;
00A5A6  EB0000     CLR W0
00A5A8  884280     MOV W0, instantaneousSend
89:                    
90:                    initMtrx();
00A5AA  070041     RCALL _initMtrx
91:                    refreshSPIDisplay();
00A5AC  07005C     RCALL refreshSPIDisplay
92:                }
00A5AE  FA8000     ULNK
00A5B0  060000     RETURN
93:                
94:                static void slaveSel (int active)
95:                {
00A5B2  FA0002     LNK #0x2
00A5B4  780F00     MOV W0, [W14]
96:                    if (active)
00A5B6  78001E     MOV [W14], W0
00A5B8  500FE0     SUB W0, #0x0, [W15]
00A5BA  320002     BRA Z, 0xA5C0
97:                    {
98:                        CS1_LAT = 0;
00A5BC  A962CD     BCLR 0x2CD, #3
00A5BE  370001     BRA 0xA5C2
99:                    }
100:                   else
101:                   {
102:                       CS1_LAT = 1;
00A5C0  A862CD     BSET 0x2CD, #3
103:                   }
104:               }
00A5C2  FA8000     ULNK
00A5C4  060000     RETURN
105:               
106:               static void delay(int cycles)
107:               {
00A5C6  FA0004     LNK #0x4
00A5C8  980710     MOV W0, [W14+2]
108:               int i;
109:               
110:                   for (i = 0; i < cycles; i++);
00A5CA  EB0000     CLR W0
00A5CC  780F00     MOV W0, [W14]
00A5CE  370001     BRA 0xA5D2
00A5D0  E80F1E     INC [W14], [W14]
00A5D2  90001E     MOV [W14+2], W0
00A5D4  78009E     MOV [W14], W1
00A5D6  508F80     SUB W1, W0, [W15]
00A5D8  35FFFB     BRA LT, 0xA5D0
111:               }
00A5DA  FA8000     ULNK
00A5DC  060000     RETURN
112:               
113:               static inline void sendCommand (char command)
114:               {
00A5DE  FA0002     LNK #0x2
00A5E0  784F00     MOV.B W0, [W14]
115:                   SET_A0_COMMAND;
00A5E2  A9E2CD     BCLR 0x2CD, #7
116:               
117:                   sendSPI (command);
00A5E4  78401E     MOV.B [W14], W0
00A5E6  070DC1     RCALL sendSPI
118:               }
00A5E8  FA8000     ULNK
00A5EA  060000     RETURN
119:               
120:               static inline void sendData (char data)
121:               {
00A5EC  FA0002     LNK #0x2
00A5EE  784F00     MOV.B W0, [W14]
122:                   SET_A0_DATA;
00A5F0  A8E2CD     BSET 0x2CD, #7
123:               
124:                   sendSPI (data);
00A5F2  78401E     MOV.B [W14], W0
00A5F4  070DBA     RCALL sendSPI
125:               }
00A5F6  FA8000     ULNK
00A5F8  060000     RETURN
126:               
127:               static inline void setPosition (char x, char y)
128:               {
00A5FA  FA0006     LNK #0x6
00A5FC  984740     MOV.B W0, [W14+4]
00A5FE  984751     MOV.B W1, [W14+5]
129:                   char com1, com2, com3;
130:               
131:                   com1 = (0x0B<<4) | (y & 0x0F);
00A600  90405E     MOV.B [W14+5], W0
00A602  6040EF     AND.B W0, #0xF, W1
00A604  B3CB00     MOV #0xB0, W0
00A606  70CF00     IOR.B W1, W0, [W14]
132:                   com2 = (0x00<<4) | (x & 0x0F);
00A608  90404E     MOV.B [W14+4], W0
00A60A  60406F     AND.B W0, #0xF, W0
00A60C  984710     MOV.B W0, [W14+1]
133:                   com3 = (0x01<<4) | ((x & 0xF0)>>4);
00A60E  90404E     MOV.B [W14+4], W0
00A610  FB0080     SE W0, W1
00A612  200F00     MOV #0xF0, W0
00A614  608000     AND W1, W0, W0
00A616  DE8044     ASR W0, #4, W0
00A618  784000     MOV.B W0, W0
00A61A  A04400     BSET.B W0, #4
00A61C  984720     MOV.B W0, [W14+2]
134:               
135:                   sendCommand (com1);
00A61E  78401E     MOV.B [W14], W0
00A620  07FFDE     RCALL _sendCommand
136:                   sendCommand (com2);
00A622  90401E     MOV.B [W14+1], W0
00A624  07FFDC     RCALL _sendCommand
137:                   sendCommand (com3);
00A626  90402E     MOV.B [W14+2], W0
00A628  07FFDA     RCALL _sendCommand
138:               }
00A62A  FA8000     ULNK
00A62C  060000     RETURN
139:               
140:               static void initMtrx()
141:               {
00A62E  FA0004     LNK #0x4
142:                   int i, j;
143:               
144:                   for (i = 0; i < PAGE_NUM; i++)
00A630  EB0000     CLR W0
00A632  780F00     MOV W0, [W14]
00A634  370013     BRA 0xA65C
00A65A  E80F1E     INC [W14], [W14]
00A65C  78001E     MOV [W14], W0
00A65E  500FE7     SUB W0, #0x7, [W15]
00A660  34FFEA     BRA LE, 0xA636
145:                   {
146:                       for (j = 0; j < MAXX; j++)
00A636  EB0000     CLR W0
00A638  980710     MOV W0, [W14+2]
00A63A  37000B     BRA 0xA652
00A64C  90001E     MOV [W14+2], W0
00A64E  E80000     INC W0, W0
00A650  980710     MOV W0, [W14+2]
00A652  90009E     MOV [W14+2], W1
00A654  2007F0     MOV #0x7F, W0
00A656  508F80     SUB W1, W0, [W15]
00A658  34FFF1     BRA LE, 0xA63C
147:                       {
148:                           displayMtrx[i][j] = 0;
00A63C  78001E     MOV [W14], W0
00A63E  DD00C7     SL W0, #7, W1
00A640  90001E     MOV [W14+2], W0
00A642  408080     ADD W1, W0, W1
00A644  208520     MOV #0x852, W0
00A646  408080     ADD W1, W0, W1
00A648  EB4000     CLR.B W0
00A64A  784880     MOV.B W0, [W1]
149:                       }
150:                   }
151:               }
00A662  FA8000     ULNK
00A664  060000     RETURN
152:               
153:               void inline refreshSPIDisplay ()
154:               {
00A666  FA0004     LNK #0x4
155:                   int i, j;
156:               
157:                   for (i = 0; i < PAGE_NUM; i++)
00A668  EB0000     CLR W0
00A66A  780F00     MOV W0, [W14]
00A66C  370018     BRA 0xA69E
00A69C  E80F1E     INC [W14], [W14]
00A69E  78001E     MOV [W14], W0
00A6A0  500FE7     SUB W0, #0x7, [W15]
00A6A2  34FFE5     BRA LE, 0xA66E
158:                   {
159:                       setPosition (0, i);
00A66E  78001E     MOV [W14], W0
00A670  784000     MOV.B W0, W0
00A672  784080     MOV.B W0, W1
00A674  EB4000     CLR.B W0
00A676  07FFC1     RCALL _setPosition
160:                       for (j = 0; j < MAXX; j++)
00A678  EB0000     CLR W0
00A67A  980710     MOV W0, [W14+2]
00A67C  37000B     BRA 0xA694
00A68E  90001E     MOV [W14+2], W0
00A690  E80000     INC W0, W0
00A692  980710     MOV W0, [W14+2]
00A694  90009E     MOV [W14+2], W1
00A696  2007F0     MOV #0x7F, W0
00A698  508F80     SUB W1, W0, [W15]
00A69A  34FFF1     BRA LE, 0xA67E
161:                       {
162:                           sendData (displayMtrx[i][j]);
00A67E  78001E     MOV [W14], W0
00A680  DD00C7     SL W0, #7, W1
00A682  90001E     MOV [W14+2], W0
00A684  408080     ADD W1, W0, W1
00A686  208520     MOV #0x852, W0
00A688  408000     ADD W1, W0, W0
00A68A  784010     MOV.B [W0], W0
00A68C  07FFAF     RCALL _sendData
163:                       }
164:                   }
165:               }
00A6A4  FA8000     ULNK
00A6A6  060000     RETURN
166:               
167:               void inline setPixelSPIDisplay (int x, int y, char color)
168:               {
00A6A8  FA000A     LNK #0xA
00A6AA  980720     MOV W0, [W14+4]
00A6AC  980731     MOV W1, [W14+6]
00A6AE  984F02     MOV.B W2, [W14+8]
169:                   char page = (char)y>>3, data, bitNum = (char)y%8, mask;
00A6B0  90003E     MOV [W14+6], W0
00A6B2  784000     MOV.B W0, W0
00A6B4  FB0000     SE W0, W0
00A6B6  DE8043     ASR W0, #3, W0
00A6B8  984710     MOV.B W0, [W14+1]
00A6BA  90003E     MOV [W14+6], W0
00A6BC  784000     MOV.B W0, W0
00A6BE  FB0080     SE W0, W1
00A6C0  200080     MOV #0x8, W0
00A6C2  780100     MOV W0, W2
00A6C4  090011     REPEAT #0x11
00A6C6  D80082     DIV.SW W1, W2
00A6C8  FD0080     EXCH W0, W1
00A6CA  984720     MOV.B W0, [W14+2]
170:               
171:                   if (x < MAXX && y < MAXY)
00A6CC  9000AE     MOV [W14+4], W1
00A6CE  2007F0     MOV #0x7F, W0
00A6D0  508F80     SUB W1, W0, [W15]
00A6D2  3C002D     BRA GT, 0xA72E
00A6D4  9000BE     MOV [W14+6], W1
00A6D6  2003F0     MOV #0x3F, W0
00A6D8  508F80     SUB W1, W0, [W15]
00A6DA  3C0029     BRA GT, 0xA72E
172:                   {
173:                       data = displayMtrx[page][x];
00A6DC  90401E     MOV.B [W14+1], W0
00A6DE  FB0000     SE W0, W0
00A6E0  DD00C7     SL W0, #7, W1
00A6E2  90002E     MOV [W14+4], W0
00A6E4  408080     ADD W1, W0, W1
00A6E6  208520     MOV #0x852, W0
00A6E8  408000     ADD W1, W0, W0
00A6EA  784F10     MOV.B [W0], [W14]
174:               
175:                       mask = 0x01<<bitNum;
00A6EC  90402E     MOV.B [W14+2], W0
00A6EE  FB0000     SE W0, W0
00A6F0  200011     MOV #0x1, W1
00A6F2  DD0800     SL W1, W0, W0
00A6F4  984730     MOV.B W0, [W14+3]
176:               
177:                       if (color != 0)
00A6F6  90480E     MOV.B [W14+8], W0
00A6F8  504FE0     SUB.B W0, #0x0, [W15]
00A6FA  320003     BRA Z, 0xA702
178:                       {
179:                           data |= mask;
00A6FC  90403E     MOV.B [W14+3], W0
00A6FE  704F1E     IOR.B W0, [W14], [W14]
00A700  370005     BRA 0xA70C
180:                       }
181:                       else
182:                       {
183:                           mask = ~mask;
00A702  90403E     MOV.B [W14+3], W0
00A704  EA8000     COM W0, W0
00A706  984730     MOV.B W0, [W14+3]
184:                           data &= mask;
00A708  90403E     MOV.B [W14+3], W0
00A70A  604F1E     AND.B W0, [W14], [W14]
185:                       }
186:               
187:                       displayMtrx[page][x] = data;
00A70C  90401E     MOV.B [W14+1], W0
00A70E  FB0000     SE W0, W0
00A710  DD00C7     SL W0, #7, W1
00A712  90002E     MOV [W14+4], W0
00A714  408080     ADD W1, W0, W1
00A716  208520     MOV #0x852, W0
00A718  408000     ADD W1, W0, W0
00A71A  78481E     MOV.B [W14], [W0]
188:               
189:                       if (instantaneousSend != 0)
00A71C  804280     MOV instantaneousSend, W0
00A71E  500FE0     SUB W0, #0x0, [W15]
00A720  320006     BRA Z, 0xA72E
190:                       {
191:                           setPosition (x, page);
00A722  90002E     MOV [W14+4], W0
00A724  784000     MOV.B W0, W0
00A726  90409E     MOV.B [W14+1], W1
00A728  07FF68     RCALL _setPosition
192:                           sendData(data);
00A72A  78401E     MOV.B [W14], W0
00A72C  07FF5F     RCALL _sendData
193:                       }
194:                   }
195:               }
00A72E  FA8000     ULNK
00A730  060000     RETURN
196:               
197:               void drawLineSPIDisplay (point p1, point p2)
198:               {
00A732  FA0026     LNK #0x26
00A734  BE9F88     MOV.D W8, [W15++]
00A736  980F70     MOV W0, [W14+30]
00A738  981701     MOV W1, [W14+32]
00A73A  981712     MOV W2, [W14+34]
00A73C  981723     MOV W3, [W14+36]
199:               point pMin, pMax, pAct, pPrec;
200:               int x, y;
201:               double m, q;
202:               
203:                   pMin = p1.x<p2.x?p1:p2;
00A73E  9008FE     MOV [W14+30], W1
00A740  90101E     MOV [W14+34], W0
00A742  508F80     SUB W1, W0, [W15]
00A744  3D0005     BRA GE, 0xA750
00A746  90087E     MOV [W14+30], W0
00A748  90108E     MOV [W14+32], W1
00A74A  980770     MOV W0, [W14+14]
00A74C  980F01     MOV W1, [W14+16]
00A74E  370004     BRA 0xA758
00A750  90101E     MOV [W14+34], W0
00A752  9010AE     MOV [W14+36], W1
00A754  980770     MOV W0, [W14+14]
00A756  980F01     MOV W1, [W14+16]
204:                   pMax = p1.x>p2.x?p1:p2;
00A758  9008FE     MOV [W14+30], W1
00A75A  90101E     MOV [W14+34], W0
00A75C  508F80     SUB W1, W0, [W15]
00A75E  340005     BRA LE, 0xA76A
00A760  90087E     MOV [W14+30], W0
00A762  90108E     MOV [W14+32], W1
00A764  980F10     MOV W0, [W14+18]
00A766  980F21     MOV W1, [W14+20]
00A768  370004     BRA 0xA772
00A76A  90101E     MOV [W14+34], W0
00A76C  9010AE     MOV [W14+36], W1
00A76E  980F10     MOV W0, [W14+18]
00A770  980F21     MOV W1, [W14+20]
205:               
206:                   if (p1.x != p2.x)
00A772  9008FE     MOV [W14+30], W1
00A774  90101E     MOV [W14+34], W0
00A776  508F80     SUB W1, W0, [W15]
00A778  32005B     BRA Z, 0xA830
207:                   {
208:                       m = (pMax.y-pMin.y)/(double)(pMax.x-pMin.x);
00A77A  9008AE     MOV [W14+20], W1
00A77C  90080E     MOV [W14+16], W0
00A77E  508000     SUB W1, W0, W0
00A780  DE80CF     ASR W0, #15, W1
00A782  07B8FC     RCALL ___floatsisf
00A784  BE0400     MOV.D W0, W8
00A786  90089E     MOV [W14+18], W1
00A788  90007E     MOV [W14+14], W0
00A78A  508000     SUB W1, W0, W0
00A78C  DE80CF     ASR W0, #15, W1
00A78E  07B8F6     RCALL ___floatsisf
00A790  BE0100     MOV.D W0, W2
00A792  BE0008     MOV.D W8, W0
00A794  07B864     RCALL ___divsf3
00A796  980710     MOV W0, [W14+2]
00A798  980721     MOV W1, [W14+4]
209:                       q = pMin.y - m*pMin.x;
00A79A  90080E     MOV [W14+16], W0
00A79C  DE80CF     ASR W0, #15, W1
00A79E  07B8EE     RCALL ___floatsisf
00A7A0  BE0400     MOV.D W0, W8
00A7A2  90007E     MOV [W14+14], W0
00A7A4  DE80CF     ASR W0, #15, W1
00A7A6  07B8EA     RCALL ___floatsisf
00A7A8  90011E     MOV [W14+2], W2
00A7AA  9001AE     MOV [W14+4], W3
00A7AC  07B93F     RCALL ___mulsf3
00A7AE  BE0100     MOV.D W0, W2
00A7B0  BE0008     MOV.D W8, W0
00A7B2  07B7F7     RCALL ___subsf3
00A7B4  980730     MOV W0, [W14+6]
00A7B6  980741     MOV W1, [W14+8]
210:               
211:                       for (x = pMin.x, pPrec = pMin; x <= pMax.x; x++)
00A7B8  9000FE     MOV [W14+14], W1
00A7BA  780F01     MOV W1, [W14]
00A7BC  90007E     MOV [W14+14], W0
00A7BE  90088E     MOV [W14+16], W1
00A7C0  980F50     MOV W0, [W14+26]
00A7C2  980F61     MOV W1, [W14+28]
00A7C4  370031     BRA 0xA828
00A826  E80F1E     INC [W14], [W14]
00A828  90081E     MOV [W14+18], W0
00A82A  500F9E     SUB W0, [W14], [W15]
00A82C  3DFFCC     BRA GE, 0xA7C6
00A82E  370004     BRA 0xA838
212:                       {
213:                       int yMax, yMin;
214:               
215:                           pAct.x = x;
00A7C6  78009E     MOV [W14], W1
00A7C8  980F31     MOV W1, [W14+22]
216:                           pAct.y = m*x + q;
00A7CA  78001E     MOV [W14], W0
00A7CC  DE80CF     ASR W0, #15, W1
00A7CE  07B8D6     RCALL ___floatsisf
00A7D0  90011E     MOV [W14+2], W2
00A7D2  9001AE     MOV [W14+4], W3
00A7D4  07B92B     RCALL ___mulsf3
00A7D6  90013E     MOV [W14+6], W2
00A7D8  9001CE     MOV [W14+8], W3
00A7DA  07B7E4     RCALL ___addsf3
00A7DC  07B893     RCALL ___fixsfsi
00A7DE  780000     MOV W0, W0
00A7E0  980F40     MOV W0, [W14+24]
217:               
218:                           yMax = pAct.y > pPrec.y?pAct.y:pPrec.y;
00A7E2  90086E     MOV [W14+28], W0
00A7E4  9008CE     MOV [W14+24], W1
00A7E6  500F81     SUB W0, W1, [W15]
00A7E8  3D0001     BRA GE, 0xA7EC
00A7EA  780001     MOV W1, W0
00A7EC  980750     MOV W0, [W14+10]
219:                           yMin = pAct.y < pPrec.y?pAct.y:pPrec.y;
00A7EE  90086E     MOV [W14+28], W0
00A7F0  9008CE     MOV [W14+24], W1
00A7F2  500F81     SUB W0, W1, [W15]
00A7F4  340001     BRA LE, 0xA7F8
00A7F6  780001     MOV W1, W0
00A7F8  980760     MOV W0, [W14+12]
220:               
221:                           yMin ++;
00A7FA  90006E     MOV [W14+12], W0
00A7FC  E80000     INC W0, W0
00A7FE  980760     MOV W0, [W14+12]
222:                           yMax --;
00A800  90005E     MOV [W14+10], W0
00A802  E90000     DEC W0, W0
00A804  980750     MOV W0, [W14+10]
223:               
224:                           if (yMax >= yMin) drawVLine (pAct.x, yMin, yMax);
00A806  9000DE     MOV [W14+10], W1
00A808  90006E     MOV [W14+12], W0
00A80A  508F80     SUB W1, W0, [W15]
00A80C  350004     BRA LT, 0xA816
00A80E  90083E     MOV [W14+22], W0
00A810  90015E     MOV [W14+10], W2
00A812  9000EE     MOV [W14+12], W1
00A814  070014     RCALL _drawVLine
225:               
226:                           setPixelSPIDisplay (pAct.x, pAct.y, 1);
00A816  9008CE     MOV [W14+24], W1
00A818  90083E     MOV [W14+22], W0
00A81A  B3C012     MOV #0x1, W2
00A81C  07FF45     RCALL setPixelSPIDisplay
227:               
228:                           pPrec = pAct;
00A81E  90083E     MOV [W14+22], W0
00A820  9008CE     MOV [W14+24], W1
00A822  980F50     MOV W0, [W14+26]
00A824  980F61     MOV W1, [W14+28]
229:                       }
230:                   }
231:                   else
232:                   {
233:                       drawVLine (p1.x, p1.y, p2.y);
00A830  90112E     MOV [W14+36], W2
00A832  90108E     MOV [W14+32], W1
00A834  90087E     MOV [W14+30], W0
00A836  070003     RCALL _drawVLine
234:                   }
235:               }
00A838  BE044F     MOV.D [--W15], W8
00A83A  FA8000     ULNK
00A83C  060000     RETURN
236:               
237:               static void drawVLine (int x, int y1, int y2)
238:               {
00A83E  FA000C     LNK #0xC
00A840  980730     MOV W0, [W14+6]
00A842  980741     MOV W1, [W14+8]
00A844  980752     MOV W2, [W14+10]
239:                   int i, yMin, yMax;
240:               
241:                   yMin = y1 < y2? y1 : y2;
00A846  9000CE     MOV [W14+8], W1
00A848  90005E     MOV [W14+10], W0
00A84A  500F81     SUB W0, W1, [W15]
00A84C  340001     BRA LE, 0xA850
00A84E  780001     MOV W1, W0
00A850  980710     MOV W0, [W14+2]
242:                   yMax = y1 > y2? y1 : y2;
00A852  9000CE     MOV [W14+8], W1
00A854  90005E     MOV [W14+10], W0
00A856  500F81     SUB W0, W1, [W15]
00A858  3D0001     BRA GE, 0xA85C
00A85A  780001     MOV W1, W0
00A85C  980720     MOV W0, [W14+4]
243:               
244:                   for (i = yMin; i <= yMax; i++)
00A85E  90001E     MOV [W14+2], W0
00A860  780F00     MOV W0, [W14]
00A862  370005     BRA 0xA86E
00A86C  E80F1E     INC [W14], [W14]
00A86E  90002E     MOV [W14+4], W0
00A870  78009E     MOV [W14], W1
00A872  508F80     SUB W1, W0, [W15]
00A874  34FFF7     BRA LE, 0xA864
245:                   {
246:                       setPixelSPIDisplay (x, i, 1);
00A864  B3C012     MOV #0x1, W2
00A866  78009E     MOV [W14], W1
00A868  90003E     MOV [W14+6], W0
00A86A  07FF1E     RCALL setPixelSPIDisplay
247:                   }
248:               }
00A876  FA8000     ULNK
00A878  060000     RETURN
249:               
250:               void eraseSPIDisplay()
251:               {
00A87A  FA0000     LNK #0x0
252:                   initMtrx();
00A87C  07FED8     RCALL _initMtrx
253:               }
00A87E  FA8000     ULNK
00A880  060000     RETURN
254:               
255:               point getPointSPIDisplay (int x, int y)
256:               {
00A882  FA0008     LNK #0x8
00A884  980721     MOV W1, [W14+4]
00A886  980732     MOV W2, [W14+6]
257:               point ris;
258:               
259:                   ris.x = x;
00A888  9000AE     MOV [W14+4], W1
00A88A  780F01     MOV W1, [W14]
260:                   ris.y = y;
00A88C  90013E     MOV [W14+6], W2
00A88E  980712     MOV W2, [W14+2]
261:               
262:                   return ris;
00A890  BE011E     MOV.D [W14], W2
00A892  BE8802     MOV.D W2, [W0]
263:               }
00A894  FA8000     ULNK
00A896  060000     RETURN
264:               
265:               int inline maxXSPIDisplay ()
266:               {
00A898  FA0000     LNK #0x0
267:                   return MAXX;
00A89A  200800     MOV #0x80, W0
268:               }
00A89C  FA8000     ULNK
00A89E  060000     RETURN
269:               
270:               int inline maxYSPIDisplay ()
271:               {
00A8A0  FA0000     LNK #0x0
272:                   return MAXY;
00A8A2  200400     MOV #0x40, W0
273:               }
00A8A4  FA8000     ULNK
00A8A6  060000     RETURN
274:               
275:               void printCharSPIDisplay (char c, int x, int y)
276:               {
00A8A8  FA008A     LNK #0x8A
00A8AA  98C740     MOV.B W0, [W14+68]
00A8AC  982731     MOV W1, [W14+70]
00A8AE  982742     MOV W2, [W14+72]
277:               vincentChar chr;
278:               int i,j;
279:               
280:                   chr = getCharVincent (c);
00A8B0  2004A0     MOV #0x4A, W0
00A8B2  40000E     ADD W0, W14, W0
00A8B4  90C0CE     MOV.B [W14+68], W1
00A8B6  070E24     RCALL getCharVincent
00A8B8  78000E     MOV W14, W0
00A8BA  B00040     ADD #0x4, W0
00A8BC  78008E     MOV W14, W1
00A8BE  B004A1     ADD #0x4A, W1
00A8C0  09003F     REPEAT #0x3F
00A8C2  785831     MOV.B [W1++], [W0++]
281:               
282:                   for (i = 0; i < CHAR_HEIGHT; i++)
00A8C4  EB0000     CLR W0
00A8C6  780F00     MOV W0, [W14]
00A8C8  370018     BRA 0xA8FA
00A8F8  E80F1E     INC [W14], [W14]
00A8FA  78001E     MOV [W14], W0
00A8FC  500FE7     SUB W0, #0x7, [W15]
00A8FE  34FFE5     BRA LE, 0xA8CA
283:                   {
284:                       for (j = 0; j < CHAR_HEIGHT; j++)
00A8CA  EB0000     CLR W0
00A8CC  980710     MOV W0, [W14+2]
00A8CE  370011     BRA 0xA8F2
00A8EC  90001E     MOV [W14+2], W0
00A8EE  E80000     INC W0, W0
00A8F0  980710     MOV W0, [W14+2]
00A8F2  90001E     MOV [W14+2], W0
00A8F4  500FE7     SUB W0, #0x7, [W15]
00A8F6  34FFEC     BRA LE, 0xA8D0
285:                       {
286:                           setPixelSPIDisplay (x + j, y + i, chr.pixelMatrix[i][j]);
00A8D0  78001E     MOV [W14], W0
00A8D2  DD00C3     SL W0, #3, W1
00A8D4  90001E     MOV [W14+2], W0
00A8D6  408000     ADD W1, W0, W0
00A8D8  470000     ADD W14, W0, W0
00A8DA  904040     MOV.B [W0+4], W0
00A8DC  9020CE     MOV [W14+72], W1
00A8DE  40809E     ADD W1, [W14], W1
00A8E0  9021BE     MOV [W14+70], W3
00A8E2  90011E     MOV [W14+2], W2
00A8E4  418182     ADD W3, W2, W3
00A8E6  784100     MOV.B W0, W2
00A8E8  780003     MOV W3, W0
00A8EA  07FEDE     RCALL setPixelSPIDisplay
287:                       }
288:                   }
289:               }
00A900  FA8000     ULNK
00A902  060000     RETURN
290:               
291:               void setInstantaneousSendSPIDisplay (int value)
292:               {
00A904  FA0002     LNK #0x2
00A906  780F00     MOV W0, [W14]
293:                   instantaneousSend = value;
00A908  78001E     MOV [W14], W0
00A90A  884280     MOV W0, instantaneousSend
294:               }
00A90C  FA8000     ULNK
00A90E  060000     RETURN
295:               
296:               int getInstantaneousSendSPIDisplay ()
297:               {
00A910  FA0000     LNK #0x0
298:                   return instantaneousSend;
00A912  804280     MOV instantaneousSend, W0
299:               }
00A914  FA8000     ULNK
00A916  060000     RETURN
300:               
301:               char getPixelSPIDisplay (int x, int y)
302:               {
00A918  FA000A     LNK #0xA
00A91A  980730     MOV W0, [W14+6]
00A91C  980741     MOV W1, [W14+8]
303:                   char page = (char)y>>3, data, bitNum = (char)y%8, mask, ris;
00A91E  90004E     MOV [W14+8], W0
00A920  784000     MOV.B W0, W0
00A922  FB0000     SE W0, W0
00A924  DE8043     ASR W0, #3, W0
00A926  784F00     MOV.B W0, [W14]
00A928  90004E     MOV [W14+8], W0
00A92A  784000     MOV.B W0, W0
00A92C  FB0080     SE W0, W1
00A92E  200080     MOV #0x8, W0
00A930  780100     MOV W0, W2
00A932  090011     REPEAT #0x11
00A934  D80082     DIV.SW W1, W2
00A936  FD0080     EXCH W0, W1
00A938  984710     MOV.B W0, [W14+1]
304:               
305:                   if (x < MAXX && y < MAXY)
00A93A  9000BE     MOV [W14+6], W1
00A93C  2007F0     MOV #0x7F, W0
00A93E  508F80     SUB W1, W0, [W15]
00A940  3C001D     BRA GT, 0xA97C
00A942  9000CE     MOV [W14+8], W1
00A944  2003F0     MOV #0x3F, W0
00A946  508F80     SUB W1, W0, [W15]
00A948  3C0019     BRA GT, 0xA97C
306:                   {
307:                       data = displayMtrx[page][x];
00A94A  FB001E     SE [W14], W0
00A94C  DD00C7     SL W0, #7, W1
00A94E  90003E     MOV [W14+6], W0
00A950  408080     ADD W1, W0, W1
00A952  208520     MOV #0x852, W0
00A954  408000     ADD W1, W0, W0
00A956  784090     MOV.B [W0], W1
00A958  984721     MOV.B W1, [W14+2]
308:               
309:                       mask = 0x01<<bitNum;
00A95A  90401E     MOV.B [W14+1], W0
00A95C  FB0000     SE W0, W0
00A95E  200011     MOV #0x1, W1
00A960  DD0800     SL W1, W0, W0
00A962  984730     MOV.B W0, [W14+3]
310:               
311:                       ris = data & mask;
00A964  9040AE     MOV.B [W14+2], W1
00A966  90403E     MOV.B [W14+3], W0
00A968  60C000     AND.B W1, W0, W0
00A96A  984740     MOV.B W0, [W14+4]
312:               
313:                       ris = ris >> bitNum;
00A96C  90404E     MOV.B [W14+4], W0
00A96E  FB0080     SE W0, W1
00A970  90401E     MOV.B [W14+1], W0
00A972  FB0000     SE W0, W0
00A974  DE8800     ASR W1, W0, W0
00A976  984740     MOV.B W0, [W14+4]
314:               
315:                       return ris;
00A978  90404E     MOV.B [W14+4], W0
00A97A  370001     BRA 0xA97E
316:                   }
317:               
318:                   return 0;
00A97C  EB4000     CLR.B W0
319:               }
00A97E  FA8000     ULNK
00A980  060000     RETURN
320:               
321:               inline char getPageSPIDisplay (int x, int y)
322:               {
00A982  FA0004     LNK #0x4
00A984  780F00     MOV W0, [W14]
00A986  980711     MOV W1, [W14+2]
323:                   return displayMtrx[(char)(y>>3)][x];
00A988  90001E     MOV [W14+2], W0
00A98A  DE8043     ASR W0, #3, W0
00A98C  784000     MOV.B W0, W0
00A98E  FB0000     SE W0, W0
00A990  DD0047     SL W0, #7, W0
00A992  40009E     ADD W0, [W14], W1
00A994  208520     MOV #0x852, W0
00A996  408000     ADD W1, W0, W0
00A998  784010     MOV.B [W0], W0
324:               }
00A99A  FA8000     ULNK
00A99C  060000     RETURN
325:               
326:               inline void setPageSPIDisplay (int x, int y, char val)
327:               {
00A99E  FA0006     LNK #0x6
00A9A0  780F00     MOV W0, [W14]
00A9A2  980711     MOV W1, [W14+2]
00A9A4  984742     MOV.B W2, [W14+4]
328:                   displayMtrx[(char)(y>>3)][x] = val;
00A9A6  90001E     MOV [W14+2], W0
00A9A8  DE8043     ASR W0, #3, W0
00A9AA  784000     MOV.B W0, W0
00A9AC  FB0000     SE W0, W0
00A9AE  DD0047     SL W0, #7, W0
00A9B0  40009E     ADD W0, [W14], W1
00A9B2  208520     MOV #0x852, W0
00A9B4  408000     ADD W1, W0, W0
00A9B6  9040CE     MOV.B [W14+4], W1
00A9B8  784801     MOV.B W1, [W0]
329:                   if (instantaneousSend != 0)
00A9BA  804280     MOV instantaneousSend, W0
00A9BC  500FE0     SUB W0, #0x0, [W15]
00A9BE  320010     BRA Z, 0xA9E0
330:                   {
331:                      setPosition (x, y>>3);
00A9C0  90001E     MOV [W14+2], W0
00A9C2  DE8043     ASR W0, #3, W0
00A9C4  784080     MOV.B W0, W1
00A9C6  78001E     MOV [W14], W0
00A9C8  784000     MOV.B W0, W0
00A9CA  07FE17     RCALL _setPosition
332:                      sendData(displayMtrx[(char)(y>>3)][x]);
00A9CC  90001E     MOV [W14+2], W0
00A9CE  DE8043     ASR W0, #3, W0
00A9D0  784000     MOV.B W0, W0
00A9D2  FB0000     SE W0, W0
00A9D4  DD0047     SL W0, #7, W0
00A9D6  40009E     ADD W0, [W14], W1
00A9D8  208520     MOV #0x852, W0
00A9DA  408000     ADD W1, W0, W0
00A9DC  784010     MOV.B [W0], W0
00A9DE  07FE06     RCALL _sendData
333:                   }
334:               }
00A9E0  FA8000     ULNK
00A9E2  060000     RETURN
---  D:/Davide/Documenti/CL Project/Lavoro/PIC/Rosmeter.X/SPIControl.c  ---------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include "globalPinout.h"
4:                 
5:                 #include "SPIControl.h"
6:                 #include "display.h"
7:                 
8:                 #include "timer1.h"
9:                 
10:                static void (*slaveSel) (int active);
11:                
12:                //Aspetta del tempo
13:                static void delay(int cycles);
14:                
15:                void initSPI (int prescale1, int prescale2, int clockEdge, int clockPolarity)
16:                {
00C0D2  FA0008     LNK #0x8
00C0D4  780F00     MOV W0, [W14]
00C0D6  980711     MOV W1, [W14+2]
00C0D8  980722     MOV W2, [W14+4]
00C0DA  980733     MOV W3, [W14+6]
17:                
18:                    SPI1STATbits.SPIEN = 0;
00C0DC  A9E241     BCLR 0x241, #7
19:                
20:                    delay (20000);
00C0DE  24E200     MOV #0x4E20, W0
00C0E0  070058     RCALL _delay
21:                
22:                    SPI1CON1bits.DISSCK = 0;
00C0E2  A98243     BCLR 0x243, #4
23:                    SPI1CON1bits.DISSDO = 0;
00C0E4  A96243     BCLR 0x243, #3
24:                    
25:                    SPI1CON1bits.MODE16 = 0;
00C0E6  A94243     BCLR 0x243, #2
26:                    
27:                    SPI1CON1bits.CKE = clockEdge;
00C0E8  90002E     MOV [W14+4], W0
00C0EA  784000     MOV.B W0, W0
00C0EC  604061     AND.B W0, #0x1, W0
00C0EE  FB8000     ZE W0, W0
00C0F0  600061     AND W0, #0x1, W0
00C0F2  DD0048     SL W0, #8, W0
00C0F4  801212     MOV SPI1CON1, W2
00C0F6  2FEFF1     MOV #0xFEFF, W1
00C0F8  610081     AND W2, W1, W1
00C0FA  708000     IOR W1, W0, W0
00C0FC  881210     MOV W0, SPI1CON1
28:                    SPI1CON1bits.CKP = clockPolarity;
00C0FE  90003E     MOV [W14+6], W0
00C100  784000     MOV.B W0, W0
00C102  604061     AND.B W0, #0x1, W0
00C104  FB8000     ZE W0, W0
00C106  600061     AND W0, #0x1, W0
00C108  DD0046     SL W0, #6, W0
00C10A  801212     MOV SPI1CON1, W2
00C10C  2FFBF1     MOV #0xFFBF, W1
00C10E  610081     AND W2, W1, W1
00C110  708000     IOR W1, W0, W0
00C112  881210     MOV W0, SPI1CON1
29:                    
30:                    SPI1CON1bits.SSEN = 0;
00C114  A9E242     BCLR SPI1CON1, #7
31:                    
32:                    SPI1CON1bits.MSTEN = 1;
00C116  A8A242     BSET SPI1CON1, #5
33:                
34:                    SPI1CON1bits.SMP = 1;
00C118  A82243     BSET 0x243, #1
35:                
36:                    SPI1CON1bits.SPRE = prescale2;
00C11A  90001E     MOV [W14+2], W0
00C11C  784000     MOV.B W0, W0
00C11E  604067     AND.B W0, #0x7, W0
00C120  FB8000     ZE W0, W0
00C122  600067     AND W0, #0x7, W0
00C124  DD0042     SL W0, #2, W0
00C126  801212     MOV SPI1CON1, W2
00C128  2FFE31     MOV #0xFFE3, W1
00C12A  610081     AND W2, W1, W1
00C12C  708000     IOR W1, W0, W0
00C12E  881210     MOV W0, SPI1CON1
37:                    SPI1CON1bits.PPRE = prescale1;
00C130  78001E     MOV [W14], W0
00C132  784000     MOV.B W0, W0
00C134  604063     AND.B W0, #0x3, W0
00C136  FB8000     ZE W0, W0
00C138  600063     AND W0, #0x3, W0
00C13A  801212     MOV SPI1CON1, W2
00C13C  2FFFC1     MOV #0xFFFC, W1
00C13E  610081     AND W2, W1, W1
00C140  708000     IOR W1, W0, W0
00C142  881210     MOV W0, SPI1CON1
38:                
39:                    prescale2 = SPI1CON1bits.SPRE;
00C144  801210     MOV SPI1CON1, W0
00C146  DE0042     LSR W0, #2, W0
00C148  604067     AND.B W0, #0x7, W0
00C14A  FB8000     ZE W0, W0
00C14C  980710     MOV W0, [W14+2]
40:                    prescale1 = SPI1CON1bits.PPRE;
00C14E  801210     MOV SPI1CON1, W0
00C150  784000     MOV.B W0, W0
00C152  604063     AND.B W0, #0x3, W0
00C154  FB8000     ZE W0, W0
00C156  780F00     MOV W0, [W14]
41:                
42:                    SPI1STATbits.SPIEN = 1;
00C158  A8E241     BSET 0x241, #7
43:                }
00C15A  FA8000     ULNK
00C15C  060000     RETURN
44:                
45:                void inline setSlaveSelectSPI (void (*ss) (int active))
46:                {
00C15E  FA0002     LNK #0x2
00C160  780F00     MOV W0, [W14]
47:                    slaveSel = ss;
00C162  78001E     MOV [W14], W0
00C164  888C80     MOV W0, slaveSel
48:                }
00C166  FA8000     ULNK
00C168  060000     RETURN
49:                
50:                void inline sendSPI (char byte)
51:                {
00C16A  FA0002     LNK #0x2
00C16C  784F00     MOV.B W0, [W14]
52:                    slaveSel (1);
00C16E  808C81     MOV slaveSel, W1
00C170  200010     MOV #0x1, W0
00C172  010001     CALL W1
53:                
54:                    SPI1BUF = byte;
00C174  FB001E     SE [W14], W0
00C176  881240     MOV W0, SPI1BUF
55:                
56:                    while (!IFS0bits.SPI1IF);
00C178  000000     NOP
00C17A  800421     MOV IFS0, W1
00C17C  204000     MOV #0x400, W0
00C17E  608000     AND W1, W0, W0
00C180  500FE0     SUB W0, #0x0, [W15]
00C182  32FFFB     BRA Z, 0xC17A
57:                
58:                    byte = SPI1BUF;
00C184  801240     MOV SPI1BUF, W0
00C186  784F00     MOV.B W0, [W14]
59:                
60:                    slaveSel (0);
00C188  808C81     MOV slaveSel, W1
00C18A  EB0000     CLR W0
00C18C  010001     CALL W1
61:                }
00C18E  FA8000     ULNK
00C190  060000     RETURN
62:                
63:                static void delay(int cycles)
64:                {
00C192  FA0004     LNK #0x4
00C194  980710     MOV W0, [W14+2]
65:                int i;
66:                
67:                    for (i = 0; i < cycles; i++);
00C196  EB0000     CLR W0
00C198  780F00     MOV W0, [W14]
00C19A  370001     BRA 0xC19E
00C19C  E80F1E     INC [W14], [W14]
00C19E  90001E     MOV [W14+2], W0
00C1A0  78009E     MOV [W14], W1
00C1A2  508F80     SUB W1, W0, [W15]
00C1A4  35FFFB     BRA LT, 0xC19C
68:                }
00C1A6  FA8000     ULNK
00C1A8  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timers.c  -------------------------------------
1:                 #include "stdlib.h"
2:                 #include "string.h"
3:                 
4:                 #include "timers.h"
5:                 #include "timer1.h"
6:                 #include "timer2.h"
7:                 
8:                 #define TIMERS_NO 2
9:                 
10:                int timersUsed [TIMERS_NO];
11:                timer timers [TIMERS_NO];
12:                
13:                timer err = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
14:                
15:                void timersInit()
16:                {
00BEFC  FA0002     LNK #0x2
17:                int i;
18:                
19:                    for (i = 0; i < TIMERS_NO; i++)
00BEFE  EB0000     CLR W0
00BF00  780F00     MOV W0, [W14]
00BF02  370007     BRA 0xBF12
00BF10  E80F1E     INC [W14], [W14]
00BF12  78001E     MOV [W14], W0
00BF14  500FE1     SUB W0, #0x1, [W15]
00BF16  34FFF6     BRA LE, 0xBF04
20:                    {
21:                        timersUsed[i] = 0;
00BF04  78001E     MOV [W14], W0
00BF06  400080     ADD W0, W0, W1
00BF08  20FEC0     MOV #0xFEC, W0
00BF0A  408000     ADD W1, W0, W0
00BF0C  EB0080     CLR W1
00BF0E  780801     MOV W1, [W0]
22:                    }
23:                
24:                    timers[0].init = timer1Init_OLD;
00BF18  20AF20     MOV #0xAF2, W0
00BF1A  887FA0     MOV W0, 0xFF4
25:                    timers[0].delay = timer1Delay;
00BF1C  20C620     MOV #0xC62, W0
00BF1E  887FB0     MOV W0, 0xFF6
26:                    timers[0].getCount = getTimer1Count;
00BF20  20CC80     MOV #0xCC8, W0
00BF22  887FF0     MOV W0, 0xFFE
27:                    timers[0].reset = timer1Reset;
00BF24  20CBE0     MOV #0xCBE, W0
00BF26  887FE0     MOV W0, 0xFFC
28:                    timers[0].setCallback = setTimer1Callback;
00BF28  20CE80     MOV #0xCE8, W0
00BF2A  888010     MOV W0, 0x1002
29:                    timers[0].setInterval = setTimer1Interval;
00BF2C  20B4A0     MOV #0xB4A, W0
00BF2E  887F90     MOV W0, 0xFF2
30:                    timers[0].setPrescaler = setTimer1Prescaler;
00BF30  20B1A0     MOV #0xB1A, W0
00BF32  887F80     MOV W0, timers
31:                    timers[0].start = timer1Start;
00BF34  20CAE0     MOV #0xCAE, W0
00BF36  887FC0     MOV W0, 0xFF8
32:                    timers[0].stop = timer1Stop;
00BF38  20CB60     MOV #0xCB6, W0
00BF3A  887FD0     MOV W0, 0xFFA
33:                    timers[0].elaspedTime = timer1ElaspedTime;
00BF3C  20CF40     MOV #0xCF4, W0
00BF3E  888020     MOV W0, 0x1004
34:                    timers[0].waitUntilEnd = timer1WaitUntilEnd;
00BF40  20CD20     MOV #0xCD2, W0
00BF42  888000     MOV W0, 0x1000
35:                    timers[0].getFreq = getTimer1Freq;
00BF44  20C860     MOV #0xC86, W0
00BF46  888030     MOV W0, 0x1006
36:                
37:                    timers[1].init = timer2Init;
00BF48  20D640     MOV #0xD64, W0
00BF4A  888060     MOV W0, 0x100C
38:                    timers[1].delay = timer2Delay;
00BF4C  20F2C0     MOV #0xF2C, W0
00BF4E  888070     MOV W0, 0x100E
39:                    timers[1].getCount = getTimer2Count;
00BF50  20F940     MOV #0xF94, W0
00BF52  8880B0     MOV W0, 0x1016
40:                    timers[1].reset = timer2Reset;
00BF54  20F8A0     MOV #0xF8A, W0
00BF56  8880A0     MOV W0, 0x1014
41:                    timers[1].setCallback = setTimer2Callback;
00BF58  20FB60     MOV #0xFB6, W0
00BF5A  8880D0     MOV W0, 0x101A
42:                    timers[1].setInterval = setTimer2Interval;
00BF5C  20DC80     MOV #0xDC8, W0
00BF5E  888050     MOV W0, 0x100A
43:                    timers[1].setPrescaler = setTimer2Prescaler;
00BF60  20D8A0     MOV #0xD8A, W0
00BF62  888040     MOV W0, 0x1008
44:                    timers[1].start = timer2Start;
00BF64  20F7A0     MOV #0xF7A, W0
00BF66  888080     MOV W0, 0x1010
45:                    timers[1].stop = timer2Stop;
00BF68  20F820     MOV #0xF82, W0
00BF6A  888090     MOV W0, 0x1012
46:                    timers[1].elaspedTime = timer2ElaspedTime;
00BF6C  20FC20     MOV #0xFC2, W0
00BF6E  8880E0     MOV W0, 0x101C
47:                    timers[1].waitUntilEnd = timer2WaitUntilEnd;
00BF70  20F9E0     MOV #0xF9E, W0
00BF72  8880C0     MOV W0, 0x1018
48:                    timers[1].getFreq = getTimer2Freq;
00BF74  20F520     MOV #0xF52, W0
00BF76  8880F0     MOV W0, 0x101E
49:                
50:                    
51:                    for (i = 0; i < TIMERS_NO; i++)
00BF78  EB0000     CLR W0
00BF7A  780F00     MOV W0, [W14]
00BF7C  370009     BRA 0xBF90
00BF8E  E80F1E     INC [W14], [W14]
00BF90  78001E     MOV [W14], W0
00BF92  500FE1     SUB W0, #0x1, [W15]
00BF94  34FFF4     BRA LE, 0xBF7E
52:                    {
53:                        timers[i].init();
00BF7E  78001E     MOV [W14], W0
00BF80  B90078     MUL.SU W0, #24, W0
00BF82  780000     MOV W0, W0
00BF84  4000E4     ADD W0, #0x4, W1
00BF86  20FF00     MOV #0xFF0, W0
00BF88  408000     ADD W1, W0, W0
00BF8A  780010     MOV [W0], W0
00BF8C  010000     CALL W0
54:                    }
55:                
56:                }
00BF96  FA8000     ULNK
00BF98  060000     RETURN
57:                
58:                int getTimer (timerID id, timer *tmr)
59:                {
00BF9A  FA0004     LNK #0x4
00BF9C  780F00     MOV W0, [W14]
00BF9E  980711     MOV W1, [W14+2]
60:                    if (id < TIMERS_NO && timersUsed[id] == 0)
00BFA0  78001E     MOV [W14], W0
00BFA2  500FE1     SUB W0, #0x1, [W15]
00BFA4  3E0013     BRA GTU, 0xBFCC
00BFA6  78001E     MOV [W14], W0
00BFA8  400080     ADD W0, W0, W1
00BFAA  20FEC0     MOV #0xFEC, W0
00BFAC  408000     ADD W1, W0, W0
00BFAE  780010     MOV [W0], W0
00BFB0  500FE0     SUB W0, #0x0, [W15]
00BFB2  3A000C     BRA NZ, 0xBFCC
61:                    {
62:                        (*tmr) = timers[id];
00BFB4  90011E     MOV [W14+2], W2
00BFB6  78001E     MOV [W14], W0
00BFB8  B90078     MUL.SU W0, #24, W0
00BFBA  780080     MOV W0, W1
00BFBC  20FF00     MOV #0xFF0, W0
00BFBE  408000     ADD W1, W0, W0
00BFC0  09000B     REPEAT #0xB
00BFC2  781930     MOV [W0++], [W2++]
00BFC4  B10182     SUB #0x18, W2
00BFC6  B10180     SUB #0x18, W0
63:                        return 1;
00BFC8  200010     MOV #0x1, W0
00BFCA  370006     BRA 0xBFD8
64:                    }
65:                    else
66:                    {
67:                        (*tmr) = err;
00BFCC  90001E     MOV [W14+2], W0
00BFCE  210C21     MOV #0x10C2, W1
00BFD0  09000B     REPEAT #0xB
00BFD2  781831     MOV [W1++], [W0++]
00BFD4  B10180     SUB #0x18, W0
68:                        return 0;
00BFD6  EB0000     CLR W0
69:                    }
70:                }
00BFD8  FA8000     ULNK
00BFDA  060000     RETURN
71:                
72:                void freeTimer (timerID id)
73:                {
00BFDC  FA0002     LNK #0x2
00BFDE  780F00     MOV W0, [W14]
74:                    if (id < TIMERS_NO)
00BFE0  78001E     MOV [W14], W0
00BFE2  500FE1     SUB W0, #0x1, [W15]
00BFE4  3E0006     BRA GTU, 0xBFF2
75:                    {
76:                        timersUsed [id] = 0;
00BFE6  78001E     MOV [W14], W0
00BFE8  400080     ADD W0, W0, W1
00BFEA  20FEC0     MOV #0xFEC, W0
00BFEC  408000     ADD W1, W0, W0
00BFEE  EB0080     CLR W1
00BFF0  780801     MOV W1, [W0]
77:                    }
78:                }
00BFF2  FA8000     ULNK
00BFF4  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timer45.c  ------------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include <stdlib.h>
4:                 #include "ClockControl.h"
5:                 #include "timer3.h"
6:                 
7:                 #define MIN_PRESCALER 0
8:                 #define MAX_PRESCALER 3
9:                 
10:                #define TIMER_SIZE 4294967296
11:                
12:                #define SECOND_US 1000000
13:                #define SECOND_NS 1000000000
14:                
15:                static void (*tmr45Clbk)();
16:                
17:                static const int prescaler [4] = {1, 8, 64, 256};
18:                
19:                void timer45Init ()
20:                {
00C1AA  FA0000     LNK #0x0
21:                    T4CONbits.TON = 0;
00C1AC  A9E11F     BCLR 0x11F, #7
22:                
23:                    T4CONbits.TGATE = 0;
00C1AE  A9C11E     BCLR T4CON, #6
24:                    T4CONbits.TCS = 1;
00C1B0  A8211E     BSET T4CON, #1
25:                    T4CONbits.TCKPS = 0;
00C1B2  8008F1     MOV T4CON, W1
00C1B4  2FFCF0     MOV #0xFFCF, W0
00C1B6  608000     AND W1, W0, W0
00C1B8  8808F0     MOV W0, T4CON
26:                
27:                    T4CONbits.T32 = 1;
00C1BA  A8611E     BSET T4CON, #3
28:                
29:                    tmr45Clbk = NULL;
00C1BC  EB0000     CLR W0
00C1BE  888CD0     MOV W0, tmr45Clbk
30:                
31:                    IEC1bits.T5IE = 0;
00C1C0  A98097     BCLR 0x97, #4
32:                
33:                    IPC7bits.T5IP = 3;
00C1C2  800591     MOV IPC7, W1
00C1C4  2FFF80     MOV #0xFFF8, W0
00C1C6  608000     AND W1, W0, W0
00C1C8  B30030     IOR #0x3, W0
00C1CA  880590     MOV W0, IPC7
34:                }
00C1CC  FA8000     ULNK
00C1CE  060000     RETURN
35:                
36:                void setTimer45Prescaler (char prsc)
37:                {
00C1D0  FA0002     LNK #0x2
00C1D2  784F00     MOV.B W0, [W14]
38:                
39:                    if (prsc < MIN_PRESCALER) prsc = MIN_PRESCALER;
00C1D4  78401E     MOV.B [W14], W0
00C1D6  504FE0     SUB.B W0, #0x0, [W15]
00C1D8  3D0002     BRA GE, 0xC1DE
00C1DA  EB4000     CLR.B W0
00C1DC  784F00     MOV.B W0, [W14]
40:                    if (prsc > MAX_PRESCALER) prsc = MAX_PRESCALER;
00C1DE  78401E     MOV.B [W14], W0
00C1E0  504FE3     SUB.B W0, #0x3, [W15]
00C1E2  340002     BRA LE, 0xC1E8
00C1E4  B3C030     MOV #0x3, W0
00C1E6  784F00     MOV.B W0, [W14]
41:                
42:                    if (T4CONbits.TCKPS != prsc)
00C1E8  8008F0     MOV T4CON, W0
00C1EA  DE0044     LSR W0, #4, W0
00C1EC  604063     AND.B W0, #0x3, W0
00C1EE  FB8080     ZE W0, W1
00C1F0  FB001E     SE [W14], W0
00C1F2  508F80     SUB W1, W0, [W15]
00C1F4  32000A     BRA Z, 0xC20A
43:                        T4CONbits.TCKPS = prsc;
00C1F6  78401E     MOV.B [W14], W0
00C1F8  604063     AND.B W0, #0x3, W0
00C1FA  FB8000     ZE W0, W0
00C1FC  600063     AND W0, #0x3, W0
00C1FE  DD0044     SL W0, #4, W0
00C200  8008F2     MOV T4CON, W2
00C202  2FFCF1     MOV #0xFFCF, W1
00C204  610081     AND W2, W1, W1
00C206  708000     IOR W1, W0, W0
00C208  8808F0     MOV W0, T4CON
44:                
45:                }
00C20A  FA8000     ULNK
00C20C  060000     RETURN
46:                
47:                inline void timer45Start ()
48:                {
00C20E  FA0000     LNK #0x0
49:                    T4CONbits.TON = 1;
00C210  A8E11F     BSET 0x11F, #7
50:                }
00C212  FA8000     ULNK
00C214  060000     RETURN
51:                
52:                inline void timer45Stop ()
53:                {
00C216  FA0000     LNK #0x0
54:                    T4CONbits.TON = 0;
00C218  A9E11F     BCLR 0x11F, #7
55:                }
00C21A  FA8000     ULNK
00C21C  060000     RETURN
56:                
57:                inline void timer45Reset ()
58:                {
00C21E  FA0000     LNK #0x0
59:                    TMR4 = 0;
00C220  EB0000     CLR W0
00C222  8808A0     MOV W0, TMR4
60:                    TMR5 = 0;
00C224  EB0000     CLR W0
00C226  8808C0     MOV W0, TMR5
61:                }
00C228  FA8000     ULNK
00C22A  060000     RETURN
62:                
63:                inline unsigned long int getTimer45Count ()
64:                {
00C22C  FA0000     LNK #0x0
65:                    return TMR4 + (TMR5<<16);
00C22E  8008C0     MOV TMR5, W0
00C230  DD00C0     SL W0, #0, W1
00C232  8008A0     MOV TMR4, W0
00C234  408000     ADD W1, W0, W0
00C236  200001     MOV #0x0, W1
66:                }
00C238  FA8000     ULNK
00C23A  060000     RETURN
67:                
68:                void timer45WaitUntilEnd ()
69:                {
00C23C  FA0000     LNK #0x0
70:                    IEC1bits.T5IE = 0;
00C23E  A98097     BCLR 0x97, #4
71:                
72:                    while (IFS1bits.T5IF != 1);
00C240  000000     NOP
00C242  800431     MOV IFS1, W1
00C244  210000     MOV #0x1000, W0
00C246  608000     AND W1, W0, W0
00C248  500FE0     SUB W0, #0x0, [W15]
00C24A  32FFFB     BRA Z, 0xC242
73:                
74:                    IFS1bits.T5IF = 0;
00C24C  A98087     BCLR 0x87, #4
75:                
76:                    IEC1bits.T5IE = 1;
00C24E  A88097     BSET 0x97, #4
77:                }
00C250  FA8000     ULNK
00C252  060000     RETURN
78:                
79:                void setTimer45Callback (void (*clbk)())
80:                {
00C254  FA0002     LNK #0x2
00C256  780F00     MOV W0, [W14]
81:                    tmr45Clbk = clbk;
00C258  78001E     MOV [W14], W0
00C25A  888CD0     MOV W0, tmr45Clbk
82:                }
00C25C  FA8000     ULNK
00C25E  060000     RETURN
83:                
84:                int getTimer45Prescaler ()
85:                {
00C260  FA0000     LNK #0x0
86:                    return prescaler[T4CONbits.TCKPS];
00C262  8008F0     MOV T4CON, W0
00C264  DE0044     LSR W0, #4, W0
00C266  604063     AND.B W0, #0x3, W0
00C268  FB8000     ZE W0, W0
00C26A  2D4861     MOV #0xD486, W1
00C26C  400000     ADD W0, W0, W0
00C26E  408000     ADD W1, W0, W0
00C270  780010     MOV [W0], W0
87:                }
00C272  FA8000     ULNK
00C274  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timer4.c  -------------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include <stdlib.h>
4:                 #include "ClockControl.h"
5:                 #include "timer4.h"
6:                 
7:                 #define MIN_PRESCALER 0
8:                 #define MAX_PRESCALER 3
9:                 
10:                #define TIMER_SIZE 65536
11:                
12:                #define SECOND_US 1000000
13:                #define SECOND_NS 1000000000
14:                
15:                static void (*tmr4Clbk)();
16:                
17:                static const int prescaler [4] = {1, 8, 64, 256};
18:                
19:                static long int tryTimer4Prescaler (int prsc, long int interval);
20:                static long int tryTimer4PrescalerNS (int prsc, long int interval);
21:                
22:                static long int getTimer4Step ();
23:                static long int getTimer4StepNS ();
24:                
25:                static int getTimer4Prescaler ();
26:                
27:                void __attribute__((__interrupt__, __auto_psv__))  _T4Interrupt (void)
28:                {
001384  F80036     PUSH RCOUNT
001386  BE9F80     MOV.D W0, [W15++]
001388  BE9F82     MOV.D W2, [W15++]
00138A  BE9F84     MOV.D W4, [W15++]
00138C  BE9F86     MOV.D W6, [W15++]
00138E  F80034     PUSH PSVPAG
001390  200000     MOV #0x0, W0
001392  8801A0     MOV W0, PSVPAG
001394  FA0000     LNK #0x0
29:                    if (tmr4Clbk != NULL)
001396  808CC0     MOV tmr4Clbk, W0
001398  500FE0     SUB W0, #0x0, [W15]
00139A  320002     BRA Z, 0x13A0
30:                    {
31:                        tmr4Clbk();
00139C  808CC0     MOV tmr4Clbk, W0
00139E  010000     CALL W0
32:                    }
33:                
34:                    IFS1bits.T4IF = 0;
0013A0  A96087     BCLR 0x87, #3
35:                }
0013A2  FA8000     ULNK
0013A4  F90034     POP PSVPAG
0013A6  BE034F     MOV.D [--W15], W6
0013A8  BE024F     MOV.D [--W15], W4
0013AA  BE014F     MOV.D [--W15], W2
0013AC  BE004F     MOV.D [--W15], W0
0013AE  F90036     POP RCOUNT
0013B0  064000     RETFIE
36:                
37:                void timer4Init ()
38:                {
0013B2  FA0000     LNK #0x0
39:                    T4CONbits.TON = 0;
0013B4  A9E11F     BCLR 0x11F, #7
40:                
41:                    T4CONbits.TGATE = 0;
0013B6  A9C11E     BCLR T4CON, #6
42:                    T4CONbits.TCS = 0;
0013B8  A9211E     BCLR T4CON, #1
43:                    T4CONbits.TCKPS = 0;
0013BA  8008F1     MOV T4CON, W1
0013BC  2FFCF0     MOV #0xFFCF, W0
0013BE  608000     AND W1, W0, W0
0013C0  8808F0     MOV W0, T4CON
44:                
45:                    tmr4Clbk = NULL;
0013C2  EB0000     CLR W0
0013C4  888CC0     MOV W0, tmr4Clbk
46:                
47:                    IEC1bits.T4IE = 1;
0013C6  A86097     BSET 0x97, #3
48:                
49:                    IPC6bits.T4IP = 6;
0013C8  800581     MOV IPC6, W1
0013CA  28FFF0     MOV #0x8FFF, W0
0013CC  608080     AND W1, W0, W1
0013CE  260000     MOV #0x6000, W0
0013D0  708000     IOR W1, W0, W0
0013D2  880580     MOV W0, IPC6
50:                }
0013D4  FA8000     ULNK
0013D6  060000     RETURN
51:                
52:                void setTimer4Prescaler (char prsc)
53:                {
0013D8  FA0002     LNK #0x2
0013DA  784F00     MOV.B W0, [W14]
54:                
55:                    if (prsc < MIN_PRESCALER) prsc = MIN_PRESCALER;
0013DC  78401E     MOV.B [W14], W0
0013DE  504FE0     SUB.B W0, #0x0, [W15]
0013E0  3D0002     BRA GE, 0x13E6
0013E2  EB4000     CLR.B W0
0013E4  784F00     MOV.B W0, [W14]
56:                    if (prsc > MAX_PRESCALER) prsc = MAX_PRESCALER;
0013E6  78401E     MOV.B [W14], W0
0013E8  504FE3     SUB.B W0, #0x3, [W15]
0013EA  340002     BRA LE, 0x13F0
0013EC  B3C030     MOV #0x3, W0
0013EE  784F00     MOV.B W0, [W14]
57:                
58:                    if (T4CONbits.TCKPS != prsc)
0013F0  8008F0     MOV T4CON, W0
0013F2  DE0044     LSR W0, #4, W0
0013F4  604063     AND.B W0, #0x3, W0
0013F6  FB8080     ZE W0, W1
0013F8  FB001E     SE [W14], W0
0013FA  508F80     SUB W1, W0, [W15]
0013FC  32000A     BRA Z, 0x1412
59:                        T4CONbits.TCKPS = prsc;
0013FE  78401E     MOV.B [W14], W0
001400  604063     AND.B W0, #0x3, W0
001402  FB8000     ZE W0, W0
001404  600063     AND W0, #0x3, W0
001406  DD0044     SL W0, #4, W0
001408  8008F2     MOV T4CON, W2
00140A  2FFCF1     MOV #0xFFCF, W1
00140C  610081     AND W2, W1, W1
00140E  708000     IOR W1, W0, W0
001410  8808F0     MOV W0, T4CON
60:                
61:                }
001412  FA8000     ULNK
001414  060000     RETURN
62:                
63:                long int setTimer4IntervalNS (long int nS)
64:                {
001416  FA0012     LNK #0x12
001418  980770     MOV W0, [W14+14]
00141A  980F01     MOV W1, [W14+16]
65:                long int actStep, requestedSteps, ris;
66:                
67:                    if ((ris = tryTimer4PrescalerNS (getTimer4Prescaler(), nS)) >= 0)
00141C  070181     RCALL _getTimer4Prescaler
00141E  90017E     MOV [W14+14], W2
001420  90098E     MOV [W14+16], W3
001422  070139     RCALL _tryTimer4PrescalerNS
001424  980710     MOV W0, [W14+2]
001426  980721     MOV W1, [W14+4]
001428  90001E     MOV [W14+2], W0
00142A  9000AE     MOV [W14+4], W1
00142C  500FE0     SUB W0, #0x0, [W15]
00142E  588FE0     SUBB W1, #0x0, [W15]
001430  350003     BRA LT, 0x1438
68:                    {
69:                        return ris;
001432  90001E     MOV [W14+2], W0
001434  9000AE     MOV [W14+4], W1
001436  37002C     BRA 0x1490
70:                    }
71:                    else
72:                    {
73:                    int i;
74:                
75:                        for (i = MIN_PRESCALER; i < MAX_PRESCALER; i++)
001438  EB0000     CLR W0
00143A  780F00     MOV W0, [W14]
00143C  37000F     BRA 0x145C
00145A  E80F1E     INC [W14], [W14]
00145C  78001E     MOV [W14], W0
00145E  500FE2     SUB W0, #0x2, [W15]
001460  34FFEE     BRA LE, 0x143E
76:                        {
77:                            if ((ris = tryTimer4PrescalerNS (i, nS)) >= 0)
00143E  90017E     MOV [W14+14], W2
001440  90098E     MOV [W14+16], W3
001442  78001E     MOV [W14], W0
001444  070128     RCALL _tryTimer4PrescalerNS
001446  980710     MOV W0, [W14+2]
001448  980721     MOV W1, [W14+4]
00144A  90001E     MOV [W14+2], W0
00144C  9000AE     MOV [W14+4], W1
00144E  500FE0     SUB W0, #0x0, [W15]
001450  588FE0     SUBB W1, #0x0, [W15]
001452  350003     BRA LT, 0x145A
78:                            {
79:                                return ris;
001454  90001E     MOV [W14+2], W0
001456  9000AE     MOV [W14+4], W1
001458  37001B     BRA 0x1490
80:                            }
81:                        }
82:                
83:                    }
84:                
85:                    setTimer4Prescaler (3);
001462  B3C030     MOV #0x3, W0
001464  07FFB9     RCALL setTimer4Prescaler
86:                
87:                    actStep = getTimer4StepNS();
001466  07016B     RCALL _getTimer4StepNS
001468  980730     MOV W0, [W14+6]
00146A  980741     MOV W1, [W14+8]
88:                
89:                    PR4 = TIMER_SIZE - 1;
00146C  EB8000     SETM W0
00146E  8808D0     MOV W0, PR4
90:                    if (TMR4 > requestedSteps - 1) TMR4 = requestedSteps - 1;
001470  8008A0     MOV TMR4, W0
001472  B80161     MUL.UU W0, #1, W2
001474  90005E     MOV [W14+10], W0
001476  9000EE     MOV [W14+12], W1
001478  500061     SUB W0, #0x1, W0
00147A  5880E0     SUBB W1, #0x0, W1
00147C  510F80     SUB W2, W0, [W15]
00147E  598F81     SUBB W3, W1, [W15]
001480  340003     BRA LE, 0x1488
001482  90005E     MOV [W14+10], W0
001484  E90000     DEC W0, W0
001486  8808A0     MOV W0, TMR4
91:                
92:                    return TIMER_SIZE * actStep;
001488  90003E     MOV [W14+6], W0
00148A  9000CE     MOV [W14+8], W1
00148C  DD00C0     SL W0, #0, W1
00148E  200000     MOV #0x0, W0
93:                }
001490  FA8000     ULNK
001492  060000     RETURN
94:                
95:                long int setTimer4Interval (long int uS)
96:                {
001494  FA0012     LNK #0x12
001496  980770     MOV W0, [W14+14]
001498  980F01     MOV W1, [W14+16]
97:                long int actStep, requestedSteps, ris;
98:                
99:                    if ((ris = tryTimer4Prescaler (getTimer4Prescaler(), uS)) >= 0)
00149A  070142     RCALL _getTimer4Prescaler
00149C  90017E     MOV [W14+14], W2
00149E  90098E     MOV [W14+16], W3
0014A0  0700B5     RCALL _tryTimer4Prescaler
0014A2  980710     MOV W0, [W14+2]
0014A4  980721     MOV W1, [W14+4]
0014A6  90001E     MOV [W14+2], W0
0014A8  9000AE     MOV [W14+4], W1
0014AA  500FE0     SUB W0, #0x0, [W15]
0014AC  588FE0     SUBB W1, #0x0, [W15]
0014AE  350003     BRA LT, 0x14B6
100:                   {
101:                       return ris;
0014B0  90001E     MOV [W14+2], W0
0014B2  9000AE     MOV [W14+4], W1
0014B4  37002C     BRA 0x150E
102:                   }
103:                   else
104:                   {
105:                   int i;
106:               
107:                       for (i = MIN_PRESCALER; i < MAX_PRESCALER; i++)
0014B6  EB0000     CLR W0
0014B8  780F00     MOV W0, [W14]
0014BA  37000F     BRA 0x14DA
0014D8  E80F1E     INC [W14], [W14]
0014DA  78001E     MOV [W14], W0
0014DC  500FE2     SUB W0, #0x2, [W15]
0014DE  34FFEE     BRA LE, 0x14BC
108:                       {
109:                           if ((ris = tryTimer4Prescaler (i, uS)) >= 0)
0014BC  90017E     MOV [W14+14], W2
0014BE  90098E     MOV [W14+16], W3
0014C0  78001E     MOV [W14], W0
0014C2  0700A4     RCALL _tryTimer4Prescaler
0014C4  980710     MOV W0, [W14+2]
0014C6  980721     MOV W1, [W14+4]
0014C8  90001E     MOV [W14+2], W0
0014CA  9000AE     MOV [W14+4], W1
0014CC  500FE0     SUB W0, #0x0, [W15]
0014CE  588FE0     SUBB W1, #0x0, [W15]
0014D0  350003     BRA LT, 0x14D8
110:                           {
111:                               return ris;
0014D2  90001E     MOV [W14+2], W0
0014D4  9000AE     MOV [W14+4], W1
0014D6  37001B     BRA 0x150E
112:                           }
113:                       }
114:               
115:                   }
116:               
117:                   setTimer4Prescaler (3);
0014E0  B3C030     MOV #0x3, W0
0014E2  07FF7A     RCALL setTimer4Prescaler
118:               
119:                   actStep = getTimer4Step();
0014E4  070124     RCALL _getTimer4Step
0014E6  980730     MOV W0, [W14+6]
0014E8  980741     MOV W1, [W14+8]
120:               
121:                   PR4 = TIMER_SIZE - 1;
0014EA  EB8000     SETM W0
0014EC  8808D0     MOV W0, PR4
122:                   if (TMR4 > requestedSteps - 1) TMR4 = requestedSteps - 1;
0014EE  8008A0     MOV TMR4, W0
0014F0  B80161     MUL.UU W0, #1, W2
0014F2  90005E     MOV [W14+10], W0
0014F4  9000EE     MOV [W14+12], W1
0014F6  500061     SUB W0, #0x1, W0
0014F8  5880E0     SUBB W1, #0x0, W1
0014FA  510F80     SUB W2, W0, [W15]
0014FC  598F81     SUBB W3, W1, [W15]
0014FE  340003     BRA LE, 0x1506
001500  90005E     MOV [W14+10], W0
001502  E90000     DEC W0, W0
001504  8808A0     MOV W0, TMR4
123:               
124:                   return TIMER_SIZE * actStep;
001506  90003E     MOV [W14+6], W0
001508  9000CE     MOV [W14+8], W1
00150A  DD00C0     SL W0, #0, W1
00150C  200000     MOV #0x0, W0
125:               }
00150E  FA8000     ULNK
001510  060000     RETURN
126:               
127:               void timer4Delay (long int uS)
128:               {
001512  FA0004     LNK #0x4
001514  BE8F00     MOV.D W0, [W14]
129:                   setTimer4Interval (uS);
001516  BE001E     MOV.D [W14], W0
001518  07FFBD     RCALL setTimer4Interval
130:               
131:                   IEC1bits.T4IE = 0;
00151A  A96097     BCLR 0x97, #3
132:               
133:                   timer4Reset();
00151C  070029     RCALL timer4Reset
134:                   timer4Start();
00151E  070020     RCALL timer4Start
135:               
136:                   while (IFS1bits.T4IF != 1);
001520  000000     NOP
001522  800431     MOV IFS1, W1
001524  208000     MOV #0x800, W0
001526  608000     AND W1, W0, W0
001528  500FE0     SUB W0, #0x0, [W15]
00152A  32FFFB     BRA Z, 0x1522
137:               
138:                   IFS1bits.T4IF = 0;
00152C  A96087     BCLR 0x87, #3
139:               
140:                   timer4Stop();
00152E  07001C     RCALL timer4Stop
141:                   timer4Reset();
001530  07001F     RCALL timer4Reset
142:               
143:                   IEC1bits.T4IE = 1;
001532  A86097     BSET 0x97, #3
144:               }
001534  FA8000     ULNK
001536  060000     RETURN
145:               
146:               inline long int getTimer4Freq ()
147:               {
001538  FA0004     LNK #0x4
148:               long int ris;
149:               
150:                   ris = getClockFreq() / (2 * prescaler [T4CONbits.TCKPS]);
00153A  07525C     RCALL getClockFreq
00153C  BE0200     MOV.D W0, W4
00153E  8008F0     MOV T4CON, W0
001540  DE0044     LSR W0, #4, W0
001542  604063     AND.B W0, #0x3, W0
001544  FB8000     ZE W0, W0
001546  2D47E1     MOV #0xD47E, W1
001548  400000     ADD W0, W0, W0
00154A  408000     ADD W1, W0, W0
00154C  780010     MOV [W0], W0
00154E  400000     ADD W0, W0, W0
001550  DE80CF     ASR W0, #15, W1
001552  BE0100     MOV.D W0, W2
001554  BE0004     MOV.D W4, W0
001556  0701C5     RCALL ___divsi3
001558  BE8F00     MOV.D W0, [W14]
151:               
152:                   return ris;
00155A  BE001E     MOV.D [W14], W0
153:               }
00155C  FA8000     ULNK
00155E  060000     RETURN
154:               
155:               inline void timer4Start ()
156:               {
001560  FA0000     LNK #0x0
157:                   T4CONbits.TON = 1;
001562  A8E11F     BSET 0x11F, #7
158:               }
001564  FA8000     ULNK
001566  060000     RETURN
159:               
160:               inline void timer4Stop ()
161:               {
001568  FA0000     LNK #0x0
162:                   T4CONbits.TON = 0;
00156A  A9E11F     BCLR 0x11F, #7
163:               }
00156C  FA8000     ULNK
00156E  060000     RETURN
164:               
165:               inline void timer4Reset ()
166:               {
001570  FA0000     LNK #0x0
167:                   TMR4 = 0;
001572  EB0000     CLR W0
001574  8808A0     MOV W0, TMR4
168:               }
001576  FA8000     ULNK
001578  060000     RETURN
169:               
170:               inline long int getTimer4Count ()
171:               {
00157A  FA0000     LNK #0x0
172:                   return TMR4;
00157C  8008A0     MOV TMR4, W0
00157E  200001     MOV #0x0, W1
173:               }
001580  FA8000     ULNK
001582  060000     RETURN
174:               
175:               void timer4WaitUntilEnd ()
176:               {
001584  FA0000     LNK #0x0
177:                   IEC1bits.T4IE = 0;
001586  A96097     BCLR 0x97, #3
178:               
179:                   while (IFS1bits.T4IF != 1);
001588  000000     NOP
00158A  800431     MOV IFS1, W1
00158C  208000     MOV #0x800, W0
00158E  608000     AND W1, W0, W0
001590  500FE0     SUB W0, #0x0, [W15]
001592  32FFFB     BRA Z, 0x158A
180:               
181:                   IFS1bits.T4IF = 0;
001594  A96087     BCLR 0x87, #3
182:               
183:                   IEC1bits.T4IE = 1;
001596  A86097     BSET 0x97, #3
184:               }
001598  FA8000     ULNK
00159A  060000     RETURN
185:               
186:               void setTimer4Callback (void (*clbk)())
187:               {
00159C  FA0002     LNK #0x2
00159E  780F00     MOV W0, [W14]
188:                   tmr4Clbk = clbk;
0015A0  78001E     MOV [W14], W0
0015A2  888CC0     MOV W0, tmr4Clbk
189:               }
0015A4  FA8000     ULNK
0015A6  060000     RETURN
190:               
191:               long int timer4ElaspedTime ()
192:               {
0015A8  FA0004     LNK #0x4
193:               long int actStep = SECOND_US / getTimer4Freq();
0015AA  07FFC6     RCALL getTimer4Freq
0015AC  BE0100     MOV.D W0, W2
0015AE  242400     MOV #0x4240, W0
0015B0  2000F1     MOV #0xF, W1
0015B2  070197     RCALL ___divsi3
0015B4  BE8F00     MOV.D W0, [W14]
194:               
195:                   return actStep * TMR4;
0015B6  8008A0     MOV TMR4, W0
0015B8  200001     MOV #0x0, W1
0015BA  78011E     MOV [W14], W2
0015BC  B99101     MUL.SS W2, W1, W2
0015BE  780102     MOV W2, W2
0015C0  90019E     MOV [W14+2], W3
0015C2  B99A00     MUL.SS W3, W0, W4
0015C4  780184     MOV W4, W3
0015C6  410103     ADD W2, W3, W2
0015C8  78019E     MOV [W14], W3
0015CA  B81800     MUL.UU W3, W0, W0
0015CC  410101     ADD W2, W1, W2
0015CE  780082     MOV W2, W1
196:               }
0015D0  FA8000     ULNK
0015D2  060000     RETURN
197:               
198:               unsigned long int timer4ElaspedTimeNS()
199:               {
0015D4  FA0008     LNK #0x8
200:               unsigned long int actStep = SECOND_NS / getTimer4Freq(), ris;
0015D6  07FFB0     RCALL getTimer4Freq
0015D8  BE0100     MOV.D W0, W2
0015DA  2CA000     MOV #0xCA00, W0
0015DC  23B9A1     MOV #0x3B9A, W1
0015DE  070181     RCALL ___divsi3
0015E0  BE8F00     MOV.D W0, [W14]
201:               
202:                   ris = actStep * TMR4;
0015E2  8008A0     MOV TMR4, W0
0015E4  200001     MOV #0x0, W1
0015E6  78011E     MOV [W14], W2
0015E8  B99101     MUL.SS W2, W1, W2
0015EA  780102     MOV W2, W2
0015EC  90019E     MOV [W14+2], W3
0015EE  B99A00     MUL.SS W3, W0, W4
0015F0  780184     MOV W4, W3
0015F2  410103     ADD W2, W3, W2
0015F4  78019E     MOV [W14], W3
0015F6  B81800     MUL.UU W3, W0, W0
0015F8  410101     ADD W2, W1, W2
0015FA  780082     MOV W2, W1
0015FC  980720     MOV W0, [W14+4]
0015FE  980731     MOV W1, [W14+6]
001600  980720     MOV W0, [W14+4]
001602  980731     MOV W1, [W14+6]
203:               
204:                   return ris;
001604  90002E     MOV [W14+4], W0
001606  9000BE     MOV [W14+6], W1
205:               }
001608  FA8000     ULNK
00160A  060000     RETURN
206:               
207:               static long int tryTimer4Prescaler (int prsc, long int interval)
208:               {
00160C  FA000E     LNK #0xE
00160E  980740     MOV W0, [W14+8]
001610  980752     MOV W2, [W14+10]
001612  980763     MOV W3, [W14+12]
209:               long int actStep, requestedSteps;
210:               
211:                   if (getTimer4Prescaler() != prsc) setTimer4Prescaler(prsc);
001614  070085     RCALL _getTimer4Prescaler
001616  9000CE     MOV [W14+8], W1
001618  500F81     SUB W0, W1, [W15]
00161A  320003     BRA Z, 0x1622
00161C  90004E     MOV [W14+8], W0
00161E  784000     MOV.B W0, W0
001620  07FEDB     RCALL setTimer4Prescaler
212:               
213:                   actStep = getTimer4Step();
001622  070085     RCALL _getTimer4Step
001624  980720     MOV W0, [W14+4]
001626  980731     MOV W1, [W14+6]
214:               
215:                   if (actStep != 0)
001628  90002E     MOV [W14+4], W0
00162A  9000BE     MOV [W14+6], W1
00162C  500FE0     SUB W0, #0x0, [W15]
00162E  588FE0     SUBB W1, #0x0, [W15]
001630  320006     BRA Z, 0x163E
216:                       requestedSteps = interval / actStep;
001632  90012E     MOV [W14+4], W2
001634  9001BE     MOV [W14+6], W3
001636  90005E     MOV [W14+10], W0
001638  9000EE     MOV [W14+12], W1
00163A  070153     RCALL ___divsi3
00163C  BE8F00     MOV.D W0, [W14]
217:               
218:                   if (requestedSteps <= TIMER_SIZE && actStep != 0)
00163E  200000     MOV #0x0, W0
001640  200011     MOV #0x1, W1
001642  BE011E     MOV.D [W14], W2
001644  510F80     SUB W2, W0, [W15]
001646  598F81     SUBB W3, W1, [W15]
001648  3C0022     BRA GT, 0x168E
00164A  90002E     MOV [W14+4], W0
00164C  9000BE     MOV [W14+6], W1
00164E  500FE0     SUB W0, #0x0, [W15]
001650  588FE0     SUBB W1, #0x0, [W15]
001652  32001D     BRA Z, 0x168E
219:                   {
220:                       if (TMR4 > requestedSteps - 1) TMR4 = requestedSteps - 1;
001654  8008A0     MOV TMR4, W0
001656  B80161     MUL.UU W0, #1, W2
001658  EB8200     SETM W4
00165A  EB8280     SETM W5
00165C  42003E     ADD W4, [W14++], W0
00165E  4A80AE     ADDC W5, [W14--], W1
001660  510F80     SUB W2, W0, [W15]
001662  598F81     SUBB W3, W1, [W15]
001664  340003     BRA LE, 0x166C
001666  78001E     MOV [W14], W0
001668  E90000     DEC W0, W0
00166A  8808A0     MOV W0, TMR4
221:                       PR4 = requestedSteps - 1;
00166C  78001E     MOV [W14], W0
00166E  E90000     DEC W0, W0
001670  8808D0     MOV W0, PR4
222:               
223:                       return actStep * requestedSteps;
001672  9000BE     MOV [W14+6], W1
001674  78001E     MOV [W14], W0
001676  B98800     MUL.SS W1, W0, W0
001678  780100     MOV W0, W2
00167A  90009E     MOV [W14+2], W1
00167C  90002E     MOV [W14+4], W0
00167E  B98800     MUL.SS W1, W0, W0
001680  780000     MOV W0, W0
001682  410100     ADD W2, W0, W2
001684  90002E     MOV [W14+4], W0
001686  B8001E     MUL.UU W0, [W14], W0
001688  410101     ADD W2, W1, W2
00168A  780082     MOV W2, W1
00168C  370002     BRA 0x1692
224:                   }
225:                   else
226:                   {
227:                       return -1;
00168E  EB8000     SETM W0
001690  EB8080     SETM W1
228:                   }
229:               }
001692  FA8000     ULNK
001694  060000     RETURN
230:               
231:               static long int tryTimer4PrescalerNS (int prsc, long int interval)
232:               {
001696  FA000E     LNK #0xE
001698  980740     MOV W0, [W14+8]
00169A  980752     MOV W2, [W14+10]
00169C  980763     MOV W3, [W14+12]
233:               long int actStep, requestedSteps;
234:               
235:                   if (getTimer4Prescaler() != prsc) setTimer4Prescaler(prsc);
00169E  070040     RCALL _getTimer4Prescaler
0016A0  9000CE     MOV [W14+8], W1
0016A2  500F81     SUB W0, W1, [W15]
0016A4  320003     BRA Z, 0x16AC
0016A6  90004E     MOV [W14+8], W0
0016A8  784000     MOV.B W0, W0
0016AA  07FE96     RCALL setTimer4Prescaler
236:               
237:                   actStep = getTimer4StepNS();
0016AC  070048     RCALL _getTimer4StepNS
0016AE  980720     MOV W0, [W14+4]
0016B0  980731     MOV W1, [W14+6]
238:               
239:                   if (actStep != 0)
0016B2  90002E     MOV [W14+4], W0
0016B4  9000BE     MOV [W14+6], W1
0016B6  500FE0     SUB W0, #0x0, [W15]
0016B8  588FE0     SUBB W1, #0x0, [W15]
0016BA  320006     BRA Z, 0x16C8
240:                       requestedSteps = interval / actStep;
0016BC  90012E     MOV [W14+4], W2
0016BE  9001BE     MOV [W14+6], W3
0016C0  90005E     MOV [W14+10], W0
0016C2  9000EE     MOV [W14+12], W1
0016C4  07010E     RCALL ___divsi3
0016C6  BE8F00     MOV.D W0, [W14]
241:               
242:                   if (requestedSteps <= TIMER_SIZE && actStep != 0)
0016C8  200000     MOV #0x0, W0
0016CA  200011     MOV #0x1, W1
0016CC  BE011E     MOV.D [W14], W2
0016CE  510F80     SUB W2, W0, [W15]
0016D0  598F81     SUBB W3, W1, [W15]
0016D2  3C0022     BRA GT, 0x1718
0016D4  90002E     MOV [W14+4], W0
0016D6  9000BE     MOV [W14+6], W1
0016D8  500FE0     SUB W0, #0x0, [W15]
0016DA  588FE0     SUBB W1, #0x0, [W15]
0016DC  32001D     BRA Z, 0x1718
243:                   {
244:                       if (TMR4 > requestedSteps - 1) TMR4 = requestedSteps - 1;
0016DE  8008A0     MOV TMR4, W0
0016E0  B80161     MUL.UU W0, #1, W2
0016E2  EB8200     SETM W4
0016E4  EB8280     SETM W5
0016E6  42003E     ADD W4, [W14++], W0
0016E8  4A80AE     ADDC W5, [W14--], W1
0016EA  510F80     SUB W2, W0, [W15]
0016EC  598F81     SUBB W3, W1, [W15]
0016EE  340003     BRA LE, 0x16F6
0016F0  78001E     MOV [W14], W0
0016F2  E90000     DEC W0, W0
0016F4  8808A0     MOV W0, TMR4
245:                       PR4 = requestedSteps - 1;
0016F6  78001E     MOV [W14], W0
0016F8  E90000     DEC W0, W0
0016FA  8808D0     MOV W0, PR4
246:               
247:                       return actStep * requestedSteps;
0016FC  9000BE     MOV [W14+6], W1
0016FE  78001E     MOV [W14], W0
001700  B98800     MUL.SS W1, W0, W0
001702  780100     MOV W0, W2
001704  90009E     MOV [W14+2], W1
001706  90002E     MOV [W14+4], W0
001708  B98800     MUL.SS W1, W0, W0
00170A  780000     MOV W0, W0
00170C  410100     ADD W2, W0, W2
00170E  90002E     MOV [W14+4], W0
001710  B8001E     MUL.UU W0, [W14], W0
001712  410101     ADD W2, W1, W2
001714  780082     MOV W2, W1
001716  370002     BRA 0x171C
248:                   }
249:                   else
250:                   {
251:                       return -1;
001718  EB8000     SETM W0
00171A  EB8080     SETM W1
252:                   }
253:               }
00171C  FA8000     ULNK
00171E  060000     RETURN
254:               
255:               static int getTimer4Prescaler ()
256:               {
001720  FA0000     LNK #0x0
257:                   return T4CONbits.TCKPS;
001722  8008F0     MOV T4CON, W0
001724  DE0044     LSR W0, #4, W0
001726  604063     AND.B W0, #0x3, W0
001728  FB8000     ZE W0, W0
258:               }
00172A  FA8000     ULNK
00172C  060000     RETURN
259:               
260:               static long int getTimer4Step ()
261:               {
00172E  FA0000     LNK #0x0
262:                   return SECOND_US / getTimer4Freq();
001730  07FF03     RCALL getTimer4Freq
001732  BE0100     MOV.D W0, W2
001734  242400     MOV #0x4240, W0
001736  2000F1     MOV #0xF, W1
001738  0700D4     RCALL ___divsi3
263:               }
00173A  FA8000     ULNK
00173C  060000     RETURN
264:               
265:               static long int getTimer4StepNS ()
266:               {
00173E  FA0000     LNK #0x0
267:                   return SECOND_NS / getTimer4Freq();
001740  07FEFB     RCALL getTimer4Freq
001742  BE0100     MOV.D W0, W2
001744  2CA000     MOV #0xCA00, W0
001746  23B9A1     MOV #0x3B9A, W1
001748  0700CC     RCALL ___divsi3
268:               }
00174A  FA8000     ULNK
00174C  060000     RETURN
269:               
270:               inline long int getTimer4MaxTime ()
271:               {
00174E  FA0000     LNK #0x0
272:                   return getTimer4Step() * PR4;
001750  07FFEE     RCALL _getTimer4Step
001752  BE0100     MOV.D W0, W2
001754  8008D0     MOV PR4, W0
001756  200001     MOV #0x0, W1
001758  B99A00     MUL.SS W3, W0, W4
00175A  780204     MOV W4, W4
00175C  B98B02     MUL.SS W1, W2, W6
00175E  780286     MOV W6, W5
001760  420205     ADD W4, W5, W4
001762  B81000     MUL.UU W2, W0, W0
001764  420201     ADD W4, W1, W4
001766  780084     MOV W4, W1
273:               }
001768  FA8000     ULNK
00176A  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timer3.c  -------------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include <stdlib.h>
4:                 #include "ClockControl.h"
5:                 #include "timer3.h"
6:                 
7:                 #define MIN_PRESCALER 0
8:                 #define MAX_PRESCALER 3
9:                 
10:                #define TIMER_SIZE 65536
11:                
12:                #define SECOND_US 1000000
13:                #define SECOND_NS 1000000000
14:                
15:                static void (*tmr3Clbk)();
16:                
17:                static const int prescaler [4] = {1, 8, 64, 256};
18:                
19:                static long int tryTimer3Prescaler (int prsc, long int interval);
20:                static long int tryTimer3PrescalerNS (int prsc, long int interval);
21:                
22:                static long int getTimer3Step ();
23:                static long int getTimer3StepNS ();
24:                
25:                static int getTimer3Prescaler ();
26:                
27:                void __attribute__((__interrupt__, __auto_psv__))  _T3Interrupt (void)
28:                {
000FF2  F80036     PUSH RCOUNT
000FF4  BE9F80     MOV.D W0, [W15++]
000FF6  BE9F82     MOV.D W2, [W15++]
000FF8  BE9F84     MOV.D W4, [W15++]
000FFA  BE9F86     MOV.D W6, [W15++]
000FFC  F80034     PUSH PSVPAG
000FFE  200000     MOV #0x0, W0
001000  8801A0     MOV W0, PSVPAG
001002  FA0000     LNK #0x0
29:                    if (tmr3Clbk != NULL)
001004  808CB0     MOV tmr3Clbk, W0
001006  500FE0     SUB W0, #0x0, [W15]
001008  320002     BRA Z, 0x100E
30:                    {
31:                        tmr3Clbk();
00100A  808CB0     MOV tmr3Clbk, W0
00100C  010000     CALL W0
32:                    }
33:                
34:                    IFS0bits.T3IF = 0;
00100E  A90085     BCLR 0x85, #0
35:                }
001010  FA8000     ULNK
001012  F90034     POP PSVPAG
001014  BE034F     MOV.D [--W15], W6
001016  BE024F     MOV.D [--W15], W4
001018  BE014F     MOV.D [--W15], W2
00101A  BE004F     MOV.D [--W15], W0
00101C  F90036     POP RCOUNT
00101E  064000     RETFIE
36:                
37:                void timer3Init ()
38:                {
001020  FA0000     LNK #0x0
39:                    T3CONbits.TON = 0;
001022  A9E113     BCLR 0x113, #7
40:                
41:                    T3CONbits.TGATE = 0;
001024  A9C112     BCLR T3CON, #6
42:                    T3CONbits.TCS = 0;
001026  A92112     BCLR T3CON, #1
43:                    T3CONbits.TCKPS = 0;
001028  800891     MOV T3CON, W1
00102A  2FFCF0     MOV #0xFFCF, W0
00102C  608000     AND W1, W0, W0
00102E  880890     MOV W0, T3CON
44:                
45:                    tmr3Clbk = NULL;
001030  EB0000     CLR W0
001032  888CB0     MOV W0, tmr3Clbk
46:                
47:                    IEC0bits.T3IE = 1;
001034  A80095     BSET 0x95, #0
48:                
49:                    IPC2bits.T3IP = 3;
001036  800541     MOV IPC2, W1
001038  2FFF80     MOV #0xFFF8, W0
00103A  608000     AND W1, W0, W0
00103C  B30030     IOR #0x3, W0
00103E  880540     MOV W0, IPC2
50:                }
001040  FA8000     ULNK
001042  060000     RETURN
51:                
52:                void setTimer3Prescaler (char prsc)
53:                {
001044  FA0002     LNK #0x2
001046  784F00     MOV.B W0, [W14]
54:                
55:                    if (prsc < MIN_PRESCALER) prsc = MIN_PRESCALER;
001048  78401E     MOV.B [W14], W0
00104A  504FE0     SUB.B W0, #0x0, [W15]
00104C  3D0002     BRA GE, 0x1052
00104E  EB4000     CLR.B W0
001050  784F00     MOV.B W0, [W14]
56:                    if (prsc > MAX_PRESCALER) prsc = MAX_PRESCALER;
001052  78401E     MOV.B [W14], W0
001054  504FE3     SUB.B W0, #0x3, [W15]
001056  340002     BRA LE, 0x105C
001058  B3C030     MOV #0x3, W0
00105A  784F00     MOV.B W0, [W14]
57:                
58:                    if (T3CONbits.TCKPS != prsc)
00105C  800890     MOV T3CON, W0
00105E  DE0044     LSR W0, #4, W0
001060  604063     AND.B W0, #0x3, W0
001062  FB8080     ZE W0, W1
001064  FB001E     SE [W14], W0
001066  508F80     SUB W1, W0, [W15]
001068  32000A     BRA Z, 0x107E
59:                        T3CONbits.TCKPS = prsc;
00106A  78401E     MOV.B [W14], W0
00106C  604063     AND.B W0, #0x3, W0
00106E  FB8000     ZE W0, W0
001070  600063     AND W0, #0x3, W0
001072  DD0044     SL W0, #4, W0
001074  800892     MOV T3CON, W2
001076  2FFCF1     MOV #0xFFCF, W1
001078  610081     AND W2, W1, W1
00107A  708000     IOR W1, W0, W0
00107C  880890     MOV W0, T3CON
60:                
61:                }
00107E  FA8000     ULNK
001080  060000     RETURN
62:                
63:                long int setTimer3IntervalNS (long int nS)
64:                {
001082  FA0010     LNK #0x10
001084  980760     MOV W0, [W14+12]
001086  980771     MOV W1, [W14+14]
65:                long int actStep, requestedSteps, ris;
66:                
67:                    //T2CONbits.TON = 0;
68:                
69:                    if ((ris = tryTimer3PrescalerNS (getTimer3Prescaler(), nS)) >= 0)
001088  070166     RCALL _getTimer3Prescaler
00108A  90016E     MOV [W14+12], W2
00108C  9001FE     MOV [W14+14], W3
00108E  07011E     RCALL _tryTimer3PrescalerNS
001090  BE8F00     MOV.D W0, [W14]
001092  BE001E     MOV.D [W14], W0
001094  500FE0     SUB W0, #0x0, [W15]
001096  588FE0     SUBB W1, #0x0, [W15]
001098  350002     BRA LT, 0x109E
70:                    {
71:                        return ris;
00109A  BE001E     MOV.D [W14], W0
00109C  370022     BRA 0x10E2
72:                    }
73:                    else
74:                    {
75:                    int i;
76:                
77:                        if ((ris = tryTimer3PrescalerNS (getTimer3Prescaler(), nS)) >= 0)
00109E  07015B     RCALL _getTimer3Prescaler
0010A0  90016E     MOV [W14+12], W2
0010A2  9001FE     MOV [W14+14], W3
0010A4  070113     RCALL _tryTimer3PrescalerNS
0010A6  BE8F00     MOV.D W0, [W14]
0010A8  BE001E     MOV.D [W14], W0
0010AA  500FE0     SUB W0, #0x0, [W15]
0010AC  588FE0     SUBB W1, #0x0, [W15]
0010AE  350002     BRA LT, 0x10B4
78:                        {
79:                            return ris;
0010B0  BE001E     MOV.D [W14], W0
0010B2  370017     BRA 0x10E2
80:                        }
81:                
82:                    }
83:                
84:                    setTimer3Prescaler (3);
0010B4  B3C030     MOV #0x3, W0
0010B6  07FFC6     RCALL setTimer3Prescaler
85:                
86:                    actStep = getTimer3StepNS();
0010B8  07015D     RCALL _getTimer3StepNS
0010BA  980720     MOV W0, [W14+4]
0010BC  980731     MOV W1, [W14+6]
87:                
88:                    PR3 = TIMER_SIZE - 1;
0010BE  EB8000     SETM W0
0010C0  880870     MOV W0, PR3
89:                    if (TMR3 > requestedSteps - 1) TMR3 = requestedSteps - 1;
0010C2  800850     MOV TMR3, W0
0010C4  B80161     MUL.UU W0, #1, W2
0010C6  90004E     MOV [W14+8], W0
0010C8  9000DE     MOV [W14+10], W1
0010CA  500061     SUB W0, #0x1, W0
0010CC  5880E0     SUBB W1, #0x0, W1
0010CE  510F80     SUB W2, W0, [W15]
0010D0  598F81     SUBB W3, W1, [W15]
0010D2  340003     BRA LE, 0x10DA
0010D4  90004E     MOV [W14+8], W0
0010D6  E90000     DEC W0, W0
0010D8  880850     MOV W0, TMR3
90:                
91:                    return TIMER_SIZE * actStep;
0010DA  90002E     MOV [W14+4], W0
0010DC  9000BE     MOV [W14+6], W1
0010DE  DD00C0     SL W0, #0, W1
0010E0  200000     MOV #0x0, W0
92:                }
0010E2  FA8000     ULNK
0010E4  060000     RETURN
93:                
94:                long int setTimer3Interval (long int uS)
95:                {
0010E6  FA0010     LNK #0x10
0010E8  980760     MOV W0, [W14+12]
0010EA  980771     MOV W1, [W14+14]
96:                long int actStep, requestedSteps, ris;
97:                
98:                    //T2CONbits.TON = 0;
99:                
100:                   if ((ris = tryTimer3Prescaler (getTimer3Prescaler(), uS)) >= 0)
0010EC  070134     RCALL _getTimer3Prescaler
0010EE  90016E     MOV [W14+12], W2
0010F0  9001FE     MOV [W14+14], W3
0010F2  0700A7     RCALL _tryTimer3Prescaler
0010F4  BE8F00     MOV.D W0, [W14]
0010F6  BE001E     MOV.D [W14], W0
0010F8  500FE0     SUB W0, #0x0, [W15]
0010FA  588FE0     SUBB W1, #0x0, [W15]
0010FC  350002     BRA LT, 0x1102
101:                   {
102:                       return ris;
0010FE  BE001E     MOV.D [W14], W0
001100  370022     BRA 0x1146
103:                   }
104:                   else
105:                   {
106:                   int i;
107:               
108:                       if ((ris = tryTimer3Prescaler (getTimer3Prescaler(), uS)) >= 0)
001102  070129     RCALL _getTimer3Prescaler
001104  90016E     MOV [W14+12], W2
001106  9001FE     MOV [W14+14], W3
001108  07009C     RCALL _tryTimer3Prescaler
00110A  BE8F00     MOV.D W0, [W14]
00110C  BE001E     MOV.D [W14], W0
00110E  500FE0     SUB W0, #0x0, [W15]
001110  588FE0     SUBB W1, #0x0, [W15]
001112  350002     BRA LT, 0x1118
109:                       {
110:                           return ris;
001114  BE001E     MOV.D [W14], W0
001116  370017     BRA 0x1146
111:                       }
112:               
113:                   }
114:               
115:                   setTimer3Prescaler (3);
001118  B3C030     MOV #0x3, W0
00111A  07FF94     RCALL setTimer3Prescaler
116:               
117:                   actStep = getTimer3Step();
00111C  070123     RCALL _getTimer3Step
00111E  980720     MOV W0, [W14+4]
001120  980731     MOV W1, [W14+6]
118:               
119:                   PR3 = TIMER_SIZE - 1;
001122  EB8000     SETM W0
001124  880870     MOV W0, PR3
120:                   if (TMR3 > requestedSteps - 1) TMR3 = requestedSteps - 1;
001126  800850     MOV TMR3, W0
001128  B80161     MUL.UU W0, #1, W2
00112A  90004E     MOV [W14+8], W0
00112C  9000DE     MOV [W14+10], W1
00112E  500061     SUB W0, #0x1, W0
001130  5880E0     SUBB W1, #0x0, W1
001132  510F80     SUB W2, W0, [W15]
001134  598F81     SUBB W3, W1, [W15]
001136  340003     BRA LE, 0x113E
001138  90004E     MOV [W14+8], W0
00113A  E90000     DEC W0, W0
00113C  880850     MOV W0, TMR3
121:               
122:                   return TIMER_SIZE * actStep;
00113E  90002E     MOV [W14+4], W0
001140  9000BE     MOV [W14+6], W1
001142  DD00C0     SL W0, #0, W1
001144  200000     MOV #0x0, W0
123:               }
001146  FA8000     ULNK
001148  060000     RETURN
124:               
125:               void timer3Delay (long int uS)
126:               {
00114A  FA0004     LNK #0x4
00114C  BE8F00     MOV.D W0, [W14]
127:                   setTimer3Interval (uS);
00114E  BE001E     MOV.D [W14], W0
001150  07FFCA     RCALL setTimer3Interval
128:               
129:                   IEC0bits.T3IE = 0;
001152  A90095     BCLR 0x95, #0
130:               
131:                   timer3Reset();
001154  07002E     RCALL timer3Reset
132:                   timer3Start();
001156  070025     RCALL timer3Start
133:               
134:                   while (IFS0bits.T3IF != 1);
001158  000000     NOP
00115A  800421     MOV IFS0, W1
00115C  201000     MOV #0x100, W0
00115E  608000     AND W1, W0, W0
001160  500FE0     SUB W0, #0x0, [W15]
001162  32FFFB     BRA Z, 0x115A
135:               
136:                   IFS0bits.T3IF = 0;
001164  A90085     BCLR 0x85, #0
137:               
138:                   timer3Stop();
001166  070021     RCALL timer3Stop
139:                   timer3Reset();
001168  070024     RCALL timer3Reset
140:               
141:                   IEC0bits.T3IE = 1;
00116A  A80095     BSET 0x95, #0
142:               }
00116C  FA8000     ULNK
00116E  060000     RETURN
143:               
144:               inline long int getTimer3Freq ()
145:               {
001170  FA000C     LNK #0xC
146:               long int ris, freq, div;
147:               
148:                   freq = getClockFreq();
001172  075440     RCALL getClockFreq
001174  BE8F00     MOV.D W0, [W14]
149:               
150:                   div = 2 * prescaler [T3CONbits.TCKPS];
001176  800890     MOV T3CON, W0
001178  DE0044     LSR W0, #4, W0
00117A  604063     AND.B W0, #0x3, W0
00117C  FB8000     ZE W0, W0
00117E  2D4761     MOV #0xD476, W1
001180  400000     ADD W0, W0, W0
001182  408000     ADD W1, W0, W0
001184  780010     MOV [W0], W0
001186  400000     ADD W0, W0, W0
001188  DE80CF     ASR W0, #15, W1
00118A  980720     MOV W0, [W14+4]
00118C  980731     MOV W1, [W14+6]
151:               
152:                   ris = freq / div;
00118E  90012E     MOV [W14+4], W2
001190  9001BE     MOV [W14+6], W3
001192  BE001E     MOV.D [W14], W0
001194  0703A6     RCALL ___divsi3
001196  980740     MOV W0, [W14+8]
001198  980751     MOV W1, [W14+10]
153:               
154:                   return ris;
00119A  90004E     MOV [W14+8], W0
00119C  9000DE     MOV [W14+10], W1
155:               }
00119E  FA8000     ULNK
0011A0  060000     RETURN
156:               
157:               inline void timer3Start ()
158:               {
0011A2  FA0000     LNK #0x0
159:                   T3CONbits.TON = 1;
0011A4  A8E113     BSET 0x113, #7
160:               }
0011A6  FA8000     ULNK
0011A8  060000     RETURN
161:               
162:               inline void timer3Stop ()
163:               {
0011AA  FA0000     LNK #0x0
164:                   T3CONbits.TON = 0;
0011AC  A9E113     BCLR 0x113, #7
165:               }
0011AE  FA8000     ULNK
0011B0  060000     RETURN
166:               
167:               inline void timer3Reset ()
168:               {
0011B2  FA0000     LNK #0x0
169:                   TMR3 = 0;
0011B4  EB0000     CLR W0
0011B6  880850     MOV W0, TMR3
170:               }
0011B8  FA8000     ULNK
0011BA  060000     RETURN
171:               
172:               inline long int getTimer3Count ()
173:               {
0011BC  FA0000     LNK #0x0
174:                   return TMR3;
0011BE  800850     MOV TMR3, W0
0011C0  200001     MOV #0x0, W1
175:               }
0011C2  FA8000     ULNK
0011C4  060000     RETURN
176:               
177:               void timer3WaitUntilEnd ()
178:               {
0011C6  FA0000     LNK #0x0
179:                   IEC0bits.T3IE = 0;
0011C8  A90095     BCLR 0x95, #0
180:               
181:                   while (IFS0bits.T3IF != 1);
0011CA  000000     NOP
0011CC  800421     MOV IFS0, W1
0011CE  201000     MOV #0x100, W0
0011D0  608000     AND W1, W0, W0
0011D2  500FE0     SUB W0, #0x0, [W15]
0011D4  32FFFB     BRA Z, 0x11CC
182:               
183:                   IFS0bits.T3IF = 0;
0011D6  A90085     BCLR 0x85, #0
184:               
185:                   IEC0bits.T3IE = 1;
0011D8  A80095     BSET 0x95, #0
186:               }
0011DA  FA8000     ULNK
0011DC  060000     RETURN
187:               
188:               void setTimer3Callback (void (*clbk)())
189:               {
0011DE  FA0002     LNK #0x2
0011E0  780F00     MOV W0, [W14]
190:                   tmr3Clbk = clbk;
0011E2  78001E     MOV [W14], W0
0011E4  888CB0     MOV W0, tmr3Clbk
191:               }
0011E6  FA8000     ULNK
0011E8  060000     RETURN
192:               
193:               long int timer3ElaspedTime ()
194:               {
0011EA  FA0004     LNK #0x4
195:               long int actStep = SECOND_US / getTimer3Freq();
0011EC  07FFC1     RCALL getTimer3Freq
0011EE  BE0100     MOV.D W0, W2
0011F0  242400     MOV #0x4240, W0
0011F2  2000F1     MOV #0xF, W1
0011F4  070376     RCALL ___divsi3
0011F6  BE8F00     MOV.D W0, [W14]
196:               
197:                   return actStep * TMR3;
0011F8  800850     MOV TMR3, W0
0011FA  200001     MOV #0x0, W1
0011FC  78011E     MOV [W14], W2
0011FE  B99101     MUL.SS W2, W1, W2
001200  780102     MOV W2, W2
001202  90019E     MOV [W14+2], W3
001204  B99A00     MUL.SS W3, W0, W4
001206  780184     MOV W4, W3
001208  410103     ADD W2, W3, W2
00120A  78019E     MOV [W14], W3
00120C  B81800     MUL.UU W3, W0, W0
00120E  410101     ADD W2, W1, W2
001210  780082     MOV W2, W1
198:               }
001212  FA8000     ULNK
001214  060000     RETURN
199:               
200:               long int timer3ElaspedTimeNS()
201:               {
001216  FA0004     LNK #0x4
202:               unsigned long int actStep = SECOND_NS / getTimer3Freq();
001218  07FFAB     RCALL getTimer3Freq
00121A  BE0100     MOV.D W0, W2
00121C  2CA000     MOV #0xCA00, W0
00121E  23B9A1     MOV #0x3B9A, W1
001220  070360     RCALL ___divsi3
001222  BE8F00     MOV.D W0, [W14]
203:               
204:                   return actStep * TMR3;
001224  800850     MOV TMR3, W0
001226  200001     MOV #0x0, W1
001228  78011E     MOV [W14], W2
00122A  B99101     MUL.SS W2, W1, W2
00122C  780102     MOV W2, W2
00122E  90019E     MOV [W14+2], W3
001230  B99A00     MUL.SS W3, W0, W4
001232  780184     MOV W4, W3
001234  410103     ADD W2, W3, W2
001236  78019E     MOV [W14], W3
001238  B81800     MUL.UU W3, W0, W0
00123A  410101     ADD W2, W1, W2
00123C  780082     MOV W2, W1
205:               }
00123E  FA8000     ULNK
001240  060000     RETURN
206:               
207:               static long int tryTimer3Prescaler (int prsc, long int interval)
208:               {
001242  FA000E     LNK #0xE
001244  980740     MOV W0, [W14+8]
001246  980752     MOV W2, [W14+10]
001248  980763     MOV W3, [W14+12]
209:               long int actStep, requestedSteps;
210:               
211:                   if (getTimer3Prescaler() != prsc) setTimer3Prescaler(prsc);
00124A  070085     RCALL _getTimer3Prescaler
00124C  9000CE     MOV [W14+8], W1
00124E  500F81     SUB W0, W1, [W15]
001250  320003     BRA Z, 0x1258
001252  90004E     MOV [W14+8], W0
001254  784000     MOV.B W0, W0
001256  07FEF6     RCALL setTimer3Prescaler
212:               
213:                   actStep = getTimer3Step();
001258  070085     RCALL _getTimer3Step
00125A  980720     MOV W0, [W14+4]
00125C  980731     MOV W1, [W14+6]
214:               
215:                   if (actStep != 0)
00125E  90002E     MOV [W14+4], W0
001260  9000BE     MOV [W14+6], W1
001262  500FE0     SUB W0, #0x0, [W15]
001264  588FE0     SUBB W1, #0x0, [W15]
001266  320006     BRA Z, 0x1274
216:                       requestedSteps = interval / actStep;
001268  90012E     MOV [W14+4], W2
00126A  9001BE     MOV [W14+6], W3
00126C  90005E     MOV [W14+10], W0
00126E  9000EE     MOV [W14+12], W1
001270  070338     RCALL ___divsi3
001272  BE8F00     MOV.D W0, [W14]
217:               
218:                   if (requestedSteps <= TIMER_SIZE && actStep != 0)
001274  200000     MOV #0x0, W0
001276  200011     MOV #0x1, W1
001278  BE011E     MOV.D [W14], W2
00127A  510F80     SUB W2, W0, [W15]
00127C  598F81     SUBB W3, W1, [W15]
00127E  3C0022     BRA GT, 0x12C4
001280  90002E     MOV [W14+4], W0
001282  9000BE     MOV [W14+6], W1
001284  500FE0     SUB W0, #0x0, [W15]
001286  588FE0     SUBB W1, #0x0, [W15]
001288  32001D     BRA Z, 0x12C4
219:                   {
220:                       if (TMR3 > requestedSteps - 1) TMR3 = requestedSteps - 1;
00128A  800850     MOV TMR3, W0
00128C  B80161     MUL.UU W0, #1, W2
00128E  EB8200     SETM W4
001290  EB8280     SETM W5
001292  42003E     ADD W4, [W14++], W0
001294  4A80AE     ADDC W5, [W14--], W1
001296  510F80     SUB W2, W0, [W15]
001298  598F81     SUBB W3, W1, [W15]
00129A  340003     BRA LE, 0x12A2
00129C  78001E     MOV [W14], W0
00129E  E90000     DEC W0, W0
0012A0  880850     MOV W0, TMR3
221:                       PR3 = requestedSteps - 1;
0012A2  78001E     MOV [W14], W0
0012A4  E90000     DEC W0, W0
0012A6  880870     MOV W0, PR3
222:               
223:                       return actStep * requestedSteps;
0012A8  9000BE     MOV [W14+6], W1
0012AA  78001E     MOV [W14], W0
0012AC  B98800     MUL.SS W1, W0, W0
0012AE  780100     MOV W0, W2
0012B0  90009E     MOV [W14+2], W1
0012B2  90002E     MOV [W14+4], W0
0012B4  B98800     MUL.SS W1, W0, W0
0012B6  780000     MOV W0, W0
0012B8  410100     ADD W2, W0, W2
0012BA  90002E     MOV [W14+4], W0
0012BC  B8001E     MUL.UU W0, [W14], W0
0012BE  410101     ADD W2, W1, W2
0012C0  780082     MOV W2, W1
0012C2  370002     BRA 0x12C8
224:                   }
225:                   else
226:                   {
227:                       return -1;
0012C4  EB8000     SETM W0
0012C6  EB8080     SETM W1
228:                   }
229:               }
0012C8  FA8000     ULNK
0012CA  060000     RETURN
230:               
231:               static long int tryTimer3PrescalerNS (int prsc, long int interval)
232:               {
0012CC  FA000E     LNK #0xE
0012CE  980740     MOV W0, [W14+8]
0012D0  980752     MOV W2, [W14+10]
0012D2  980763     MOV W3, [W14+12]
233:               long int actStep, requestedSteps;
234:               
235:                   if (getTimer3Prescaler() != prsc) setTimer3Prescaler(prsc);
0012D4  070040     RCALL _getTimer3Prescaler
0012D6  9000CE     MOV [W14+8], W1
0012D8  500F81     SUB W0, W1, [W15]
0012DA  320003     BRA Z, 0x12E2
0012DC  90004E     MOV [W14+8], W0
0012DE  784000     MOV.B W0, W0
0012E0  07FEB1     RCALL setTimer3Prescaler
236:               
237:                   actStep = getTimer3StepNS();
0012E2  070048     RCALL _getTimer3StepNS
0012E4  980720     MOV W0, [W14+4]
0012E6  980731     MOV W1, [W14+6]
238:               
239:                   if (actStep != 0)
0012E8  90002E     MOV [W14+4], W0
0012EA  9000BE     MOV [W14+6], W1
0012EC  500FE0     SUB W0, #0x0, [W15]
0012EE  588FE0     SUBB W1, #0x0, [W15]
0012F0  320006     BRA Z, 0x12FE
240:                       requestedSteps = interval / actStep;
0012F2  90012E     MOV [W14+4], W2
0012F4  9001BE     MOV [W14+6], W3
0012F6  90005E     MOV [W14+10], W0
0012F8  9000EE     MOV [W14+12], W1
0012FA  0702F3     RCALL ___divsi3
0012FC  BE8F00     MOV.D W0, [W14]
241:               
242:                   if (requestedSteps <= TIMER_SIZE && actStep != 0)
0012FE  200000     MOV #0x0, W0
001300  200011     MOV #0x1, W1
001302  BE011E     MOV.D [W14], W2
001304  510F80     SUB W2, W0, [W15]
001306  598F81     SUBB W3, W1, [W15]
001308  3C0022     BRA GT, 0x134E
00130A  90002E     MOV [W14+4], W0
00130C  9000BE     MOV [W14+6], W1
00130E  500FE0     SUB W0, #0x0, [W15]
001310  588FE0     SUBB W1, #0x0, [W15]
001312  32001D     BRA Z, 0x134E
243:                   {
244:                       if (TMR3 > requestedSteps - 1) TMR3 = requestedSteps - 1;
001314  800850     MOV TMR3, W0
001316  B80161     MUL.UU W0, #1, W2
001318  EB8200     SETM W4
00131A  EB8280     SETM W5
00131C  42003E     ADD W4, [W14++], W0
00131E  4A80AE     ADDC W5, [W14--], W1
001320  510F80     SUB W2, W0, [W15]
001322  598F81     SUBB W3, W1, [W15]
001324  340003     BRA LE, 0x132C
001326  78001E     MOV [W14], W0
001328  E90000     DEC W0, W0
00132A  880850     MOV W0, TMR3
245:                       PR3 = requestedSteps - 1;
00132C  78001E     MOV [W14], W0
00132E  E90000     DEC W0, W0
001330  880870     MOV W0, PR3
246:               
247:                       return actStep * requestedSteps;
001332  9000BE     MOV [W14+6], W1
001334  78001E     MOV [W14], W0
001336  B98800     MUL.SS W1, W0, W0
001338  780100     MOV W0, W2
00133A  90009E     MOV [W14+2], W1
00133C  90002E     MOV [W14+4], W0
00133E  B98800     MUL.SS W1, W0, W0
001340  780000     MOV W0, W0
001342  410100     ADD W2, W0, W2
001344  90002E     MOV [W14+4], W0
001346  B8001E     MUL.UU W0, [W14], W0
001348  410101     ADD W2, W1, W2
00134A  780082     MOV W2, W1
00134C  370002     BRA 0x1352
248:                   }
249:                   else
250:                   {
251:                       return -1;
00134E  EB8000     SETM W0
001350  EB8080     SETM W1
252:                   }
253:               }
001352  FA8000     ULNK
001354  060000     RETURN
254:               
255:               static int getTimer3Prescaler ()
256:               {
001356  FA0000     LNK #0x0
257:                   return T3CONbits.TCKPS;
001358  800890     MOV T3CON, W0
00135A  DE0044     LSR W0, #4, W0
00135C  604063     AND.B W0, #0x3, W0
00135E  FB8000     ZE W0, W0
258:               }
001360  FA8000     ULNK
001362  060000     RETURN
259:               
260:               static long int getTimer3Step ()
261:               {
001364  FA0000     LNK #0x0
262:                   return SECOND_US / getTimer3Freq();
001366  07FF04     RCALL getTimer3Freq
001368  BE0100     MOV.D W0, W2
00136A  242400     MOV #0x4240, W0
00136C  2000F1     MOV #0xF, W1
00136E  0702B9     RCALL ___divsi3
263:               }
001370  FA8000     ULNK
001372  060000     RETURN
264:               
265:               static long int getTimer3StepNS ()
266:               {
001374  FA0000     LNK #0x0
267:                   return SECOND_NS / getTimer3Freq();
001376  07FEFC     RCALL getTimer3Freq
001378  BE0100     MOV.D W0, W2
00137A  2CA000     MOV #0xCA00, W0
00137C  23B9A1     MOV #0x3B9A, W1
00137E  0702B1     RCALL ___divsi3
268:               }
001380  FA8000     ULNK
001382  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timer2.c  -------------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include <stdlib.h>
4:                 #include "ClockControl.h"
5:                 #include "timer2.h"
6:                 
7:                 #define MIN_PRESCALER 0
8:                 #define MAX_PRESCALER 3
9:                 
10:                #define TIMER_SIZE 65536
11:                
12:                #define SECOND_US 1000000.0
13:                
14:                static void (*tmr2Clbk)();
15:                
16:                static const int prescaler [4] = {1, 8, 64, 256};
17:                
18:                void __attribute__((__interrupt__, __auto_psv__))  _T2Interrupt (void)
19:                {
000D36  F80036     PUSH RCOUNT
000D38  BE9F80     MOV.D W0, [W15++]
000D3A  BE9F82     MOV.D W2, [W15++]
000D3C  BE9F84     MOV.D W4, [W15++]
000D3E  BE9F86     MOV.D W6, [W15++]
000D40  F80034     PUSH PSVPAG
000D42  200000     MOV #0x0, W0
000D44  8801A0     MOV W0, PSVPAG
000D46  FA0000     LNK #0x0
20:                    if (tmr2Clbk != NULL)
000D48  808CA0     MOV tmr2Clbk, W0
000D4A  500FE0     SUB W0, #0x0, [W15]
000D4C  320002     BRA Z, 0xD52
21:                    {
22:                        tmr2Clbk();
000D4E  808CA0     MOV tmr2Clbk, W0
000D50  010000     CALL W0
23:                    }
24:                
25:                    IFS0bits.T1IF = 0;
000D52  A96084     BCLR IFS0, #3
26:                }
000D54  FA8000     ULNK
000D56  F90034     POP PSVPAG
000D58  BE034F     MOV.D [--W15], W6
000D5A  BE024F     MOV.D [--W15], W4
000D5C  BE014F     MOV.D [--W15], W2
000D5E  BE004F     MOV.D [--W15], W0
000D60  F90036     POP RCOUNT
000D62  064000     RETFIE
27:                
28:                void timer2Init ()
29:                {
000D64  FA0000     LNK #0x0
30:                    T2CONbits.TON = 0;
000D66  A9E111     BCLR 0x111, #7
31:                
32:                    T2CONbits.TGATE = 0;
000D68  A9C110     BCLR T2CON, #6
33:                    T2CONbits.TCS = 0;
000D6A  A92110     BCLR T2CON, #1
34:                    T2CONbits.TCKPS = 0;
000D6C  800881     MOV T2CON, W1
000D6E  2FFCF0     MOV #0xFFCF, W0
000D70  608000     AND W1, W0, W0
000D72  880880     MOV W0, T2CON
35:                
36:                    tmr2Clbk = NULL;
000D74  EB0000     CLR W0
000D76  888CA0     MOV W0, tmr2Clbk
37:                
38:                    IEC0bits.T2IE = 1;
000D78  A8E094     BSET IEC0, #7
39:                
40:                    IPC1bits.T2IP = 3;
000D7A  800531     MOV IPC1, W1
000D7C  28FFF0     MOV #0x8FFF, W0
000D7E  608080     AND W1, W0, W1
000D80  230000     MOV #0x3000, W0
000D82  708000     IOR W1, W0, W0
000D84  880530     MOV W0, IPC1
41:                }
000D86  FA8000     ULNK
000D88  060000     RETURN
42:                
43:                void setTimer2Prescaler (char prsc)
44:                {
000D8A  FA0002     LNK #0x2
000D8C  784F00     MOV.B W0, [W14]
45:                
46:                    if (prsc < MIN_PRESCALER) prsc = MIN_PRESCALER;
000D8E  78401E     MOV.B [W14], W0
000D90  504FE0     SUB.B W0, #0x0, [W15]
000D92  3D0002     BRA GE, 0xD98
000D94  EB4000     CLR.B W0
000D96  784F00     MOV.B W0, [W14]
47:                    if (prsc > MAX_PRESCALER) prsc = MAX_PRESCALER;
000D98  78401E     MOV.B [W14], W0
000D9A  504FE3     SUB.B W0, #0x3, [W15]
000D9C  340002     BRA LE, 0xDA2
000D9E  B3C030     MOV #0x3, W0
000DA0  784F00     MOV.B W0, [W14]
48:                
49:                    if (T2CONbits.TCKPS != prsc)
000DA2  800880     MOV T2CON, W0
000DA4  DE0044     LSR W0, #4, W0
000DA6  604063     AND.B W0, #0x3, W0
000DA8  FB8080     ZE W0, W1
000DAA  FB001E     SE [W14], W0
000DAC  508F80     SUB W1, W0, [W15]
000DAE  32000A     BRA Z, 0xDC4
50:                        T2CONbits.TCKPS = prsc;
000DB0  78401E     MOV.B [W14], W0
000DB2  604063     AND.B W0, #0x3, W0
000DB4  FB8000     ZE W0, W0
000DB6  600063     AND W0, #0x3, W0
000DB8  DD0044     SL W0, #4, W0
000DBA  800882     MOV T2CON, W2
000DBC  2FFCF1     MOV #0xFFCF, W1
000DBE  610081     AND W2, W1, W1
000DC0  708000     IOR W1, W0, W0
000DC2  880880     MOV W0, T2CON
51:                
52:                }
000DC4  FA8000     ULNK
000DC6  060000     RETURN
53:                
54:                long int setTimer2Interval (long int uS)
55:                {
000DC8  FA0012     LNK #0x12
000DCA  980770     MOV W0, [W14+14]
000DCC  980F01     MOV W1, [W14+16]
56:                long int actStep, timerFreq = getTimer2Freq(), requestedSteps;
000DCE  0700C1     RCALL getTimer2Freq
000DD0  980730     MOV W0, [W14+6]
000DD2  980741     MOV W1, [W14+8]
57:                
58:                    actStep = SECOND_US / timerFreq;
000DD4  90003E     MOV [W14+6], W0
000DD6  9000CE     MOV [W14+8], W1
000DD8  0705D1     RCALL ___floatsisf
000DDA  BE0100     MOV.D W0, W2
000DDC  224000     MOV #0x2400, W0
000DDE  249741     MOV #0x4974, W1
000DE0  07053E     RCALL ___divsf3
000DE2  070590     RCALL ___fixsfsi
000DE4  980750     MOV W0, [W14+10]
000DE6  980761     MOV W1, [W14+12]
59:                
60:                    if (actStep != 0)
000DE8  90005E     MOV [W14+10], W0
000DEA  9000EE     MOV [W14+12], W1
000DEC  500FE0     SUB W0, #0x0, [W15]
000DEE  588FE0     SUBB W1, #0x0, [W15]
000DF0  320006     BRA Z, 0xDFE
61:                        requestedSteps = uS / actStep;
000DF2  90015E     MOV [W14+10], W2
000DF4  9001EE     MOV [W14+12], W3
000DF6  90007E     MOV [W14+14], W0
000DF8  90088E     MOV [W14+16], W1
000DFA  070573     RCALL ___divsi3
000DFC  BE8F00     MOV.D W0, [W14]
62:                
63:                    if (requestedSteps <= TIMER_SIZE && actStep != 0)
000DFE  200000     MOV #0x0, W0
000E00  200011     MOV #0x1, W1
000E02  BE011E     MOV.D [W14], W2
000E04  510F80     SUB W2, W0, [W15]
000E06  598F81     SUBB W3, W1, [W15]
000E08  3C0022     BRA GT, 0xE4E
000E0A  90005E     MOV [W14+10], W0
000E0C  9000EE     MOV [W14+12], W1
000E0E  500FE0     SUB W0, #0x0, [W15]
000E10  588FE0     SUBB W1, #0x0, [W15]
000E12  32001D     BRA Z, 0xE4E
64:                    {
65:                        if (TMR2 > requestedSteps - 1) TMR2 = requestedSteps - 1;
000E14  800830     MOV TMR2, W0
000E16  B80161     MUL.UU W0, #1, W2
000E18  EB8200     SETM W4
000E1A  EB8280     SETM W5
000E1C  42003E     ADD W4, [W14++], W0
000E1E  4A80AE     ADDC W5, [W14--], W1
000E20  510F80     SUB W2, W0, [W15]
000E22  598F81     SUBB W3, W1, [W15]
000E24  340003     BRA LE, 0xE2C
000E26  78001E     MOV [W14], W0
000E28  E90000     DEC W0, W0
000E2A  880830     MOV W0, TMR2
66:                        PR2 = requestedSteps - 1;
000E2C  78001E     MOV [W14], W0
000E2E  E90000     DEC W0, W0
000E30  880860     MOV W0, PR2
67:                
68:                        return actStep * requestedSteps;
000E32  9000EE     MOV [W14+12], W1
000E34  78001E     MOV [W14], W0
000E36  B98800     MUL.SS W1, W0, W0
000E38  780100     MOV W0, W2
000E3A  90009E     MOV [W14+2], W1
000E3C  90005E     MOV [W14+10], W0
000E3E  B98800     MUL.SS W1, W0, W0
000E40  780000     MOV W0, W0
000E42  410100     ADD W2, W0, W2
000E44  90005E     MOV [W14+10], W0
000E46  B8001E     MUL.UU W0, [W14], W0
000E48  410101     ADD W2, W1, W2
000E4A  780082     MOV W2, W1
000E4C  37006D     BRA 0xF28
69:                    }
70:                    else
71:                    {
72:                    int i;
73:                
74:                        for (i = 0; i < 4; i++)
000E4E  EB0000     CLR W0
000E50  980720     MOV W0, [W14+4]
000E52  370046     BRA 0xEE0
000EDA  90002E     MOV [W14+4], W0
000EDC  E80000     INC W0, W0
000EDE  980720     MOV W0, [W14+4]
000EE0  90002E     MOV [W14+4], W0
000EE2  500FE3     SUB W0, #0x3, [W15]
000EE4  34FFB7     BRA LE, 0xE54
75:                        {
76:                            setTimer2Prescaler (i);
000E54  90002E     MOV [W14+4], W0
000E56  784000     MOV.B W0, W0
000E58  07FF98     RCALL setTimer2Prescaler
77:                
78:                            timerFreq = getTimer2Freq();
000E5A  07007B     RCALL getTimer2Freq
000E5C  980730     MOV W0, [W14+6]
000E5E  980741     MOV W1, [W14+8]
79:                
80:                            actStep = SECOND_US / timerFreq;
000E60  90003E     MOV [W14+6], W0
000E62  9000CE     MOV [W14+8], W1
000E64  07058B     RCALL ___floatsisf
000E66  BE0100     MOV.D W0, W2
000E68  224000     MOV #0x2400, W0
000E6A  249741     MOV #0x4974, W1
000E6C  0704F8     RCALL ___divsf3
000E6E  07054A     RCALL ___fixsfsi
000E70  980750     MOV W0, [W14+10]
000E72  980761     MOV W1, [W14+12]
81:                
82:                            if (actStep != 0)
000E74  90005E     MOV [W14+10], W0
000E76  9000EE     MOV [W14+12], W1
000E78  500FE0     SUB W0, #0x0, [W15]
000E7A  588FE0     SUBB W1, #0x0, [W15]
000E7C  320006     BRA Z, 0xE8A
83:                                requestedSteps = uS / actStep;
000E7E  90015E     MOV [W14+10], W2
000E80  9001EE     MOV [W14+12], W3
000E82  90007E     MOV [W14+14], W0
000E84  90088E     MOV [W14+16], W1
000E86  07052D     RCALL ___divsi3
000E88  BE8F00     MOV.D W0, [W14]
84:                
85:                            if (requestedSteps <= TIMER_SIZE && actStep != 0)
000E8A  200000     MOV #0x0, W0
000E8C  200011     MOV #0x1, W1
000E8E  BE011E     MOV.D [W14], W2
000E90  510F80     SUB W2, W0, [W15]
000E92  598F81     SUBB W3, W1, [W15]
000E94  3C0022     BRA GT, 0xEDA
000E96  90005E     MOV [W14+10], W0
000E98  9000EE     MOV [W14+12], W1
000E9A  500FE0     SUB W0, #0x0, [W15]
000E9C  588FE0     SUBB W1, #0x0, [W15]
000E9E  32001D     BRA Z, 0xEDA
86:                            {
87:                                if (TMR2 > requestedSteps - 1) TMR2 = requestedSteps - 1;
000EA0  800830     MOV TMR2, W0
000EA2  B80161     MUL.UU W0, #1, W2
000EA4  EB8200     SETM W4
000EA6  EB8280     SETM W5
000EA8  42003E     ADD W4, [W14++], W0
000EAA  4A80AE     ADDC W5, [W14--], W1
000EAC  510F80     SUB W2, W0, [W15]
000EAE  598F81     SUBB W3, W1, [W15]
000EB0  340003     BRA LE, 0xEB8
000EB2  78001E     MOV [W14], W0
000EB4  E90000     DEC W0, W0
000EB6  880830     MOV W0, TMR2
88:                                PR2 = requestedSteps - 1;
000EB8  78001E     MOV [W14], W0
000EBA  E90000     DEC W0, W0
000EBC  880860     MOV W0, PR2
89:                
90:                                return actStep * requestedSteps;
000EBE  9000EE     MOV [W14+12], W1
000EC0  78001E     MOV [W14], W0
000EC2  B98800     MUL.SS W1, W0, W0
000EC4  780100     MOV W0, W2
000EC6  90009E     MOV [W14+2], W1
000EC8  90005E     MOV [W14+10], W0
000ECA  B98800     MUL.SS W1, W0, W0
000ECC  780000     MOV W0, W0
000ECE  410100     ADD W2, W0, W2
000ED0  90005E     MOV [W14+10], W0
000ED2  B8001E     MUL.UU W0, [W14], W0
000ED4  410101     ADD W2, W1, W2
000ED6  780082     MOV W2, W1
000ED8  370027     BRA 0xF28
91:                            }
92:                        }
93:                
94:                    }
95:                
96:                    setTimer2Prescaler (3);
000EE6  B3C030     MOV #0x3, W0
000EE8  07FF50     RCALL setTimer2Prescaler
97:                
98:                    timerFreq = getTimer2Freq();
000EEA  070033     RCALL getTimer2Freq
000EEC  980730     MOV W0, [W14+6]
000EEE  980741     MOV W1, [W14+8]
99:                
100:                   actStep = SECOND_US / timerFreq;
000EF0  90003E     MOV [W14+6], W0
000EF2  9000CE     MOV [W14+8], W1
000EF4  070543     RCALL ___floatsisf
000EF6  BE0100     MOV.D W0, W2
000EF8  224000     MOV #0x2400, W0
000EFA  249741     MOV #0x4974, W1
000EFC  0704B0     RCALL ___divsf3
000EFE  070502     RCALL ___fixsfsi
000F00  980750     MOV W0, [W14+10]
000F02  980761     MOV W1, [W14+12]
101:               
102:                   PR2 = TIMER_SIZE - 1;
000F04  EB8000     SETM W0
000F06  880860     MOV W0, PR2
103:                   if (TMR2 > requestedSteps - 1) TMR2 = requestedSteps - 1;
000F08  800830     MOV TMR2, W0
000F0A  B80161     MUL.UU W0, #1, W2
000F0C  EB8200     SETM W4
000F0E  EB8280     SETM W5
000F10  42003E     ADD W4, [W14++], W0
000F12  4A80AE     ADDC W5, [W14--], W1
000F14  510F80     SUB W2, W0, [W15]
000F16  598F81     SUBB W3, W1, [W15]
000F18  340003     BRA LE, 0xF20
000F1A  78001E     MOV [W14], W0
000F1C  E90000     DEC W0, W0
000F1E  880830     MOV W0, TMR2
104:               
105:                   return TIMER_SIZE * actStep;
000F20  90005E     MOV [W14+10], W0
000F22  9000EE     MOV [W14+12], W1
000F24  DD00C0     SL W0, #0, W1
000F26  200000     MOV #0x0, W0
106:               }
000F28  FA8000     ULNK
000F2A  060000     RETURN
107:               
108:               void timer2Delay (long int uS)
109:               {
000F2C  FA0004     LNK #0x4
000F2E  BE8F00     MOV.D W0, [W14]
110:                   setTimer2Interval (uS);
000F30  BE001E     MOV.D [W14], W0
000F32  07FF4A     RCALL setTimer2Interval
111:               
112:                   IEC0bits.T2IE = 0;
000F34  A9E094     BCLR IEC0, #7
113:               
114:                   timer2Reset();
000F36  070029     RCALL timer2Reset
115:                   timer2Start();
000F38  070020     RCALL timer2Start
116:               
117:                   while (IFS0bits.T2IF != 1);
000F3A  000000     NOP
000F3C  800421     MOV IFS0, W1
000F3E  200800     MOV #0x80, W0
000F40  608000     AND W1, W0, W0
000F42  500FE0     SUB W0, #0x0, [W15]
000F44  32FFFB     BRA Z, 0xF3C
118:               
119:                   IFS0bits.T2IF = 0;
000F46  A9E084     BCLR IFS0, #7
120:               
121:                   timer2Stop();
000F48  07001C     RCALL timer2Stop
122:                   timer2Reset();
000F4A  07001F     RCALL timer2Reset
123:               
124:                   IEC0bits.T2IE = 1;
000F4C  A8E094     BSET IEC0, #7
125:               }
000F4E  FA8000     ULNK
000F50  060000     RETURN
126:               
127:               inline long int getTimer2Freq ()
128:               {
000F52  FA0004     LNK #0x4
129:               long int ris;
130:               
131:                   ris = getClockFreq() / (2 * prescaler [T2CONbits.TCKPS]);
000F54  07554F     RCALL getClockFreq
000F56  BE0200     MOV.D W0, W4
000F58  800880     MOV T2CON, W0
000F5A  DE0044     LSR W0, #4, W0
000F5C  604063     AND.B W0, #0x3, W0
000F5E  FB8000     ZE W0, W0
000F60  2D46E1     MOV #0xD46E, W1
000F62  400000     ADD W0, W0, W0
000F64  408000     ADD W1, W0, W0
000F66  780010     MOV [W0], W0
000F68  400000     ADD W0, W0, W0
000F6A  DE80CF     ASR W0, #15, W1
000F6C  BE0100     MOV.D W0, W2
000F6E  BE0004     MOV.D W4, W0
000F70  0704B8     RCALL ___divsi3
000F72  BE8F00     MOV.D W0, [W14]
132:               
133:                   return ris;
000F74  BE001E     MOV.D [W14], W0
134:               }
000F76  FA8000     ULNK
000F78  060000     RETURN
135:               
136:               inline void timer2Start ()
137:               {
000F7A  FA0000     LNK #0x0
138:                   T2CONbits.TON = 1;
000F7C  A8E111     BSET 0x111, #7
139:               }
000F7E  FA8000     ULNK
000F80  060000     RETURN
140:               
141:               inline void timer2Stop ()
142:               {
000F82  FA0000     LNK #0x0
143:                   T2CONbits.TON = 0;
000F84  A9E111     BCLR 0x111, #7
144:               }
000F86  FA8000     ULNK
000F88  060000     RETURN
145:               
146:               inline void timer2Reset ()
147:               {
000F8A  FA0000     LNK #0x0
148:                   TMR2 = 0;
000F8C  EB0000     CLR W0
000F8E  880830     MOV W0, TMR2
149:               }
000F90  FA8000     ULNK
000F92  060000     RETURN
150:               
151:               inline long int getTimer2Count ()
152:               {
000F94  FA0000     LNK #0x0
153:                   return TMR2;
000F96  800830     MOV TMR2, W0
000F98  200001     MOV #0x0, W1
154:               }
000F9A  FA8000     ULNK
000F9C  060000     RETURN
155:               
156:               void timer2WaitUntilEnd ()
157:               {
000F9E  FA0000     LNK #0x0
158:                   IEC0bits.T2IE = 0;
000FA0  A9E094     BCLR IEC0, #7
159:               
160:                   while (IFS0bits.T2IF != 1);
000FA2  000000     NOP
000FA4  800421     MOV IFS0, W1
000FA6  200800     MOV #0x80, W0
000FA8  608000     AND W1, W0, W0
000FAA  500FE0     SUB W0, #0x0, [W15]
000FAC  32FFFB     BRA Z, 0xFA4
161:               
162:                   IFS0bits.T2IF = 0;
000FAE  A9E084     BCLR IFS0, #7
163:               
164:                   IEC0bits.T2IE = 1;
000FB0  A8E094     BSET IEC0, #7
165:               }
000FB2  FA8000     ULNK
000FB4  060000     RETURN
166:               
167:               void setTimer2Callback (void (*clbk)())
168:               {
000FB6  FA0002     LNK #0x2
000FB8  780F00     MOV W0, [W14]
169:                   tmr2Clbk = clbk;
000FBA  78001E     MOV [W14], W0
000FBC  888CA0     MOV W0, tmr2Clbk
170:               }
000FBE  FA8000     ULNK
000FC0  060000     RETURN
171:               
172:               long int timer2ElaspedTime ()
173:               {
000FC2  FA0004     LNK #0x4
174:               long int actStep = SECOND_US / getTimer2Freq();
000FC4  07FFC6     RCALL getTimer2Freq
000FC6  0704DA     RCALL ___floatsisf
000FC8  BE0100     MOV.D W0, W2
000FCA  224000     MOV #0x2400, W0
000FCC  249741     MOV #0x4974, W1
000FCE  070447     RCALL ___divsf3
000FD0  070499     RCALL ___fixsfsi
000FD2  BE8F00     MOV.D W0, [W14]
175:               
176:                   return actStep * TMR2;
000FD4  800830     MOV TMR2, W0
000FD6  200001     MOV #0x0, W1
000FD8  78011E     MOV [W14], W2
000FDA  B99101     MUL.SS W2, W1, W2
000FDC  780102     MOV W2, W2
000FDE  90019E     MOV [W14+2], W3
000FE0  B99A00     MUL.SS W3, W0, W4
000FE2  780184     MOV W4, W3
000FE4  410103     ADD W2, W3, W2
000FE6  78019E     MOV [W14], W3
000FE8  B81800     MUL.UU W3, W0, W0
000FEA  410101     ADD W2, W1, W2
000FEC  780082     MOV W2, W1
177:               }
000FEE  FA8000     ULNK
000FF0  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timer1.c  -------------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include <stdlib.h>
4:                 #include "ClockControl.h"
5:                 #include "timer1.h"
6:                 
7:                 #define MIN_PRESCALER 0
8:                 #define MAX_PRESCALER 3
9:                 
10:                #define TIMER_SIZE 65536
11:                
12:                #define SECOND_US 1000000
13:                
14:                static void (*tmr1Clbk)();
15:                
16:                static const int prescaler [4] = {1, 8, 64, 256};
17:                
18:                void __attribute__((__interrupt__, __auto_psv__))  _T1Interrupt (void)
19:                {
000A5A  F80036     PUSH RCOUNT
000A5C  BE9F80     MOV.D W0, [W15++]
000A5E  BE9F82     MOV.D W2, [W15++]
000A60  BE9F84     MOV.D W4, [W15++]
000A62  BE9F86     MOV.D W6, [W15++]
000A64  F80034     PUSH PSVPAG
000A66  200000     MOV #0x0, W0
000A68  8801A0     MOV W0, PSVPAG
000A6A  FA0000     LNK #0x0
20:                    if (tmr1Clbk != NULL)
000A6C  808C90     MOV tmr1Clbk, W0
000A6E  500FE0     SUB W0, #0x0, [W15]
000A70  320002     BRA Z, 0xA76
21:                    {
22:                        tmr1Clbk();
000A72  808C90     MOV tmr1Clbk, W0
000A74  010000     CALL W0
23:                    }
24:                
25:                    IFS0bits.T1IF = 0;
000A76  A96084     BCLR IFS0, #3
26:                }
000A78  FA8000     ULNK
000A7A  F90034     POP PSVPAG
000A7C  BE034F     MOV.D [--W15], W6
000A7E  BE024F     MOV.D [--W15], W4
000A80  BE014F     MOV.D [--W15], W2
000A82  BE004F     MOV.D [--W15], W0
000A84  F90036     POP RCOUNT
000A86  064000     RETFIE
27:                
28:                void timer1Init (timerMode md, timerGate gt, timerSync sy)
29:                {   
000A88  FA0006     LNK #0x6
000A8A  780F00     MOV W0, [W14]
000A8C  980711     MOV W1, [W14+2]
000A8E  980722     MOV W2, [W14+4]
30:                    T1CONbits.TON = 0;
000A90  A9E105     BCLR 0x105, #7
31:                    
32:                    T1CONbits.TGATE = gt;
000A92  90001E     MOV [W14+2], W0
000A94  784000     MOV.B W0, W0
000A96  604061     AND.B W0, #0x1, W0
000A98  FB8000     ZE W0, W0
000A9A  600061     AND W0, #0x1, W0
000A9C  DD0046     SL W0, #6, W0
000A9E  800822     MOV T1CON, W2
000AA0  2FFBF1     MOV #0xFFBF, W1
000AA2  610081     AND W2, W1, W1
000AA4  708000     IOR W1, W0, W0
000AA6  880820     MOV W0, T1CON
33:                    T1CONbits.TCS = md;
000AA8  78001E     MOV [W14], W0
000AAA  784000     MOV.B W0, W0
000AAC  604061     AND.B W0, #0x1, W0
000AAE  FB8000     ZE W0, W0
000AB0  600061     AND W0, #0x1, W0
000AB2  400000     ADD W0, W0, W0
000AB4  800822     MOV T1CON, W2
000AB6  2FFFD1     MOV #0xFFFD, W1
000AB8  610081     AND W2, W1, W1
000ABA  708000     IOR W1, W0, W0
000ABC  880820     MOV W0, T1CON
34:                    T1CONbits.TSYNC = sy;
000ABE  90002E     MOV [W14+4], W0
000AC0  784000     MOV.B W0, W0
000AC2  604061     AND.B W0, #0x1, W0
000AC4  FB8000     ZE W0, W0
000AC6  600061     AND W0, #0x1, W0
000AC8  DD0042     SL W0, #2, W0
000ACA  800822     MOV T1CON, W2
000ACC  2FFFB1     MOV #0xFFFB, W1
000ACE  610081     AND W2, W1, W1
000AD0  708000     IOR W1, W0, W0
000AD2  880820     MOV W0, T1CON
35:                
36:                    T1CONbits.TCKPS = 0;
000AD4  800821     MOV T1CON, W1
000AD6  2FFCF0     MOV #0xFFCF, W0
000AD8  608000     AND W1, W0, W0
000ADA  880820     MOV W0, T1CON
37:                    
38:                    tmr1Clbk = NULL;
000ADC  EB0000     CLR W0
000ADE  888C90     MOV W0, tmr1Clbk
39:                    
40:                    IEC0bits.T1IE = 1;
000AE0  A86094     BSET IEC0, #3
41:                
42:                    IPC0bits.T1IP = 3;
000AE2  800521     MOV IPC0, W1
000AE4  28FFF0     MOV #0x8FFF, W0
000AE6  608080     AND W1, W0, W1
000AE8  230000     MOV #0x3000, W0
000AEA  708000     IOR W1, W0, W0
000AEC  880520     MOV W0, IPC0
43:                }
000AEE  FA8000     ULNK
000AF0  060000     RETURN
44:                
45:                void timer1Init_OLD ()
46:                {
000AF2  FA0000     LNK #0x0
47:                    T1CONbits.TON = 0;
000AF4  A9E105     BCLR 0x105, #7
48:                
49:                    T1CONbits.TGATE = 0;
000AF6  A9C104     BCLR T1CON, #6
50:                    T1CONbits.TCS = 0;
000AF8  A92104     BCLR T1CON, #1
51:                    T1CONbits.TSYNC = 0;
000AFA  A94104     BCLR T1CON, #2
52:                
53:                    T1CONbits.TCKPS = 0;
000AFC  800821     MOV T1CON, W1
000AFE  2FFCF0     MOV #0xFFCF, W0
000B00  608000     AND W1, W0, W0
000B02  880820     MOV W0, T1CON
54:                
55:                    tmr1Clbk = NULL;
000B04  EB0000     CLR W0
000B06  888C90     MOV W0, tmr1Clbk
56:                
57:                    IEC0bits.T1IE = 1;
000B08  A86094     BSET IEC0, #3
58:                
59:                    IPC0bits.T1IP = 3;
000B0A  800521     MOV IPC0, W1
000B0C  28FFF0     MOV #0x8FFF, W0
000B0E  608080     AND W1, W0, W1
000B10  230000     MOV #0x3000, W0
000B12  708000     IOR W1, W0, W0
000B14  880520     MOV W0, IPC0
60:                }
000B16  FA8000     ULNK
000B18  060000     RETURN
61:                
62:                void setTimer1Prescaler (char prsc)
63:                {
000B1A  FA0002     LNK #0x2
000B1C  784F00     MOV.B W0, [W14]
64:                
65:                    if (prsc < MIN_PRESCALER) prsc = MIN_PRESCALER;
000B1E  78401E     MOV.B [W14], W0
000B20  504FE0     SUB.B W0, #0x0, [W15]
000B22  3D0002     BRA GE, 0xB28
000B24  EB4000     CLR.B W0
000B26  784F00     MOV.B W0, [W14]
66:                    if (prsc > MAX_PRESCALER) prsc = MAX_PRESCALER;
000B28  78401E     MOV.B [W14], W0
000B2A  504FE3     SUB.B W0, #0x3, [W15]
000B2C  340002     BRA LE, 0xB32
000B2E  B3C030     MOV #0x3, W0
000B30  784F00     MOV.B W0, [W14]
67:                    
68:                    T1CONbits.TCKPS = prsc;
000B32  78401E     MOV.B [W14], W0
000B34  604063     AND.B W0, #0x3, W0
000B36  FB8000     ZE W0, W0
000B38  600063     AND W0, #0x3, W0
000B3A  DD0044     SL W0, #4, W0
000B3C  800822     MOV T1CON, W2
000B3E  2FFCF1     MOV #0xFFCF, W1
000B40  610081     AND W2, W1, W1
000B42  708000     IOR W1, W0, W0
000B44  880820     MOV W0, T1CON
69:                    
70:                }
000B46  FA8000     ULNK
000B48  060000     RETURN
71:                
72:                long int setTimer1Interval (long int uS)
73:                {
000B4A  FA0012     LNK #0x12
000B4C  980770     MOV W0, [W14+14]
000B4E  980F01     MOV W1, [W14+16]
74:                long int actStep, timerFreq = getTimer1Freq(), requestedSteps;
000B50  07009A     RCALL getTimer1Freq
000B52  980730     MOV W0, [W14+6]
000B54  980741     MOV W1, [W14+8]
75:                
76:                    T1CONbits.TON = 0;
000B56  A9E105     BCLR 0x105, #7
77:                
78:                    actStep = SECOND_US / timerFreq;
000B58  90013E     MOV [W14+6], W2
000B5A  9001CE     MOV [W14+8], W3
000B5C  242400     MOV #0x4240, W0
000B5E  2000F1     MOV #0xF, W1
000B60  0706C0     RCALL ___divsi3
000B62  980750     MOV W0, [W14+10]
000B64  980761     MOV W1, [W14+12]
79:                
80:                    if (actStep != 0)
000B66  90005E     MOV [W14+10], W0
000B68  9000EE     MOV [W14+12], W1
000B6A  500FE0     SUB W0, #0x0, [W15]
000B6C  588FE0     SUBB W1, #0x0, [W15]
000B6E  320006     BRA Z, 0xB7C
81:                        requestedSteps = uS / actStep;
000B70  90015E     MOV [W14+10], W2
000B72  9001EE     MOV [W14+12], W3
000B74  90007E     MOV [W14+14], W0
000B76  90088E     MOV [W14+16], W1
000B78  0706B4     RCALL ___divsi3
000B7A  BE8F00     MOV.D W0, [W14]
82:                    
83:                    if (requestedSteps <= TIMER_SIZE && actStep != 0)
000B7C  200000     MOV #0x0, W0
000B7E  200011     MOV #0x1, W1
000B80  BE011E     MOV.D [W14], W2
000B82  510F80     SUB W2, W0, [W15]
000B84  598F81     SUBB W3, W1, [W15]
000B86  3C0018     BRA GT, 0xBB8
000B88  90005E     MOV [W14+10], W0
000B8A  9000EE     MOV [W14+12], W1
000B8C  500FE0     SUB W0, #0x0, [W15]
000B8E  588FE0     SUBB W1, #0x0, [W15]
000B90  320013     BRA Z, 0xBB8
84:                    {
85:                        TMR1 = 0;
000B92  EB0000     CLR W0
000B94  880800     MOV W0, TMR1
86:                        PR1 = requestedSteps - 1;
000B96  78001E     MOV [W14], W0
000B98  E90000     DEC W0, W0
000B9A  880810     MOV W0, PR1
87:                        
88:                        return actStep * requestedSteps;
000B9C  9000EE     MOV [W14+12], W1
000B9E  78001E     MOV [W14], W0
000BA0  B98800     MUL.SS W1, W0, W0
000BA2  780100     MOV W0, W2
000BA4  90009E     MOV [W14+2], W1
000BA6  90005E     MOV [W14+10], W0
000BA8  B98800     MUL.SS W1, W0, W0
000BAA  780000     MOV W0, W0
000BAC  410100     ADD W2, W0, W2
000BAE  90005E     MOV [W14+10], W0
000BB0  B8001E     MUL.UU W0, [W14], W0
000BB2  410101     ADD W2, W1, W2
000BB4  780082     MOV W2, W1
000BB6  370053     BRA 0xC5E
89:                    }
90:                    else
91:                    {
92:                    int i;
93:                        
94:                        for (i = 0; i < 4; i++)
000BB8  EB0000     CLR W0
000BBA  980720     MOV W0, [W14+4]
000BBC  370039     BRA 0xC30
000C2A  90002E     MOV [W14+4], W0
000C2C  E80000     INC W0, W0
000C2E  980720     MOV W0, [W14+4]
000C30  90002E     MOV [W14+4], W0
000C32  500FE3     SUB W0, #0x3, [W15]
000C34  34FFC4     BRA LE, 0xBBE
95:                        {
96:                            setTimer1Prescaler (i);
000BBE  90002E     MOV [W14+4], W0
000BC0  784000     MOV.B W0, W0
000BC2  07FFAB     RCALL setTimer1Prescaler
97:                            
98:                            timerFreq = getTimer1Freq();
000BC4  070060     RCALL getTimer1Freq
000BC6  980730     MOV W0, [W14+6]
000BC8  980741     MOV W1, [W14+8]
99:                            
100:                           actStep = SECOND_US / timerFreq;
000BCA  90013E     MOV [W14+6], W2
000BCC  9001CE     MOV [W14+8], W3
000BCE  242400     MOV #0x4240, W0
000BD0  2000F1     MOV #0xF, W1
000BD2  070687     RCALL ___divsi3
000BD4  980750     MOV W0, [W14+10]
000BD6  980761     MOV W1, [W14+12]
101:                   
102:                           if (actStep != 0)
000BD8  90005E     MOV [W14+10], W0
000BDA  9000EE     MOV [W14+12], W1
000BDC  500FE0     SUB W0, #0x0, [W15]
000BDE  588FE0     SUBB W1, #0x0, [W15]
000BE0  320006     BRA Z, 0xBEE
103:                               requestedSteps = uS / actStep;
000BE2  90015E     MOV [W14+10], W2
000BE4  9001EE     MOV [W14+12], W3
000BE6  90007E     MOV [W14+14], W0
000BE8  90088E     MOV [W14+16], W1
000BEA  07067B     RCALL ___divsi3
000BEC  BE8F00     MOV.D W0, [W14]
104:               
105:                           if (requestedSteps <= TIMER_SIZE && actStep != 0)
000BEE  200000     MOV #0x0, W0
000BF0  200011     MOV #0x1, W1
000BF2  BE011E     MOV.D [W14], W2
000BF4  510F80     SUB W2, W0, [W15]
000BF6  598F81     SUBB W3, W1, [W15]
000BF8  3C0018     BRA GT, 0xC2A
000BFA  90005E     MOV [W14+10], W0
000BFC  9000EE     MOV [W14+12], W1
000BFE  500FE0     SUB W0, #0x0, [W15]
000C00  588FE0     SUBB W1, #0x0, [W15]
000C02  320013     BRA Z, 0xC2A
106:                           {
107:                               TMR1 = 0;
000C04  EB0000     CLR W0
000C06  880800     MOV W0, TMR1
108:                               PR1 = requestedSteps - 1;
000C08  78001E     MOV [W14], W0
000C0A  E90000     DEC W0, W0
000C0C  880810     MOV W0, PR1
109:               
110:                               return actStep * requestedSteps;
000C0E  9000EE     MOV [W14+12], W1
000C10  78001E     MOV [W14], W0
000C12  B98800     MUL.SS W1, W0, W0
000C14  780100     MOV W0, W2
000C16  90009E     MOV [W14+2], W1
000C18  90005E     MOV [W14+10], W0
000C1A  B98800     MUL.SS W1, W0, W0
000C1C  780000     MOV W0, W0
000C1E  410100     ADD W2, W0, W2
000C20  90005E     MOV [W14+10], W0
000C22  B8001E     MUL.UU W0, [W14], W0
000C24  410101     ADD W2, W1, W2
000C26  780082     MOV W2, W1
000C28  37001A     BRA 0xC5E
111:                           } 
112:                       }
113:                       
114:                   }
115:                   
116:                   setTimer1Prescaler (3);
000C36  B3C030     MOV #0x3, W0
000C38  07FF70     RCALL setTimer1Prescaler
117:                   
118:                   timerFreq = getTimer1Freq();
000C3A  070025     RCALL getTimer1Freq
000C3C  980730     MOV W0, [W14+6]
000C3E  980741     MOV W1, [W14+8]
119:                           
120:                   actStep = SECOND_US / timerFreq;
000C40  90013E     MOV [W14+6], W2
000C42  9001CE     MOV [W14+8], W3
000C44  242400     MOV #0x4240, W0
000C46  2000F1     MOV #0xF, W1
000C48  07064C     RCALL ___divsi3
000C4A  980750     MOV W0, [W14+10]
000C4C  980761     MOV W1, [W14+12]
121:                   
122:                   PR1 = TIMER_SIZE - 1;
000C4E  EB8000     SETM W0
000C50  880810     MOV W0, PR1
123:                   TMR1 = 0;
000C52  EB0000     CLR W0
000C54  880800     MOV W0, TMR1
124:                   
125:                   return TIMER_SIZE * actStep;
000C56  90005E     MOV [W14+10], W0
000C58  9000EE     MOV [W14+12], W1
000C5A  DD00C0     SL W0, #0, W1
000C5C  200000     MOV #0x0, W0
126:               }
000C5E  FA8000     ULNK
000C60  060000     RETURN
127:               
128:               void timer1Delay (long int uS)
129:               {
000C62  FA0004     LNK #0x4
000C64  BE8F00     MOV.D W0, [W14]
130:                   setTimer1Interval (uS);
000C66  BE001E     MOV.D [W14], W0
000C68  07FF70     RCALL setTimer1Interval
131:                   
132:                   IEC0bits.T1IE = 0;
000C6A  A96094     BCLR IEC0, #3
133:               
134:                   timer1Reset();
000C6C  070028     RCALL timer1Reset
135:                   timer1Start();
000C6E  07001F     RCALL timer1Start
136:                   
137:                   while (IFS0bits.T1IF != 1);
000C70  000000     NOP
000C72  800420     MOV IFS0, W0
000C74  600068     AND W0, #0x8, W0
000C76  500FE0     SUB W0, #0x0, [W15]
000C78  32FFFC     BRA Z, 0xC72
138:                   
139:                   IFS0bits.T1IF = 0;
000C7A  A96084     BCLR IFS0, #3
140:               
141:                   timer1Stop();
000C7C  07001C     RCALL timer1Stop
142:                   timer1Reset();
000C7E  07001F     RCALL timer1Reset
143:                   
144:                   IEC0bits.T1IE = 1;
000C80  A86094     BSET IEC0, #3
145:               }
000C82  FA8000     ULNK
000C84  060000     RETURN
146:               
147:               inline long int getTimer1Freq ()
148:               {
000C86  FA0004     LNK #0x4
149:               long int ris;
150:                   
151:                   ris = getClockFreq() / (2 * prescaler [T1CONbits.TCKPS]);
000C88  0756B5     RCALL getClockFreq
000C8A  BE0200     MOV.D W0, W4
000C8C  800820     MOV T1CON, W0
000C8E  DE0044     LSR W0, #4, W0
000C90  604063     AND.B W0, #0x3, W0
000C92  FB8000     ZE W0, W0
000C94  2D4661     MOV #0xD466, W1
000C96  400000     ADD W0, W0, W0
000C98  408000     ADD W1, W0, W0
000C9A  780010     MOV [W0], W0
000C9C  400000     ADD W0, W0, W0
000C9E  DE80CF     ASR W0, #15, W1
000CA0  BE0100     MOV.D W0, W2
000CA2  BE0004     MOV.D W4, W0
000CA4  07061E     RCALL ___divsi3
000CA6  BE8F00     MOV.D W0, [W14]
152:                   
153:                   return ris;
000CA8  BE001E     MOV.D [W14], W0
154:               }
000CAA  FA8000     ULNK
000CAC  060000     RETURN
155:               
156:               inline void timer1Start ()
157:               {
000CAE  FA0000     LNK #0x0
158:                   T1CONbits.TON = 1;
000CB0  A8E105     BSET 0x105, #7
159:               }
000CB2  FA8000     ULNK
000CB4  060000     RETURN
160:               
161:               inline void timer1Stop ()
162:               {
000CB6  FA0000     LNK #0x0
163:                   T1CONbits.TON = 0;
000CB8  A9E105     BCLR 0x105, #7
164:               }
000CBA  FA8000     ULNK
000CBC  060000     RETURN
165:               
166:               inline void timer1Reset ()
167:               {
000CBE  FA0000     LNK #0x0
168:                   TMR1 = 0;
000CC0  EB0000     CLR W0
000CC2  880800     MOV W0, TMR1
169:               }
000CC4  FA8000     ULNK
000CC6  060000     RETURN
170:               
171:               inline unsigned long int getTimer1Count ()
172:               {
000CC8  FA0000     LNK #0x0
173:                   return TMR1;
000CCA  800800     MOV TMR1, W0
000CCC  200001     MOV #0x0, W1
174:               }
000CCE  FA8000     ULNK
000CD0  060000     RETURN
175:               
176:               void timer1WaitUntilEnd ()
177:               {
000CD2  FA0000     LNK #0x0
178:                   IEC0bits.T1IE = 0;
000CD4  A96094     BCLR IEC0, #3
179:               
180:                   while (IFS0bits.T1IF != 1);
000CD6  000000     NOP
000CD8  800420     MOV IFS0, W0
000CDA  600068     AND W0, #0x8, W0
000CDC  500FE0     SUB W0, #0x0, [W15]
000CDE  32FFFC     BRA Z, 0xCD8
181:               
182:                   IFS0bits.T1IF = 0;
000CE0  A96084     BCLR IFS0, #3
183:               
184:                   IEC0bits.T1IE = 1;
000CE2  A86094     BSET IEC0, #3
185:               }
000CE4  FA8000     ULNK
000CE6  060000     RETURN
186:               
187:               void setTimer1Callback (void (*clbk)())
188:               {
000CE8  FA0002     LNK #0x2
000CEA  780F00     MOV W0, [W14]
189:                   tmr1Clbk = clbk;
000CEC  78001E     MOV [W14], W0
000CEE  888C90     MOV W0, tmr1Clbk
190:               }
000CF0  FA8000     ULNK
000CF2  060000     RETURN
191:               
192:               long int timer1ElaspedTime ()
193:               {
000CF4  FA0004     LNK #0x4
194:               long int actStep = SECOND_US / getTimer1Freq();
000CF6  07FFC7     RCALL getTimer1Freq
000CF8  BE0100     MOV.D W0, W2
000CFA  242400     MOV #0x4240, W0
000CFC  2000F1     MOV #0xF, W1
000CFE  0705F1     RCALL ___divsi3
000D00  BE8F00     MOV.D W0, [W14]
195:               
196:                   return actStep * TMR1;
000D02  800800     MOV TMR1, W0
000D04  200001     MOV #0x0, W1
000D06  78011E     MOV [W14], W2
000D08  B99101     MUL.SS W2, W1, W2
000D0A  780102     MOV W2, W2
000D0C  90019E     MOV [W14+2], W3
000D0E  B99A00     MUL.SS W3, W0, W4
000D10  780184     MOV W4, W3
000D12  410103     ADD W2, W3, W2
000D14  78019E     MOV [W14], W3
000D16  B81800     MUL.UU W3, W0, W0
000D18  410101     ADD W2, W1, W2
000D1A  780082     MOV W2, W1
197:               }
000D1C  FA8000     ULNK
000D1E  060000     RETURN
198:               
199:               int getTimer1Prescaler ()
200:               {
000D20  FA0000     LNK #0x0
201:                   return prescaler[T1CONbits.TCKPS];
000D22  800820     MOV T1CON, W0
000D24  DE0044     LSR W0, #4, W0
000D26  604063     AND.B W0, #0x3, W0
000D28  FB8000     ZE W0, W0
000D2A  2D4661     MOV #0xD466, W1
000D2C  400000     ADD W0, W0, W0
000D2E  408000     ADD W1, W0, W0
000D30  780010     MOV [W0], W0
202:               }
000D32  FA8000     ULNK
000D34  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/timeMeasurement.c  ----------------------------
1:                 #include "timer4.h"
2:                 
3:                 #include "timeMeasurement.h"
4:                 
5:                 
6:                 #define MEASUREMENT_MAX_NUM 20
7:                 
8:                 #define STOP_COUNTING TIMER4_INSTANT_STOP
9:                 #define RESTART_COUNTING TIMER4_INSTANT_RESET; TIMER4_INSTANT_START
10:                #define INIT_COUNTER setTimer4Interval(1000); setTimer4Callback(tmrClbk); TIMER4_INSTANT_START
11:                #define GET_COUNTER_TIME timer4ElaspedTime()
12:                #define COUNTER_MAX_SIZE getTimer4MaxTime ()
13:                
14:                typedef enum {FREE, BUSY} measurementState_t;
15:                
16:                typedef timeUS_t timeMeasurement_t;
17:                
18:                timeUS_t measurements [MEASUREMENT_MAX_NUM];
19:                measurementState_t measurementsState [MEASUREMENT_MAX_NUM];
20:                
21:                /*
22:                 * Aggiorna le misurazioni
23:                 */
24:                void updateMeasurements ();
25:                
26:                /*
27:                 * Ritorna l'indice di una misurazione libera
28:                 *
29:                 * output:
30:                 *  - indice della prima misurazione libera o MEASUREMENT_NO_SPACE_ERR
31:                 */
32:                timeMeasurementID_t getFreeMeasurement ();
33:                
34:                /*
35:                 * Inizializza una misurazione
36:                 *
37:                 * input:
38:                 *  - id: id della misurazione da inizializzare
39:                 */
40:                void initMeasurement (timeMeasurementID_t id);
41:                
42:                /*
43:                 * Richiamata in caso di overconteggio
44:                 */
45:                void tmrClbk ();
46:                
47:                
48:                /*
49:                 * Inizializza il modulo che effettua le misurazioni temporali
50:                 */
51:                void initTimeMeasurement ()
52:                {
00BC3A  FA0002     LNK #0x2
53:                timeMeasurementID_t i;
54:                
55:                    for (i = 0; i < MEASUREMENT_MAX_NUM; i++)
00BC3C  EB0000     CLR W0
00BC3E  780F00     MOV W0, [W14]
00BC40  370007     BRA 0xBC50
00BC4E  E80F1E     INC [W14], [W14]
00BC50  78001E     MOV [W14], W0
00BC52  500FF3     SUB W0, #0x13, [W15]
00BC54  34FFF6     BRA LE, 0xBC42
56:                    {
57:                        measurementsState[i] = FREE;
00BC42  78001E     MOV [W14], W0
00BC44  400080     ADD W0, W0, W1
00BC46  20FC40     MOV #0xFC4, W0
00BC48  408000     ADD W1, W0, W0
00BC4A  EB0080     CLR W1
00BC4C  780801     MOV W1, [W0]
58:                    }
59:                
60:                    INIT_COUNTER;
00BC56  203E80     MOV #0x3E8, W0
00BC58  200001     MOV #0x0, W1
00BC5A  07AC1C     RCALL setTimer4Interval
00BC5C  2BD6C0     MOV #0xBD6C, W0
00BC5E  07AC9E     RCALL setTimer4Callback
00BC60  A8E11F     BSET 0x11F, #7
61:                }
00BC62  FA8000     ULNK
00BC64  060000     RETURN
62:                
63:                /*
64:                 * Inizia una nuova misurazione
65:                 *
66:                 * output:
67:                 *  - id della misurazione (MEASUREMENT_NO_SPACE_ERR se non c'
68:                 *    spazio per la misurazione)
69:                 */
70:                timeMeasurementID_t startTimeMeasurement ()
71:                {
00BC66  FA0002     LNK #0x2
72:                timeMeasurementID_t ris;
73:                
74:                    STOP_COUNTING;
00BC68  A9E11F     BCLR 0x11F, #7
75:                    
76:                    updateMeasurements();
00BC6A  07005E     RCALL updateMeasurements
77:                
78:                    ris = getFreeMeasurement();
00BC6C  07002F     RCALL getFreeMeasurement
00BC6E  780F00     MOV W0, [W14]
79:                    
80:                    initMeasurement (ris);
00BC70  78001E     MOV [W14], W0
00BC72  070040     RCALL initMeasurement
81:                    
82:                    RESTART_COUNTING;
00BC74  EF2114     CLR TMR4
00BC76  A8E11F     BSET 0x11F, #7
83:                    
84:                    return ris;
00BC78  78001E     MOV [W14], W0
85:                }
00BC7A  FA8000     ULNK
00BC7C  060000     RETURN
86:                
87:                /*
88:                 * Ritorna il tempo trascorso dall'attivazione della misurazione
89:                 * 
90:                 * input:
91:                 *  - id: l'id della misurazione
92:                 * 
93:                 * output:
94:                 *  - tempo trascorso dall'attivazione della misurazione (uS)
95:                 */
96:                timeUS_t getElaspedTime (timeMeasurementID_t id)
97:                {
00BC7E  FA0002     LNK #0x2
00BC80  780F00     MOV W0, [W14]
98:                    STOP_COUNTING;
00BC82  A9E11F     BCLR 0x11F, #7
99:                    
100:                   updateMeasurements();
00BC84  070051     RCALL updateMeasurements
101:                   
102:                   return measurements[id];
00BC86  78001E     MOV [W14], W0
00BC88  DD00C2     SL W0, #2, W1
00BC8A  20F740     MOV #0xF74, W0
00BC8C  408000     ADD W1, W0, W0
00BC8E  BE0010     MOV.D [W0], W0
103:                   
104:                   RESTART_COUNTING;
105:               }
00BC90  FA8000     ULNK
00BC92  060000     RETURN
106:               
107:               /*
108:                * Fa ripartire da 0 una misurazione
109:                * 
110:                * input:
111:                *  - id: l'id della misurazione
112:                */
113:               void restartMeasurement (timeMeasurementID_t id)
114:               {
00BC94  FA0002     LNK #0x2
00BC96  780F00     MOV W0, [W14]
115:                   STOP_COUNTING;
00BC98  A9E11F     BCLR 0x11F, #7
116:                   
117:                   updateMeasurements();
00BC9A  070046     RCALL updateMeasurements
118:                   
119:                   RESTART_COUNTING;
00BC9C  EF2114     CLR TMR4
00BC9E  A8E11F     BSET 0x11F, #7
120:                   
121:                   measurements[id] = 0;
00BCA0  78001E     MOV [W14], W0
00BCA2  DD00C2     SL W0, #2, W1
00BCA4  20F740     MOV #0xF74, W0
00BCA6  408100     ADD W1, W0, W2
00BCA8  B80060     MUL.UU W0, #0, W0
00BCAA  BE8900     MOV.D W0, [W2]
122:               }
00BCAC  FA8000     ULNK
00BCAE  060000     RETURN
123:               
124:               /*
125:                * Libera una misurazione
126:                * 
127:                * input:
128:                *  - id: l'id della misurazione
129:                */
130:               void freeMeasurement (timeMeasurementID_t id)
131:               {
00BCB0  FA0002     LNK #0x2
00BCB2  780F00     MOV W0, [W14]
132:                   STOP_COUNTING;
00BCB4  A9E11F     BCLR 0x11F, #7
133:                   
134:                   updateMeasurements();
00BCB6  070038     RCALL updateMeasurements
135:               
136:                   measurementsState[id] = FREE;
00BCB8  78001E     MOV [W14], W0
00BCBA  400080     ADD W0, W0, W1
00BCBC  20FC40     MOV #0xFC4, W0
00BCBE  408000     ADD W1, W0, W0
00BCC0  EB0080     CLR W1
00BCC2  780801     MOV W1, [W0]
137:               
138:                   RESTART_COUNTING;
00BCC4  EF2114     CLR TMR4
00BCC6  A8E11F     BSET 0x11F, #7
139:               }
00BCC8  FA8000     ULNK
00BCCA  060000     RETURN
140:               
141:               
142:               
143:               
144:               
145:               /*
146:                * Ritorna l'indice di una misurazione libera
147:                *
148:                * output:
149:                *  - indice della prima misurazione libera o MEASUREMENT_NO_SPACE_ERR
150:                */
151:               timeMeasurementID_t getFreeMeasurement ()
152:               {
00BCCC  FA0002     LNK #0x2
153:               timeMeasurementID_t i;
154:               
155:                   for (i = 0; i < MEASUREMENT_MAX_NUM; i++)
00BCCE  EB0000     CLR W0
00BCD0  780F00     MOV W0, [W14]
00BCD2  37000A     BRA 0xBCE8
00BCE6  E80F1E     INC [W14], [W14]
00BCE8  78001E     MOV [W14], W0
00BCEA  500FF3     SUB W0, #0x13, [W15]
00BCEC  34FFF3     BRA LE, 0xBCD4
156:                   {
157:                       if (measurementsState[i] == FREE) return i;
00BCD4  78001E     MOV [W14], W0
00BCD6  400080     ADD W0, W0, W1
00BCD8  20FC40     MOV #0xFC4, W0
00BCDA  408000     ADD W1, W0, W0
00BCDC  780010     MOV [W0], W0
00BCDE  500FE0     SUB W0, #0x0, [W15]
00BCE0  3A0002     BRA NZ, 0xBCE6
00BCE2  78001E     MOV [W14], W0
00BCE4  370005     BRA 0xBCF0
158:                   }
159:               
160:                   return MEASUREMENT_NO_SPACE_ERR;
00BCEE  EB8000     SETM W0
161:               }
00BCF0  FA8000     ULNK
00BCF2  060000     RETURN
162:               
163:               /*
164:                * Inizializza una misurazione
165:                *
166:                * input:
167:                *  - id: id della misurazione da inizializzare
168:                */
169:               void initMeasurement (timeMeasurementID_t id)
170:               {
00BCF4  FA0002     LNK #0x2
00BCF6  780F00     MOV W0, [W14]
171:                   if (measurementsState[id] == FREE && id != MEASUREMENT_NO_SPACE_ERR)
00BCF8  78001E     MOV [W14], W0
00BCFA  400080     ADD W0, W0, W1
00BCFC  20FC40     MOV #0xFC4, W0
00BCFE  408000     ADD W1, W0, W0
00BD00  780010     MOV [W0], W0
00BD02  500FE0     SUB W0, #0x0, [W15]
00BD04  3A000F     BRA NZ, 0xBD24
00BD06  78001E     MOV [W14], W0
00BD08  400FE1     ADD W0, #0x1, [W15]
00BD0A  32000C     BRA Z, 0xBD24
172:                   {
173:                       measurementsState[id] = BUSY;
00BD0C  78001E     MOV [W14], W0
00BD0E  400080     ADD W0, W0, W1
00BD10  20FC40     MOV #0xFC4, W0
00BD12  408000     ADD W1, W0, W0
00BD14  200011     MOV #0x1, W1
00BD16  780801     MOV W1, [W0]
174:                       measurements[id] = 0;
00BD18  78001E     MOV [W14], W0
00BD1A  DD00C2     SL W0, #2, W1
00BD1C  20F740     MOV #0xF74, W0
00BD1E  408100     ADD W1, W0, W2
00BD20  B80060     MUL.UU W0, #0, W0
00BD22  BE8900     MOV.D W0, [W2]
175:                   }
176:               }
00BD24  FA8000     ULNK
00BD26  060000     RETURN
177:               
178:               /*
179:                * Aggiorna le misurazioni
180:                */
181:               void updateMeasurements ()
182:               {
00BD28  FA0006     LNK #0x6
183:               timeMeasurementID_t i;
184:               timeMeasurement_t count;
185:               
186:                   count = GET_COUNTER_TIME;
00BD2A  07AC3E     RCALL timer4ElaspedTime
00BD2C  980710     MOV W0, [W14+2]
00BD2E  980721     MOV W1, [W14+4]
187:               
188:                   for (i = 0; i < MEASUREMENT_MAX_NUM; i++)
00BD30  EB0000     CLR W0
00BD32  780F00     MOV W0, [W14]
00BD34  370016     BRA 0xBD62
00BD60  E80F1E     INC [W14], [W14]
00BD62  78001E     MOV [W14], W0
00BD64  500FF3     SUB W0, #0x13, [W15]
00BD66  34FFE7     BRA LE, 0xBD36
189:                   {
190:                       if (measurementsState[i] == BUSY)
00BD36  78001E     MOV [W14], W0
00BD38  400080     ADD W0, W0, W1
00BD3A  20FC40     MOV #0xFC4, W0
00BD3C  408000     ADD W1, W0, W0
00BD3E  780010     MOV [W0], W0
00BD40  500FE1     SUB W0, #0x1, [W15]
00BD42  3A000E     BRA NZ, 0xBD60
191:                           measurements[i] += count;
00BD44  78001E     MOV [W14], W0
00BD46  DD00C2     SL W0, #2, W1
00BD48  20F740     MOV #0xF74, W0
00BD4A  408000     ADD W1, W0, W0
00BD4C  BE0110     MOV.D [W0], W2
00BD4E  90001E     MOV [W14+2], W0
00BD50  9000AE     MOV [W14+4], W1
00BD52  400002     ADD W0, W2, W0
00BD54  488083     ADDC W1, W3, W1
00BD56  78011E     MOV [W14], W2
00BD58  DD11C2     SL W2, #2, W3
00BD5A  20F742     MOV #0xF74, W2
00BD5C  418102     ADD W3, W2, W2
00BD5E  BE8900     MOV.D W0, [W2]
192:                   }
193:               }
00BD68  FA8000     ULNK
00BD6A  060000     RETURN
194:               
195:               /*
196:                * Richiamata in caso di overconteggio
197:                */
198:               void tmrClbk ()
199:               {
00BD6C  FA0002     LNK #0x2
00BD6E  BE9F88     MOV.D W8, [W15++]
200:               timeMeasurementID_t i;
201:               
202:                   STOP_COUNTING;
00BD70  A9E11F     BCLR 0x11F, #7
203:                   for (i = 0; i < MEASUREMENT_MAX_NUM; i++)
00BD72  EB0000     CLR W0
00BD74  780F00     MOV W0, [W14]
00BD76  370015     BRA 0xBDA2
00BDA0  E80F1E     INC [W14], [W14]
00BDA2  78001E     MOV [W14], W0
00BDA4  500FF3     SUB W0, #0x13, [W15]
00BDA6  34FFE8     BRA LE, 0xBD78
204:                   {
205:                       if (measurementsState[i] == BUSY)
00BD78  78001E     MOV [W14], W0
00BD7A  400080     ADD W0, W0, W1
00BD7C  20FC40     MOV #0xFC4, W0
00BD7E  408000     ADD W1, W0, W0
00BD80  780010     MOV [W0], W0
00BD82  500FE1     SUB W0, #0x1, [W15]
00BD84  3A000D     BRA NZ, 0xBDA0
206:                           measurements[i] += COUNTER_MAX_SIZE;
00BD86  78001E     MOV [W14], W0
00BD88  DD00C2     SL W0, #2, W1
00BD8A  20F740     MOV #0xF74, W0
00BD8C  408000     ADD W1, W0, W0
00BD8E  BE0410     MOV.D [W0], W8
00BD90  07ACDE     RCALL getTimer4MaxTime
00BD92  400008     ADD W0, W8, W0
00BD94  488089     ADDC W1, W9, W1
00BD96  78011E     MOV [W14], W2
00BD98  DD11C2     SL W2, #2, W3
00BD9A  20F742     MOV #0xF74, W2
00BD9C  418102     ADD W3, W2, W2
00BD9E  BE8900     MOV.D W0, [W2]
207:                   }
208:                   RESTART_COUNTING;
00BDA8  EF2114     CLR TMR4
00BDAA  A8E11F     BSET 0x11F, #7
209:               }
00BDAC  BE044F     MOV.D [--W15], W8
00BDAE  FA8000     ULNK
00BDB0  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/rosmeterControl.c  ----------------------------
1:                 #include "rosmeterControl.h"
2:                 
3:                 typedef int rosCounter_t;
4:                 
5:                 typedef struct
6:                 {
7:                     rosmeterMeasurementLen_t rosmeterSampleNum; //Numero di campioni contenuti in memoria
8:                 
9:                     waveMeasurement_t *dirWaves; //Vettore contenente il buffer delle onde dirette
10:                    waveMeasurement_t *refWaves; //Vettore contenente il buffer delle onde riflesse
11:                
12:                    rosMeasurement_t *rosMeasurements; //Vettore contenente il buffer di tutte le misurazioni effettuate dal rosmetro
13:                
14:                    rosCounter_t rosCount; //Attuale posizione all'interno della misurazione
15:                }rosmeterState_t;
16:                
17:                rosmeterState_t state;
18:                
19:                /*
20:                 * Inizializza il modulo di controllo del rosmetro
21:                 */
22:                void initRosmeterControl (rosmeterMeasurementLen_t measurementLen)
23:                {
00C3CA  FA0002     LNK #0x2
00C3CC  780F00     MOV W0, [W14]
24:                    state.rosmeterSampleNum = measurementLen;
00C3CE  78001E     MOV [W14], W0
00C3D0  888AA0     MOV W0, state
25:                
26:                    state.dirWaves = (waveMeasurement_t *)malloc(state.rosmeterSampleNum * sizeof(waveMeasurement_t));
00C3D2  808AA0     MOV state, W0
00C3D4  400000     ADD W0, W0, W0
00C3D6  07ADBC     RCALL _malloc
00C3D8  888AB0     MOV W0, 0x1156
27:                    state.refWaves = (waveMeasurement_t *)malloc(state.rosmeterSampleNum * sizeof(waveMeasurement_t));
00C3DA  808AA0     MOV state, W0
00C3DC  400000     ADD W0, W0, W0
00C3DE  07ADB8     RCALL _malloc
00C3E0  888AC0     MOV W0, 0x1158
28:                    state.rosMeasurements = (rosMeasurement_t *)malloc(state.rosmeterSampleNum * sizeof(rosMeasurement_t));
00C3E2  808AA0     MOV state, W0
00C3E4  400000     ADD W0, W0, W0
00C3E6  07ADB4     RCALL _malloc
00C3E8  888AD0     MOV W0, 0x115A
29:                
30:                    resetRosmeterControl();
00C3EA  070002     RCALL resetRosmeterControl
31:                }
00C3EC  FA8000     ULNK
00C3EE  060000     RETURN
32:                
33:                /*
34:                 * Riporta la misurazione all'attimo iniziale
35:                 */
36:                void resetRosmeterControl ()
37:                {
00C3F0  FA0000     LNK #0x0
38:                    state.rosCount = 0;
00C3F2  EB0000     CLR W0
00C3F4  888AE0     MOV W0, 0x115C
39:                }
00C3F6  FA8000     ULNK
00C3F8  060000     RETURN
40:                
41:                /*
42:                 * Imposta l'attuale valore misurato dal rosmetro. Calcola il ros (in %).
43:                 *
44:                 * input:
45:                 *  - dirWave: attuale ampiezza dell'onda diretta
46:                 *  - refWave: attuale ampiezza dell'onda riflessa
47:                 */
48:                void rosmeterActualInstantSet (waveMeasurement_t dirWave, waveMeasurement_t refWave)
49:                {
00C3FA  FA0004     LNK #0x4
00C3FC  780F00     MOV W0, [W14]
00C3FE  980711     MOV W1, [W14+2]
50:                    if (state.rosCount < state.rosmeterSampleNum)
00C400  808AE1     MOV 0x115C, W1
00C402  808AA0     MOV state, W0
00C404  508F80     SUB W1, W0, [W15]
00C406  3D0020     BRA GE, 0xC448
51:                    {
52:                       state.dirWaves[state.rosCount] = dirWave;
00C408  808AB1     MOV 0x1156, W1
00C40A  808AE0     MOV 0x115C, W0
00C40C  400000     ADD W0, W0, W0
00C40E  408000     ADD W1, W0, W0
00C410  78081E     MOV [W14], [W0]
53:                       state.refWaves[state.rosCount] = refWave;
00C412  808AC1     MOV 0x1158, W1
00C414  808AE0     MOV 0x115C, W0
00C416  400000     ADD W0, W0, W0
00C418  408000     ADD W1, W0, W0
00C41A  90009E     MOV [W14+2], W1
00C41C  780801     MOV W1, [W0]
54:                       state.rosMeasurements[state.rosCount] = dirWave != 0?(refWave*100)/dirWave:100;
00C41E  808AD1     MOV 0x115A, W1
00C420  808AE0     MOV 0x115C, W0
00C422  400000     ADD W0, W0, W0
00C424  408100     ADD W1, W0, W2
00C426  78001E     MOV [W14], W0
00C428  500FE0     SUB W0, #0x0, [W15]
00C42A  320009     BRA Z, 0xC43E
00C42C  90009E     MOV [W14+2], W1
00C42E  200640     MOV #0x64, W0
00C430  B98800     MUL.SS W1, W0, W0
00C432  780080     MOV W0, W1
00C434  78001E     MOV [W14], W0
00C436  780180     MOV W0, W3
00C438  090011     REPEAT #0x11
00C43A  D88083     DIV.UW W1, W3
00C43C  370001     BRA 0xC440
00C43E  200640     MOV #0x64, W0
00C440  780900     MOV W0, [W2]
55:                
56:                       state.rosCount++;
00C442  808AE0     MOV 0x115C, W0
00C444  E80000     INC W0, W0
00C446  888AE0     MOV W0, 0x115C
57:                    }
58:                }
00C448  FA8000     ULNK
00C44A  060000     RETURN
59:                
60:                /*
61:                 * Ritorna l'attuale ros misurato (in %).
62:                 *
63:                 * output:
64:                 *  - ros attualmente misurato
65:                 */
66:                rosMeasurement_t getActRos ()
67:                {
00C44C  FA0000     LNK #0x0
68:                    if (state.rosCount > 0 && state.rosCount <= state.rosmeterSampleNum)
00C44E  808AE0     MOV 0x115C, W0
00C450  500FE0     SUB W0, #0x0, [W15]
00C452  34000B     BRA LE, 0xC46A
00C454  808AE1     MOV 0x115C, W1
00C456  808AA0     MOV state, W0
00C458  508F80     SUB W1, W0, [W15]
00C45A  3C0007     BRA GT, 0xC46A
69:                        return state.rosMeasurements[state.rosCount - 1];
00C45C  808AD1     MOV 0x115A, W1
00C45E  808AE0     MOV 0x115C, W0
00C460  E90000     DEC W0, W0
00C462  400000     ADD W0, W0, W0
00C464  408000     ADD W1, W0, W0
00C466  780010     MOV [W0], W0
00C468  370001     BRA 0xC46C
70:                    else
71:                        return 0;
00C46A  EB0000     CLR W0
72:                }
00C46C  FA8000     ULNK
00C46E  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/ros.c  ----------------------------------------
1:                 #include "xc.h"
2:                 
3:                 #include "stdlib.h"
4:                 #include "string.h"
5:                 
6:                 #include "graphics/GOL.h"
7:                 #include "Graphics/Primitive.h"
8:                 #include "Graphics/StaticText.h"
9:                 #include "MyGraph.h"
10:                
11:                #include "ros.h"
12:                
13:                #include "controls.h"
14:                #include "rampControl.h"
15:                #include "timer3.h"
16:                #include "timer1.h"
17:                #include "errorControl.h"
18:                #include "rosmeterControl.h"
19:                #include "ADC1Control.h"
20:                
21:                #include "globalPinout.h"
22:                
23:                static freqKHZ_t displayFreq = 0;
24:                static rosMeasurement_t ros = 0;
25:                
26:                static MYGRAPH *gr;
27:                static STATICTEXT *measurement;
28:                
29:                static int dataSerie[128];
30:                
31:                static int afterInit;
32:                
33:                /*
34:                 * Inizializza gli oggetti grafici
35:                 */
36:                void rosInitGraphicObjects ();
37:                
38:                /*
39:                 * Inizializza il modulo che si occupa di misurare e visualizzare la quantit
40:                 * dell'errore effettuato sulla rampa di frequenza
41:                 */
42:                void rosMeasurementInit ()
43:                {
00B502  FA0000     LNK #0x0
44:                    rosInitGraphicObjects();
00B504  0700E6     RCALL rosInitGraphicObjects
45:                    setTimer3IntervalNS(1000000L);
00B506  242400     MOV #0x4240, W0
00B508  2000F1     MOV #0xF, W1
00B50A  07ADBB     RCALL setTimer3IntervalNS
46:                    TIMER3_INSTANT_START;
00B50C  A8E113     BSET 0x113, #7
47:                    afterInit = 1;
00B50E  200010     MOV #0x1, W0
00B510  887350     MOV W0, afterInit
48:                }
00B512  FA8000     ULNK
00B514  060000     RETURN
49:                
50:                /*
51:                 * Misura e visualizza sul display la quantit dell'errore effettuato sulla
52:                 * rampa di frequenza
53:                 */
54:                void rosMeasurementMainLoopBody ()
55:                {
00B516  FA019A     LNK #0x19A
56:                keyID key;
57:                double f;
58:                char txt[50];
59:                int i;
60:                freqKHZ_t freq;
61:                error_t e;
62:                waveMeasurement_t dirWav, refWav;
63:                
64:                        fastReturn_begin();
00B518  07FAFC     RCALL fastReturn_begin
65:                
66:                        resetRamp();
00B51A  07FA8D     RCALL resetRamp
67:                        resetRosmeterControl();
00B51C  070769     RCALL resetRosmeterControl
68:                
69:                        if (!afterInit)
00B51E  807350     MOV afterInit, W0
00B520  500FE0     SUB W0, #0x0, [W15]
00B522  3A0031     BRA NZ, 0xB586
70:                        {
71:                            key = getPressedKey();
00B524  07082E     RCALL getPressedKey
00B526  980710     MOV W0, [W14+2]
72:                
73:                            if (key == CONTROLS_T1)
00B528  90001E     MOV [W14+2], W0
00B52A  500FE1     SUB W0, #0x1, [W15]
00B52C  3A0002     BRA NZ, 0xB532
74:                                initialFreqSeek (-1);
00B52E  EB8000     SETM W0
00B530  07FC86     RCALL initialFreqSeek
75:                            if (key == CONTROLS_T2)
00B532  90001E     MOV [W14+2], W0
00B534  500FE2     SUB W0, #0x2, [W15]
00B536  3A0002     BRA NZ, 0xB53C
76:                                initialFreqSeek (+1);
00B538  200010     MOV #0x1, W0
00B53A  07FC81     RCALL initialFreqSeek
77:                
78:                            f = displayFreq/1000.0;
00B53C  806B00     MOV displayFreq, W0
00B53E  806B11     MOV 0xD62, W1
00B540  07B21D     RCALL ___floatsisf
00B542  200002     MOV #0x0, W2
00B544  2447A3     MOV #0x447A, W3
00B546  07B18B     RCALL ___divsf3
00B548  980720     MOV W0, [W14+4]
00B54A  980731     MOV W1, [W14+6]
79:                
80:                            sprintf (txt, "F: %5.2fMHZ ROS: %3d%%", f, ros);
00B54C  806B20     MOV ros, W0
00B54E  470170     ADD W14, #0x10, W2
00B550  781F80     MOV W0, [W15++]
00B552  90002E     MOV [W14+4], W0
00B554  9000BE     MOV [W14+6], W1
00B556  BE9F80     MOV.D W0, [W15++]
00B558  2D3980     MOV #0xD398, W0
00B55A  781F80     MOV W0, [W15++]
00B55C  780002     MOV W2, W0
00B55E  07B603     RCALL __sprintf_cdfFnopuxX
00B560  5787E8     SUB W15, #0x8, W15
81:                            measurement->hdr.state |= ST_DRAW;
00B562  806B40     MOV measurement, W0
00B564  806B41     MOV measurement, W1
00B566  900131     MOV [W1+6], W2
00B568  240001     MOV #0x4000, W1
00B56A  710081     IOR W2, W1, W1
00B56C  980031     MOV W1, [W0+6]
82:                            StSetText (measurement, txt);
00B56E  806B40     MOV measurement, W0
00B570  4700F0     ADD W14, #0x10, W1
00B572  07FCD2     RCALL StSetText
83:                            gr->hdr.DrawObj((void*)gr);
00B574  806B30     MOV gr, W0
00B576  900890     MOV [W0+18], W1
00B578  806B30     MOV gr, W0
00B57A  010001     CALL W1
84:                            GOLDraw();
00B57C  07E865     RCALL GOLDraw
85:                            refreshSPIDisplay();
00B57E  07F873     RCALL refreshSPIDisplay
86:                            invalidateMyGraph (gr);
00B580  806B30     MOV gr, W0
00B582  07F520     RCALL invalidateMyGraph
00B584  370018     BRA 0xB5B6
87:                        }
88:                        else
89:                        {
90:                            char errDescr[ERROR_DESCRIPTION_MAX_CHAR];
91:                
92:                            sprintf (errDescr, "PASSANDO A ROSMETRO...");
00B586  200BC0     MOV #0xBC, W0
00B588  40000E     ADD W0, W14, W0
00B58A  200172     MOV #0x17, W2
00B58C  2D3AF1     MOV #0xD3AF, W1
00B58E  07B5B0     RCALL _memcpy
93:                
94:                            e = newError("QUANTITY CHANGE", errDescr, WARNING);
00B590  201200     MOV #0x120, W0
00B592  40000E     ADD W0, W14, W0
00B594  200BC1     MOV #0xBC, W1
00B596  40808E     ADD W1, W14, W1
00B598  200013     MOV #0x1, W3
00B59A  780101     MOV W1, W2
00B59C  2D3C61     MOV #0xD3C6, W1
00B59E  0706C9     RCALL newError
00B5A0  78000E     MOV W14, W0
00B5A2  B00420     ADD #0x42, W0
00B5A4  78008E     MOV W14, W1
00B5A6  B01201     ADD #0x120, W1
00B5A8  09003C     REPEAT #0x3C
00B5AA  781831     MOV [W1++], [W0++]
95:                            addError (&e);
00B5AC  200420     MOV #0x42, W0
00B5AE  40000E     ADD W0, W14, W0
00B5B0  0706D6     RCALL addError
96:                
97:                            afterInit = 0;
00B5B2  EB0000     CLR W0
00B5B4  887350     MOV W0, afterInit
98:                        }
99:                        
100:                       setTimer3IntervalNS(1000000L);
00B5B6  242400     MOV #0x4240, W0
00B5B8  2000F1     MOV #0xF, W1
00B5BA  07AD63     RCALL setTimer3IntervalNS
101:               
102:                       fastReturn_waitForEnd ();
00B5BC  07FAB3     RCALL fastReturn_waitForEnd
103:               
104:                       TIMER3_INSTANT_RESET;
00B5BE  EF210A     CLR TMR3
105:                       TIMER1_INSTANT_RESET;
00B5C0  EF2100     CLR TMR1
106:                       TIMER1_INSTANT_START;
00B5C2  A8E105     BSET 0x105, #7
107:               
108:                       IFS0bits.T3IF = 0;
00B5C4  A90085     BCLR 0x85, #0
109:               
110:                       for (i = 0; i < 128; i++)
00B5C6  EB0000     CLR W0
00B5C8  780F00     MOV W0, [W14]
00B5CA  370079     BRA 0xB6BE
00B6BC  E80F1E     INC [W14], [W14]
00B6BE  2007F0     MOV #0x7F, W0
00B6C0  78009E     MOV [W14], W1
00B6C2  508F80     SUB W1, W0, [W15]
00B6C4  34FF83     BRA LE, 0xB5CC
111:                       {
112:                           while (TMR3 < (PR3>>1));
00B5CC  000000     NOP
00B5CE  800870     MOV PR3, W0
00B5D0  D10080     LSR W0, W1
00B5D2  800850     MOV TMR3, W0
00B5D4  508F80     SUB W1, W0, [W15]
00B5D6  3EFFFB     BRA GTU, 0xB5CE
113:               
114:                           setInputPinADC1 (DIRWAV_AN_PIN_NO);
00B5D8  200040     MOV #0x4, W0
00B5DA  07A7A7     RCALL setInputPinADC1
115:                           beginSamplingADC1();
00B5DC  07A76C     RCALL beginSamplingADC1
116:                           while (!doneADC1());
00B5DE  000000     NOP
00B5E0  07A774     RCALL doneADC1
00B5E2  500FE0     SUB W0, #0x0, [W15]
00B5E4  32FFFD     BRA Z, 0xB5E0
117:                           dirWav = getActBUFADC1();
00B5E6  07A763     RCALL getActBUFADC1
00B5E8  980740     MOV W0, [W14+8]
118:               
119:                           setInputPinADC1 (REFWAV_AN_PIN_NO);
00B5EA  EB0000     CLR W0
00B5EC  07A79E     RCALL setInputPinADC1
120:                           beginSamplingADC1();
00B5EE  07A763     RCALL beginSamplingADC1
121:                           while (!doneADC1());
00B5F0  000000     NOP
00B5F2  07A76B     RCALL doneADC1
00B5F4  500FE0     SUB W0, #0x0, [W15]
00B5F6  32FFFD     BRA Z, 0xB5F2
122:                           refWav = getActBUFADC1();
00B5F8  07A75A     RCALL getActBUFADC1
00B5FA  980750     MOV W0, [W14+10]
123:               
124:                           rosmeterActualInstantSet (dirWav, refWav);
00B5FC  9000DE     MOV [W14+10], W1
00B5FE  90004E     MOV [W14+8], W0
00B600  0706FC     RCALL rosmeterActualInstantSet
125:               
126:                           if (i == getBarPos (gr))
00B602  806B30     MOV gr, W0
00B604  07F338     RCALL getBarPos
00B606  500F9E     SUB W0, [W14], [W15]
00B608  3A0002     BRA NZ, 0xB60E
127:                           {
128:                               ros = getActRos();
00B60A  070720     RCALL getActRos
00B60C  886B20     MOV W0, ros
129:                           }
130:               
131:                           if (IFS0bits.T3IF == 1)
00B60E  800421     MOV IFS0, W1
00B610  201000     MOV #0x100, W0
00B612  608000     AND W1, W0, W0
00B614  500FE0     SUB W0, #0x0, [W15]
00B616  32001F     BRA Z, 0xB656
132:                           {
133:                               char errDescr[ERROR_DESCRIPTION_MAX_CHAR];
134:               
135:                               sprintf (errDescr, "IMPOSSIBILE RISPETTARE\nIL TEMPO DI 1MS\nA I = %d (%ld uS)", i, timer3ElaspedTimeNS()/1000);
00B618  07ADFE     RCALL timer3ElaspedTimeNS
00B61A  203E82     MOV #0x3E8, W2
00B61C  200003     MOV #0x0, W3
00B61E  07B161     RCALL ___divsi3
00B620  200BC2     MOV #0xBC, W2
00B622  41010E     ADD W2, W14, W2
00B624  BE9F80     MOV.D W0, [W15++]
00B626  781F9E     MOV [W14], [W15++]
00B628  2D3D60     MOV #0xD3D6, W0
00B62A  781F80     MOV W0, [W15++]
00B62C  780002     MOV W2, W0
00B62E  07B59B     RCALL __sprintf_cdfFnopuxX
00B630  5787E8     SUB W15, #0x8, W15
136:               
137:                               e = newError("TIME FAULT", errDescr, ERROR);
00B632  201200     MOV #0x120, W0
00B634  40000E     ADD W0, W14, W0
00B636  200BC1     MOV #0xBC, W1
00B638  40808E     ADD W1, W14, W1
00B63A  EB0180     CLR W3
00B63C  780101     MOV W1, W2
00B63E  2D40F1     MOV #0xD40F, W1
00B640  070678     RCALL newError
00B642  78000E     MOV W14, W0
00B644  B00420     ADD #0x42, W0
00B646  78008E     MOV W14, W1
00B648  B01201     ADD #0x120, W1
00B64A  09003C     REPEAT #0x3C
00B64C  781831     MOV [W1++], [W0++]
138:                               addError (&e);
00B64E  200420     MOV #0x42, W0
00B650  40000E     ADD W0, W14, W0
00B652  070685     RCALL addError
139:                               break;
00B654  370038     BRA 0xB6C6
140:                           }
141:               
142:                           while (IFS0bits.T3IF==0);
00B656  000000     NOP
00B658  800421     MOV IFS0, W1
00B65A  201000     MOV #0x100, W0
00B65C  608000     AND W1, W0, W0
00B65E  500FE0     SUB W0, #0x0, [W15]
00B660  32FFFB     BRA Z, 0xB658
143:                           IFS0bits.T3IF = 0;
00B662  A90085     BCLR 0x85, #0
144:               
145:                           TIMER1_INSTANT_STOP;
00B664  A9E105     BCLR 0x105, #7
146:               
147:                           freq = (getTimer1Count())<<5;
00B666  07AB30     RCALL getTimer1Count
00B668  BE0100     MOV.D W0, W2
00B66A  DD1845     SL W3, #5, W0
00B66C  DE10CB     LSR W2, #11, W1
00B66E  700081     IOR W0, W1, W1
00B670  DD1045     SL W2, #5, W0
00B672  980760     MOV W0, [W14+12]
00B674  980771     MOV W1, [W14+14]
148:               
149:                           TIMER3_INSTANT_RESET;
00B676  EF210A     CLR TMR3
150:                           TIMER1_INSTANT_RESET;
00B678  EF2100     CLR TMR1
151:                           TIMER1_INSTANT_START;
00B67A  A8E105     BSET 0x105, #7
152:               
153:                           actualInstantSet (freq);
00B67C  90006E     MOV [W14+12], W0
00B67E  9000FE     MOV [W14+14], W1
00B680  07FA05     RCALL actualInstantSet
154:               
155:                           dataSerie[i] = (63L*getActRos())/100;
00B682  0706E4     RCALL getActRos
00B684  DE80CF     ASR W0, #15, W1
00B686  2003F2     MOV #0x3F, W2
00B688  B98902     MUL.SS W1, W2, W2
00B68A  780102     MOV W2, W2
00B68C  B90260     MUL.SU W0, #0, W4
00B68E  780184     MOV W4, W3
00B690  410103     ADD W2, W3, W2
00B692  2003F3     MOV #0x3F, W3
00B694  B80003     MUL.UU W0, W3, W0
00B696  410101     ADD W2, W1, W2
00B698  780082     MOV W2, W1
00B69A  200642     MOV #0x64, W2
00B69C  200003     MOV #0x0, W3
00B69E  07B121     RCALL ___divsi3
00B6A0  780080     MOV W0, W1
00B6A2  78001E     MOV [W14], W0
00B6A4  400100     ADD W0, W0, W2
00B6A6  20D6A0     MOV #0xD6A, W0
00B6A8  410000     ADD W2, W0, W0
00B6AA  780801     MOV W1, [W0]
156:               
157:                           if (i == getBarPos (gr))
00B6AC  806B30     MOV gr, W0
00B6AE  07F2E3     RCALL getBarPos
00B6B0  500F9E     SUB W0, [W14], [W15]
00B6B2  3A0004     BRA NZ, 0xB6BC
158:                           {
159:                               displayFreq = freq;
00B6B4  90006E     MOV [W14+12], W0
00B6B6  9000FE     MOV [W14+14], W1
00B6B8  886B00     MOV W0, displayFreq
00B6BA  886B11     MOV W1, 0xD62
160:                           }
161:                       }
162:               }
00B6C6  FA8000     ULNK
00B6C8  060000     RETURN
163:               
164:               /*
165:                * Stoppa il modulo che si occupa di misurare e visualizzare la quantit
166:                * dell'errore effettuato sulla rampa di frequenza
167:                */
168:               void rosMeasurementStop ()
169:               {
00B6CA  FA0000     LNK #0x0
170:                   GOLFree();
00B6CC  07E72B     RCALL GOLFree
171:               }
00B6CE  FA8000     ULNK
00B6D0  060000     RETURN
172:               
173:               /*
174:                * Inizializza gli oggetti grafici
175:                */
176:               void rosInitGraphicObjects ()
177:               {
00B6D2  FA0006     LNK #0x6
178:               GOL_SCHEME *pScheme;
179:               WORD state;
180:               int i;
181:               
182:                   GOLNewList();
00B6D4  EB0000     CLR W0
00B6D6  888B30     MOV W0, 0x1166
00B6D8  EB0000     CLR W0
00B6DA  888B50     MOV W0, 0x116A
183:               
184:                   pScheme = GOLCreateScheme();
00B6DC  07E70F     RCALL GOLCreateScheme
00B6DE  980710     MOV W0, [W14+2]
185:               
186:                   pScheme ->Color0 = 0x00;
00B6E0  90009E     MOV [W14+2], W1
00B6E2  EB4000     CLR.B W0
00B6E4  9840D0     MOV.B W0, [W1+5]
187:                   pScheme ->Color1 = 0x01;
00B6E6  90009E     MOV [W14+2], W1
00B6E8  B3C010     MOV #0x1, W0
00B6EA  9840E0     MOV.B W0, [W1+6]
188:               
189:                   pScheme ->CommonBkColor = 0x01;
00B6EC  90009E     MOV [W14+2], W1
00B6EE  B3C010     MOV #0x1, W0
00B6F0  984880     MOV.B W0, [W1+8]
190:               
191:                   pScheme ->EmbossDkColor = 0x00;
00B6F2  90009E     MOV [W14+2], W1
00B6F4  EB4000     CLR.B W0
00B6F6  784880     MOV.B W0, [W1]
192:                   pScheme ->EmbossLtColor = 0x01;
00B6F8  90009E     MOV [W14+2], W1
00B6FA  B3C010     MOV #0x1, W0
00B6FC  984090     MOV.B W0, [W1+1]
193:               
194:                   pScheme ->TextColor0 = 0x00;
00B6FE  90009E     MOV [W14+2], W1
00B700  EB4000     CLR.B W0
00B702  9840A0     MOV.B W0, [W1+2]
195:                   pScheme ->TextColor1 = 0x00;
00B704  90009E     MOV [W14+2], W1
00B706  EB4000     CLR.B W0
00B708  9840B0     MOV.B W0, [W1+3]
196:               
197:                   for (i = 0; i < 128; i++)
00B70A  EB0000     CLR W0
00B70C  780F00     MOV W0, [W14]
00B70E  37000D     BRA 0xB72A
00B728  E80F1E     INC [W14], [W14]
00B72A  2007F0     MOV #0x7F, W0
00B72C  78009E     MOV [W14], W1
00B72E  508F80     SUB W1, W0, [W15]
00B730  34FFEF     BRA LE, 0xB710
198:                   {
199:                       dataSerie[i] = rand()%64;
00B710  07B4FE     RCALL _rand
00B712  200401     MOV #0x40, W1
00B714  780101     MOV W1, W2
00B716  090011     REPEAT #0x11
00B718  D80002     DIV.SW W0, W2
00B71A  FD0080     EXCH W0, W1
00B71C  780080     MOV W0, W1
00B71E  78001E     MOV [W14], W0
00B720  400100     ADD W0, W0, W2
00B722  20D6A0     MOV #0xD6A, W0
00B724  410000     ADD W2, W0, W0
00B726  780801     MOV W1, [W0]
200:                   }
201:               
202:               
203:                   state = MYGR_DRAW | MYGR_OPTIMIZED;
00B732  2FC010     MOV #0xFC01, W0
00B734  980720     MOV W0, [W14+4]
204:                   gr = MygrCreate (3, 0, 0, 127, 63, state, dataSerie, sizeof(dataSerie)/sizeof(int), 0, 128, 0, 64, 0, 0, 128, 8,  pScheme);
00B736  90001E     MOV [W14+2], W0
00B738  781F80     MOV W0, [W15++]
00B73A  200080     MOV #0x8, W0
00B73C  781F80     MOV W0, [W15++]
00B73E  200800     MOV #0x80, W0
00B740  781F80     MOV W0, [W15++]
00B742  EB0000     CLR W0
00B744  781F80     MOV W0, [W15++]
00B746  EB0000     CLR W0
00B748  781F80     MOV W0, [W15++]
00B74A  200400     MOV #0x40, W0
00B74C  781F80     MOV W0, [W15++]
00B74E  EB0000     CLR W0
00B750  781F80     MOV W0, [W15++]
00B752  200800     MOV #0x80, W0
00B754  781F80     MOV W0, [W15++]
00B756  EB0000     CLR W0
00B758  781F80     MOV W0, [W15++]
00B75A  200807     MOV #0x80, W7
00B75C  20D6A6     MOV #0xD6A, W6
00B75E  9002AE     MOV [W14+4], W5
00B760  2003F4     MOV #0x3F, W4
00B762  2007F3     MOV #0x7F, W3
00B764  EB0100     CLR W2
00B766  EB0080     CLR W1
00B768  200030     MOV #0x3, W0
00B76A  07F14B     RCALL MygrCreate
00B76C  5787F2     SUB W15, #0x12, W15
00B76E  886B30     MOV W0, gr
205:               
206:                   state = ST_DRAW;
00B770  240000     MOV #0x4000, W0
00B772  980720     MOV W0, [W14+4]
207:                   measurement = StCreate (2, 0, 0, 128, 8, state, "MEASURING: ROS", pScheme);
00B774  90039E     MOV [W14+2], W7
00B776  2D41A6     MOV #0xD41A, W6
00B778  9002AE     MOV [W14+4], W5
00B77A  200084     MOV #0x8, W4
00B77C  200803     MOV #0x80, W3
00B77E  EB0100     CLR W2
00B780  EB0080     CLR W1
00B782  200020     MOV #0x2, W0
00B784  07FB73     RCALL StCreate
00B786  886B40     MOV W0, measurement
208:               
209:                   setBarPos (gr, 64);
00B788  806B30     MOV gr, W0
00B78A  200401     MOV #0x40, W1
00B78C  07F264     RCALL setBarPos
210:               }
00B78E  FA8000     ULNK
00B790  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/rampControl.c  --------------------------------
1:                 #include <stdlib.h>
2:                 #include <math.h>
3:                 
4:                 #include "globalPinout.h"
5:                 
6:                 #include "ADC1Control.h"
7:                 #include "rampControl.h"
8:                 
9:                 #include "timeMeasurement.h"
10:                
11:                #define DEFAULT_ERR_MUL_FACTOR 255
12:                #define DEFAULT_SPAN 2000
13:                
14:                #define MAX_V0 600
15:                #define MIN_V0 20
16:                #define DEFAULT_V0 100
17:                #define DEFAULT_F0_ERR_MUL 0.0002
18:                
19:                #define MAX_IMPULSE 255
20:                #define MIN_IMPULSE 0
21:                
22:                #define IMPULSE_ERROR_DIVISOR 1000
23:                
24:                typedef int rampCounter_t;
25:                typedef double f0ErrMul_t;
26:                
27:                typedef int errTimes_t;
28:                typedef unsigned int impulseLen_t;
29:                typedef long int grade_t;
30:                
31:                typedef enum {UP_I, DOWN_I} impulsePolarity_t;
32:                
33:                typedef struct
34:                {
35:                
36:                    span_t span; //Determina la differenza di frequenza richiesta tra un'apertura e l'altra
37:                
38:                    rampCounter_t cnt; //Determina il numero di istanti trascorsi dall'inizio della rampa
39:                
40:                    f0ErrMul_t f0ErrMul; // Fattore utilizzato per correggere v0
41:                    freqKHZ_t f0; //Frequenza iniziale
42:                    voltage10bits_t v0; //Voltaggio iniziale
43:                    bool_t afterInit; //Flag che verifica se ci si trova dopo un inizializzazione
44:                
45:                    rampLen_t rampSampleNum; //Numero massimo di campioni che la rampa pu contenere
46:                    freqKHZ_t *freqs; //Collezione di tutte le frequenze lette dall'inizio della rampa
47:                    freqKHZ_t *teorFreqs; //Collezione di tutte le frequenze lette dall'inizio della rampa
48:                
49:                    errMulFactor_t errMulFactor; //Fattore per il quale viene moltiplicato l'errore
50:                
51:                    voltageV_t maxReadenVoltage; //Massima tensione letta sul pin analogico di controllo rampa
52:                    voltageV_t maxRampVoltage; //Massima tensione raggiungibile dalla rampa
53:                
54:                    errTimes_t errors;
55:                
56:                    bool_t limited;
57:                    impulsePolarity_t impulsePolarity;
58:                    
59:                }rampState_t;
60:                
61:                static rampState_t state;
62:                
63:                //Metodi privati - prototipi
64:                
65:                    /*
66:                     * Ritorna l'attuale voltaggio della rampa
67:                     *
68:                     * output:
69:                     *  - attuale voltaggio della rampa
70:                     */
71:                    inline voltage10bits_t getRampVoltage10Bits();
72:                
73:                    /*
74:                     * Ritorna l'attuale voltaggio della rampa
75:                     *
76:                     * output:
77:                     *  - attuale voltaggio della rampa
78:                     */
79:                    inline voltageV_t getRampVoltage();
80:                
81:                    /*
82:                     * Imposta lo stato del pin rampH
83:                     *
84:                     * input:
85:                     *  - st: lo stato a cui impostare il pin (0: disattivato, !0: attivato)
86:                     */
87:                    inline void setRampH (int st);
88:                
89:                    /*
90:                     * Imposta lo stato del pin rampL
91:                     *
92:                     * input:
93:                     *  - st: lo stato a cui impostare il pin (0: disattivato, !0: attivato)
94:                     */
95:                    inline void setRampL (int st);
96:                
97:                    /*
98:                     * Imposta lo stato del pin fastReturn
99:                     *
100:                    * input:
101:                    *  - st: lo stato a cui impostare il pin (0: disattivato, !0: attivato)
102:                    */
103:                   inline void setFastReturn (int st);
104:               
105:                   /*
106:                    * Regola la rampa. Prende tutti gli input necessari dallo stato.
107:                    */
108:                   inline void rampRegolation ();
109:               
110:               //Inizializzazione
111:               
112:                   /*
113:                    * Inizializza la rampa
114:                    */
115:                   inline void initRamp (rampLen_t rampSampleNum,
116:                                         voltageV_t maxReadenV,
117:                                         voltageV_t maxRampV)
118:                   {
00A9E4  FA000A     LNK #0xA
00A9E6  780F00     MOV W0, [W14]
00A9E8  980712     MOV W2, [W14+2]
00A9EA  980723     MOV W3, [W14+4]
00A9EC  980734     MOV W4, [W14+6]
00A9EE  980745     MOV W5, [W14+8]
119:                       state.rampSampleNum = rampSampleNum;
00A9F0  78001E     MOV [W14], W0
00A9F2  888190     MOV W0, 0x1032
120:                       state.freqs = (freqKHZ_t *)malloc(rampSampleNum * sizeof(freqKHZ_t));
00A9F4  78001E     MOV [W14], W0
00A9F6  DD0042     SL W0, #2, W0
00A9F8  07BAAB     RCALL _malloc
00A9FA  8881A0     MOV W0, 0x1034
121:                       state.teorFreqs = (freqKHZ_t *)malloc(rampSampleNum * sizeof(freqKHZ_t));
00A9FC  78001E     MOV [W14], W0
00A9FE  DD0042     SL W0, #2, W0
00AA00  07BAA7     RCALL _malloc
00AA02  8881B0     MOV W0, 0x1036
122:                       
123:                       state.maxReadenVoltage = maxReadenV;
00AA04  90001E     MOV [W14+2], W0
00AA06  9000AE     MOV [W14+4], W1
00AA08  8881D0     MOV W0, 0x103A
00AA0A  8881E1     MOV W1, 0x103C
124:                       state.maxRampVoltage = maxRampV;
00AA0C  90003E     MOV [W14+6], W0
00AA0E  9000CE     MOV [W14+8], W1
00AA10  8881F0     MOV W0, 0x103E
00AA12  888201     MOV W1, 0x1040
125:               
126:                       state.errMulFactor = DEFAULT_ERR_MUL_FACTOR;
00AA14  200FF0     MOV #0xFF, W0
00AA16  8881C0     MOV W0, 0x1038
127:               
128:                       state.span = DEFAULT_SPAN;
00AA18  207D00     MOV #0x7D0, W0
00AA1A  200001     MOV #0x0, W1
00AA1C  888100     MOV W0, state
00AA1E  888111     MOV W1, 0x1022
129:               
130:                       state.v0 = DEFAULT_V0;
00AA20  200640     MOV #0x64, W0
00AA22  888170     MOV W0, 0x102E
131:                       state.afterInit = TRUE_B;
00AA24  200010     MOV #0x1, W0
00AA26  888180     MOV W0, 0x1030
132:               
133:                       state.f0ErrMul = DEFAULT_F0_ERR_MUL;
00AA28  2B7170     MOV #0xB717, W0
00AA2A  239511     MOV #0x3951, W1
00AA2C  888130     MOV W0, 0x1026
00AA2E  888141     MOV W1, 0x1028
134:               
135:                       resetRamp();
00AA30  070002     RCALL resetRamp
136:                   }
00AA32  FA8000     ULNK
00AA34  060000     RETURN
137:               
138:                   /*
139:                    * Mette la rampa nelle condizioni di ricominciare
140:                    */
141:                   inline void resetRamp ()
142:                   {
00AA36  FA0000     LNK #0x0
143:                       state.cnt = 0;
00AA38  EB0000     CLR W0
00AA3A  888120     MOV W0, 0x1024
144:                       state.errors = 0;
00AA3C  EB0000     CLR W0
00AA3E  888210     MOV W0, 0x1042
145:                       state.limited = FALSE_B;
00AA40  EB0000     CLR W0
00AA42  888220     MOV W0, 0x1044
146:                   }
00AA44  FA8000     ULNK
00AA46  060000     RETURN
147:               
148:               //Propriet
149:               
150:                   //Span
151:               
152:                       /*
153:                       * Imposta lo span al valore desiderato
154:                       *
155:                       * input:
156:                       *  - span: il valore a cui si desidera impostare lo span (in KHz)
157:                       */
158:                       inline void setSpan (span_t span)
159:                       {
00AA48  FA0004     LNK #0x4
00AA4A  BE8F00     MOV.D W0, [W14]
160:                           state.span = span;
00AA4C  BE001E     MOV.D [W14], W0
00AA4E  888100     MOV W0, state
00AA50  888111     MOV W1, 0x1022
161:                       }
00AA52  FA8000     ULNK
00AA54  060000     RETURN
162:               
163:                       /*
164:                       * Ritorna lo span attualmente impostato per la rampa
165:                       *
166:                       * output:
167:                       *  - lo span attualmente impostato
168:                       */
169:                       inline span_t getSpan ()
170:                       {
00AA56  FA0000     LNK #0x0
171:                           return state.span;
00AA58  808100     MOV state, W0
00AA5A  808111     MOV 0x1022, W1
172:                       }
00AA5C  FA8000     ULNK
00AA5E  060000     RETURN
173:               
174:                   //InitialFreq
175:               
176:                       /*
177:                       * Imposta la frequenza iniziale della rampa
178:                       *
179:                       * input:
180:                       *  - initialFreq: frequenza iniziale desiderata (in KHz)
181:                       */
182:                       inline void setInitialFreq (freqKHZ_t initialFreq)
183:                       {
00AA60  FA0004     LNK #0x4
00AA62  BE8F00     MOV.D W0, [W14]
184:                           state.f0 = initialFreq;
00AA64  BE001E     MOV.D [W14], W0
00AA66  888150     MOV W0, 0x102A
00AA68  888161     MOV W1, 0x102C
185:                       }
00AA6A  FA8000     ULNK
00AA6C  060000     RETURN
186:               
187:                       /*
188:                       * Ritorna l'attuale frequenza iniziale
189:                       *
190:                       * output:
191:                       *  - attuale frequenza iniziale (in KHz)
192:                       */
193:                       inline freqKHZ_t getInitialFreq ()
194:                       {
00AA6E  FA0000     LNK #0x0
195:                           return state.f0;
00AA70  808150     MOV 0x102A, W0
00AA72  808161     MOV 0x102C, W1
196:                       }
00AA74  FA8000     ULNK
00AA76  060000     RETURN
197:               
198:                   //ErrMulFactor
199:               
200:                       /*
201:                        * Imposta il fattore per il quale viene moltiplicato l'errore sulla
202:                        * frequenza teorica in modo da proporzionare l'impulso
203:                        *
204:                        * input:
205:                        *  - errMulFactor: il fattore moltiplicativo desiderato
206:                        */
207:                       inline void setErrMulFactor (errMulFactor_t errMulFactor)
208:                       {
00AA78  FA0002     LNK #0x2
00AA7A  780F00     MOV W0, [W14]
209:                           state.errMulFactor = errMulFactor;
00AA7C  78001E     MOV [W14], W0
00AA7E  8881C0     MOV W0, 0x1038
210:                       }
00AA80  FA8000     ULNK
00AA82  060000     RETURN
211:               
212:                       /*
213:                        * Ritorna il fattore per il quale viene moltiplicato l'errore sulla
214:                        * frequenza teorica in modo da proporzionare l'impulso
215:                        *
216:                        * output:
217:                        *  - il fattore moltiplicativo attuale
218:                        */
219:                       inline errMulFactor_t getErrMulFactor ()
220:                       {
00AA84  FA0000     LNK #0x0
221:                           return state.errMulFactor;
00AA86  8081C0     MOV 0x1038, W0
222:                       }
00AA88  FA8000     ULNK
00AA8A  060000     RETURN
223:               
224:               //Utilit
225:               
226:                   /*
227:                    * Imposta l'attimo corrente ed esegue le regolazioni necessarie
228:                    * sulla rampa
229:                    *
230:                    * input:
231:                    *  - freq: la frequenza attualmente registrata
232:                    */
233:                   inline void actualInstantSet (freqKHZ_t freq)
234:                   {
00AA8C  FA0004     LNK #0x4
00AA8E  BE8F00     MOV.D W0, [W14]
235:                       state.freqs[state.cnt] = freq;
00AA90  8081A1     MOV 0x1034, W1
00AA92  808120     MOV 0x1024, W0
00AA94  DD0042     SL W0, #2, W0
00AA96  408000     ADD W1, W0, W0
00AA98  BE011E     MOV.D [W14], W2
00AA9A  BE8802     MOV.D W2, [W0]
236:                       
237:                       if (state.afterInit == TRUE_B)
00AA9C  808180     MOV 0x1030, W0
00AA9E  500FE1     SUB W0, #0x1, [W15]
00AAA0  3A0012     BRA NZ, 0xAAC6
238:                       {
239:                           state.afterInit = FALSE_B;
00AAA2  EB0000     CLR W0
00AAA4  888180     MOV W0, 0x1030
240:                           
241:                           state.f0 = (freq/5000)*5000;
00AAA6  BE001E     MOV.D [W14], W0
00AAA8  213882     MOV #0x1388, W2
00AAAA  200003     MOV #0x0, W3
00AAAC  07B71A     RCALL ___divsi3
00AAAE  213882     MOV #0x1388, W2
00AAB0  B98902     MUL.SS W1, W2, W2
00AAB2  780102     MOV W2, W2
00AAB4  B90260     MUL.SU W0, #0, W4
00AAB6  780184     MOV W4, W3
00AAB8  410103     ADD W2, W3, W2
00AABA  213883     MOV #0x1388, W3
00AABC  B80003     MUL.UU W0, W3, W0
00AABE  410101     ADD W2, W1, W2
00AAC0  780082     MOV W2, W1
00AAC2  888150     MOV W0, 0x102A
00AAC4  888161     MOV W1, 0x102C
242:                       }
243:                       
244:                       if (state.cnt == 0)  state.teorFreqs[state.cnt] = state.f0;
00AAC6  808120     MOV 0x1024, W0
00AAC8  500FE0     SUB W0, #0x0, [W15]
00AACA  3A0008     BRA NZ, 0xAADC
00AACC  8081B1     MOV 0x1036, W1
00AACE  808120     MOV 0x1024, W0
00AAD0  DD0042     SL W0, #2, W0
00AAD2  408100     ADD W1, W0, W2
00AAD4  808150     MOV 0x102A, W0
00AAD6  808161     MOV 0x102C, W1
00AAD8  BE8900     MOV.D W0, [W2]
00AADA  37000F     BRA 0xAAFA
245:                       else state.teorFreqs[state.cnt] = state.teorFreqs[state.cnt - 1] + state.span;
00AADC  8081B1     MOV 0x1036, W1
00AADE  808120     MOV 0x1024, W0
00AAE0  DD0042     SL W0, #2, W0
00AAE2  408200     ADD W1, W0, W4
00AAE4  8081B1     MOV 0x1036, W1
00AAE6  808120     MOV 0x1024, W0
00AAE8  E90000     DEC W0, W0
00AAEA  DD0042     SL W0, #2, W0
00AAEC  408000     ADD W1, W0, W0
00AAEE  BE0110     MOV.D [W0], W2
00AAF0  808100     MOV state, W0
00AAF2  808111     MOV 0x1022, W1
00AAF4  400002     ADD W0, W2, W0
00AAF6  488083     ADDC W1, W3, W1
00AAF8  BE8A00     MOV.D W0, [W4]
246:               
247:                       rampRegolation();
00AAFA  070068     RCALL rampRegolation
248:               
249:                       state.cnt++;
00AAFC  808120     MOV 0x1024, W0
00AAFE  E80000     INC W0, W0
00AB00  888120     MOV W0, 0x1024
250:               
251:                       setRampH(0);        
00AB02  EB0000     CLR W0
00AB04  070045     RCALL setRampH
252:                       setRampL(0);
00AB06  EB0000     CLR W0
00AB08  07004D     RCALL setRampL
253:                       setFastReturn(0);
00AB0A  EB0000     CLR W0
00AB0C  070055     RCALL setFastReturn
254:                   }
00AB0E  FA8000     ULNK
00AB10  060000     RETURN
255:               
256:                   /*
257:                    * Inizia il ritorno rapido della rampa
258:                    */
259:                   inline void fastReturn_begin ()
260:                   {
00AB12  FA0000     LNK #0x0
261:                       setRampH(0);
00AB14  EB0000     CLR W0
00AB16  07003C     RCALL setRampH
262:                       setRampL(0);
00AB18  EB0000     CLR W0
00AB1A  070044     RCALL setRampL
263:                       setFastReturn (1);
00AB1C  200010     MOV #0x1, W0
00AB1E  07004C     RCALL setFastReturn
264:                   }
00AB20  FA8000     ULNK
00AB22  060000     RETURN
265:               
266:                   /*
267:                    * Attende la conclusione del ritorno rapido
268:                    */
269:                   inline void fastReturn_waitForEnd ()
270:                   {
00AB24  FA0000     LNK #0x0
271:                       setRampH(0);
00AB26  EB0000     CLR W0
00AB28  070033     RCALL setRampH
272:                       setRampL(0);
00AB2A  EB0000     CLR W0
00AB2C  07003B     RCALL setRampL
273:               
274:                       while (getRampVoltage10Bits() >= state.v0);
00AB2E  000000     NOP
00AB30  07000C     RCALL getRampVoltage10Bits
00AB32  808171     MOV 0x102E, W1
00AB34  500F81     SUB W0, W1, [W15]
00AB36  31FFFC     BRA C, 0xAB30
275:               
276:                       setFastReturn (0);
00AB38  EB0000     CLR W0
00AB3A  07003E     RCALL setFastReturn
277:               
278:                       while (getRampVoltage10Bits() < state.v0);         
00AB3C  000000     NOP
00AB3E  070005     RCALL getRampVoltage10Bits
00AB40  808171     MOV 0x102E, W1
00AB42  500F81     SUB W0, W1, [W15]
00AB44  39FFFC     BRA NC, 0xAB3E
279:                   }
00AB46  FA8000     ULNK
00AB48  060000     RETURN
280:               
281:               //Metodi privati - implementazione
282:               
283:                   /*
284:                    * Ritorna l'attuale voltaggio della rampa
285:                    *
286:                    * output:
287:                    *  - attuale voltaggio della rampa
288:                    */
289:                   inline voltage10bits_t getRampVoltage10Bits()
290:                   {
00AB4A  FA0000     LNK #0x0
291:                       setInputPinADC1(RMPAN_AN_PIN_NO);
00AB4C  200010     MOV #0x1, W0
00AB4E  07ACED     RCALL setInputPinADC1
292:               
293:                       beginSamplingADC1();
00AB50  07ACB2     RCALL beginSamplingADC1
294:               
295:                       while (!doneADC1());
00AB52  000000     NOP
00AB54  07ACBA     RCALL doneADC1
00AB56  500FE0     SUB W0, #0x0, [W15]
00AB58  32FFFD     BRA Z, 0xAB54
296:               
297:                       return getActBUFADC1();
00AB5A  07ACA9     RCALL getActBUFADC1
298:                   }
00AB5C  FA8000     ULNK
00AB5E  060000     RETURN
299:               
300:                   /*
301:                    * Ritorna l'attuale voltaggio della rampa
302:                    *
303:                    * output:
304:                    *  - attuale voltaggio della rampa
305:                    */
306:                   inline voltageV_t getRampVoltage()
307:                   {
00AB60  FA0000     LNK #0x0
00AB62  BE9F88     MOV.D W8, [W15++]
308:                       setInputPinADC1(RMPAN_AN_PIN_NO);
00AB64  200010     MOV #0x1, W0
00AB66  07ACE1     RCALL setInputPinADC1
309:               
310:                       beginSamplingADC1();
00AB68  07ACA6     RCALL beginSamplingADC1
311:               
312:                       while (!doneADC1());
00AB6A  000000     NOP
00AB6C  07ACAE     RCALL doneADC1
00AB6E  500FE0     SUB W0, #0x0, [W15]
00AB70  32FFFD     BRA Z, 0xAB6C
313:               
314:                       return (state.maxRampVoltage * getActVoltageADC1()) / state.maxReadenVoltage;
00AB72  8081F8     MOV 0x103E, W8
00AB74  808209     MOV 0x1040, W9
00AB76  07AC7E     RCALL getActVoltageADC1
00AB78  BE0100     MOV.D W0, W2
00AB7A  BE0008     MOV.D W8, W0
00AB7C  07B757     RCALL ___mulsf3
00AB7E  BE0200     MOV.D W0, W4
00AB80  8081D0     MOV 0x103A, W0
00AB82  8081E1     MOV 0x103C, W1
00AB84  BE0100     MOV.D W0, W2
00AB86  BE0004     MOV.D W4, W0
00AB88  07B66A     RCALL ___divsf3
315:                   }
00AB8A  BE044F     MOV.D [--W15], W8
00AB8C  FA8000     ULNK
00AB8E  060000     RETURN
316:               
317:                   /*
318:                    * Imposta lo stato del pin rampH
319:                    *
320:                    * input:
321:                    *  - st: lo stato a cui impostare il pin (0: disattivato, !0: attivato)
322:                    */
323:                   inline void setRampH (int st)
324:                   {
00AB90  FA0002     LNK #0x2
00AB92  780F00     MOV W0, [W14]
325:                       if (st == 0)
00AB94  78001E     MOV [W14], W0
00AB96  500FE0     SUB W0, #0x0, [W15]
00AB98  3A0002     BRA NZ, 0xAB9E
326:                           RMPH_LAT = 0;
00AB9A  A922CD     BCLR 0x2CD, #1
00AB9C  370001     BRA 0xABA0
327:                       else
328:                           RMPH_LAT = 1;
00AB9E  A822CD     BSET 0x2CD, #1
329:                   }
00ABA0  FA8000     ULNK
00ABA2  060000     RETURN
330:               
331:                   /*
332:                    * Imposta lo stato del pin rampL
333:                    *
334:                    * input:
335:                    *  - st: lo stato a cui impostare il pin (0: disattivato, !0: attivato)
336:                    */
337:                   inline void setRampL (int st)
338:                   {
00ABA4  FA0002     LNK #0x2
00ABA6  780F00     MOV W0, [W14]
339:                       if (st == 0)
00ABA8  78001E     MOV [W14], W0
00ABAA  500FE0     SUB W0, #0x0, [W15]
00ABAC  3A0002     BRA NZ, 0xABB2
340:                           RMPL_LAT = 1;
00ABAE  A802CD     BSET 0x2CD, #0
00ABB0  370001     BRA 0xABB4
341:                       else
342:                           RMPL_LAT = 0;
00ABB2  A902CD     BCLR 0x2CD, #0
343:                   }
00ABB4  FA8000     ULNK
00ABB6  060000     RETURN
344:               
345:                   /*
346:                    * Imposta lo stato del pin fastReturn
347:                    *
348:                    * input:
349:                    *  - st: lo stato a cui impostare il pin (0: disattivato, !0: attivato)
350:                    */
351:                   inline void setFastReturn (int st)
352:                   {
00ABB8  FA0002     LNK #0x2
00ABBA  780F00     MOV W0, [W14]
353:                      if (st == 0)
00ABBC  78001E     MOV [W14], W0
00ABBE  500FE0     SUB W0, #0x0, [W15]
00ABC0  3A0002     BRA NZ, 0xABC6
354:                           RMPFSTR_LAT = 0;
00ABC2  A982CC     BCLR LATB, #4
00ABC4  370001     BRA 0xABC8
355:                       else
356:                           RMPFSTR_LAT = 1;
00ABC6  A882CC     BSET LATB, #4
357:                   }
00ABC8  FA8000     ULNK
00ABCA  060000     RETURN
358:               
359:                   inline void rampRegolation ()
360:                   {
00ABCC  FA0024     LNK #0x24
00ABCE  781F88     MOV W8, [W15++]
361:                   freqKHZ_t lett;
362:               
363:               
364:                       if (state.cnt == 1)
00ABD0  808120     MOV 0x1024, W0
00ABD2  500FE1     SUB W0, #0x1, [W15]
00ABD4  3A0007     BRA NZ, 0xABE4
365:                           lett = state.freqs[state.cnt];
00ABD6  8081A1     MOV 0x1034, W1
00ABD8  808120     MOV 0x1024, W0
00ABDA  DD0042     SL W0, #2, W0
00ABDC  408000     ADD W1, W0, W0
00ABDE  BE0110     MOV.D [W0], W2
00ABE0  980722     MOV W2, [W14+4]
00ABE2  980733     MOV W3, [W14+6]
366:               
367:                       if (state.cnt == 0)
00ABE4  808120     MOV 0x1024, W0
00ABE6  500FE0     SUB W0, #0x0, [W15]
00ABE8  3A005D     BRA NZ, 0xACA4
368:                       {
369:                           if (state.freqs[state.cnt] != state.f0)
00ABEA  8081A1     MOV 0x1034, W1
00ABEC  808120     MOV 0x1024, W0
00ABEE  DD0042     SL W0, #2, W0
00ABF0  408000     ADD W1, W0, W0
00ABF2  BE0110     MOV.D [W0], W2
00ABF4  808150     MOV 0x102A, W0
00ABF6  808161     MOV 0x102C, W1
00ABF8  510F80     SUB W2, W0, [W15]
00ABFA  598F81     SUBB W3, W1, [W15]
00ABFC  3200F9     BRA Z, 0xADF0
370:                           {
371:                           freqKHZ_t diff;
372:                           voltageV_t dV;
373:                               
374:                               diff =  state.f0 - state.freqs[state.cnt];
00ABFE  808152     MOV 0x102A, W2
00AC00  808163     MOV 0x102C, W3
00AC02  8081A1     MOV 0x1034, W1
00AC04  808120     MOV 0x1024, W0
00AC06  DD0042     SL W0, #2, W0
00AC08  408000     ADD W1, W0, W0
00AC0A  BE0010     MOV.D [W0], W0
00AC0C  510000     SUB W2, W0, W0
00AC0E  598081     SUBB W3, W1, W1
00AC10  980740     MOV W0, [W14+8]
00AC12  980751     MOV W1, [W14+10]
375:                               
376:                               dV = diff * state.f0ErrMul;
00AC14  90004E     MOV [W14+8], W0
00AC16  9000DE     MOV [W14+10], W1
00AC18  07B6B1     RCALL ___floatsisf
00AC1A  BE0200     MOV.D W0, W4
00AC1C  808130     MOV 0x1026, W0
00AC1E  808141     MOV 0x1028, W1
00AC20  BE0100     MOV.D W0, W2
00AC22  BE0004     MOV.D W4, W0
00AC24  07B703     RCALL ___mulsf3
00AC26  980760     MOV W0, [W14+12]
00AC28  980771     MOV W1, [W14+14]
377:               
378:                               //if (state.v0 + dV > MIN_V0 && state.v0 + dV < MAX_V0)
379:                               state.v0 += dV;
00AC2A  808170     MOV 0x102E, W0
00AC2C  200001     MOV #0x0, W1
00AC2E  07B6A9     RCALL ___floatunsisf
00AC30  90016E     MOV [W14+12], W2
00AC32  9001FE     MOV [W14+14], W3
00AC34  07B5B7     RCALL ___addsf3
00AC36  07B687     RCALL ___fixunssfsi
00AC38  780000     MOV W0, W0
00AC3A  888170     MOV W0, 0x102E
380:               
381:                               if (state.v0 < MIN_V0)
00AC3C  808170     MOV 0x102E, W0
00AC3E  500FF3     SUB W0, #0x13, [W15]
00AC40  3E0016     BRA GTU, 0xAC6E
382:                               {
383:                                   state.v0 = MIN_V0;
00AC42  200140     MOV #0x14, W0
00AC44  888170     MOV W0, 0x102E
384:                                   state.f0 = (state.freqs[state.cnt]/5000)*5000;
00AC46  8081A1     MOV 0x1034, W1
00AC48  808120     MOV 0x1024, W0
00AC4A  DD0042     SL W0, #2, W0
00AC4C  408000     ADD W1, W0, W0
00AC4E  BE0010     MOV.D [W0], W0
00AC50  213882     MOV #0x1388, W2
00AC52  200003     MOV #0x0, W3
00AC54  07B646     RCALL ___divsi3
00AC56  213882     MOV #0x1388, W2
00AC58  B98902     MUL.SS W1, W2, W2
00AC5A  780102     MOV W2, W2
00AC5C  B90260     MUL.SU W0, #0, W4
00AC5E  780184     MOV W4, W3
00AC60  410103     ADD W2, W3, W2
00AC62  213883     MOV #0x1388, W3
00AC64  B80003     MUL.UU W0, W3, W0
00AC66  410101     ADD W2, W1, W2
00AC68  780082     MOV W2, W1
00AC6A  888150     MOV W0, 0x102A
00AC6C  888161     MOV W1, 0x102C
385:                               }
386:               
387:                               if (state.v0 > MAX_V0)
00AC6E  808171     MOV 0x102E, W1
00AC70  202580     MOV #0x258, W0
00AC72  508F80     SUB W1, W0, [W15]
00AC74  3600BF     BRA LEU, 0xADF4
388:                               {
389:                                   state.v0 = MAX_V0;
00AC76  202580     MOV #0x258, W0
00AC78  888170     MOV W0, 0x102E
390:                                   state.f0 = (state.freqs[state.cnt]/5000)*5000;
00AC7A  8081A1     MOV 0x1034, W1
00AC7C  808120     MOV 0x1024, W0
00AC7E  DD0042     SL W0, #2, W0
00AC80  408000     ADD W1, W0, W0
00AC82  BE0010     MOV.D [W0], W0
00AC84  213882     MOV #0x1388, W2
00AC86  200003     MOV #0x0, W3
00AC88  07B62C     RCALL ___divsi3
00AC8A  213882     MOV #0x1388, W2
00AC8C  B98902     MUL.SS W1, W2, W2
00AC8E  780102     MOV W2, W2
00AC90  B90260     MUL.SU W0, #0, W4
00AC92  780184     MOV W4, W3
00AC94  410103     ADD W2, W3, W2
00AC96  213883     MOV #0x1388, W3
00AC98  B80003     MUL.UU W0, W3, W0
00AC9A  410101     ADD W2, W1, W2
00AC9C  780082     MOV W2, W1
00AC9E  888150     MOV W0, 0x102A
00ACA0  888161     MOV W1, 0x102C
391:                               }
392:                           }
393:                           return;
00ACA2  3700AB     BRA 0xADFA
00ADF0  000000     NOP
00ADF2  370003     BRA 0xADFA
00ADF4  000000     NOP
00ADF6  370001     BRA 0xADFA
394:                       }
395:               
396:                       if (getRampVoltage() > 25.0) return;
00ACA4  07FF5D     RCALL getRampVoltage
00ACA6  B3C018     MOV #0x1, W8
00ACA8  200002     MOV #0x0, W2
00ACAA  241C83     MOV #0x41C8, W3
00ACAC  07B629     RCALL ___gtsf2
00ACAE  500FE0     SUB W0, #0x0, [W15]
00ACB0  3C0001     BRA GT, 0xACB4
00ACB2  EB4400     CLR.B W8
00ACB4  544FE0     SUB.B W8, #0x0, [W15]
00ACB6  3A00A0     BRA NZ, 0xADF8
00ADF8  000000     NOP
397:               
398:                       if (state.cnt % 2 != 0)
00ACB8  808120     MOV 0x1024, W0
00ACBA  600061     AND W0, #0x1, W0
00ACBC  784000     MOV.B W0, W0
00ACBE  504FE0     SUB.B W0, #0x0, [W15]
00ACC0  32009C     BRA Z, 0xADFA
399:                       {
400:                       freq100KHZ_t df, futurePracticalFreq, futureTheoricalFreq, dFuture, dLim, prev, act, theorAct, theorPrev, span;
401:                       auto unsigned int i;
402:                       impulseLen_t impulse;
403:               
404:                           act = (state.freqs[state.cnt] >> 7);
00ACC2  8081A1     MOV 0x1034, W1
00ACC4  808120     MOV 0x1024, W0
00ACC6  DD0042     SL W0, #2, W0
00ACC8  408000     ADD W1, W0, W0
00ACCA  BE0010     MOV.D [W0], W0
00ACCC  DD09C9     SL W1, #9, W3
00ACCE  DE0047     LSR W0, #7, W0
00ACD0  718000     IOR W3, W0, W0
00ACD2  DE88C7     ASR W1, #7, W1
00ACD4  980F00     MOV W0, [W14+16]
405:                           prev = (state.freqs[state.cnt - 1] >> 7);
00ACD6  8081A1     MOV 0x1034, W1
00ACD8  808120     MOV 0x1024, W0
00ACDA  E90000     DEC W0, W0
00ACDC  DD0042     SL W0, #2, W0
00ACDE  408000     ADD W1, W0, W0
00ACE0  BE0010     MOV.D [W0], W0
00ACE2  DD0949     SL W1, #9, W2
00ACE4  DE0047     LSR W0, #7, W0
00ACE6  710000     IOR W2, W0, W0
00ACE8  DE88C7     ASR W1, #7, W1
00ACEA  980F10     MOV W0, [W14+18]
406:                           theorAct = (state.teorFreqs[state.cnt] >> 7);
00ACEC  8081B1     MOV 0x1036, W1
00ACEE  808120     MOV 0x1024, W0
00ACF0  DD0042     SL W0, #2, W0
00ACF2  408000     ADD W1, W0, W0
00ACF4  BE0010     MOV.D [W0], W0
00ACF6  DD09C9     SL W1, #9, W3
00ACF8  DE0047     LSR W0, #7, W0
00ACFA  718000     IOR W3, W0, W0
00ACFC  DE88C7     ASR W1, #7, W1
00ACFE  980F20     MOV W0, [W14+20]
407:                           theorPrev = (state.teorFreqs[state.cnt - 1] >> 7);
00AD00  8081B1     MOV 0x1036, W1
00AD02  808120     MOV 0x1024, W0
00AD04  E90000     DEC W0, W0
00AD06  DD0042     SL W0, #2, W0
00AD08  408000     ADD W1, W0, W0
00AD0A  BE0010     MOV.D [W0], W0
00AD0C  DD0949     SL W1, #9, W2
00AD0E  DE0047     LSR W0, #7, W0
00AD10  710000     IOR W2, W0, W0
00AD12  DE88C7     ASR W1, #7, W1
00AD14  980F30     MOV W0, [W14+22]
408:                           span = (state.span >> 7);
00AD16  808100     MOV state, W0
00AD18  808111     MOV 0x1022, W1
00AD1A  DD09C9     SL W1, #9, W3
00AD1C  DE0047     LSR W0, #7, W0
00AD1E  718000     IOR W3, W0, W0
00AD20  DE88C7     ASR W1, #7, W1
00AD22  980F40     MOV W0, [W14+24]
409:               
410:                           df = act - prev;
00AD24  90088E     MOV [W14+16], W1
00AD26  90081E     MOV [W14+18], W0
00AD28  508000     SUB W1, W0, W0
00AD2A  980F50     MOV W0, [W14+26]
411:               
412:                           futurePracticalFreq = act + df + df + df;
00AD2C  90088E     MOV [W14+16], W1
00AD2E  90085E     MOV [W14+26], W0
00AD30  408080     ADD W1, W0, W1
00AD32  90085E     MOV [W14+26], W0
00AD34  408080     ADD W1, W0, W1
00AD36  90085E     MOV [W14+26], W0
00AD38  408000     ADD W1, W0, W0
00AD3A  980F60     MOV W0, [W14+28]
413:               
414:                           futureTheoricalFreq = theorAct + span + span + span;
00AD3C  9008AE     MOV [W14+20], W1
00AD3E  90084E     MOV [W14+24], W0
00AD40  408080     ADD W1, W0, W1
00AD42  90084E     MOV [W14+24], W0
00AD44  408080     ADD W1, W0, W1
00AD46  90084E     MOV [W14+24], W0
00AD48  408000     ADD W1, W0, W0
00AD4A  980F70     MOV W0, [W14+30]
415:               
416:                           dFuture = futureTheoricalFreq - futurePracticalFreq;
00AD4C  9008FE     MOV [W14+30], W1
00AD4E  90086E     MOV [W14+28], W0
00AD50  508000     SUB W1, W0, W0
00AD52  981700     MOV W0, [W14+32]
417:               
418:                           dLim = abs(dFuture);
00AD54  90100E     MOV [W14+32], W0
00AD56  500FE0     SUB W0, #0x0, [W15]
00AD58  3D0001     BRA GE, 0xAD5C
00AD5A  EA0000     NEG W0, W0
00AD5C  780F00     MOV W0, [W14]
419:               
420:                           if (dLim > 80) dLim = 80;
00AD5E  200500     MOV #0x50, W0
00AD60  78009E     MOV [W14], W1
00AD62  508F80     SUB W1, W0, [W15]
00AD64  340002     BRA LE, 0xAD6A
00AD66  200500     MOV #0x50, W0
00AD68  780F00     MOV W0, [W14]
421:               
422:                           dLim = (255*dLim)/80;
00AD6A  78009E     MOV [W14], W1
00AD6C  200FF0     MOV #0xFF, W0
00AD6E  B98800     MUL.SS W1, W0, W0
00AD70  780080     MOV W0, W1
00AD72  200500     MOV #0x50, W0
00AD74  780100     MOV W0, W2
00AD76  090011     REPEAT #0x11
00AD78  D80082     DIV.SW W1, W2
00AD7A  780F00     MOV W0, [W14]
423:               
424:                           impulse = dLim*state.errMulFactor;
00AD7C  8081C1     MOV 0x1038, W1
00AD7E  78001E     MOV [W14], W0
00AD80  B98800     MUL.SS W1, W0, W0
00AD82  780000     MOV W0, W0
00AD84  980710     MOV W0, [W14+2]
425:               
426:                           impulse >>= 8/*8*/;
00AD86  90001E     MOV [W14+2], W0
00AD88  DE0048     LSR W0, #8, W0
00AD8A  980710     MOV W0, [W14+2]
427:               
428:                           if (impulse > MAX_IMPULSE)
00AD8C  90009E     MOV [W14+2], W1
00AD8E  200FF0     MOV #0xFF, W0
00AD90  508F80     SUB W1, W0, [W15]
00AD92  360005     BRA LEU, 0xAD9E
429:                           {
430:                               impulse = MAX_IMPULSE;
00AD94  200FF0     MOV #0xFF, W0
00AD96  980710     MOV W0, [W14+2]
431:                               state.limited = TRUE_B;
00AD98  200010     MOV #0x1, W0
00AD9A  888220     MOV W0, 0x1044
00AD9C  370002     BRA 0xADA2
432:                           }
433:                           else if (impulse < MIN_IMPULSE)
434:                           {
435:                               impulse = MIN_IMPULSE;
436:                               state.limited = TRUE_B;
437:                           }
438:                           else
439:                           {
440:                               state.limited = FALSE_B;
00AD9E  EB0000     CLR W0
00ADA0  888220     MOV W0, 0x1044
441:                           }
442:               
443:                           if (state.cnt == 45)
00ADA2  808121     MOV 0x1024, W1
00ADA4  2002D0     MOV #0x2D, W0
00ADA6  508F80     SUB W1, W0, [W15]
00ADA8  3A0003     BRA NZ, 0xADB0
444:                               i++;
00ADAA  90101E     MOV [W14+34], W0
00ADAC  E80000     INC W0, W0
00ADAE  981710     MOV W0, [W14+34]
445:               
446:                           if (impulse == 0)
00ADB0  90001E     MOV [W14+2], W0
00ADB2  500FE0     SUB W0, #0x0, [W15]
00ADB4  320022     BRA Z, 0xADFA
447:                           {
448:                               
449:                           }
450:                           else if (dFuture > 0)
00ADB6  90100E     MOV [W14+32], W0
00ADB8  500FE0     SUB W0, #0x0, [W15]
00ADBA  34000D     BRA LE, 0xADD6
451:                           {
452:                               setRampH(1);
00ADBC  200010     MOV #0x1, W0
00ADBE  07FEE8     RCALL setRampH
453:                               asm ("RH:\nNOP\nDEC %0, %0\nBRA NZ, RH\n" : "+r"(impulse));
00ADC0  90001E     MOV [W14+2], W0
00ADC2  780400     MOV W0, W8
00ADC4  000000     NOP
00ADC6  E90408     DEC W8, W8
00ADC8  3AFFFD     BRA NZ, RH
00ADCA  980718     MOV W8, [W14+2]
454:                               setRampH(0);
00ADCC  EB0000     CLR W0
00ADCE  07FEE0     RCALL setRampH
455:                               state.impulsePolarity = UP_I;
00ADD0  EB0000     CLR W0
00ADD2  888230     MOV W0, 0x1046
00ADD4  370012     BRA 0xADFA
456:                           }
457:                           else
458:                           {
459:                               setRampL(1);
00ADD6  200010     MOV #0x1, W0
00ADD8  07FEE5     RCALL setRampL
460:                               asm ("RL:\nNOP\nDEC %0, %0\nBRA NZ, RL\n" : "+r"(impulse));
00ADDA  90001E     MOV [W14+2], W0
00ADDC  780400     MOV W0, W8
00ADDE  000000     NOP
00ADE0  E90408     DEC W8, W8
00ADE2  3AFFFD     BRA NZ, RL
00ADE4  980718     MOV W8, [W14+2]
461:                               setRampL(0);
00ADE6  EB0000     CLR W0
00ADE8  07FEDD     RCALL setRampL
462:                               state.impulsePolarity = DOWN_I;
00ADEA  200010     MOV #0x1, W0
00ADEC  888230     MOV W0, 0x1046
00ADEE  370005     BRA 0xADFA
463:                           }
464:                       }
465:                       else
466:                       {
467:                           /*if (state.cnt >= 10)
468:                           {
469:                           grade_t practicalGrade, theoricalGrade, dGrade;
470:                           freqKHZ_t actP, prevP, actT, prevT;
471:                           int error;
472:               
473:                               actP = state.freqs[state.cnt];
474:                               prevP = state.freqs[state.cnt - 1];
475:                               actT = state.teorFreqs[state.cnt];
476:                               prevT = state.teorFreqs[state.cnt - 1];
477:               
478:                               practicalGrade = actP - prevP; //Pendenza effettiva (KHz/ms)
479:                               theoricalGrade = actT - prevP; //Pendenza teorica (KHz/ms)
480:               
481:                               dGrade = theoricalGrade - practicalGrade;
482:               
483:                               error = (int)(dGrade/IMPULSE_ERROR_DIVISOR);
484:               
485:                               if (state.impulsePolarity == UP_I && error != 0)
486:                               {
487:                                   if (theoricalGrade >= 0 && practicalGrade >= 0 && state.limited == FALSE_B)
488:                                   {
489:                                       state.errMulFactor += error;
490:                                   }
491:                               }
492:                               else if (state.impulsePolarity == DOWN_I && error != 0)
493:                               {
494:                                   if (theoricalGrade >= 0 && practicalGrade >= 0 && state.limited == FALSE_B)
495:                                   {
496:                                       state.errMulFactor -= error;
497:                                   }
498:                               }
499:               
500:                               if (state.errMulFactor < 0) state.errMulFactor = 0;
501:                           }*/
502:                       }
503:                   }
00ADFA  78044F     MOV [--W15], W8
00ADFC  FA8000     ULNK
00ADFE  060000     RETURN
504:               
505:                   /*
506:                    * Ritrona l'attuale scarto tra la frequenza misurata e teorica
507:                    *
508:                    * output:
509:                    *  - attuale scarto tra la frequenza misurata e teorica
510:                    */
511:                   freqKHZ_t getActDF ()
512:                   {
00AE00  FA0000     LNK #0x0
513:                       if (state.cnt > 0 && state.cnt <= state.rampSampleNum)
00AE02  808120     MOV 0x1024, W0
00AE04  500FE0     SUB W0, #0x0, [W15]
00AE06  340018     BRA LE, 0xAE38
00AE08  808121     MOV 0x1024, W1
00AE0A  808190     MOV 0x1032, W0
00AE0C  508F80     SUB W1, W0, [W15]
00AE0E  3C0014     BRA GT, 0xAE38
514:                           return labs(state.freqs[state.cnt - 1] - state.teorFreqs[state.cnt - 1]);
00AE10  8081A1     MOV 0x1034, W1
00AE12  808120     MOV 0x1024, W0
00AE14  E90000     DEC W0, W0
00AE16  DD0042     SL W0, #2, W0
00AE18  408000     ADD W1, W0, W0
00AE1A  BE0110     MOV.D [W0], W2
00AE1C  8081B1     MOV 0x1036, W1
00AE1E  808120     MOV 0x1024, W0
00AE20  E90000     DEC W0, W0
00AE22  DD0042     SL W0, #2, W0
00AE24  408000     ADD W1, W0, W0
00AE26  BE0010     MOV.D [W0], W0
00AE28  510000     SUB W2, W0, W0
00AE2A  598081     SUBB W3, W1, W1
00AE2C  500FE0     SUB W0, #0x0, [W15]
00AE2E  588FE0     SUBB W1, #0x0, [W15]
00AE30  3D0002     BRA GE, 0xAE36
00AE32  100060     SUBR W0, #0x0, W0
00AE34  1880E0     SUBBR W1, #0x0, W1
00AE36  370001     BRA 0xAE3A
515:                       else
516:                           return 0;
00AE38  B80060     MUL.UU W0, #0, W0
517:                   }
00AE3A  FA8000     ULNK
00AE3C  060000     RETURN
518:               
519:                   /*
520:                    * Sposta la frequenza iniziale dell'ammontare desiderato
521:                    *
522:                    * input:
523:                    *  - pos: di quante posizioni spostare la frequenza iniziale (positivo a destra, negativo a sinistra)
524:                    */
525:                   void initialFreqSeek (int pos)
526:                   {
00AE3E  FA0002     LNK #0x2
00AE40  BE9F88     MOV.D W8, [W15++]
00AE42  780F00     MOV W0, [W14]
527:                       setInitialFreq(getInitialFreq() + getSpan() * pos);
00AE44  07FE14     RCALL getInitialFreq
00AE46  BE0400     MOV.D W0, W8
00AE48  07FE06     RCALL getSpan
00AE4A  BE0100     MOV.D W0, W2
00AE4C  78001E     MOV [W14], W0
00AE4E  DE80CF     ASR W0, #15, W1
00AE50  B99A00     MUL.SS W3, W0, W4
00AE52  780204     MOV W4, W4
00AE54  B98B02     MUL.SS W1, W2, W6
00AE56  780286     MOV W6, W5
00AE58  420205     ADD W4, W5, W4
00AE5A  B81000     MUL.UU W2, W0, W0
00AE5C  420201     ADD W4, W1, W4
00AE5E  780084     MOV W4, W1
00AE60  400008     ADD W0, W8, W0
00AE62  488089     ADDC W1, W9, W1
00AE64  07FDFD     RCALL setInitialFreq
528:                   }
00AE66  BE044F     MOV.D [--W15], W8
00AE68  FA8000     ULNK
00AE6A  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/quantities.c  ---------------------------------
1:                 #include "stdlib.h"
2:                 
3:                 #include "quantities.h"
4:                 
5:                 #include "dF.h"
6:                 #include "ros.h"
7:                 
8:                 quantity_t qs[Q_NUM] = {{ROS_QID, "ROS", rosMeasurementMainLoopBody, rosMeasurementInit, rosMeasurementStop}, {DF_QID, "DF", dFMeasurementMainLoopBody, dFMeasurementInit, dFMeasurementStop}};
9:                 
10:                typedef struct
11:                {
12:                    qId_t actQ;
13:                }qState_t;
14:                
15:                qState_t st;
16:                
17:                /*
18:                 * Inizializza il modulo per la misurazione semplificata di pi grandezze
19:                 */
20:                void initQuantities ()
21:                {
00C654  FA0000     LNK #0x0
22:                    st.actQ = ROS_QID;
00C656  EB0000     CLR W0
00C658  888C70     MOV W0, st
23:                }
00C65A  FA8000     ULNK
00C65C  060000     RETURN
24:                
25:                /*
26:                 * Ritorna l'attuale grandezza misurata
27:                 * 
28:                 * output:
29:                 *  - puntatore alla grandezza attualmente desiderata
30:                 */
31:                quantity_t *getActQuantity ()
32:                {
00C65E  FA0000     LNK #0x0
33:                    return &qs[st.actQ];
00C660  808C70     MOV st, W0
00C662  B9006E     MUL.SU W0, #14, W0
00C664  780080     MOV W0, W1
00C666  2108E0     MOV #0x108E, W0
00C668  408000     ADD W1, W0, W0
34:                }
00C66A  FA8000     ULNK
00C66C  060000     RETURN
35:                
36:                /*
37:                 * Imposta l'attuale grandezza misurata
38:                 *
39:                 * input:
40:                 *  - qId: id della grandezza da misurare
41:                 */
42:                void setActQuantity (qId_t qId)
43:                {
00C66E  FA0002     LNK #0x2
00C670  780F00     MOV W0, [W14]
44:                    if (qId >= Q_NUM) qId = 0;
00C672  78001E     MOV [W14], W0
00C674  500FE1     SUB W0, #0x1, [W15]
00C676  340002     BRA LE, 0xC67C
00C678  EB0000     CLR W0
00C67A  780F00     MOV W0, [W14]
45:                    if (qId < 0) qId = Q_NUM - 1;
00C67C  78001E     MOV [W14], W0
00C67E  500FE0     SUB W0, #0x0, [W15]
00C680  3D0002     BRA GE, 0xC686
00C682  200010     MOV #0x1, W0
00C684  780F00     MOV W0, [W14]
46:                    getActQuantity() -> stop();
00C686  07FFEB     RCALL getActQuantity
00C688  900060     MOV [W0+12], W0
00C68A  010000     CALL W0
47:                    st.actQ = qId;
00C68C  78001E     MOV [W14], W0
00C68E  888C70     MOV W0, st
48:                    getActQuantity() -> init();
00C690  07FFE6     RCALL getActQuantity
00C692  900050     MOV [W0+10], W0
00C694  010000     CALL W0
49:                }
00C696  FA8000     ULNK
00C698  060000     RETURN
50:                
51:                /*
52:                 * Va alla prossima quantit
53:                 */
54:                void goToNextQuantity ()
55:                {
00C69A  FA0000     LNK #0x0
56:                    setActQuantity(getActQuantity()->ID + 1);
00C69C  07FFE0     RCALL getActQuantity
00C69E  780010     MOV [W0], W0
00C6A0  E80000     INC W0, W0
00C6A2  07FFE5     RCALL setActQuantity
57:                }
00C6A4  FA8000     ULNK
00C6A6  060000     RETURN
58:                
59:                /*
60:                 * Va alla precedente quantit
61:                 */
62:                void goToPreviousQuantity ()
63:                {
00C6A8  FA0000     LNK #0x0
64:                    setActQuantity(getActQuantity()->ID - 1);
00C6AA  07FFD9     RCALL getActQuantity
00C6AC  780010     MOV [W0], W0
00C6AE  E90000     DEC W0, W0
00C6B0  07FFDE     RCALL setActQuantity
65:                }
00C6B2  FA8000     ULNK
00C6B4  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/globalPinout.c  -------------------------------
1:                 #include <xc.h>
2:                 #include <math.h>
3:                 
4:                 #include "globalPinout.h"
5:                 
6:                 
7:                 
8:                 /*
9:                  * Mappa i pin rimappabili
10:                 */
11:                void mapRPPins ();
12:                
13:                /*
14:                 * Imposta i pin digitali per essere ingressi o uscite
15:                 */
16:                void digitalPinsIOSelection ();
17:                
18:                /*
19:                 * Imposta i pin analogici per funzionare correttamente
20:                 */
21:                void analogPinsConfig ();
22:                
23:                /*
24:                 * Inizializza il modulo globalPinout. Mappa i pin alla funzione
25:                 * corretta.
26:                 */
27:                void initGlobalPinout ()
28:                {
00C470  FA0000     LNK #0x0
29:                    mapRPPins();
00C472  070003     RCALL mapRPPins
30:                    digitalPinsIOSelection();
00C474  070021     RCALL digitalPinsIOSelection
31:                }
00C476  FA8000     ULNK
00C478  060000     RETURN
32:                
33:                /*
34:                 * Mappa i pin rimappabili
35:                 */
36:                void mapRPPins ()
37:                {
00C47A  FA0000     LNK #0x0
38:                    asm volatile (                             // Unlock Registers (Per DS39881B-page 102)
00C47C  207421     MOV #0x742, W1
00C47E  200462     MOV #0x46, W2
00C480  200573     MOV #0x57, W3
00C482  784882     MOV.B W2, [W1]
00C484  784883     MOV.B W3, [W1]
00C486  A9C742     BCLR OSCCON, #6
39:                                "MOV #OSCCON, w1 \n"
40:                                "MOV #0x46, w2 \n"
41:                                "MOV #0x57, w3 \n"
42:                                "MOV.b w2, [w1] \n"
43:                                "MOV.b w3, [w1] \n"
44:                                "BCLR OSCCON,#6"
45:                                );
46:                
47:                    SI_RPOR = SI_CNST;
00C488  803661     MOV RPOR6, W1
00C48A  2FFE00     MOV #0xFFE0, W0
00C48C  608000     AND W1, W0, W0
00C48E  B30070     IOR #0x7, W0
00C490  883660     MOV W0, RPOR6
48:                    SCL_RPOR = SCL_CNST;
00C492  803651     MOV RPOR5, W1
00C494  2FFE00     MOV #0xFFE0, W0
00C496  608000     AND W1, W0, W0
00C498  A03000     BSET W0, #3
00C49A  883650     MOV W0, RPOR5
49:                
50:                    BUZZ_RPOR = BUZZ_CNST;
00C49C  803611     MOV RPOR1, W1
00C49E  2E0FF0     MOV #0xE0FF, W0
00C4A0  608080     AND W1, W0, W1
00C4A2  212000     MOV #0x1200, W0
00C4A4  708000     IOR W1, W0, W0
00C4A6  883610     MOV W0, RPOR1
51:                
52:                    asm volatile (                             // Lock Registers
00C4A8  207421     MOV #0x742, W1
00C4AA  200462     MOV #0x46, W2
00C4AC  200573     MOV #0x57, W3
00C4AE  784882     MOV.B W2, [W1]
00C4B0  784883     MOV.B W3, [W1]
00C4B2  A8C742     BSET OSCCON, #6
53:                                "MOV #OSCCON, w1 \n"
54:                                "MOV #0x46, w2 \n"
55:                                "MOV #0x57, w3 \n"
56:                                "MOV.b w2, [w1] \n"
57:                                "MOV.b w3, [w1] \n"
58:                                "BSET OSCCON, #6"
59:                                );
60:                }
00C4B4  FA8000     ULNK
00C4B6  060000     RETURN
61:                
62:                /*
63:                 * Imposta i pin digitali per essere ingressi o uscite
64:                 */
65:                void digitalPinsIOSelection ()
66:                {
00C4B8  FA0000     LNK #0x0
67:                    A0_TRIS = 0;
00C4BA  A9E2C9     BCLR 0x2C9, #7
68:                    RES_TRIS = 0;
00C4BC  A9C2C9     BCLR 0x2C9, #6
69:                    CS1_TRIS = 0;
00C4BE  A962C9     BCLR 0x2C9, #3
70:                    PS_TRIS = 0;
00C4C0  A9E2C8     BCLR TRISB, #7
71:                
72:                    RMPH_TRIS = 0;
00C4C2  A922C9     BCLR 0x2C9, #1
73:                    RMPH_ODC = 1;
00C4C4  A822CF     BSET 0x2CF, #1
74:                
75:                    RMPL_TRIS = 0;
00C4C6  A902C9     BCLR 0x2C9, #0
76:                    RMPL_ODC = 1;
00C4C8  A802CF     BSET 0x2CF, #0
77:                
78:                    RMPFSTR_TRIS = 0;
00C4CA  A982C8     BCLR TRISB, #4
79:                
80:                    P1_TRIS = 1;
00C4CC  A8A2C9     BSET 0x2C9, #5
81:                    P1_CNPU = 1;
00C4CE  A8A069     BSET 0x69, #5
82:                
83:                    P2_TRIS = 1;
00C4D0  A8C2C8     BSET TRISB, #6
84:                    P2_CNPU = 1;
00C4D2  A8006B     BSET 0x6B, #0
85:                    
86:                    P3_TRIS = 1;
00C4D4  A8A2C8     BSET TRISB, #5
87:                    P3_CNPU = 1;
00C4D6  A8606B     BSET 0x6B, #3
88:                }
00C4D8  FA8000     ULNK
00C4DA  060000     RETURN
89:                
90:                /*
91:                 * Imposta i pin analogici per funzionare correttamente
92:                 */
93:                void analogPinsConfig ()
94:                {
00C4DC  FA0000     LNK #0x0
95:                    RMPAN_TRIS = 1;
00C4DE  A822C0     BSET TRISA, #1
96:                    AD1PCFGL &= ~((int)pow(2, RMPAN_AN_PIN_NO));
00C4E0  801961     MOV AD1PCFGL, W1
00C4E2  2FFFD0     MOV #0xFFFD, W0
00C4E4  608000     AND W1, W0, W0
00C4E6  881960     MOV W0, AD1PCFGL
97:                
98:                    DIRWAV_TRIS = 1;
00C4E8  A842C8     BSET TRISB, #2
99:                    AD1PCFGL &= ~((int)pow(2, DIRWAV_AN_PIN_NO));
00C4EA  801961     MOV AD1PCFGL, W1
00C4EC  2FFEF0     MOV #0xFFEF, W0
00C4EE  608000     AND W1, W0, W0
00C4F0  881960     MOV W0, AD1PCFGL
100:               
101:                   REFWAV_TRIS = 1;
00C4F2  A802C0     BSET TRISA, #0
102:                   AD1PCFGL &= ~((int)pow(2, REFWAV_AN_PIN_NO));
00C4F4  801961     MOV AD1PCFGL, W1
00C4F6  2FFFE0     MOV #0xFFFE, W0
00C4F8  608000     AND W1, W0, W0
00C4FA  881960     MOV W0, AD1PCFGL
103:               }
00C4FC  FA8000     ULNK
00C4FE  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/errorControl.c  -------------------------------
1:                 #include "errorControl.h"
2:                 
3:                 #include <string.h>
4:                 #include <stdlib.h>
5:                 
6:                 typedef struct _errorQueueNode_t
7:                 {
8:                     error_t error;
9:                     struct _errorQueueNode_t *next;
10:                }errorQueueNode_t;
11:                
12:                typedef errorQueueNode_t *errorQueueIterator_t;
13:                
14:                typedef struct
15:                {
16:                    errorQueueIterator_t head;
17:                    errorQueueIterator_t tail;
18:                }errorQueue_t;
19:                
20:                errorQueue_t eq;
21:                
22:                /*
23:                 * Inizializza il modulo di gestione e controllo degli errori
24:                 */
25:                void initErrorControl()
26:                {
00C324  FA0000     LNK #0x0
27:                    eq.head = NULL;
00C326  EB0000     CLR W0
00C328  888C20     MOV W0, eq
28:                    eq.tail = NULL;
00C32A  EB0000     CLR W0
00C32C  888C30     MOV W0, 0x1186
29:                }
00C32E  FA8000     ULNK
00C330  060000     RETURN
30:                
31:                /*
32:                 * Ritorna un nuovo errore date le caratteristiche che deve avere
33:                 *
34:                 * input:
35:                 *  - name: nome dell'errore
36:                 *  - description: descrizione dell'errore
37:                 *  - errorType: tipo dell'errore
38:                 */
39:                error_t newError (const char *name, const char *description, errorType_t errorType)
40:                {
00C332  FA0080     LNK #0x80
00C334  781F88     MOV W8, [W15++]
00C336  780400     MOV W0, W8
00C338  983F51     MOV W1, [W14+122]
00C33A  983F62     MOV W2, [W14+124]
00C33C  983F73     MOV W3, [W14+126]
41:                error_t ris;
42:                
43:                    strcpy (ris.name, name);
00C33E  9038DE     MOV [W14+122], W1
00C340  78000E     MOV W14, W0
00C342  07AF04     RCALL _strcpy
44:                    strcpy (ris.description, description);
00C344  470074     ADD W14, #0x14, W0
00C346  9038EE     MOV [W14+124], W1
00C348  07AF01     RCALL _strcpy
45:                    ris.errorType = errorType;
00C34A  90387E     MOV [W14+126], W0
00C34C  983F40     MOV W0, [W14+120]
46:                
47:                    return ris;
00C34E  09003C     REPEAT #0x3C
00C350  781C3E     MOV [W14++], [W8++]
00C352  B107A8     SUB #0x7A, W8
00C354  B107AE     SUB #0x7A, W14
48:                }
00C356  780008     MOV W8, W0
00C358  78044F     MOV [--W15], W8
00C35A  FA8000     ULNK
00C35C  060000     RETURN
49:                
50:                /*
51:                 * Aggiunge un errore alla coda
52:                 *
53:                 * input:
54:                 *  - error: l'errore da aggiungere
55:                 */
56:                void addError (error_t *error)
57:                {
00C35E  FA0004     LNK #0x4
00C360  980710     MOV W0, [W14+2]
58:                errorQueueIterator_t newNode;
59:                
60:                    newNode = (errorQueueIterator_t) malloc (sizeof(errorQueueNode_t));
00C362  2007C0     MOV #0x7C, W0
00C364  07ADF5     RCALL _malloc
00C366  780F00     MOV W0, [W14]
61:                
62:                    newNode -> next = NULL;
00C368  78001E     MOV [W14], W0
00C36A  EB0080     CLR W1
00C36C  983851     MOV W1, [W0+122]
63:                
64:                    newNode -> error = *error;
00C36E  78001E     MOV [W14], W0
00C370  90009E     MOV [W14+2], W1
00C372  09003C     REPEAT #0x3C
00C374  781831     MOV [W1++], [W0++]
00C376  B107A0     SUB #0x7A, W0
00C378  B107A1     SUB #0x7A, W1
65:                
66:                    if (eq.tail != NULL)
00C37A  808C30     MOV 0x1186, W0
00C37C  500FE0     SUB W0, #0x0, [W15]
00C37E  320004     BRA Z, 0xC388
67:                    {
68:                        eq.tail -> next = newNode;
00C380  808C30     MOV 0x1186, W0
00C382  78009E     MOV [W14], W1
00C384  983851     MOV W1, [W0+122]
00C386  370002     BRA 0xC38C
69:                    }
70:                    else
71:                    {
72:                        eq.head = newNode;
00C388  78001E     MOV [W14], W0
00C38A  888C20     MOV W0, eq
73:                    }
74:                
75:                    eq.tail = newNode;
00C38C  78009E     MOV [W14], W1
00C38E  888C31     MOV W1, 0x1186
76:                }
00C390  FA8000     ULNK
00C392  060000     RETURN
77:                
78:                /*
79:                 * Ritorna il primo errore della coda
80:                 *
81:                 * output:
82:                 *  - il primo errore della coda
83:                 */
84:                error_t *getError ()
85:                {
00C394  FA0000     LNK #0x0
86:                    if (eq.head != NULL)
00C396  808C20     MOV eq, W0
00C398  500FE0     SUB W0, #0x0, [W15]
00C39A  320002     BRA Z, 0xC3A0
87:                        return &(eq.head -> error);
00C39C  808C20     MOV eq, W0
00C39E  370001     BRA 0xC3A2
88:                    else
89:                        return NULL;
00C3A0  EB0000     CLR W0
90:                }
00C3A2  FA8000     ULNK
00C3A4  060000     RETURN
91:                
92:                /*
93:                 * Elimina il primo errore della coda
94:                 */
95:                void deleteError ()
96:                {
00C3A6  FA0002     LNK #0x2
97:                    if (eq.head != NULL)
00C3A8  808C20     MOV eq, W0
00C3AA  500FE0     SUB W0, #0x0, [W15]
00C3AC  32000C     BRA Z, 0xC3C6
98:                    {
99:                    errorQueueIterator_t tmp;
100:               
101:                       tmp = eq.head;
00C3AE  808C20     MOV eq, W0
00C3B0  780F00     MOV W0, [W14]
102:               
103:                       eq.head = tmp->next;
00C3B2  78001E     MOV [W14], W0
00C3B4  903850     MOV [W0+122], W0
00C3B6  888C20     MOV W0, eq
104:               
105:                       if (eq.head == NULL) eq.tail = NULL;
00C3B8  808C20     MOV eq, W0
00C3BA  500FE0     SUB W0, #0x0, [W15]
00C3BC  3A0002     BRA NZ, 0xC3C2
00C3BE  EB0000     CLR W0
00C3C0  888C30     MOV W0, 0x1186
106:               
107:                       free (tmp);
00C3C2  78001E     MOV [W14], W0
00C3C4  07AE60     RCALL _free
108:                   }
109:               }
00C3C6  FA8000     ULNK
00C3C8  060000     RETURN
110:               
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/dF.c  -----------------------------------------
1:                 #include "stdlib.h"
2:                 #include "string.h"
3:                 
4:                 #include "graphics/GOL.h"
5:                 #include "Graphics/Primitive.h"
6:                 #include "Graphics/StaticText.h"
7:                 #include "MyGraph.h"
8:                 
9:                 #include "df.h"
10:                
11:                #include "controls.h"
12:                #include "rampControl.h"
13:                #include "timer3.h"
14:                #include "timer1.h"
15:                #include "errorControl.h"
16:                
17:                #include "globalPinout.h"
18:                
19:                static freqKHZ_t displayFreq = 0;
20:                static freqKHZ_t dF = 0;
21:                
22:                static MYGRAPH *gr;
23:                static STATICTEXT *measurement;
24:                
25:                static int dataSerie[128];
26:                
27:                static int afterInit;
28:                
29:                /*
30:                 * Inizializza gli oggetti grafici
31:                 */
32:                void dFInitGraphicObjects ();
33:                
34:                /*
35:                 * Inizializza il modulo che si occupa di misurare e visualizzare la quantit
36:                 * dell'errore effettuato sulla rampa di frequenza
37:                 */
38:                void dFMeasurementInit ()
39:                {
00B792  FA0000     LNK #0x0
40:                    dFInitGraphicObjects();
00B794  0700CF     RCALL dFInitGraphicObjects
41:                    setTimer3IntervalNS(1000000L);
00B796  242400     MOV #0x4240, W0
00B798  2000F1     MOV #0xF, W1
00B79A  07AC73     RCALL setTimer3IntervalNS
42:                    TIMER3_INSTANT_START;
00B79C  A8E113     BSET 0x113, #7
43:                    afterInit = 1;
00B79E  200010     MOV #0x1, W0
00B7A0  886AF0     MOV W0, afterInit
44:                }
00B7A2  FA8000     ULNK
00B7A4  060000     RETURN
45:                
46:                /*
47:                 * Misura e visualizza sul display la quantit dell'errore effettuato sulla
48:                 * rampa di frequenza
49:                 */
50:                void dFMeasurementMainLoopBody ()
51:                {
00B7A6  FA019A     LNK #0x19A
52:                keyID key;
53:                double f;
54:                char txt[50];
55:                int i;
56:                freqKHZ_t freq, actDf;
57:                error_t e;
58:                
59:                        fastReturn_begin();
00B7A8  07F9B4     RCALL fastReturn_begin
60:                
61:                
62:                        resetRamp();
00B7AA  07F945     RCALL resetRamp
63:                
64:                        if (!afterInit)
00B7AC  806AF0     MOV afterInit, W0
00B7AE  500FE0     SUB W0, #0x0, [W15]
00B7B0  3A0032     BRA NZ, 0xB816
65:                        {
66:                            key = getPressedKey();
00B7B2  0706E7     RCALL getPressedKey
00B7B4  980710     MOV W0, [W14+2]
67:                
68:                            if (key == CONTROLS_T1)
00B7B6  90001E     MOV [W14+2], W0
00B7B8  500FE1     SUB W0, #0x1, [W15]
00B7BA  3A0002     BRA NZ, 0xB7C0
69:                                initialFreqSeek (-1);
00B7BC  EB8000     SETM W0
00B7BE  07FB3F     RCALL initialFreqSeek
70:                            if (key == CONTROLS_T2)
00B7C0  90001E     MOV [W14+2], W0
00B7C2  500FE2     SUB W0, #0x2, [W15]
00B7C4  3A0002     BRA NZ, 0xB7CA
71:                                initialFreqSeek (+1);
00B7C6  200010     MOV #0x1, W0
00B7C8  07FB3A     RCALL initialFreqSeek
72:                
73:                            f = displayFreq/1000.0;
00B7CA  806290     MOV displayFreq, W0
00B7CC  8062A1     MOV 0xC54, W1
00B7CE  07B0D6     RCALL ___floatsisf
00B7D0  200002     MOV #0x0, W2
00B7D2  2447A3     MOV #0x447A, W3
00B7D4  07B044     RCALL ___divsf3
00B7D6  980720     MOV W0, [W14+4]
00B7D8  980731     MOV W1, [W14+6]
74:                
75:                            sprintf (txt, "F: %5.2fMHZ DF: %5ldKHZ", f, dF);
00B7DA  8062B0     MOV dF, W0
00B7DC  8062C1     MOV 0xC58, W1
00B7DE  470170     ADD W14, #0x10, W2
00B7E0  BE9F80     MOV.D W0, [W15++]
00B7E2  90002E     MOV [W14+4], W0
00B7E4  9000BE     MOV [W14+6], W1
00B7E6  BE9F80     MOV.D W0, [W15++]
00B7E8  2D2FC0     MOV #0xD2FC, W0
00B7EA  781F80     MOV W0, [W15++]
00B7EC  780002     MOV W2, W0
00B7EE  07B4BB     RCALL __sprintf_cdfFnopuxX
00B7F0  5787EA     SUB W15, #0xA, W15
76:                            measurement->hdr.state |= ST_DRAW;
00B7F2  8062E0     MOV measurement, W0
00B7F4  8062E1     MOV measurement, W1
00B7F6  900131     MOV [W1+6], W2
00B7F8  240001     MOV #0x4000, W1
00B7FA  710081     IOR W2, W1, W1
00B7FC  980031     MOV W1, [W0+6]
77:                            StSetText (measurement, txt);
00B7FE  8062E0     MOV measurement, W0
00B800  4700F0     ADD W14, #0x10, W1
00B802  07FB8A     RCALL StSetText
78:                            gr->hdr.DrawObj((void*)gr);
00B804  8062D0     MOV gr, W0
00B806  900890     MOV [W0+18], W1
00B808  8062D0     MOV gr, W0
00B80A  010001     CALL W1
79:                            GOLDraw();
00B80C  07E71D     RCALL GOLDraw
80:                            refreshSPIDisplay();
00B80E  07F72B     RCALL refreshSPIDisplay
81:                            invalidateMyGraph (gr);
00B810  8062D0     MOV gr, W0
00B812  07F3D8     RCALL invalidateMyGraph
00B814  370018     BRA 0xB846
82:                        }
83:                        else
84:                        {
85:                            char errDescr[ERROR_DESCRIPTION_MAX_CHAR];
86:                
87:                            sprintf (errDescr, "PASSANDO A MISURAZIONE\nERRORE...");
00B816  200BC0     MOV #0xBC, W0
00B818  40000E     ADD W0, W14, W0
00B81A  200212     MOV #0x21, W2
00B81C  2D3141     MOV #0xD314, W1
00B81E  07B468     RCALL _memcpy
88:                
89:                            e = newError("QUANTITY CHANGE", errDescr, WARNING);
00B820  201200     MOV #0x120, W0
00B822  40000E     ADD W0, W14, W0
00B824  200BC1     MOV #0xBC, W1
00B826  40808E     ADD W1, W14, W1
00B828  200013     MOV #0x1, W3
00B82A  780101     MOV W1, W2
00B82C  2D3351     MOV #0xD335, W1
00B82E  070581     RCALL newError
00B830  78000E     MOV W14, W0
00B832  B00420     ADD #0x42, W0
00B834  78008E     MOV W14, W1
00B836  B01201     ADD #0x120, W1
00B838  09003C     REPEAT #0x3C
00B83A  781831     MOV [W1++], [W0++]
90:                            addError (&e);
00B83C  200420     MOV #0x42, W0
00B83E  40000E     ADD W0, W14, W0
00B840  07058E     RCALL addError
91:                
92:                            afterInit = 0;
00B842  EB0000     CLR W0
00B844  886AF0     MOV W0, afterInit
93:                        }
94:                        
95:                        setTimer3IntervalNS(1000000L);
00B846  242400     MOV #0x4240, W0
00B848  2000F1     MOV #0xF, W1
00B84A  07AC1B     RCALL setTimer3IntervalNS
96:                
97:                        fastReturn_waitForEnd ();
00B84C  07F96B     RCALL fastReturn_waitForEnd
98:                
99:                        TIMER3_INSTANT_RESET;
00B84E  EF210A     CLR TMR3
100:                       TIMER1_INSTANT_RESET;
00B850  EF2100     CLR TMR1
101:                       TIMER1_INSTANT_START;
00B852  A8E105     BSET 0x105, #7
102:               
103:                       IFS0bits.T3IF = 0;
00B854  A90085     BCLR 0x85, #0
104:               
105:                       for (i = 0; i < 128; i++)
00B856  EB0000     CLR W0
00B858  780F00     MOV W0, [W14]
00B85A  370062     BRA 0xB920
00B91E  E80F1E     INC [W14], [W14]
00B920  2007F0     MOV #0x7F, W0
00B922  78009E     MOV [W14], W1
00B924  508F80     SUB W1, W0, [W15]
00B926  34FF9A     BRA LE, 0xB85C
106:                       {
107:                           while (TMR3 < (PR3>>1));
00B85C  000000     NOP
00B85E  800870     MOV PR3, W0
00B860  D10080     LSR W0, W1
00B862  800850     MOV TMR3, W0
00B864  508F80     SUB W1, W0, [W15]
00B866  3EFFFB     BRA GTU, 0xB85E
108:               
109:                           if (IFS0bits.T3IF == 1)
00B868  800421     MOV IFS0, W1
00B86A  201000     MOV #0x100, W0
00B86C  608000     AND W1, W0, W0
00B86E  500FE0     SUB W0, #0x0, [W15]
00B870  32001F     BRA Z, 0xB8B0
110:                           {
111:                               char errDescr[ERROR_DESCRIPTION_MAX_CHAR];
112:               
113:                               sprintf (errDescr, "IMPOSSIBILE RISPETTARE\nIL TEMPO DI 1MS\nA I = %d (%ld uS)", i, timer3ElaspedTimeNS()/1000);
00B872  07ACD1     RCALL timer3ElaspedTimeNS
00B874  203E82     MOV #0x3E8, W2
00B876  200003     MOV #0x0, W3
00B878  07B034     RCALL ___divsi3
00B87A  200BC2     MOV #0xBC, W2
00B87C  41010E     ADD W2, W14, W2
00B87E  BE9F80     MOV.D W0, [W15++]
00B880  781F9E     MOV [W14], [W15++]
00B882  2D3450     MOV #0xD345, W0
00B884  781F80     MOV W0, [W15++]
00B886  780002     MOV W2, W0
00B888  07B46E     RCALL __sprintf_cdfFnopuxX
00B88A  5787E8     SUB W15, #0x8, W15
114:               
115:                               e = newError("TIME FAULT", errDescr, ERROR);
00B88C  201200     MOV #0x120, W0
00B88E  40000E     ADD W0, W14, W0
00B890  200BC1     MOV #0xBC, W1
00B892  40808E     ADD W1, W14, W1
00B894  EB0180     CLR W3
00B896  780101     MOV W1, W2
00B898  2D37E1     MOV #0xD37E, W1
00B89A  07054B     RCALL newError
00B89C  78000E     MOV W14, W0
00B89E  B00420     ADD #0x42, W0
00B8A0  78008E     MOV W14, W1
00B8A2  B01201     ADD #0x120, W1
00B8A4  09003C     REPEAT #0x3C
00B8A6  781831     MOV [W1++], [W0++]
116:                               addError (&e);
00B8A8  200420     MOV #0x42, W0
00B8AA  40000E     ADD W0, W14, W0
00B8AC  070558     RCALL addError
117:                               break;
00B8AE  37003C     BRA 0xB928
118:                           }
119:               
120:                           while (IFS0bits.T3IF==0);
00B8B0  000000     NOP
00B8B2  800421     MOV IFS0, W1
00B8B4  201000     MOV #0x100, W0
00B8B6  608000     AND W1, W0, W0
00B8B8  500FE0     SUB W0, #0x0, [W15]
00B8BA  32FFFB     BRA Z, 0xB8B2
121:                           IFS0bits.T3IF = 0;
00B8BC  A90085     BCLR 0x85, #0
122:               
123:                           TIMER1_INSTANT_STOP;
00B8BE  A9E105     BCLR 0x105, #7
124:               
125:                           freq = (getTimer1Count())<<5;
00B8C0  07AA03     RCALL getTimer1Count
00B8C2  BE0100     MOV.D W0, W2
00B8C4  DD1845     SL W3, #5, W0
00B8C6  DE10CB     LSR W2, #11, W1
00B8C8  700081     IOR W0, W1, W1
00B8CA  DD1045     SL W2, #5, W0
00B8CC  980740     MOV W0, [W14+8]
00B8CE  980751     MOV W1, [W14+10]
126:               
127:                           TIMER3_INSTANT_RESET;
00B8D0  EF210A     CLR TMR3
128:                           TIMER1_INSTANT_RESET;
00B8D2  EF2100     CLR TMR1
129:                           TIMER1_INSTANT_START;
00B8D4  A8E105     BSET 0x105, #7
130:               
131:                           actualInstantSet (freq);
00B8D6  90004E     MOV [W14+8], W0
00B8D8  9000DE     MOV [W14+10], W1
00B8DA  07F8D8     RCALL actualInstantSet
132:               
133:                           actDf = (63L*getActDF())/25500;
00B8DC  07FA91     RCALL getActDF
00B8DE  2003F2     MOV #0x3F, W2
00B8E0  B98902     MUL.SS W1, W2, W2
00B8E2  780102     MOV W2, W2
00B8E4  B90260     MUL.SU W0, #0, W4
00B8E6  780184     MOV W4, W3
00B8E8  410103     ADD W2, W3, W2
00B8EA  2003F3     MOV #0x3F, W3
00B8EC  B80003     MUL.UU W0, W3, W0
00B8EE  410101     ADD W2, W1, W2
00B8F0  780082     MOV W2, W1
00B8F2  2639C2     MOV #0x639C, W2
00B8F4  200003     MOV #0x0, W3
00B8F6  07AFF5     RCALL ___divsi3
00B8F8  980760     MOV W0, [W14+12]
00B8FA  980771     MOV W1, [W14+14]
134:               
135:                           dataSerie[i] = actDf;
00B8FC  9000EE     MOV [W14+12], W1
00B8FE  78001E     MOV [W14], W0
00B900  400100     ADD W0, W0, W2
00B902  20C5E0     MOV #0xC5E, W0
00B904  410000     ADD W2, W0, W0
00B906  780801     MOV W1, [W0]
136:               
137:                           if (i == getBarPos (gr))
00B908  8062D0     MOV gr, W0
00B90A  07F1B5     RCALL getBarPos
00B90C  500F9E     SUB W0, [W14], [W15]
00B90E  3A0007     BRA NZ, 0xB91E
138:                           {
139:                               displayFreq = freq;
00B910  90004E     MOV [W14+8], W0
00B912  9000DE     MOV [W14+10], W1
00B914  886290     MOV W0, displayFreq
00B916  8862A1     MOV W1, 0xC54
140:                               dF = getActDF();
00B918  07FA73     RCALL getActDF
00B91A  8862B0     MOV W0, dF
00B91C  8862C1     MOV W1, 0xC58
141:                           }
142:                       }
143:               }
00B928  FA8000     ULNK
00B92A  060000     RETURN
144:               
145:               /*
146:                * Stoppa il modulo che si occupa di misurare e visualizzare la quantit
147:                * dell'errore effettuato sulla rampa di frequenza
148:                */
149:               void dFMeasurementStop ()
150:               {
00B92C  FA0000     LNK #0x0
151:                   GOLFree();
00B92E  07E5FA     RCALL GOLFree
152:               }
00B930  FA8000     ULNK
00B932  060000     RETURN
153:               
154:               /*
155:                * Inizializza gli oggetti grafici
156:                */
157:               void dFInitGraphicObjects ()
158:               {
00B934  FA0006     LNK #0x6
159:               GOL_SCHEME *pScheme;
160:               WORD state;
161:               int i;
162:               
163:                   GOLNewList();
00B936  EB0000     CLR W0
00B938  888B30     MOV W0, 0x1166
00B93A  EB0000     CLR W0
00B93C  888B50     MOV W0, 0x116A
164:               
165:                   pScheme = GOLCreateScheme();
00B93E  07E5DE     RCALL GOLCreateScheme
00B940  980710     MOV W0, [W14+2]
166:               
167:                   pScheme ->Color0 = 0x00;
00B942  90009E     MOV [W14+2], W1
00B944  EB4000     CLR.B W0
00B946  9840D0     MOV.B W0, [W1+5]
168:                   pScheme ->Color1 = 0x01;
00B948  90009E     MOV [W14+2], W1
00B94A  B3C010     MOV #0x1, W0
00B94C  9840E0     MOV.B W0, [W1+6]
169:               
170:                   pScheme ->CommonBkColor = 0x01;
00B94E  90009E     MOV [W14+2], W1
00B950  B3C010     MOV #0x1, W0
00B952  984880     MOV.B W0, [W1+8]
171:               
172:                   pScheme ->EmbossDkColor = 0x00;
00B954  90009E     MOV [W14+2], W1
00B956  EB4000     CLR.B W0
00B958  784880     MOV.B W0, [W1]
173:                   pScheme ->EmbossLtColor = 0x01;
00B95A  90009E     MOV [W14+2], W1
00B95C  B3C010     MOV #0x1, W0
00B95E  984090     MOV.B W0, [W1+1]
174:               
175:                   pScheme ->TextColor0 = 0x00;
00B960  90009E     MOV [W14+2], W1
00B962  EB4000     CLR.B W0
00B964  9840A0     MOV.B W0, [W1+2]
176:                   pScheme ->TextColor1 = 0x00;
00B966  90009E     MOV [W14+2], W1
00B968  EB4000     CLR.B W0
00B96A  9840B0     MOV.B W0, [W1+3]
177:               
178:                   for (i = 0; i < 128; i++)
00B96C  EB0000     CLR W0
00B96E  780F00     MOV W0, [W14]
00B970  37000D     BRA 0xB98C
00B98A  E80F1E     INC [W14], [W14]
00B98C  2007F0     MOV #0x7F, W0
00B98E  78009E     MOV [W14], W1
00B990  508F80     SUB W1, W0, [W15]
00B992  34FFEF     BRA LE, 0xB972
179:                   {
180:                       dataSerie[i] = rand()%64;
00B972  07B3CD     RCALL _rand
00B974  200401     MOV #0x40, W1
00B976  780101     MOV W1, W2
00B978  090011     REPEAT #0x11
00B97A  D80002     DIV.SW W0, W2
00B97C  FD0080     EXCH W0, W1
00B97E  780080     MOV W0, W1
00B980  78001E     MOV [W14], W0
00B982  400100     ADD W0, W0, W2
00B984  20C5E0     MOV #0xC5E, W0
00B986  410000     ADD W2, W0, W0
00B988  780801     MOV W1, [W0]
181:                   }
182:               
183:               
184:                   state = MYGR_DRAW | MYGR_OPTIMIZED;
00B994  2FC010     MOV #0xFC01, W0
00B996  980720     MOV W0, [W14+4]
185:                   gr = MygrCreate (3, 0, 0, 127, 63, state, dataSerie, sizeof(dataSerie)/sizeof(int), 0, 128, 0, 64, 0, 0, 128, 8,  pScheme);
00B998  90001E     MOV [W14+2], W0
00B99A  781F80     MOV W0, [W15++]
00B99C  200080     MOV #0x8, W0
00B99E  781F80     MOV W0, [W15++]
00B9A0  200800     MOV #0x80, W0
00B9A2  781F80     MOV W0, [W15++]
00B9A4  EB0000     CLR W0
00B9A6  781F80     MOV W0, [W15++]
00B9A8  EB0000     CLR W0
00B9AA  781F80     MOV W0, [W15++]
00B9AC  200400     MOV #0x40, W0
00B9AE  781F80     MOV W0, [W15++]
00B9B0  EB0000     CLR W0
00B9B2  781F80     MOV W0, [W15++]
00B9B4  200800     MOV #0x80, W0
00B9B6  781F80     MOV W0, [W15++]
00B9B8  EB0000     CLR W0
00B9BA  781F80     MOV W0, [W15++]
00B9BC  200807     MOV #0x80, W7
00B9BE  20C5E6     MOV #0xC5E, W6
00B9C0  9002AE     MOV [W14+4], W5
00B9C2  2003F4     MOV #0x3F, W4
00B9C4  2007F3     MOV #0x7F, W3
00B9C6  EB0100     CLR W2
00B9C8  EB0080     CLR W1
00B9CA  200030     MOV #0x3, W0
00B9CC  07F01A     RCALL MygrCreate
00B9CE  5787F2     SUB W15, #0x12, W15
00B9D0  8862D0     MOV W0, gr
186:               
187:                   state = ST_DRAW;
00B9D2  240000     MOV #0x4000, W0
00B9D4  980720     MOV W0, [W14+4]
188:                   measurement = StCreate (2, 0, 0, 128, 8, state, "MEASURING: DF", pScheme);
00B9D6  90039E     MOV [W14+2], W7
00B9D8  2D3896     MOV #0xD389, W6
00B9DA  9002AE     MOV [W14+4], W5
00B9DC  200084     MOV #0x8, W4
00B9DE  200803     MOV #0x80, W3
00B9E0  EB0100     CLR W2
00B9E2  EB0080     CLR W1
00B9E4  200020     MOV #0x2, W0
00B9E6  07FA42     RCALL StCreate
00B9E8  8862E0     MOV W0, measurement
189:               
190:                   setBarPos (gr, 64);
00B9EA  8062D0     MOV gr, W0
00B9EC  200401     MOV #0x40, W1
00B9EE  07F133     RCALL setBarPos
191:               }
00B9F0  FA8000     ULNK
00B9F2  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/controls.c  -----------------------------------
1:                 #include "globalPinout.h"
2:                 
3:                 #include "controls.h"
4:                 
5:                 #define KEY_NUM 5
6:                 #define KEYBOARD_BITS 3
7:                 
8:                 /*
9:                  * Codici dei tasti premuti
10:                 */
11:                char keyCodes [KEY_NUM][KEYBOARD_BITS] = {
12:                    {1, 1, 1}, //CONTROLS_NONE
13:                    {0, 1, 1}, //CONTROLS_T1
14:                    {1, 0, 1}, //CONTROLS_T2
15:                    {1, 1, 0}, //CONTROLS_T3
16:                    {1, 0, 0}  //CONTROLS_T4
17:                };
18:                
19:                /*
20:                 * Ritorna il tasto attualmente premuto (al momento la libreria supporta un
21:                 * solo tasto per volta)
22:                 *
23:                 * output:
24:                 *  - codice del tasto attualmente premuto
25:                 */
26:                keyID getPressedKey ()
27:                {
00C582  FA0002     LNK #0x2
28:                int i;
29:                
30:                    for (i = 0; i < KEY_NUM; i++)
00C584  EB0000     CLR W0
00C586  780F00     MOV W0, [W14]
00C588  37002C     BRA 0xC5E2
00C5E0  E80F1E     INC [W14], [W14]
00C5E2  78001E     MOV [W14], W0
00C5E4  500FE4     SUB W0, #0x4, [W15]
00C5E6  34FFD1     BRA LE, 0xC58A
31:                    {
32:                        if (P1_PORT == keyCodes[i][0] && P2_PORT == keyCodes[i][1] && P3_PORT == keyCodes[i][2])
00C58A  801650     MOV PORTB, W0
00C58C  DE004D     LSR W0, #13, W0
00C58E  604061     AND.B W0, #0x1, W0
00C590  FB8100     ZE W0, W2
00C592  78001E     MOV [W14], W0
00C594  B90063     MUL.SU W0, #3, W0
00C596  780080     MOV W0, W1
00C598  211240     MOV #0x1124, W0
00C59A  408000     ADD W1, W0, W0
00C59C  784010     MOV.B [W0], W0
00C59E  FB0000     SE W0, W0
00C5A0  510F80     SUB W2, W0, [W15]
00C5A2  3A001E     BRA NZ, 0xC5E0
00C5A4  801650     MOV PORTB, W0
00C5A6  DE0046     LSR W0, #6, W0
00C5A8  604061     AND.B W0, #0x1, W0
00C5AA  FB8100     ZE W0, W2
00C5AC  78001E     MOV [W14], W0
00C5AE  B90063     MUL.SU W0, #3, W0
00C5B0  780000     MOV W0, W0
00C5B2  E80080     INC W0, W1
00C5B4  211240     MOV #0x1124, W0
00C5B6  408000     ADD W1, W0, W0
00C5B8  784010     MOV.B [W0], W0
00C5BA  FB0000     SE W0, W0
00C5BC  510F80     SUB W2, W0, [W15]
00C5BE  3A0010     BRA NZ, 0xC5E0
00C5C0  801650     MOV PORTB, W0
00C5C2  DE0045     LSR W0, #5, W0
00C5C4  604061     AND.B W0, #0x1, W0
00C5C6  FB8100     ZE W0, W2
00C5C8  78001E     MOV [W14], W0
00C5CA  B90063     MUL.SU W0, #3, W0
00C5CC  780000     MOV W0, W0
00C5CE  E88080     INC2 W0, W1
00C5D0  211240     MOV #0x1124, W0
00C5D2  408000     ADD W1, W0, W0
00C5D4  784010     MOV.B [W0], W0
00C5D6  FB0000     SE W0, W0
00C5D8  510F80     SUB W2, W0, [W15]
00C5DA  3A0002     BRA NZ, 0xC5E0
33:                            return i;
00C5DC  78001E     MOV [W14], W0
00C5DE  370005     BRA 0xC5EA
34:                    }
35:                
36:                    return CONTROLS_NONE;
00C5E8  EB0000     CLR W0
37:                }
00C5EA  FA8000     ULNK
00C5EC  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/callbacks.c  ----------------------------------
1:                 #include "Graphics/GOL.h"
2:                 
3:                 WORD GOLDrawCallback ()
4:                 {
00C6B6  FA0000     LNK #0x0
5:                     //refreshSPIDisplay();
6:                 
7:                     return 1;
00C6B8  200010     MOV #0x1, W0
8:                 }
00C6BA  FA8000     ULNK
00C6BC  060000     RETURN
9:                 
10:                WORD GOLMsgCallback( WORD objMsg, OBJ_HEADER * pObj, GOL_MSG * pMsg)
11:                {
00C6BE  FA0006     LNK #0x6
00C6C0  780F00     MOV W0, [W14]
00C6C2  980711     MOV W1, [W14+2]
00C6C4  980722     MOV W2, [W14+4]
12:                    return 1;
00C6C6  200010     MOV #0x1, W0
13:                }
00C6C8  FA8000     ULNK
00C6CA  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/addressableBits.c  ----------------------------
1:                 #include "addressableBits.h"
2:                 
3:                 static unsigned int masks[MAX_BITS] = {0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff, 0x7ff, 0xfff, 0x1fff, 0x3fff, 0x7fff, 0xffff};
4:                 
5:                 addressableBit getAddressableBit (specialFunctionRegister reg, int startingBitN, int endingBitN)
6:                 {
00BFF6  FA000C     LNK #0xC
00BFF8  980731     MOV W1, [W14+6]
00BFFA  980742     MOV W2, [W14+8]
00BFFC  980753     MOV W3, [W14+10]
7:                 addressableBit ris;
8:                 
9:                     ris.reg = reg;
00BFFE  9000BE     MOV [W14+6], W1
00C000  780F01     MOV W1, [W14]
10:                
11:                    ris.startingBitN = startingBitN;
00C002  90014E     MOV [W14+8], W2
00C004  980712     MOV W2, [W14+2]
12:                    ris.endingBitN = endingBitN;
00C006  9001DE     MOV [W14+10], W3
00C008  980723     MOV W3, [W14+4]
13:                
14:                    return ris;
00C00A  BE011E     MOV.D [W14], W2
00C00C  BE8802     MOV.D W2, [W0]
00C00E  9001AE     MOV [W14+4], W3
00C010  980023     MOV W3, [W0+4]
15:                }
00C012  FA8000     ULNK
00C014  060000     RETURN
16:                
17:                inline void setBit (addressableBit bt, unsigned int value)
18:                {
00C016  FA000E     LNK #0xE
00C018  980730     MOV W0, [W14+6]
00C01A  980741     MOV W1, [W14+8]
00C01C  980752     MOV W2, [W14+10]
00C01E  980763     MOV W3, [W14+12]
19:                    if (bt.endingBitN < MAX_BITS && bt.startingBitN <= bt.endingBitN)
00C020  90005E     MOV [W14+10], W0
00C022  500FEF     SUB W0, #0xF, [W15]
00C024  3C0030     BRA GT, 0xC086
00C026  9000CE     MOV [W14+8], W1
00C028  90005E     MOV [W14+10], W0
00C02A  508F80     SUB W1, W0, [W15]
00C02C  3C002C     BRA GT, 0xC086
20:                    {
21:                    unsigned int mask, diff, ris;
22:                
23:                        diff = (bt.endingBitN - bt.startingBitN);
00C02E  9000DE     MOV [W14+10], W1
00C030  90004E     MOV [W14+8], W0
00C032  508000     SUB W1, W0, W0
00C034  780F00     MOV W0, [W14]
24:                
25:                        mask = masks[diff];
00C036  78001E     MOV [W14], W0
00C038  400080     ADD W0, W0, W1
00C03A  2106E0     MOV #0x106E, W0
00C03C  408000     ADD W1, W0, W0
00C03E  780090     MOV [W0], W1
00C040  980711     MOV W1, [W14+2]
26:                
27:                        mask <<= bt.startingBitN;
00C042  90004E     MOV [W14+8], W0
00C044  90009E     MOV [W14+2], W1
00C046  DD0800     SL W1, W0, W0
00C048  980710     MOV W0, [W14+2]
28:                
29:                        value <<= bt.startingBitN;
00C04A  90004E     MOV [W14+8], W0
00C04C  9000EE     MOV [W14+12], W1
00C04E  DD0800     SL W1, W0, W0
00C050  980760     MOV W0, [W14+12]
30:                        value &= mask;
00C052  9000EE     MOV [W14+12], W1
00C054  90001E     MOV [W14+2], W0
00C056  608000     AND W1, W0, W0
00C058  980760     MOV W0, [W14+12]
31:                
32:                        ris = (*bt.reg);
00C05A  90003E     MOV [W14+6], W0
00C05C  780090     MOV [W0], W1
00C05E  980721     MOV W1, [W14+4]
33:                
34:                        ris |= value;
00C060  9000AE     MOV [W14+4], W1
00C062  90006E     MOV [W14+12], W0
00C064  708000     IOR W1, W0, W0
00C066  980720     MOV W0, [W14+4]
35:                
36:                        mask = ~mask;
00C068  90001E     MOV [W14+2], W0
00C06A  EA8000     COM W0, W0
00C06C  EA8081     COM W1, W1
00C06E  980710     MOV W0, [W14+2]
37:                
38:                        value |= mask;
00C070  9000EE     MOV [W14+12], W1
00C072  90001E     MOV [W14+2], W0
00C074  708000     IOR W1, W0, W0
00C076  980760     MOV W0, [W14+12]
39:                
40:                        ris &= value;
00C078  9000AE     MOV [W14+4], W1
00C07A  90006E     MOV [W14+12], W0
00C07C  608000     AND W1, W0, W0
00C07E  980720     MOV W0, [W14+4]
41:                
42:                        (*bt.reg) = ris;
00C080  90003E     MOV [W14+6], W0
00C082  9000AE     MOV [W14+4], W1
00C084  780801     MOV W1, [W0]
43:                    }
44:                
45:                }
00C086  FA8000     ULNK
00C088  060000     RETURN
46:                
47:                inline unsigned int getBit (addressableBit bt)
48:                {
00C08A  FA000A     LNK #0xA
00C08C  980720     MOV W0, [W14+4]
00C08E  980731     MOV W1, [W14+6]
00C090  980742     MOV W2, [W14+8]
49:                
50:                    if (bt.endingBitN < MAX_BITS && bt.startingBitN <= bt.endingBitN)
00C092  90004E     MOV [W14+8], W0
00C094  500FEF     SUB W0, #0xF, [W15]
00C096  3C001A     BRA GT, 0xC0CC
00C098  9000BE     MOV [W14+6], W1
00C09A  90004E     MOV [W14+8], W0
00C09C  508F80     SUB W1, W0, [W15]
00C09E  3C0016     BRA GT, 0xC0CC
51:                    {
52:                    unsigned int mask, diff;
53:                
54:                        diff = (bt.endingBitN - bt.startingBitN) + 1;
00C0A0  9000CE     MOV [W14+8], W1
00C0A2  90003E     MOV [W14+6], W0
00C0A4  508000     SUB W1, W0, W0
00C0A6  E80000     INC W0, W0
00C0A8  780F00     MOV W0, [W14]
55:                
56:                        mask = masks[diff];
00C0AA  78001E     MOV [W14], W0
00C0AC  400080     ADD W0, W0, W1
00C0AE  2106E0     MOV #0x106E, W0
00C0B0  408000     ADD W1, W0, W0
00C0B2  780090     MOV [W0], W1
00C0B4  980711     MOV W1, [W14+2]
57:                
58:                        mask <<= bt.startingBitN;
00C0B6  90003E     MOV [W14+6], W0
00C0B8  90009E     MOV [W14+2], W1
00C0BA  DD0800     SL W1, W0, W0
00C0BC  980710     MOV W0, [W14+2]
59:                
60:                        return ((*bt.reg) & mask)>>bt.startingBitN;
00C0BE  90002E     MOV [W14+4], W0
00C0C0  780090     MOV [W0], W1
00C0C2  90001E     MOV [W14+2], W0
00C0C4  608080     AND W1, W0, W1
00C0C6  90003E     MOV [W14+6], W0
00C0C8  DE0800     LSR W1, W0, W0
00C0CA  370001     BRA 0xC0CE
61:                    }
62:                
63:                    return 0;
00C0CC  EB0000     CLR W0
64:                }
00C0CE  FA8000     ULNK
00C0D0  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/OC1Control.c  ---------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include "OC1Control.h"
4:                 #include "timer2.h"
5:                 
6:                 #define OC1_RP 0x12
7:                 
8:                 #define OC1_TIMER2 0
9:                 #define OC1_TIMER3 1
10:                
11:                timer usedTmr;
12:                
13:                void OC1init (timerID tmr, OC1Mode mode)
14:                {
00BDB2  FA0006     LNK #0x6
00BDB4  980710     MOV W0, [W14+2]
00BDB6  980721     MOV W1, [W14+4]
15:                int oc1Timer;
16:                
17:                    OC1CONbits.OCM = OC1_DISABLED;
00BDB8  800C21     MOV OC1CON, W1
00BDBA  2FFF80     MOV #0xFFF8, W0
00BDBC  608000     AND W1, W0, W0
00BDBE  880C20     MOV W0, OC1CON
18:                
19:                    if (tmr == TIMER3)
00BDC0  90001E     MOV [W14+2], W0
00BDC2  500FE3     SUB W0, #0x3, [W15]
00BDC4  3A0003     BRA NZ, 0xBDCC
20:                    {
21:                        oc1Timer = OC1_TIMER3;
00BDC6  200010     MOV #0x1, W0
00BDC8  780F00     MOV W0, [W14]
00BDCA  370004     BRA 0xBDD4
22:                    }
23:                    else
24:                    {
25:                        oc1Timer = OC1_TIMER2;
00BDCC  EB0000     CLR W0
00BDCE  780F00     MOV W0, [W14]
26:                        tmr = TIMER2;
00BDD0  200010     MOV #0x1, W0
00BDD2  980710     MOV W0, [W14+2]
27:                    }
28:                
29:                    getTimer (tmr, &usedTmr);
00BDD4  210AA1     MOV #0x10AA, W1
00BDD6  90001E     MOV [W14+2], W0
00BDD8  0700E0     RCALL getTimer
30:                
31:                    OC1CONbits.OCTSEL = oc1Timer;
00BDDA  78001E     MOV [W14], W0
00BDDC  784000     MOV.B W0, W0
00BDDE  604061     AND.B W0, #0x1, W0
00BDE0  FB8000     ZE W0, W0
00BDE2  600061     AND W0, #0x1, W0
00BDE4  DD0043     SL W0, #3, W0
00BDE6  800C22     MOV OC1CON, W2
00BDE8  2FFF71     MOV #0xFFF7, W1
00BDEA  610081     AND W2, W1, W1
00BDEC  708000     IOR W1, W0, W0
00BDEE  880C20     MOV W0, OC1CON
32:                    OC1CONbits.OCM = mode;
00BDF0  90002E     MOV [W14+4], W0
00BDF2  784000     MOV.B W0, W0
00BDF4  604067     AND.B W0, #0x7, W0
00BDF6  FB8000     ZE W0, W0
00BDF8  600067     AND W0, #0x7, W0
00BDFA  800C22     MOV OC1CON, W2
00BDFC  2FFF81     MOV #0xFFF8, W1
00BDFE  610081     AND W2, W1, W1
00BE00  708000     IOR W1, W0, W0
00BE02  880C20     MOV W0, OC1CON
33:                }
00BE04  FA8000     ULNK
00BE06  060000     RETURN
34:                
35:                void setOC1Interval (int uS)
36:                {
00BE08  FA0002     LNK #0x2
00BE0A  780F00     MOV W0, [W14]
37:                    usedTmr.setInterval (uS);
00BE0C  808562     MOV 0x10AC, W2
00BE0E  78001E     MOV [W14], W0
00BE10  DE80CF     ASR W0, #15, W1
00BE12  010002     CALL W2
38:                }
00BE14  FA8000     ULNK
00BE16  060000     RETURN
39:                
40:                void setOC1R (int val)
41:                {
00BE18  FA0002     LNK #0x2
00BE1A  780F00     MOV W0, [W14]
42:                    if (OC1R != val)
00BE1C  78009E     MOV [W14], W1
00BE1E  800C10     MOV OC1R, W0
00BE20  508F80     SUB W1, W0, [W15]
00BE22  320002     BRA Z, 0xBE28
43:                        OC1R = val;
00BE24  78001E     MOV [W14], W0
00BE26  880C10     MOV W0, OC1R
44:                }
00BE28  FA8000     ULNK
00BE2A  060000     RETURN
45:                
46:                void setOC1RS (int val)
47:                {
00BE2C  FA0002     LNK #0x2
00BE2E  780F00     MOV W0, [W14]
48:                    if (OC1RS != val)
00BE30  78009E     MOV [W14], W1
00BE32  800C00     MOV OC1RS, W0
00BE34  508F80     SUB W1, W0, [W15]
00BE36  320002     BRA Z, 0xBE3C
49:                        OC1RS = val;
00BE38  78001E     MOV [W14], W0
00BE3A  880C00     MOV W0, OC1RS
50:                }
00BE3C  FA8000     ULNK
00BE3E  060000     RETURN
51:                
52:                void OC1Start ()
53:                {
00BE40  FA0000     LNK #0x0
54:                    usedTmr.reset();
00BE42  8085B0     MOV 0x10B6, W0
00BE44  010000     CALL W0
55:                    usedTmr.start();
00BE46  808590     MOV 0x10B2, W0
00BE48  010000     CALL W0
56:                }
00BE4A  FA8000     ULNK
00BE4C  060000     RETURN
57:                
58:                void OC1Stop ()
59:                {
00BE4E  FA0000     LNK #0x0
60:                    usedTmr.stop();
00BE50  8085A0     MOV 0x10B4, W0
00BE52  010000     CALL W0
61:                }
00BE54  FA8000     ULNK
00BE56  060000     RETURN
62:                
63:                void setOC1PWM (long int freq, long int dutyCycle)
64:                {
00BE58  FA0026     LNK #0x26
00BE5A  980F70     MOV W0, [W14+30]
00BE5C  981701     MOV W1, [W14+32]
00BE5E  981712     MOV W2, [W14+34]
00BE60  981723     MOV W3, [W14+36]
65:                long int tOn, step, interval, freq2 = freq;
00BE62  90087E     MOV [W14+30], W0
00BE64  90108E     MOV [W14+32], W1
00BE66  BE8F00     MOV.D W0, [W14]
66:                int r;
67:                    
68:                
69:                    if (OC1CONbits.OCM != OC1_PWM && OC1CONbits.OCM != OC1_PWM_FAULT)
00BE68  800C20     MOV OC1CON, W0
00BE6A  600067     AND W0, #0x7, W0
00BE6C  500FE6     SUB W0, #0x6, [W15]
00BE6E  320009     BRA Z, 0xBE82
00BE70  800C20     MOV OC1CON, W0
00BE72  600067     AND W0, #0x7, W0
00BE74  500FE7     SUB W0, #0x7, [W15]
00BE76  320005     BRA Z, 0xBE82
70:                    {
71:                        OC1CONbits.OCM = OC1_PWM;
00BE78  800C21     MOV OC1CON, W1
00BE7A  2FFF80     MOV #0xFFF8, W0
00BE7C  608000     AND W1, W0, W0
00BE7E  B30060     IOR #0x6, W0
00BE80  880C20     MOV W0, OC1CON
72:                    }
73:                
74:                    long int a = 1000000, b = 2000, c;
00BE82  242400     MOV #0x4240, W0
00BE84  2000F1     MOV #0xF, W1
00BE86  980720     MOV W0, [W14+4]
00BE88  980731     MOV W1, [W14+6]
00BE8A  207D00     MOV #0x7D0, W0
00BE8C  200001     MOV #0x0, W1
00BE8E  980740     MOV W0, [W14+8]
00BE90  980751     MOV W1, [W14+10]
75:                
76:                
77:                    c = 1000000L/freq2;
00BE92  BE011E     MOV.D [W14], W2
00BE94  242400     MOV #0x4240, W0
00BE96  2000F1     MOV #0xF, W1
00BE98  07AD24     RCALL ___divsi3
00BE9A  980760     MOV W0, [W14+12]
00BE9C  980771     MOV W1, [W14+14]
78:                
79:                    interval = 1000000L/freq2;
00BE9E  BE011E     MOV.D [W14], W2
00BEA0  242400     MOV #0x4240, W0
00BEA2  2000F1     MOV #0xF, W1
00BEA4  07AD1E     RCALL ___divsi3
00BEA6  980F00     MOV W0, [W14+16]
00BEA8  980F11     MOV W1, [W14+18]
80:                
81:                    tOn = (dutyCycle * interval)/100;
00BEAA  9010AE     MOV [W14+36], W1
00BEAC  90080E     MOV [W14+16], W0
00BEAE  B98800     MUL.SS W1, W0, W0
00BEB0  780100     MOV W0, W2
00BEB2  90089E     MOV [W14+18], W1
00BEB4  90101E     MOV [W14+34], W0
00BEB6  B98800     MUL.SS W1, W0, W0
00BEB8  780000     MOV W0, W0
00BEBA  410100     ADD W2, W0, W2
00BEBC  90109E     MOV [W14+34], W1
00BEBE  90080E     MOV [W14+16], W0
00BEC0  B80800     MUL.UU W1, W0, W0
00BEC2  410101     ADD W2, W1, W2
00BEC4  780082     MOV W2, W1
00BEC6  200642     MOV #0x64, W2
00BEC8  200003     MOV #0x0, W3
00BECA  07AD0B     RCALL ___divsi3
00BECC  980F20     MOV W0, [W14+20]
00BECE  980F31     MOV W1, [W14+22]
82:                
83:                    step = 1000000L / usedTmr.getFreq();
00BED0  808600     MOV 0x10C0, W0
00BED2  010000     CALL W0
00BED4  BE0100     MOV.D W0, W2
00BED6  242400     MOV #0x4240, W0
00BED8  2000F1     MOV #0xF, W1
00BEDA  07AD03     RCALL ___divsi3
00BEDC  980F40     MOV W0, [W14+24]
00BEDE  980F51     MOV W1, [W14+26]
84:                
85:                    r = tOn / step;
00BEE0  90094E     MOV [W14+24], W2
00BEE2  9009DE     MOV [W14+26], W3
00BEE4  90082E     MOV [W14+20], W0
00BEE6  9008BE     MOV [W14+22], W1
00BEE8  07ACFC     RCALL ___divsi3
00BEEA  980F60     MOV W0, [W14+28]
86:                
87:                    //OC1Stop();
88:                
89:                    setOC1Interval (interval);
00BEEC  90080E     MOV [W14+16], W0
00BEEE  07FF8C     RCALL setOC1Interval
90:                    setOC1R (r);
00BEF0  90086E     MOV [W14+28], W0
00BEF2  07FF92     RCALL setOC1R
91:                    setOC1RS (r);
00BEF4  90086E     MOV [W14+28], W0
00BEF6  07FF9A     RCALL setOC1RS
92:                
93:                    //usedTmr.reset();
94:                    //OC1Start();
95:                }
00BEF8  FA8000     ULNK
00BEFA  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/MyGraph.c  ------------------------------------
1:                 #include "Graphics/Graphics.h"
2:                 #include "MyGraph.h"
3:                 #include "Graphics/Primitive.h"
4:                 #include "SPIDisplay.h"
5:                 #include "Graphics/DisplayDriver.h"
6:                 
7:                 inline int isInsideDNDR (int x, int y, rect dndr);
8:                 inline void drawBar (int x, int y, int height, int top, GFX_COLOR cBk, GFX_COLOR c0);
9:                 inline void drawBarSpeedDNDR (int x, int y, int height, int top, GFX_COLOR cBk, GFX_COLOR c0, rect dndr);
10:                /*
11:                 * Crea un nuovo grafico (istogramma con colonne larghe 1 px)
12:                 */
13:                
14:                MYGRAPH  *MygrCreate
15:                        (
16:                            WORD        ID,
17:                            SHORT       left,
18:                            SHORT       top,
19:                            SHORT       right,
20:                            SHORT       bottom,
21:                            WORD        state,
22:                            int *dataSerie,
23:                            int dataNum,
24:                            int first,
25:                            int last,
26:                            int barPos,
27:                            int maxValue,
28:                            int leftDNDR,
29:                            int topDNDR,
30:                            int rightDNDR,
31:                            int bottomDNDR,
32:                            GOL_SCHEME  *pScheme
33:                        )
34:                {
009A02  FA0014     LNK #0x14
009A04  980720     MOV W0, [W14+4]
009A06  980731     MOV W1, [W14+6]
009A08  980742     MOV W2, [W14+8]
009A0A  980753     MOV W3, [W14+10]
009A0C  980764     MOV W4, [W14+12]
009A0E  980775     MOV W5, [W14+14]
009A10  980F06     MOV W6, [W14+16]
009A12  980F17     MOV W7, [W14+18]
35:                    int i = 0;
009A14  EB0000     CLR W0
009A16  780F00     MOV W0, [W14]
36:                    MYGRAPH  *pB = NULL;
009A18  EB0000     CLR W0
009A1A  980710     MOV W0, [W14+2]
37:                    pB = (MYGRAPH *)GFX_malloc(sizeof(MYGRAPH));
009A1C  200300     MOV #0x30, W0
009A1E  07C298     RCALL _malloc
009A20  980710     MOV W0, [W14+2]
38:                    if(pB == NULL)
009A22  90001E     MOV [W14+2], W0
009A24  500FE0     SUB W0, #0x0, [W15]
009A26  3A0002     BRA NZ, 0x9A2C
39:                        return (NULL);
009A28  EB0000     CLR W0
009A2A  370056     BRA 0x9AD8
40:                
41:                    pB -> dataValid = (char *)GFX_malloc(sizeof(char)*dataNum);
009A2C  90081E     MOV [W14+18], W0
009A2E  07C290     RCALL _malloc
009A30  780080     MOV W0, W1
009A32  90001E     MOV [W14+2], W0
009A34  981031     MOV W1, [W0+38]
42:                    
43:                    pB->hdr.ID = ID;                        // unique id assigned for referencing
009A36  90001E     MOV [W14+2], W0
009A38  9000AE     MOV [W14+4], W1
009A3A  780801     MOV W1, [W0]
44:                    pB->hdr.pNxtObj = NULL;                 // initialize pointer to NULL
009A3C  90001E     MOV [W14+2], W0
009A3E  EB0080     CLR W1
009A40  980011     MOV W1, [W0+2]
45:                    pB->hdr.type = OBJ_UNKNOWN;              // set object type
009A42  90001E     MOV [W14+2], W0
009A44  200131     MOV #0x13, W1
009A46  980021     MOV W1, [W0+4]
46:                    pB->hdr.left = left;                    // left position
009A48  90001E     MOV [W14+2], W0
009A4A  9000BE     MOV [W14+6], W1
009A4C  980041     MOV W1, [W0+8]
47:                    pB->hdr.top = top;                      // top position
009A4E  90001E     MOV [W14+2], W0
009A50  9000CE     MOV [W14+8], W1
009A52  980051     MOV W1, [W0+10]
48:                    pB->hdr.right = right;                  // right position
009A54  90001E     MOV [W14+2], W0
009A56  9000DE     MOV [W14+10], W1
009A58  980061     MOV W1, [W0+12]
49:                    pB->hdr.bottom = bottom;                // bottom position
009A5A  90001E     MOV [W14+2], W0
009A5C  9000EE     MOV [W14+12], W1
009A5E  980071     MOV W1, [W0+14]
50:                    pB->hdr.state = state;                  // state
009A60  90001E     MOV [W14+2], W0
009A62  9000FE     MOV [W14+14], W1
009A64  980031     MOV W1, [W0+6]
51:                    pB->hdr.DrawObj = MygrDraw;              // draw function
009A66  90001E     MOV [W14+2], W0
009A68  29AF41     MOV #0x9AF4, W1
009A6A  980811     MOV W1, [W0+18]
52:                    pB->hdr.MsgObj = MygrTranslateMsg;       // message function
009A6C  90001E     MOV [W14+2], W0
009A6E  29ADC1     MOV #0x9ADC, W1
009A70  980831     MOV W1, [W0+22]
53:                    pB->hdr.MsgDefaultObj = MygrMsgDefault;  // default message function
009A72  90001E     MOV [W14+2], W0
009A74  29AE81     MOV #0x9AE8, W1
009A76  980841     MOV W1, [W0+24]
54:                    pB->hdr.FreeObj = NULL;  				// free function
009A78  90001E     MOV [W14+2], W0
009A7A  EB0080     CLR W1
009A7C  980821     MOV W1, [W0+20]
55:                
56:                    pB->dataSerie = dataSerie;
009A7E  90001E     MOV [W14+2], W0
009A80  90088E     MOV [W14+16], W1
009A82  980851     MOV W1, [W0+26]
57:                    pB->dataNum = dataNum;
009A84  90001E     MOV [W14+2], W0
009A86  90089E     MOV [W14+18], W1
009A88  980861     MOV W1, [W0+28]
58:                    pB->first = first;
009A8A  90001E     MOV [W14+2], W0
009A8C  97B8CE     MOV [W14-8], W1
009A8E  980871     MOV W1, [W0+30]
59:                    pB->last = last;
009A90  90001E     MOV [W14+2], W0
009A92  97B8BE     MOV [W14-10], W1
009A94  981001     MOV W1, [W0+32]
60:                    pB->barPos = barPos;
009A96  90001E     MOV [W14+2], W0
009A98  97B8AE     MOV [W14-12], W1
009A9A  981011     MOV W1, [W0+34]
61:                    pB->maxValue = maxValue;
009A9C  90001E     MOV [W14+2], W0
009A9E  97B89E     MOV [W14-14], W1
009AA0  981021     MOV W1, [W0+36]
62:                
63:                    pB->doNotDrawArea.left = leftDNDR;
009AA2  90001E     MOV [W14+2], W0
009AA4  97B88E     MOV [W14-16], W1
009AA6  981041     MOV W1, [W0+40]
64:                    pB->doNotDrawArea.top = topDNDR;
009AA8  90001E     MOV [W14+2], W0
009AAA  97B0FE     MOV [W14-18], W1
009AAC  981051     MOV W1, [W0+42]
65:                    pB->doNotDrawArea.right = rightDNDR;
009AAE  90001E     MOV [W14+2], W0
009AB0  97B0EE     MOV [W14-20], W1
009AB2  981061     MOV W1, [W0+44]
66:                    pB->doNotDrawArea.bottom = bottomDNDR;
009AB4  90001E     MOV [W14+2], W0
009AB6  97B0DE     MOV [W14-22], W1
009AB8  981071     MOV W1, [W0+46]
67:                
68:                    // Set the color scheme to be used
69:                    if(pScheme == NULL)
009ABA  97B04E     MOV [W14-24], W0
009ABC  500FE0     SUB W0, #0x0, [W15]
009ABE  3A0004     BRA NZ, 0x9AC8
70:                        pB->hdr.pGolScheme = _pDefaultGolScheme;
009AC0  808B41     MOV 0x1168, W1
009AC2  90001E     MOV [W14+2], W0
009AC4  980801     MOV W1, [W0+16]
009AC6  370003     BRA 0x9ACE
71:                    else
72:                        pB->hdr.pGolScheme = (GOL_SCHEME *)pScheme;
009AC8  90001E     MOV [W14+2], W0
009ACA  97B0CE     MOV [W14-24], W1
009ACC  980801     MOV W1, [W0+16]
73:                
74:                    GOLAddObject((OBJ_HEADER *)pB);
009ACE  90001E     MOV [W14+2], W0
009AD0  07F5A1     RCALL GOLAddObject
75:                
76:                    invalidateMyGraph (pB);
009AD2  90001E     MOV [W14+2], W0
009AD4  070277     RCALL invalidateMyGraph
77:                
78:                    return (pB);
009AD6  90001E     MOV [W14+2], W0
79:                }
009AD8  FA8000     ULNK
009ADA  060000     RETURN
80:                
81:                /*
82:                 * Traduzione messaggi. Non implementata al momento.
83:                 */
84:                WORD    MygrTranslateMsg(void *pObj, GOL_MSG *pMsg)
85:                {
009ADC  FA0004     LNK #0x4
009ADE  780F00     MOV W0, [W14]
009AE0  980711     MOV W1, [W14+2]
86:                    return 0;
009AE2  EB0000     CLR W0
87:                }
009AE4  FA8000     ULNK
009AE6  060000     RETURN
88:                
89:                /*
90:                 * Comportamento di default ai messaggi. Non implementata al momento.
91:                 */
92:                void    MygrMsgDefault(WORD translatedMsg, void *pObj, GOL_MSG *pMsg)
93:                {
009AE8  FA0006     LNK #0x6
009AEA  780F00     MOV W0, [W14]
009AEC  980711     MOV W1, [W14+2]
009AEE  980722     MOV W2, [W14+4]
94:                
95:                }
009AF0  FA8000     ULNK
009AF2  060000     RETURN
96:                
97:                /*
98:                 * Disegna sullo schermo il grafico
99:                 */
100:               WORD MygrDraw(void *pObj)
101:               {
009AF4  FA0018     LNK #0x18
009AF6  980F30     MOV W0, [W14+22]
102:               int i, prop, height, first, last, *dataSerie, x, y, max, propEn;
103:               MYGRAPH *pMygr = (MYGRAPH*)pObj;
009AF8  90083E     MOV [W14+22], W0
009AFA  980720     MOV W0, [W14+4]
104:               
105:                   height = (pMygr->hdr.bottom - pMygr->hdr.top) + 1;
009AFC  90002E     MOV [W14+4], W0
009AFE  9000F0     MOV [W0+14], W1
009B00  90002E     MOV [W14+4], W0
009B02  900050     MOV [W0+10], W0
009B04  508000     SUB W1, W0, W0
009B06  E80000     INC W0, W0
009B08  980730     MOV W0, [W14+6]
106:               
107:                   first = pMygr->first;
009B0A  90002E     MOV [W14+4], W0
009B0C  9008F0     MOV [W0+30], W1
009B0E  980741     MOV W1, [W14+8]
108:                   last = pMygr->last;
009B10  90002E     MOV [W14+4], W0
009B12  901100     MOV [W0+32], W2
009B14  980752     MOV W2, [W14+10]
109:               
110:                   max = pMygr->maxValue;
009B16  90002E     MOV [W14+4], W0
009B18  9010A0     MOV [W0+36], W1
009B1A  980761     MOV W1, [W14+12]
111:               
112:                   dataSerie = pMygr->dataSerie;
009B1C  90002E     MOV [W14+4], W0
009B1E  900950     MOV [W0+26], W2
009B20  980772     MOV W2, [W14+14]
113:               
114:                   y = pMygr->hdr.bottom;
009B22  90002E     MOV [W14+4], W0
009B24  9000F0     MOV [W0+14], W1
009B26  980F01     MOV W1, [W14+16]
115:               
116:                   propEn = !(max == height);
009B28  9000EE     MOV [W14+12], W1
009B2A  90003E     MOV [W14+6], W0
009B2C  688000     XOR W1, W0, W0
009B2E  EA0080     NEG W0, W1
009B30  708000     IOR W1, W0, W0
009B32  DE004F     LSR W0, #15, W0
009B34  980F10     MOV W0, [W14+18]
117:               
118:                   for (i = first, x = pMygr->hdr.left; i <= last && x <= pMygr->hdr.right; i++, x++)
009B36  90014E     MOV [W14+8], W2
009B38  780F02     MOV W2, [W14]
009B3A  90002E     MOV [W14+4], W0
009B3C  9000C0     MOV [W0+8], W1
009B3E  980711     MOV W1, [W14+2]
009B40  370078     BRA 0x9C32
009C2A  E80F1E     INC [W14], [W14]
009C2C  90001E     MOV [W14+2], W0
009C2E  E80000     INC W0, W0
009C30  980710     MOV W0, [W14+2]
009C32  90005E     MOV [W14+10], W0
009C34  78009E     MOV [W14], W1
009C36  508F80     SUB W1, W0, [W15]
009C38  3C0005     BRA GT, 0x9C44
009C3A  90002E     MOV [W14+4], W0
009C3C  9000E0     MOV [W0+12], W1
009C3E  90001E     MOV [W14+2], W0
009C40  508F80     SUB W1, W0, [W15]
009C42  3DFF7F     BRA GE, 0x9B42
119:                   {
120:                       if (pMygr->dataValid[i] == DATA_INVALID)
009B42  90002E     MOV [W14+4], W0
009B44  9010B0     MOV [W0+38], W1
009B46  78001E     MOV [W14], W0
009B48  408000     ADD W1, W0, W0
009B4A  784010     MOV.B [W0], W0
009B4C  504FE0     SUB.B W0, #0x0, [W15]
009B4E  3A006D     BRA NZ, 0x9C2A
121:                       {
122:                           prop = propEn?(dataSerie[i]*height)/max:dataSerie[i];
009B50  90081E     MOV [W14+18], W0
009B52  500FE0     SUB W0, #0x0, [W15]
009B54  32000D     BRA Z, 0x9B70
009B56  78001E     MOV [W14], W0
009B58  400000     ADD W0, W0, W0
009B5A  9000FE     MOV [W14+14], W1
009B5C  408000     ADD W1, W0, W0
009B5E  780090     MOV [W0], W1
009B60  90003E     MOV [W14+6], W0
009B62  B98800     MUL.SS W1, W0, W0
009B64  780080     MOV W0, W1
009B66  90006E     MOV [W14+12], W0
009B68  780100     MOV W0, W2
009B6A  090011     REPEAT #0x11
009B6C  D80082     DIV.SW W1, W2
009B6E  370005     BRA 0x9B7A
009B70  78001E     MOV [W14], W0
009B72  400000     ADD W0, W0, W0
009B74  9000FE     MOV [W14+14], W1
009B76  408000     ADD W1, W0, W0
009B78  780010     MOV [W0], W0
009B7A  980F20     MOV W0, [W14+20]
123:               
124:                           if (i != pMygr->barPos)
009B7C  90002E     MOV [W14+4], W0
009B7E  901010     MOV [W0+34], W0
009B80  500F9E     SUB W0, [W14], [W15]
009B82  320035     BRA Z, 0x9BEE
125:                           {
126:                               #if defined (GFX_USE_DISPLAY_CONTROLLER_ST7565R)
127:                                   if (pMygr->hdr.state & MYGR_OPTIMIZED)
009B84  90002E     MOV [W14+4], W0
009B86  900030     MOV [W0+6], W0
009B88  600061     AND W0, #0x1, W0
009B8A  784000     MOV.B W0, W0
009B8C  504FE0     SUB.B W0, #0x0, [W15]
009B8E  320016     BRA Z, 0x9BBC
128:                                       drawBarSpeedDNDR (x, y, prop, pMygr->hdr.top, pMygr->hdr.pGolScheme->CommonBkColor, pMygr->hdr.pGolScheme->Color0, pMygr->doNotDrawArea);
009B90  90002E     MOV [W14+4], W0
009B92  900800     MOV [W0+16], W0
009B94  9042D0     MOV.B [W0+5], W5
009B96  90002E     MOV [W14+4], W0
009B98  900800     MOV [W0+16], W0
009B9A  904A00     MOV.B [W0+8], W4
009B9C  90002E     MOV [W14+4], W0
009B9E  900350     MOV [W0+10], W6
009BA0  90002E     MOV [W14+4], W0
009BA2  9010D0     MOV [W0+42], W1
009BA4  901160     MOV [W0+44], W2
009BA6  9011F0     MOV [W0+46], W3
009BA8  901040     MOV [W0+40], W0
009BAA  BE9F80     MOV.D W0, [W15++]
009BAC  BE9F82     MOV.D W2, [W15++]
009BAE  780186     MOV W6, W3
009BB0  90092E     MOV [W14+20], W2
009BB2  90088E     MOV [W14+16], W1
009BB4  90001E     MOV [W14+2], W0
009BB6  07015C     RCALL drawBarSpeedDNDR
009BB8  5787E8     SUB W15, #0x8, W15
009BBA  370031     BRA 0x9C1E
129:                                   else
130:                                       drawBarDNDR (x, y, prop, pMygr->hdr.top, pMygr->hdr.pGolScheme->CommonBkColor, pMygr->hdr.pGolScheme->Color0, pMygr->doNotDrawArea);
009BBC  29C826     MOV #0x9C82, W6
009BBE  90002E     MOV [W14+4], W0
009BC0  900800     MOV [W0+16], W0
009BC2  904050     MOV.B [W0+5], W0
009BC4  FB8280     ZE W0, W5
009BC6  90002E     MOV [W14+4], W0
009BC8  900800     MOV [W0+16], W0
009BCA  904800     MOV.B [W0+8], W0
009BCC  FB8200     ZE W0, W4
009BCE  90002E     MOV [W14+4], W0
009BD0  9003D0     MOV [W0+10], W7
009BD2  90002E     MOV [W14+4], W0
009BD4  9010D0     MOV [W0+42], W1
009BD6  901160     MOV [W0+44], W2
009BD8  9011F0     MOV [W0+46], W3
009BDA  901040     MOV [W0+40], W0
009BDC  BE9F80     MOV.D W0, [W15++]
009BDE  BE9F82     MOV.D W2, [W15++]
009BE0  780187     MOV W7, W3
009BE2  90092E     MOV [W14+20], W2
009BE4  90088E     MOV [W14+16], W1
009BE6  90001E     MOV [W14+2], W0
009BE8  010006     CALL W6
009BEA  5787E8     SUB W15, #0x8, W15
009BEC  370018     BRA 0x9C1E
131:                               #else
132:                                   drawBarDNDR (x, y, prop, pMygr->hdr.top, pMygr->hdr.pGolScheme->CommonBkColor, pMygr->hdr.pGolScheme->Color0, pMygr->doNotDrawArea);
133:                               #endif
134:                           }
135:                           else
136:                           {
137:                               drawBarDNDR (x, y, prop, pMygr->hdr.top, pMygr->hdr.pGolScheme->Color0, pMygr->hdr.pGolScheme->CommonBkColor, pMygr->doNotDrawArea);
009BEE  29C826     MOV #0x9C82, W6
009BF0  90002E     MOV [W14+4], W0
009BF2  900800     MOV [W0+16], W0
009BF4  904800     MOV.B [W0+8], W0
009BF6  FB8280     ZE W0, W5
009BF8  90002E     MOV [W14+4], W0
009BFA  900800     MOV [W0+16], W0
009BFC  904050     MOV.B [W0+5], W0
009BFE  FB8200     ZE W0, W4
009C00  90002E     MOV [W14+4], W0
009C02  9003D0     MOV [W0+10], W7
009C04  90002E     MOV [W14+4], W0
009C06  9010D0     MOV [W0+42], W1
009C08  901160     MOV [W0+44], W2
009C0A  9011F0     MOV [W0+46], W3
009C0C  901040     MOV [W0+40], W0
009C0E  BE9F80     MOV.D W0, [W15++]
009C10  BE9F82     MOV.D W2, [W15++]
009C12  780187     MOV W7, W3
009C14  90092E     MOV [W14+20], W2
009C16  90088E     MOV [W14+16], W1
009C18  90001E     MOV [W14+2], W0
009C1A  010006     CALL W6
009C1C  5787E8     SUB W15, #0x8, W15
138:                               //drawBar (x, y, prop, pMygr->hdr.top, pMygr->hdr.pGolScheme->Color0, pMygr->hdr.pGolScheme->CommonBkColor);
139:                           }
140:                           pMygr->dataValid[i] = DATA_VALID;
009C1E  90002E     MOV [W14+4], W0
009C20  9010B0     MOV [W0+38], W1
009C22  78001E     MOV [W14], W0
009C24  408080     ADD W1, W0, W1
009C26  B3C010     MOV #0x1, W0
009C28  784880     MOV.B W0, [W1]
141:                       }
142:                       
143:                   }
144:               
145:                   pMygr->hdr.state &= ~(MYGR_DRAW);
009C44  90002E     MOV [W14+4], W0
009C46  9000B0     MOV [W0+6], W1
009C48  203FF0     MOV #0x3FF, W0
009C4A  608080     AND W1, W0, W1
009C4C  90002E     MOV [W14+4], W0
009C4E  980031     MOV W1, [W0+6]
146:               
147:                   return 1;
009C50  200010     MOV #0x1, W0
148:               }
009C52  FA8000     ULNK
009C54  060000     RETURN
149:               
150:               void setBarPos (MYGRAPH *pMygr, int val)
151:               {
009C56  FA0004     LNK #0x4
009C58  780F00     MOV W0, [W14]
009C5A  980711     MOV W1, [W14+2]
152:                   invalidateColumn (pMygr, pMygr->barPos);
009C5C  78001E     MOV [W14], W0
009C5E  901010     MOV [W0+34], W0
009C60  780080     MOV W0, W1
009C62  78001E     MOV [W14], W0
009C64  0701C9     RCALL invalidateColumn
153:                   pMygr->barPos = val;
009C66  78001E     MOV [W14], W0
009C68  90009E     MOV [W14+2], W1
009C6A  981011     MOV W1, [W0+34]
154:                   invalidateColumn (pMygr, val);
009C6C  90009E     MOV [W14+2], W1
009C6E  78001E     MOV [W14], W0
009C70  0701C3     RCALL invalidateColumn
155:               }
009C72  FA8000     ULNK
009C74  060000     RETURN
156:               
157:               int getBarPos (MYGRAPH *pMygr)
158:               {
009C76  FA0002     LNK #0x2
009C78  780F00     MOV W0, [W14]
159:                   return pMygr->barPos;
009C7A  78001E     MOV [W14], W0
009C7C  901010     MOV [W0+34], W0
160:               }
009C7E  FA8000     ULNK
009C80  060000     RETURN
161:               
162:               inline void drawBarDNDR (int x, int y, int height, int top, GFX_COLOR cBk, GFX_COLOR c0, rect dndr)
163:               {
009C82  FA0010     LNK #0x10
009C84  980730     MOV W0, [W14+6]
009C86  980741     MOV W1, [W14+8]
009C88  980752     MOV W2, [W14+10]
009C8A  980763     MOV W3, [W14+12]
009C8C  984F64     MOV.B W4, [W14+14]
009C8E  984F75     MOV.B W5, [W14+15]
164:                   int actY = y, actX = x, i;
009C90  90004E     MOV [W14+8], W0
009C92  780F00     MOV W0, [W14]
009C94  90003E     MOV [W14+6], W0
009C96  980720     MOV W0, [W14+4]
165:               
166:                   SetColor (c0);
009C98  90487E     MOV.B [W14+15], W0
009C9A  B7F13E     MOV.B WREG, _color
167:               
168:                   for (i = 0; i < height; i++)
009C9C  EB0000     CLR W0
009C9E  980710     MOV W0, [W14+2]
009CA0  370012     BRA 0x9CC6
009CC0  90001E     MOV [W14+2], W0
009CC2  E80000     INC W0, W0
009CC4  980710     MOV W0, [W14+2]
009CC6  90009E     MOV [W14+2], W1
009CC8  90005E     MOV [W14+10], W0
009CCA  508F80     SUB W1, W0, [W15]
009CCC  35FFEA     BRA LT, 0x9CA2
169:                   {
170:                       actY = y - i;
009CA2  9000CE     MOV [W14+8], W1
009CA4  90001E     MOV [W14+2], W0
009CA6  508F00     SUB W1, W0, [W14]
171:               
172:                       if (!isInsideDNDR(actX, actY, dndr))
009CA8  97BA1E     MOV [W14-14], W4
009CAA  97BAAE     MOV [W14-12], W5
009CAC  97BB3E     MOV [W14-10], W6
009CAE  97BBCE     MOV [W14-8], W7
009CB0  78009E     MOV [W14], W1
009CB2  90002E     MOV [W14+4], W0
009CB4  0701BA     RCALL isInsideDNDR
009CB6  500FE0     SUB W0, #0x0, [W15]
009CB8  3A0003     BRA NZ, 0x9CC0
173:                       {
174:                           PutPixel (actX, actY);
009CBA  78009E     MOV [W14], W1
009CBC  90002E     MOV [W14+4], W0
009CBE  0712F5     RCALL PutPixel
175:                       }
176:                   }
177:               
178:                   actY = y - i;
009CCE  9000CE     MOV [W14+8], W1
009CD0  90001E     MOV [W14+2], W0
009CD2  508F00     SUB W1, W0, [W14]
179:               
180:                   SetColor (cBk);
009CD4  781F80     MOV W0, [W15++]
009CD6  90486E     MOV.B [W14+14], W0
009CD8  B7F13E     MOV.B WREG, _color
009CDA  78004F     MOV [--W15], W0
181:               
182:                   for (; actY >= top; actY--)
009CDC  37000D     BRA 0x9CF8
009CF6  E90F1E     DEC [W14], [W14]
009CF8  90006E     MOV [W14+12], W0
009CFA  78009E     MOV [W14], W1
009CFC  508F80     SUB W1, W0, [W15]
009CFE  3DFFEF     BRA GE, 0x9CDE
183:                   {
184:                       if (!isInsideDNDR(actX, actY, dndr))
009CDE  97BA1E     MOV [W14-14], W4
009CE0  97BAAE     MOV [W14-12], W5
009CE2  97BB3E     MOV [W14-10], W6
009CE4  97BBCE     MOV [W14-8], W7
009CE6  78009E     MOV [W14], W1
009CE8  90002E     MOV [W14+4], W0
009CEA  07019F     RCALL isInsideDNDR
009CEC  500FE0     SUB W0, #0x0, [W15]
009CEE  3A0003     BRA NZ, 0x9CF6
185:                       {
186:                           PutPixel (actX, actY);
009CF0  78009E     MOV [W14], W1
009CF2  90002E     MOV [W14+4], W0
009CF4  0712DA     RCALL PutPixel
187:                       }
188:                   }
189:               }
009D00  FA8000     ULNK
009D02  060000     RETURN
190:               
191:               inline void drawBar (int x, int y, int height, int top, GFX_COLOR cBk, GFX_COLOR c0)
192:               {
009D04  FA000A     LNK #0xA
009D06  780F00     MOV W0, [W14]
009D08  980711     MOV W1, [W14+2]
009D0A  980722     MOV W2, [W14+4]
009D0C  980733     MOV W3, [W14+6]
009D0E  984F04     MOV.B W4, [W14+8]
009D10  984F15     MOV.B W5, [W14+9]
193:                   if (height > 0)
009D12  90002E     MOV [W14+4], W0
009D14  500FE0     SUB W0, #0x0, [W15]
009D16  34001D     BRA LE, 0x9D52
194:                   {
195:                       SetColor (c0);
009D18  90481E     MOV.B [W14+9], W0
009D1A  B7F13E     MOV.B WREG, _color
196:                       Line (x, y, x, y - (height - 1));
009D1C  90002E     MOV [W14+4], W0
009D1E  1000E1     SUBR W0, #0x1, W1
009D20  90001E     MOV [W14+2], W0
009D22  408000     ADD W1, W0, W0
009D24  780180     MOV W0, W3
009D26  78011E     MOV [W14], W2
009D28  90009E     MOV [W14+2], W1
009D2A  78001E     MOV [W14], W0
009D2C  07DBEA     RCALL Line
197:               
198:                       if ((y - (height - 2)) > top)
009D2E  90002E     MOV [W14+4], W0
009D30  1000E2     SUBR W0, #0x2, W1
009D32  90001E     MOV [W14+2], W0
009D34  408080     ADD W1, W0, W1
009D36  90003E     MOV [W14+6], W0
009D38  508F80     SUB W1, W0, [W15]
009D3A  340012     BRA LE, 0x9D60
199:                       {
200:                           SetColor (cBk);
009D3C  90480E     MOV.B [W14+8], W0
009D3E  B7F13E     MOV.B WREG, _color
201:                           Line (x, y - (height), x, top);
009D40  90009E     MOV [W14+2], W1
009D42  90002E     MOV [W14+4], W0
009D44  508000     SUB W1, W0, W0
009D46  9001BE     MOV [W14+6], W3
009D48  78011E     MOV [W14], W2
009D4A  780080     MOV W0, W1
009D4C  78001E     MOV [W14], W0
009D4E  07DBD9     RCALL Line
009D50  370007     BRA 0x9D60
202:                       }
203:                   }
204:                   else
205:                   {
206:                       SetColor (cBk);
009D52  90480E     MOV.B [W14+8], W0
009D54  B7F13E     MOV.B WREG, _color
207:                       Line (x, y, x, top);
009D56  9001BE     MOV [W14+6], W3
009D58  78011E     MOV [W14], W2
009D5A  90009E     MOV [W14+2], W1
009D5C  78001E     MOV [W14], W0
009D5E  07DBD1     RCALL Line
208:                   }
209:               }
009D60  FA8000     ULNK
009D62  060000     RETURN
210:               
211:               inline void drawBarSpeed (int x, int y, int height, int top, GFX_COLOR cBk, GFX_COLOR c0)
212:               {
009D64  FA0010     LNK #0x10
009D66  980730     MOV W0, [W14+6]
009D68  980741     MOV W1, [W14+8]
009D6A  980752     MOV W2, [W14+10]
009D6C  980763     MOV W3, [W14+12]
009D6E  984F64     MOV.B W4, [W14+14]
009D70  984F75     MOV.B W5, [W14+15]
213:               char act, iPix = (y - ((y>>3)<<3)) + 1, i, numBlack, little = 0;
009D72  90004E     MOV [W14+8], W0
009D74  784000     MOV.B W0, W0
009D76  604067     AND.B W0, #0x7, W0
009D78  E84000     INC.B W0, W0
009D7A  984710     MOV.B W0, [W14+1]
009D7C  EB4000     CLR.B W0
009D7E  984730     MOV.B W0, [W14+3]
214:               
215:                   //prima pagina
216:                       act = 0;
009D80  EB4000     CLR.B W0
009D82  784F00     MOV.B W0, [W14]
217:               
218:                       if (height < iPix)
009D84  90401E     MOV.B [W14+1], W0
009D86  FB0080     SE W0, W1
009D88  90005E     MOV [W14+10], W0
009D8A  508F80     SUB W1, W0, [W15]
009D8C  340004     BRA LE, 0x9D96
219:                       {
220:                           iPix = height;
009D8E  90005E     MOV [W14+10], W0
009D90  984710     MOV.B W0, [W14+1]
221:                           little = 1;
009D92  B3C010     MOV #0x1, W0
009D94  984730     MOV.B W0, [W14+3]
222:                       }
223:               
224:                       for ( i = 0; i < iPix; i++)
009D96  EB4000     CLR.B W0
009D98  984720     MOV.B W0, [W14+2]
009D9A  370007     BRA 0x9DAA
009DA4  90402E     MOV.B [W14+2], W0
009DA6  E84000     INC.B W0, W0
009DA8  984720     MOV.B W0, [W14+2]
009DAA  9040AE     MOV.B [W14+2], W1
009DAC  90401E     MOV.B [W14+1], W0
009DAE  50CF80     SUB.B W1, W0, [W15]
009DB0  35FFF5     BRA LT, 0x9D9C
225:                       {
226:                           act = (act<<1) + 1;
009D9C  78401E     MOV.B [W14], W0
009D9E  404000     ADD.B W0, W0, W0
009DA0  E84000     INC.B W0, W0
009DA2  784F00     MOV.B W0, [W14]
227:                       }
228:                       act <<= 8 - iPix;
009DB2  FB009E     SE [W14], W1
009DB4  90401E     MOV.B [W14+1], W0
009DB6  FB0000     SE W0, W0
009DB8  100068     SUBR W0, #0x8, W0
009DBA  DD0800     SL W1, W0, W0
009DBC  784F00     MOV.B W0, [W14]
229:                       
230:               
231:                       setPageSPIDisplay (x, y, act);
009DBE  78411E     MOV.B [W14], W2
009DC0  9000CE     MOV [W14+8], W1
009DC2  90003E     MOV [W14+6], W0
009DC4  0705EC     RCALL setPageSPIDisplay
232:               
233:                       if (little)
009DC6  90403E     MOV.B [W14+3], W0
009DC8  504FE0     SUB.B W0, #0x0, [W15]
009DCA  320004     BRA Z, 0x9DD4
234:                           y -= 8;
009DCC  90004E     MOV [W14+8], W0
009DCE  500068     SUB W0, #0x8, W0
009DD0  980740     MOV W0, [W14+8]
009DD2  370006     BRA 0x9DE0
235:                       else
236:                           y -= iPix + 1;
009DD4  90401E     MOV.B [W14+1], W0
009DD6  FB0000     SE W0, W0
009DD8  EA8000     COM W0, W0
009DDA  9000CE     MOV [W14+8], W1
009DDC  408000     ADD W1, W0, W0
009DDE  980740     MOV W0, [W14+8]
237:               
238:                       //pagine solo nere
239:               
240:                       height -= iPix;
009DE0  90401E     MOV.B [W14+1], W0
009DE2  FB0000     SE W0, W0
009DE4  9000DE     MOV [W14+10], W1
009DE6  508000     SUB W1, W0, W0
009DE8  980750     MOV W0, [W14+10]
241:               
242:                       numBlack = height >> 3;
009DEA  90005E     MOV [W14+10], W0
009DEC  DE8043     ASR W0, #3, W0
009DEE  984740     MOV.B W0, [W14+4]
243:               
244:                       for (i = 0; i < numBlack; i++)
009DF0  EB4000     CLR.B W0
009DF2  984720     MOV.B W0, [W14+2]
009DF4  37000F     BRA 0x9E14
009E0E  90402E     MOV.B [W14+2], W0
009E10  E84000     INC.B W0, W0
009E12  984720     MOV.B W0, [W14+2]
009E14  9040AE     MOV.B [W14+2], W1
009E16  90404E     MOV.B [W14+4], W0
009E18  50CF80     SUB.B W1, W0, [W15]
009E1A  35FFED     BRA LT, 0x9DF6
245:                       {
246:                           act = 0xFF;
009DF6  EBC000     SETM.B W0
009DF8  784F00     MOV.B W0, [W14]
247:               
248:                           setPageSPIDisplay (x, y, act);
009DFA  78411E     MOV.B [W14], W2
009DFC  9000CE     MOV [W14+8], W1
009DFE  90003E     MOV [W14+6], W0
009E00  0705CE     RCALL setPageSPIDisplay
249:               
250:                           y -= 8;
009E02  90004E     MOV [W14+8], W0
009E04  500068     SUB W0, #0x8, W0
009E06  980740     MOV W0, [W14+8]
251:               
252:                           height -= 8;
009E08  90005E     MOV [W14+10], W0
009E0A  500068     SUB W0, #0x8, W0
009E0C  980750     MOV W0, [W14+10]
253:                       }
254:               
255:               
256:                       // ultima pagina nera
257:                       act = 0;
009E1C  EB4000     CLR.B W0
009E1E  784F00     MOV.B W0, [W14]
258:               
259:                       for ( i = 0; i < height; i++)
009E20  EB4000     CLR.B W0
009E22  984720     MOV.B W0, [W14+2]
009E24  370007     BRA 0x9E34
009E2E  90402E     MOV.B [W14+2], W0
009E30  E84000     INC.B W0, W0
009E32  984720     MOV.B W0, [W14+2]
009E34  90402E     MOV.B [W14+2], W0
009E36  FB0080     SE W0, W1
009E38  90005E     MOV [W14+10], W0
009E3A  508F80     SUB W1, W0, [W15]
009E3C  35FFF4     BRA LT, 0x9E26
260:                       {
261:                           act = (act<<1) + 1;
009E26  78401E     MOV.B [W14], W0
009E28  404000     ADD.B W0, W0, W0
009E2A  E84000     INC.B W0, W0
009E2C  784F00     MOV.B W0, [W14]
262:                       }
263:               
264:                       act <<= 8 - height;
009E3E  FB009E     SE [W14], W1
009E40  90005E     MOV [W14+10], W0
009E42  100068     SUBR W0, #0x8, W0
009E44  DD0800     SL W1, W0, W0
009E46  784F00     MOV.B W0, [W14]
265:               
266:                       setPageSPIDisplay (x, y, act);
009E48  78411E     MOV.B [W14], W2
009E4A  9000CE     MOV [W14+8], W1
009E4C  90003E     MOV [W14+6], W0
009E4E  0705A7     RCALL setPageSPIDisplay
267:               
268:                       y -= 8;
009E50  90004E     MOV [W14+8], W0
009E52  500068     SUB W0, #0x8, W0
009E54  980740     MOV W0, [W14+8]
269:               
270:                       for (;y >= 0; y -= 8)
009E56  370007     BRA 0x9E66
009E60  90004E     MOV [W14+8], W0
009E62  500068     SUB W0, #0x8, W0
009E64  980740     MOV W0, [W14+8]
009E66  90004E     MOV [W14+8], W0
009E68  500FE0     SUB W0, #0x0, [W15]
009E6A  3DFFF6     BRA GE, 0x9E58
271:                       {
272:                           setPageSPIDisplay (x, y, 0x00);
009E58  EB4100     CLR.B W2
009E5A  9000CE     MOV [W14+8], W1
009E5C  90003E     MOV [W14+6], W0
009E5E  07059F     RCALL setPageSPIDisplay
273:                       }
274:               
275:               }
009E6C  FA8000     ULNK
009E6E  060000     RETURN
276:               
277:               inline void drawBarSpeedDNDR (int x, int y, int height, int top, GFX_COLOR cBk, GFX_COLOR c0, rect dndr)
278:               {
009E70  FA0010     LNK #0x10
009E72  980730     MOV W0, [W14+6]
009E74  980741     MOV W1, [W14+8]
009E76  980752     MOV W2, [W14+10]
009E78  980763     MOV W3, [W14+12]
009E7A  984F64     MOV.B W4, [W14+14]
009E7C  984F75     MOV.B W5, [W14+15]
279:               char act, iPix = (y - ((y>>3)<<3)) + 1, i, numBlack, little = 0;
009E7E  90004E     MOV [W14+8], W0
009E80  784000     MOV.B W0, W0
009E82  604067     AND.B W0, #0x7, W0
009E84  E84000     INC.B W0, W0
009E86  984710     MOV.B W0, [W14+1]
009E88  EB4000     CLR.B W0
009E8A  984730     MOV.B W0, [W14+3]
280:               
281:                   //prima pagina
282:                       act = 0;
009E8C  EB4000     CLR.B W0
009E8E  784F00     MOV.B W0, [W14]
283:               
284:                       if (height < iPix)
009E90  90401E     MOV.B [W14+1], W0
009E92  FB0080     SE W0, W1
009E94  90005E     MOV [W14+10], W0
009E96  508F80     SUB W1, W0, [W15]
009E98  340004     BRA LE, 0x9EA2
285:                       {
286:                           iPix = height;
009E9A  90005E     MOV [W14+10], W0
009E9C  984710     MOV.B W0, [W14+1]
287:                           little = 1;
009E9E  B3C010     MOV #0x1, W0
009EA0  984730     MOV.B W0, [W14+3]
288:                       }
289:               
290:                       for ( i = 0; i < iPix; i++)
009EA2  EB4000     CLR.B W0
009EA4  984720     MOV.B W0, [W14+2]
009EA6  370007     BRA 0x9EB6
009EB0  90402E     MOV.B [W14+2], W0
009EB2  E84000     INC.B W0, W0
009EB4  984720     MOV.B W0, [W14+2]
009EB6  9040AE     MOV.B [W14+2], W1
009EB8  90401E     MOV.B [W14+1], W0
009EBA  50CF80     SUB.B W1, W0, [W15]
009EBC  35FFF5     BRA LT, 0x9EA8
291:                       {
292:                           act = (act<<1) + 1;
009EA8  78401E     MOV.B [W14], W0
009EAA  404000     ADD.B W0, W0, W0
009EAC  E84000     INC.B W0, W0
009EAE  784F00     MOV.B W0, [W14]
293:                       }
294:                       act <<= 8 - iPix;
009EBE  FB009E     SE [W14], W1
009EC0  90401E     MOV.B [W14+1], W0
009EC2  FB0000     SE W0, W0
009EC4  100068     SUBR W0, #0x8, W0
009EC6  DD0800     SL W1, W0, W0
009EC8  784F00     MOV.B W0, [W14]
295:               
296:                       if (!isInsideDNDR(x, y, dndr))
009ECA  97BA1E     MOV [W14-14], W4
009ECC  97BAAE     MOV [W14-12], W5
009ECE  97BB3E     MOV [W14-10], W6
009ED0  97BBCE     MOV [W14-8], W7
009ED2  9000CE     MOV [W14+8], W1
009ED4  90003E     MOV [W14+6], W0
009ED6  0700A9     RCALL isInsideDNDR
009ED8  500FE0     SUB W0, #0x0, [W15]
009EDA  3A0004     BRA NZ, 0x9EE4
297:                           setPageSPIDisplay (x, y, act);
009EDC  78411E     MOV.B [W14], W2
009EDE  9000CE     MOV [W14+8], W1
009EE0  90003E     MOV [W14+6], W0
009EE2  07055D     RCALL setPageSPIDisplay
298:               
299:                       if (little)
009EE4  90403E     MOV.B [W14+3], W0
009EE6  504FE0     SUB.B W0, #0x0, [W15]
009EE8  320004     BRA Z, 0x9EF2
300:                           y -= 8;
009EEA  90004E     MOV [W14+8], W0
009EEC  500068     SUB W0, #0x8, W0
009EEE  980740     MOV W0, [W14+8]
009EF0  370006     BRA 0x9EFE
301:                       else
302:                           y -= iPix + 1;
009EF2  90401E     MOV.B [W14+1], W0
009EF4  FB0000     SE W0, W0
009EF6  EA8000     COM W0, W0
009EF8  9000CE     MOV [W14+8], W1
009EFA  408000     ADD W1, W0, W0
009EFC  980740     MOV W0, [W14+8]
303:               
304:                       //pagine solo nere
305:               
306:                       height -= iPix;
009EFE  90401E     MOV.B [W14+1], W0
009F00  FB0000     SE W0, W0
009F02  9000DE     MOV [W14+10], W1
009F04  508000     SUB W1, W0, W0
009F06  980750     MOV W0, [W14+10]
307:               
308:                       numBlack = height >> 3;
009F08  90005E     MOV [W14+10], W0
009F0A  DE8043     ASR W0, #3, W0
009F0C  984740     MOV.B W0, [W14+4]
309:               
310:                       for (i = 0; i < numBlack; i++)
009F0E  EB4000     CLR.B W0
009F10  984720     MOV.B W0, [W14+2]
009F12  370018     BRA 0x9F44
009F3E  90402E     MOV.B [W14+2], W0
009F40  E84000     INC.B W0, W0
009F42  984720     MOV.B W0, [W14+2]
009F44  9040AE     MOV.B [W14+2], W1
009F46  90404E     MOV.B [W14+4], W0
009F48  50CF80     SUB.B W1, W0, [W15]
009F4A  35FFE4     BRA LT, 0x9F14
311:                       {
312:                           act = 0xFF;
009F14  EBC000     SETM.B W0
009F16  784F00     MOV.B W0, [W14]
313:               
314:                           if (!isInsideDNDR(x, y, dndr))
009F18  97BA1E     MOV [W14-14], W4
009F1A  97BAAE     MOV [W14-12], W5
009F1C  97BB3E     MOV [W14-10], W6
009F1E  97BBCE     MOV [W14-8], W7
009F20  9000CE     MOV [W14+8], W1
009F22  90003E     MOV [W14+6], W0
009F24  070082     RCALL isInsideDNDR
009F26  500FE0     SUB W0, #0x0, [W15]
009F28  3A0004     BRA NZ, 0x9F32
315:                               setPageSPIDisplay (x, y, act);
009F2A  78411E     MOV.B [W14], W2
009F2C  9000CE     MOV [W14+8], W1
009F2E  90003E     MOV [W14+6], W0
009F30  070536     RCALL setPageSPIDisplay
316:               
317:                           y -= 8;
009F32  90004E     MOV [W14+8], W0
009F34  500068     SUB W0, #0x8, W0
009F36  980740     MOV W0, [W14+8]
318:               
319:                           height -= 8;
009F38  90005E     MOV [W14+10], W0
009F3A  500068     SUB W0, #0x8, W0
009F3C  980750     MOV W0, [W14+10]
320:                       }
321:               
322:               
323:                       // ultima pagina nera
324:                       act = 0;
009F4C  EB4000     CLR.B W0
009F4E  784F00     MOV.B W0, [W14]
325:               
326:                       for ( i = 0; i < height; i++)
009F50  EB4000     CLR.B W0
009F52  984720     MOV.B W0, [W14+2]
009F54  370007     BRA 0x9F64
009F5E  90402E     MOV.B [W14+2], W0
009F60  E84000     INC.B W0, W0
009F62  984720     MOV.B W0, [W14+2]
009F64  90402E     MOV.B [W14+2], W0
009F66  FB0080     SE W0, W1
009F68  90005E     MOV [W14+10], W0
009F6A  508F80     SUB W1, W0, [W15]
009F6C  35FFF4     BRA LT, 0x9F56
327:                       {
328:                           act = (act<<1) + 1;
009F56  78401E     MOV.B [W14], W0
009F58  404000     ADD.B W0, W0, W0
009F5A  E84000     INC.B W0, W0
009F5C  784F00     MOV.B W0, [W14]
329:                       }
330:               
331:                       act <<= 8 - height;
009F6E  FB009E     SE [W14], W1
009F70  90005E     MOV [W14+10], W0
009F72  100068     SUBR W0, #0x8, W0
009F74  DD0800     SL W1, W0, W0
009F76  784F00     MOV.B W0, [W14]
332:               
333:                       if (!isInsideDNDR(x, y, dndr))
009F78  97BA1E     MOV [W14-14], W4
009F7A  97BAAE     MOV [W14-12], W5
009F7C  97BB3E     MOV [W14-10], W6
009F7E  97BBCE     MOV [W14-8], W7
009F80  9000CE     MOV [W14+8], W1
009F82  90003E     MOV [W14+6], W0
009F84  070052     RCALL isInsideDNDR
009F86  500FE0     SUB W0, #0x0, [W15]
009F88  3A0004     BRA NZ, 0x9F92
334:                           setPageSPIDisplay (x, y, act);
009F8A  78411E     MOV.B [W14], W2
009F8C  9000CE     MOV [W14+8], W1
009F8E  90003E     MOV [W14+6], W0
009F90  070506     RCALL setPageSPIDisplay
335:               
336:                       y -= 8;
009F92  90004E     MOV [W14+8], W0
009F94  500068     SUB W0, #0x8, W0
009F96  980740     MOV W0, [W14+8]
337:               
338:                       for (;y >= 0; y -= 8)
009F98  370010     BRA 0x9FBA
009FB4  90004E     MOV [W14+8], W0
009FB6  500068     SUB W0, #0x8, W0
009FB8  980740     MOV W0, [W14+8]
009FBA  90004E     MOV [W14+8], W0
009FBC  500FE0     SUB W0, #0x0, [W15]
009FBE  3DFFED     BRA GE, 0x9F9A
339:                       {
340:                           if (!isInsideDNDR(x, y, dndr))
009F9A  97BA1E     MOV [W14-14], W4
009F9C  97BAAE     MOV [W14-12], W5
009F9E  97BB3E     MOV [W14-10], W6
009FA0  97BBCE     MOV [W14-8], W7
009FA2  9000CE     MOV [W14+8], W1
009FA4  90003E     MOV [W14+6], W0
009FA6  070041     RCALL isInsideDNDR
009FA8  500FE0     SUB W0, #0x0, [W15]
009FAA  3A0004     BRA NZ, 0x9FB4
341:                               setPageSPIDisplay (x, y, 0x00);
009FAC  EB4100     CLR.B W2
009FAE  9000CE     MOV [W14+8], W1
009FB0  90003E     MOV [W14+6], W0
009FB2  0704F5     RCALL setPageSPIDisplay
342:                       }
343:               
344:               }
009FC0  FA8000     ULNK
009FC2  060000     RETURN
345:               
346:               void invalidateMyGraph (MYGRAPH *pMygr)
347:               {
009FC4  FA0004     LNK #0x4
009FC6  980710     MOV W0, [W14+2]
348:               int i = 0;
009FC8  EB0000     CLR W0
009FCA  780F00     MOV W0, [W14]
349:                   
350:                   pMygr->hdr.state |= MYGR_DRAW;
009FCC  90001E     MOV [W14+2], W0
009FCE  9000B0     MOV [W0+6], W1
009FD0  2FC000     MOV #0xFC00, W0
009FD2  708080     IOR W1, W0, W1
009FD4  90001E     MOV [W14+2], W0
009FD6  980031     MOV W1, [W0+6]
351:                   
352:                   for (i = 0; i < pMygr->dataNum; i++)
009FD8  EB0000     CLR W0
009FDA  780F00     MOV W0, [W14]
009FDC  370007     BRA 0x9FEC
009FEA  E80F1E     INC [W14], [W14]
009FEC  90001E     MOV [W14+2], W0
009FEE  900860     MOV [W0+28], W0
009FF0  500F9E     SUB W0, [W14], [W15]
009FF2  3CFFF5     BRA GT, 0x9FDE
353:                   {
354:                       pMygr -> dataValid[i] = DATA_INVALID;
009FDE  90001E     MOV [W14+2], W0
009FE0  9010B0     MOV [W0+38], W1
009FE2  78001E     MOV [W14], W0
009FE4  408080     ADD W1, W0, W1
009FE6  EB4000     CLR.B W0
009FE8  784880     MOV.B W0, [W1]
355:                   }
356:               }
009FF4  FA8000     ULNK
009FF6  060000     RETURN
357:               
358:               void invalidateColumn (MYGRAPH *pMygr, int index)
359:               {
009FF8  FA0004     LNK #0x4
009FFA  780F00     MOV W0, [W14]
009FFC  980711     MOV W1, [W14+2]
360:                   if (index >= 0 && index < pMygr->dataNum)
009FFE  90001E     MOV [W14+2], W0
00A000  500FE0     SUB W0, #0x0, [W15]
00A002  350011     BRA LT, 0xA026
00A004  78001E     MOV [W14], W0
00A006  9008E0     MOV [W0+28], W1
00A008  90001E     MOV [W14+2], W0
00A00A  508F80     SUB W1, W0, [W15]
00A00C  34000C     BRA LE, 0xA026
361:                   {
362:                       pMygr->hdr.state |= MYGR_DRAW;
00A00E  78001E     MOV [W14], W0
00A010  9000B0     MOV [W0+6], W1
00A012  2FC000     MOV #0xFC00, W0
00A014  708080     IOR W1, W0, W1
00A016  78001E     MOV [W14], W0
00A018  980031     MOV W1, [W0+6]
363:                       pMygr->dataValid[index] = DATA_INVALID;
00A01A  78001E     MOV [W14], W0
00A01C  9010B0     MOV [W0+38], W1
00A01E  90001E     MOV [W14+2], W0
00A020  408080     ADD W1, W0, W1
00A022  EB4000     CLR.B W0
00A024  784880     MOV.B W0, [W1]
364:                   }
365:               }
00A026  FA8000     ULNK
00A028  060000     RETURN
366:               
367:               inline int isInsideDNDR (int x, int y, rect dndr)
368:               {
00A02A  FA000C     LNK #0xC
00A02C  780F00     MOV W0, [W14]
00A02E  980711     MOV W1, [W14+2]
00A030  980724     MOV W4, [W14+4]
00A032  980735     MOV W5, [W14+6]
00A034  980746     MOV W6, [W14+8]
00A036  980757     MOV W7, [W14+10]
369:                   if (x >= dndr.left && x <= dndr.right && y >= dndr.top && y <= dndr.bottom)
00A038  90002E     MOV [W14+4], W0
00A03A  500F9E     SUB W0, [W14], [W15]
00A03C  3C000D     BRA GT, 0xA058
00A03E  90004E     MOV [W14+8], W0
00A040  500F9E     SUB W0, [W14], [W15]
00A042  35000A     BRA LT, 0xA058
00A044  9000BE     MOV [W14+6], W1
00A046  90001E     MOV [W14+2], W0
00A048  508F80     SUB W1, W0, [W15]
00A04A  3C0006     BRA GT, 0xA058
00A04C  9000DE     MOV [W14+10], W1
00A04E  90001E     MOV [W14+2], W0
00A050  508F80     SUB W1, W0, [W15]
00A052  350002     BRA LT, 0xA058
370:                       return 1;
00A054  200010     MOV #0x1, W0
00A056  370001     BRA 0xA05A
371:                   else
372:                       return 0;
00A058  EB0000     CLR W0
373:               }
00A05A  FA8000     ULNK
00A05C  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/ClockControl.c  -------------------------------
1:                 #include <limits.h>
2:                 #include "ClockControl.h"
3:                 #include <xc.h>
4:                 
5:                 #define PLLPRE_RANGE 32
6:                 #define PLLDIV_RANGE 512
7:                 #define PLLPOST_RANGE 4
8:                 
9:                 #define MIN_FREF 800000
10:                #define MAX_FREF 8000000
11:                
12:                #define MIN_FVCO 100000000
13:                #define MAX_FVCO 200000000
14:                
15:                #define MAX_FOSC 80000000
16:                
17:                #define PLLPRE_STARTING_DIV 2
18:                #define PLLDIV_STARTING_DIV 2
19:                
20:                static long int actClkFreq;
21:                
22:                inline static long int labs (long int num);
23:                inline static void clkSwitch (char newClkSrc);
24:                
25:                const int PLLPOST_DIVS [4] = {2, 4, 32000, 8};
26:                
27:                long int getClockFreq()
28:                {
00B9F4  FA0000     LNK #0x0
29:                    return actClkFreq;
00B9F6  808C40     MOV actClkFreq, W0
00B9F8  808C51     MOV 0x118A, W1
30:                }
00B9FA  FA8000     ULNK
00B9FC  060000     RETURN
31:                
32:                long int setClockFreq(long int targetFreq, clockSource clkSrc, long int baseFreq)
33:                {
00B9FE  FA0038     LNK #0x38
00BA00  981770     MOV W0, [W14+46]
00BA02  981F01     MOV W1, [W14+48]
00BA04  981F12     MOV W2, [W14+50]
00BA06  981F24     MOV W4, [W14+52]
00BA08  981F35     MOV W5, [W14+54]
34:                long int dMin = LONG_MAX, bestFreq = LONG_MAX, actFreq, dAct, actFref, actFvco;
00BA0A  2FFFF0     MOV #0xFFFF, W0
00BA0C  27FFF1     MOV #0x7FFF, W1
00BA0E  BE8F00     MOV.D W0, [W14]
00BA10  2FFFF0     MOV #0xFFFF, W0
00BA12  27FFF1     MOV #0x7FFF, W1
00BA14  980720     MOV W0, [W14+4]
00BA16  980731     MOV W1, [W14+6]
35:                int div1, div2, mul, rightPLLPRE = 0, rightPLLDIV = 0, rightPLLPOST = 0, actPLLPRE, actPLLDIV, actPLLPOST;
00BA18  EB0000     CLR W0
00BA1A  980740     MOV W0, [W14+8]
00BA1C  EB0000     CLR W0
00BA1E  980750     MOV W0, [W14+10]
00BA20  EB0000     CLR W0
00BA22  980760     MOV W0, [W14+12]
36:                char rightNOSC;
37:                
38:                    if (clkSrc == FRC)
00BA24  90181E     MOV [W14+50], W0
00BA26  500FE0     SUB W0, #0x0, [W15]
00BA28  3A0004     BRA NZ, 0xBA32
39:                        baseFreq = FRC_BASE_FREQ;
00BA2A  275100     MOV #0x7510, W0
00BA2C  200701     MOV #0x70, W1
00BA2E  981F20     MOV W0, [W14+52]
00BA30  981F31     MOV W1, [W14+54]
40:                    
41:                    if (targetFreq != baseFreq)
00BA32  90117E     MOV [W14+46], W2
00BA34  90198E     MOV [W14+48], W3
00BA36  90182E     MOV [W14+52], W0
00BA38  9018BE     MOV [W14+54], W1
00BA3A  510F80     SUB W2, W0, [W15]
00BA3C  598F81     SUBB W3, W1, [W15]
00BA3E  320094     BRA Z, 0xBB68
42:                    {
43:                        for (actPLLPRE = 0; actPLLPRE < PLLPRE_RANGE; actPLLPRE++)
00BA40  EB0000     CLR W0
00BA42  980770     MOV W0, [W14+14]
00BA44  370081     BRA 0xBB48
00BB42  90007E     MOV [W14+14], W0
00BB44  E80000     INC W0, W0
00BB46  980770     MOV W0, [W14+14]
00BB48  90007E     MOV [W14+14], W0
00BB4A  500FFF     SUB W0, #0x1F, [W15]
00BB4C  34FF7C     BRA LE, 0xBA46
44:                        {
45:                            for (actPLLDIV = 0; actPLLDIV < PLLDIV_RANGE; actPLLDIV++)
00BA46  EB0000     CLR W0
00BA48  980F00     MOV W0, [W14+16]
00BA4A  370077     BRA 0xBB3A
00BB34  90080E     MOV [W14+16], W0
00BB36  E80000     INC W0, W0
00BB38  980F00     MOV W0, [W14+16]
00BB3A  90088E     MOV [W14+16], W1
00BB3C  201FF0     MOV #0x1FF, W0
00BB3E  508F80     SUB W1, W0, [W15]
00BB40  34FF85     BRA LE, 0xBA4C
46:                            {
47:                                for (actPLLPOST = 0; actPLLPOST < PLLPOST_RANGE; actPLLPOST++)
00BA4C  EB0000     CLR W0
00BA4E  980F10     MOV W0, [W14+18]
00BA50  37006E     BRA 0xBB2E
00BB28  90081E     MOV [W14+18], W0
00BB2A  E80000     INC W0, W0
00BB2C  980F10     MOV W0, [W14+18]
00BB2E  90081E     MOV [W14+18], W0
00BB30  500FE3     SUB W0, #0x3, [W15]
00BB32  34FF8F     BRA LE, 0xBA52
48:                                {
49:                                    div1 = PLLPRE_STARTING_DIV + actPLLPRE;
00BA52  90007E     MOV [W14+14], W0
00BA54  E88000     INC2 W0, W0
00BA56  980F30     MOV W0, [W14+22]
50:                                    mul = PLLDIV_STARTING_DIV + actPLLDIV;
00BA58  90080E     MOV [W14+16], W0
00BA5A  E88000     INC2 W0, W0
00BA5C  980F40     MOV W0, [W14+24]
51:                                    div2 = PLLPOST_DIVS [actPLLPOST];
00BA5E  2D45E1     MOV #0xD45E, W1
00BA60  90081E     MOV [W14+18], W0
00BA62  400000     ADD W0, W0, W0
00BA64  408000     ADD W1, W0, W0
00BA66  780090     MOV [W0], W1
00BA68  980F51     MOV W1, [W14+26]
52:                
53:                                    actFref = baseFreq / div1;
00BA6A  90083E     MOV [W14+22], W0
00BA6C  DE80CF     ASR W0, #15, W1
00BA6E  BE0100     MOV.D W0, W2
00BA70  90182E     MOV [W14+52], W0
00BA72  9018BE     MOV [W14+54], W1
00BA74  07AF36     RCALL ___divsi3
00BA76  980F60     MOV W0, [W14+28]
00BA78  980F71     MOV W1, [W14+30]
54:                                    actFvco = actFref * mul;
00BA7A  90084E     MOV [W14+24], W0
00BA7C  DE80CF     ASR W0, #15, W1
00BA7E  90096E     MOV [W14+28], W2
00BA80  B99101     MUL.SS W2, W1, W2
00BA82  780102     MOV W2, W2
00BA84  9009FE     MOV [W14+30], W3
00BA86  B99A00     MUL.SS W3, W0, W4
00BA88  780184     MOV W4, W3
00BA8A  410103     ADD W2, W3, W2
00BA8C  9009EE     MOV [W14+28], W3
00BA8E  B81800     MUL.UU W3, W0, W0
00BA90  410101     ADD W2, W1, W2
00BA92  780082     MOV W2, W1
00BA94  981700     MOV W0, [W14+32]
00BA96  981711     MOV W1, [W14+34]
00BA98  981700     MOV W0, [W14+32]
00BA9A  981711     MOV W1, [W14+34]
55:                
56:                                    actFreq = actFvco / div2;
00BA9C  90085E     MOV [W14+26], W0
00BA9E  DE80CF     ASR W0, #15, W1
00BAA0  BE0100     MOV.D W0, W2
00BAA2  90100E     MOV [W14+32], W0
00BAA4  90109E     MOV [W14+34], W1
00BAA6  07AF1D     RCALL ___divsi3
00BAA8  981720     MOV W0, [W14+36]
00BAAA  981731     MOV W1, [W14+38]
57:                
58:                                    dAct = labs (targetFreq - actFreq);
00BAAC  90117E     MOV [W14+46], W2
00BAAE  90198E     MOV [W14+48], W3
00BAB0  90102E     MOV [W14+36], W0
00BAB2  9010BE     MOV [W14+38], W1
00BAB4  510000     SUB W2, W0, W0
00BAB6  598081     SUBB W3, W1, W1
00BAB8  07009F     RCALL _labs
00BABA  981740     MOV W0, [W14+40]
00BABC  981751     MOV W1, [W14+42]
59:                
60:                                    if (dAct < dMin && actFref > MIN_FREF && actFref < MAX_FREF && actFvco > MIN_FVCO && actFvco < MAX_FVCO && actFreq < MAX_FOSC)
00BABE  90104E     MOV [W14+40], W0
00BAC0  9010DE     MOV [W14+42], W1
00BAC2  500FBE     SUB W0, [W14++], [W15]
00BAC4  588FAE     SUBB W1, [W14--], [W15]
00BAC6  3D0030     BRA GE, 0xBB28
00BAC8  90096E     MOV [W14+28], W2
00BACA  9009FE     MOV [W14+30], W3
00BACC  235000     MOV #0x3500, W0
00BACE  2000C1     MOV #0xC, W1
00BAD0  510F80     SUB W2, W0, [W15]
00BAD2  598F81     SUBB W3, W1, [W15]
00BAD4  340029     BRA LE, 0xBB28
00BAD6  90096E     MOV [W14+28], W2
00BAD8  9009FE     MOV [W14+30], W3
00BADA  211FF0     MOV #0x11FF, W0
00BADC  2007A1     MOV #0x7A, W1
00BADE  510F80     SUB W2, W0, [W15]
00BAE0  598F81     SUBB W3, W1, [W15]
00BAE2  3C0022     BRA GT, 0xBB28
00BAE4  90110E     MOV [W14+32], W2
00BAE6  90119E     MOV [W14+34], W3
00BAE8  2E1000     MOV #0xE100, W0
00BAEA  205F51     MOV #0x5F5, W1
00BAEC  510F80     SUB W2, W0, [W15]
00BAEE  598F81     SUBB W3, W1, [W15]
00BAF0  34001B     BRA LE, 0xBB28
00BAF2  90110E     MOV [W14+32], W2
00BAF4  90119E     MOV [W14+34], W3
00BAF6  2C1FF0     MOV #0xC1FF, W0
00BAF8  20BEB1     MOV #0xBEB, W1
00BAFA  510F80     SUB W2, W0, [W15]
00BAFC  598F81     SUBB W3, W1, [W15]
00BAFE  3C0014     BRA GT, 0xBB28
00BB00  90112E     MOV [W14+36], W2
00BB02  9011BE     MOV [W14+38], W3
00BB04  2B3FF0     MOV #0xB3FF, W0
00BB06  204C41     MOV #0x4C4, W1
00BB08  510F80     SUB W2, W0, [W15]
00BB0A  598F81     SUBB W3, W1, [W15]
00BB0C  3C000D     BRA GT, 0xBB28
61:                                    {
62:                                        dMin = dAct;
00BB0E  90104E     MOV [W14+40], W0
00BB10  9010DE     MOV [W14+42], W1
00BB12  BE8F00     MOV.D W0, [W14]
63:                
64:                                        bestFreq = actFreq;
00BB14  90102E     MOV [W14+36], W0
00BB16  9010BE     MOV [W14+38], W1
00BB18  980720     MOV W0, [W14+4]
00BB1A  980731     MOV W1, [W14+6]
65:                
66:                                        rightPLLPRE = actPLLPRE;
00BB1C  9000FE     MOV [W14+14], W1
00BB1E  980741     MOV W1, [W14+8]
67:                                        rightPLLDIV = actPLLDIV;
00BB20  90080E     MOV [W14+16], W0
00BB22  980750     MOV W0, [W14+10]
68:                                        rightPLLPOST = actPLLPOST;
00BB24  90089E     MOV [W14+18], W1
00BB26  980761     MOV W1, [W14+12]
69:                                    }
70:                                }
71:                            }
72:                
73:                        }
74:                
75:                        switch (clkSrc)
00BB4E  90181E     MOV [W14+50], W0
00BB50  500FE0     SUB W0, #0x0, [W15]
00BB52  320003     BRA Z, 0xBB5A
00BB54  500FE1     SUB W0, #0x1, [W15]
00BB56  320005     BRA Z, 0xBB62
76:                        {
77:                            case FRC:
78:                                rightNOSC = 0x01;
00BB5A  B3C010     MOV #0x1, W0
00BB5C  985740     MOV.B W0, [W14+20]
79:                                break;
00BB5E  000000     NOP
00BB60  370013     BRA 0xBB88
80:                
81:                            case PRIMARY:
82:                                rightNOSC = 0x03;
00BB62  B3C030     MOV #0x3, W0
00BB64  985740     MOV.B W0, [W14+20]
83:                                break;
00BB58  370017     BRA 0xBB88
00BB66  370010     BRA 0xBB88
84:                        }
85:                
86:                    }
87:                    else
88:                    {
89:                        bestFreq = baseFreq;
00BB68  90182E     MOV [W14+52], W0
00BB6A  9018BE     MOV [W14+54], W1
00BB6C  980720     MOV W0, [W14+4]
00BB6E  980731     MOV W1, [W14+6]
90:                        
91:                        switch (clkSrc)
00BB70  90181E     MOV [W14+50], W0
00BB72  500FE0     SUB W0, #0x0, [W15]
00BB74  320003     BRA Z, 0xBB7C
00BB76  500FE1     SUB W0, #0x1, [W15]
00BB78  320004     BRA Z, 0xBB82
00BB7A  370006     BRA 0xBB88
92:                        {
93:                            case FRC:
94:                                rightNOSC = 0x00;
00BB7C  EB4000     CLR.B W0
00BB7E  985740     MOV.B W0, [W14+20]
95:                                break;
00BB80  370003     BRA 0xBB88
96:                
97:                            case PRIMARY:
98:                                rightNOSC = 0x02;
00BB82  B3C020     MOV #0x2, W0
00BB84  985740     MOV.B W0, [W14+20]
99:                                break;
00BB86  000000     NOP
100:                       }
101:                   }
102:               
103:                   int f = OSCCONbits.OSWEN;
00BB88  803A10     MOV OSCCON, W0
00BB8A  784000     MOV.B W0, W0
00BB8C  604061     AND.B W0, #0x1, W0
00BB8E  FB8000     ZE W0, W0
00BB90  981760     MOV W0, [W14+44]
104:               
105:                   clkSwitch (rightNOSC);
00BB92  90504E     MOV.B [W14+20], W0
00BB94  07003E     RCALL _clkSwitch
106:               
107:                   f = OSCCONbits.OSWEN;
00BB96  803A10     MOV OSCCON, W0
00BB98  784000     MOV.B W0, W0
00BB9A  604061     AND.B W0, #0x1, W0
00BB9C  FB8000     ZE W0, W0
00BB9E  981760     MOV W0, [W14+44]
108:               
109:                   while (OSCCONbits.OSWEN != 0);
00BBA0  000000     NOP
00BBA2  803A10     MOV OSCCON, W0
00BBA4  600061     AND W0, #0x1, W0
00BBA6  500FE0     SUB W0, #0x0, [W15]
00BBA8  3AFFFC     BRA NZ, 0xBBA2
110:               
111:                   CLKDIVbits.PLLPRE = rightPLLPRE;
00BBAA  90004E     MOV [W14+8], W0
00BBAC  784000     MOV.B W0, W0
00BBAE  60407F     AND.B W0, #0x1F, W0
00BBB0  FB8000     ZE W0, W0
00BBB2  60007F     AND W0, #0x1F, W0
00BBB4  803A22     MOV CLKDIV, W2
00BBB6  2FFE01     MOV #0xFFE0, W1
00BBB8  610081     AND W2, W1, W1
00BBBA  708000     IOR W1, W0, W0
00BBBC  883A20     MOV W0, CLKDIV
112:                   CLKDIVbits.PLLPOST = rightPLLPOST;
00BBBE  90006E     MOV [W14+12], W0
00BBC0  784000     MOV.B W0, W0
00BBC2  604063     AND.B W0, #0x3, W0
00BBC4  FB8000     ZE W0, W0
00BBC6  600063     AND W0, #0x3, W0
00BBC8  DD0046     SL W0, #6, W0
00BBCA  803A22     MOV CLKDIV, W2
00BBCC  2FF3F1     MOV #0xFF3F, W1
00BBCE  610081     AND W2, W1, W1
00BBD0  708000     IOR W1, W0, W0
00BBD2  883A20     MOV W0, CLKDIV
113:                   PLLFBDbits.PLLDIV = rightPLLDIV;
00BBD4  9000DE     MOV [W14+10], W1
00BBD6  201FF0     MOV #0x1FF, W0
00BBD8  608080     AND W1, W0, W1
00BBDA  201FF0     MOV #0x1FF, W0
00BBDC  608000     AND W1, W0, W0
00BBDE  803A32     MOV PLLFBD, W2
00BBE0  2FE001     MOV #0xFE00, W1
00BBE2  610081     AND W2, W1, W1
00BBE4  708000     IOR W1, W0, W0
00BBE6  883A30     MOV W0, PLLFBD
114:               
115:                   actClkFreq = bestFreq;
00BBE8  90002E     MOV [W14+4], W0
00BBEA  9000BE     MOV [W14+6], W1
00BBEC  888C40     MOV W0, actClkFreq
00BBEE  888C51     MOV W1, 0x118A
116:               
117:                   return bestFreq;
00BBF0  90002E     MOV [W14+4], W0
00BBF2  9000BE     MOV [W14+6], W1
118:               }
00BBF4  FA8000     ULNK
00BBF6  060000     RETURN
119:               
120:               inline static long int labs (long int num)
121:               {
00BBF8  FA0004     LNK #0x4
00BBFA  BE8F00     MOV.D W0, [W14]
122:                   if (num < 0)
00BBFC  BE001E     MOV.D [W14], W0
00BBFE  500FE0     SUB W0, #0x0, [W15]
00BC00  588FE0     SUBB W1, #0x0, [W15]
00BC02  3D0004     BRA GE, 0xBC0C
123:                       return -num;
00BC04  BE001E     MOV.D [W14], W0
00BC06  100060     SUBR W0, #0x0, W0
00BC08  1880E0     SUBBR W1, #0x0, W1
00BC0A  370001     BRA 0xBC0E
124:                   else
125:                       return num;
00BC0C  BE001E     MOV.D [W14], W0
126:               }
00BC0E  FA8000     ULNK
00BC10  060000     RETURN
127:               
128:               inline static void clkSwitch (char newClkSrc)
129:               {   
00BC12  FA0002     LNK #0x2
00BC14  784F00     MOV.B W0, [W14]
130:                    __asm__ ("MOV.B %0, w0" : "+r"(newClkSrc));
00BC16  78401E     MOV.B [W14], W0
00BC18  784000     MOV.B W0, W0
00BC1A  784F00     MOV.B W0, [W14]
131:                    __asm__ (                             // Unlock OSCCONH for clock switching
00BC1C  207431     MOV #0x743, W1
00BC1E  200782     MOV #0x78, W2
00BC20  2009A3     MOV #0x9A, W3
00BC22  784882     MOV.B W2, [W1]
00BC24  784883     MOV.B W3, [W1]
00BC26  B7E743     MOV.B WREG, 0x743
00BC28  200010     MOV #0x1, W0
00BC2A  207421     MOV #0x742, W1
00BC2C  200462     MOV #0x46, W2
00BC2E  200573     MOV #0x57, W3
00BC30  784882     MOV.B W2, [W1]
00BC32  784883     MOV.B W3, [W1]
00BC34  784880     MOV.B W0, [W1]
132:                               "MOV     #OSCCONH, w1\n"
133:                               "MOV     #0x78, w2\n"
134:                               "MOV     #0x9A, w3\n"
135:                               "MOV.B   w2, [w1]\n"
136:                               "MOV.B   w3, [w1]\n"
137:                               "MOV.B   WREG,OSCCONH\n"
138:                               "MOV     #0x01, w0\n"
139:                               "MOV     #OSCCONL, w1\n"
140:                               "MOV     #0x46, w2\n"
141:                               "MOV     #0x57, w3\n"
142:                               "MOV.B   w2, [w1]\n"
143:                               "MOV.B   w3, [w1]\n"
144:                               "MOV.B   w0,[w1]"
145:                               );
146:               }
00BC36  FA8000     ULNK
00BC38  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Include/ADC1Control.c  --------------------------------
1:                 #include <stdlib.h>
2:                 #include <xc.h>
3:                 #include <math.h>
4:                 #include "ADC1Control.h"
5:                 
6:                 #define CHANNEL 0
7:                 #define INTERNAL_COUNTER 7
8:                 
9:                 static void (*clbk) ();
10:                static double minVoltage;
11:                static double maxVoltage;
12:                
13:                static const int MAX_ADC1BUF0 =  1023;
14:                
15:                void __attribute__ ((__interrupt__, __auto_psv__, __shadow__)) _ADC1Interrupt()
16:                {
000354  FEA000     PUSH.S
000356  F80036     PUSH RCOUNT
000358  BE9F84     MOV.D W4, [W15++]
00035A  BE9F86     MOV.D W6, [W15++]
00035C  F80034     PUSH PSVPAG
00035E  200004     MOV #0x0, W4
000360  8801A4     MOV W4, PSVPAG
000362  FA0000     LNK #0x0
17:                    if (clbk != NULL)
000364  808A00     MOV clbk, W0
000366  500FE0     SUB W0, #0x0, [W15]
000368  320002     BRA Z, 0x36E
18:                        clbk();
00036A  808A00     MOV clbk, W0
00036C  010000     CALL W0
19:                }
00036E  FA8000     ULNK
000370  F90034     POP PSVPAG
000372  BE034F     MOV.D [--W15], W6
000374  BE024F     MOV.D [--W15], W4
000376  F90036     POP RCOUNT
000378  FE8000     POP.S
00037A  064000     RETFIE
20:                
21:                void initADC1
22:                    (int pin,
23:                    ADC1RefSelect voltageReference,
24:                    int conversionClockMul,
25:                    int autoSampleTime,
26:                    ADC1ResultForm resultForm,
27:                    int interruptEnable,
28:                    void (*interruptClbk)(),
29:                    double minV,
30:                    double maxV)
31:                {
00037C  FA000E     LNK #0xE
00037E  780F00     MOV W0, [W14]
000380  980711     MOV W1, [W14+2]
000382  980722     MOV W2, [W14+4]
000384  980733     MOV W3, [W14+6]
000386  980744     MOV W4, [W14+8]
000388  980755     MOV W5, [W14+10]
00038A  980766     MOV W6, [W14+12]
32:                    AD1CON1bits.ADON = 0;
00038C  A9E321     BCLR 0x321, #7
33:                
34:                    AD1PCFGL = ~((int)pow(2, pin));
00038E  78001E     MOV [W14], W0
000390  DE80CF     ASR W0, #15, W1
000392  070AF4     RCALL ___floatsisf
000394  BE0100     MOV.D W0, W2
000396  200000     MOV #0x0, W0
000398  240001     MOV #0x4000, W1
00039A  070B7C     RCALL _powf
00039C  070AB3     RCALL ___fixsfsi
00039E  780000     MOV W0, W0
0003A0  EA8000     COM W0, W0
0003A2  881960     MOV W0, AD1PCFGL
35:                
36:                    AD1CHS0bits.CH0SB = pin;
0003A4  78001E     MOV [W14], W0
0003A6  784000     MOV.B W0, W0
0003A8  60407F     AND.B W0, #0x1F, W0
0003AA  FB8000     ZE W0, W0
0003AC  60007F     AND W0, #0x1F, W0
0003AE  DD0048     SL W0, #8, W0
0003B0  801942     MOV AD1CHS0, W2
0003B2  2E0FF1     MOV #0xE0FF, W1
0003B4  610081     AND W2, W1, W1
0003B6  708000     IOR W1, W0, W0
0003B8  881940     MOV W0, AD1CHS0
37:                    AD1CHS0bits.CH0SA = pin;
0003BA  78001E     MOV [W14], W0
0003BC  784000     MOV.B W0, W0
0003BE  60407F     AND.B W0, #0x1F, W0
0003C0  FB8000     ZE W0, W0
0003C2  60007F     AND W0, #0x1F, W0
0003C4  801942     MOV AD1CHS0, W2
0003C6  2FFE01     MOV #0xFFE0, W1
0003C8  610081     AND W2, W1, W1
0003CA  708000     IOR W1, W0, W0
0003CC  881940     MOV W0, AD1CHS0
38:                
39:                    AD1CSSL = pow(2, pin);
0003CE  78001E     MOV [W14], W0
0003D0  DE80CF     ASR W0, #15, W1
0003D2  070AD4     RCALL ___floatsisf
0003D4  BE0100     MOV.D W0, W2
0003D6  200000     MOV #0x0, W0
0003D8  240001     MOV #0x4000, W1
0003DA  070B5C     RCALL _powf
0003DC  070AB4     RCALL ___fixunssfsi
0003DE  780000     MOV W0, W0
0003E0  881980     MOV W0, AD1CSSL
40:                
41:                    AD1CON2bits.VCFG = voltageReference;
0003E2  90001E     MOV [W14+2], W0
0003E4  784000     MOV.B W0, W0
0003E6  604067     AND.B W0, #0x7, W0
0003E8  FB8000     ZE W0, W0
0003EA  DD004D     SL W0, #13, W0
0003EC  801912     MOV AD1CON2, W2
0003EE  21FFF1     MOV #0x1FFF, W1
0003F0  610081     AND W2, W1, W1
0003F2  708000     IOR W1, W0, W0
0003F4  881910     MOV W0, AD1CON2
42:                    AD1CON3bits.ADCS = conversionClockMul - 1;
0003F6  90002E     MOV [W14+4], W0
0003F8  784000     MOV.B W0, W0
0003FA  E94000     DEC.B W0, W0
0003FC  B7E324     MOV.B WREG, AD1CON3
43:                    AD1CON2bits.CHPS = CHANNEL;
0003FE  801911     MOV AD1CON2, W1
000400  2FCFF0     MOV #0xFCFF, W0
000402  608000     AND W1, W0, W0
000404  881910     MOV W0, AD1CON2
44:                    AD1CON1bits.SSRC = INTERNAL_COUNTER;
000406  801901     MOV AD1CON1, W1
000408  200E00     MOV #0xE0, W0
00040A  708000     IOR W1, W0, W0
00040C  881900     MOV W0, AD1CON1
45:                    AD1CON3bits.SAMC = autoSampleTime;
00040E  90003E     MOV [W14+6], W0
000410  784000     MOV.B W0, W0
000412  60407F     AND.B W0, #0x1F, W0
000414  FB8000     ZE W0, W0
000416  60007F     AND W0, #0x1F, W0
000418  DD0048     SL W0, #8, W0
00041A  801922     MOV AD1CON3, W2
00041C  2E0FF1     MOV #0xE0FF, W1
00041E  610081     AND W2, W1, W1
000420  708000     IOR W1, W0, W0
000422  881920     MOV W0, AD1CON3
46:                    AD1CON1bits.FORM = resultForm;
000424  90004E     MOV [W14+8], W0
000426  784000     MOV.B W0, W0
000428  604063     AND.B W0, #0x3, W0
00042A  FB8000     ZE W0, W0
00042C  600063     AND W0, #0x3, W0
00042E  DD0048     SL W0, #8, W0
000430  801902     MOV AD1CON1, W2
000432  2FCFF1     MOV #0xFCFF, W1
000434  610081     AND W2, W1, W1
000436  708000     IOR W1, W0, W0
000438  881900     MOV W0, AD1CON1
47:                
48:                    IFS0bits.AD1IF = 0;
00043A  A9A085     BCLR 0x85, #5
49:                    IEC0bits.AD1IE = interruptEnable;
00043C  90005E     MOV [W14+10], W0
00043E  784000     MOV.B W0, W0
000440  604061     AND.B W0, #0x1, W0
000442  FB8000     ZE W0, W0
000444  600061     AND W0, #0x1, W0
000446  DD004D     SL W0, #13, W0
000448  8004A2     MOV IEC0, W2
00044A  2DFFF1     MOV #0xDFFF, W1
00044C  610081     AND W2, W1, W1
00044E  708000     IOR W1, W0, W0
000450  8804A0     MOV W0, IEC0
50:                    IPC3bits.AD1IP = 7;
000452  800551     MOV IPC3, W1
000454  200700     MOV #0x70, W0
000456  708000     IOR W1, W0, W0
000458  880550     MOV W0, IPC3
51:                
52:                    clbk = interruptClbk;
00045A  90006E     MOV [W14+12], W0
00045C  888A00     MOV W0, clbk
53:                
54:                    minVoltage = minV;
00045E  97B83E     MOV [W14-10], W0
000460  97B8CE     MOV [W14-8], W1
000462  888A10     MOV W0, minVoltage
000464  888A21     MOV W1, 0x1144
55:                    maxVoltage = maxV;
000466  97B81E     MOV [W14-14], W0
000468  97B8AE     MOV [W14-12], W1
00046A  888A30     MOV W0, maxVoltage
00046C  888A41     MOV W1, 0x1148
56:                
57:                    AD1CON1bits.ADON = 1;
00046E  A8E321     BSET 0x321, #7
58:                }
000470  FA8000     ULNK
000472  060000     RETURN
59:                
60:                inline double getActVoltageADC1 ()
61:                {
000474  FA0008     LNK #0x8
000476  BE9F88     MOV.D W8, [W15++]
62:                double ris, d;
63:                
64:                    d = maxVoltage - minVoltage;
000478  808A34     MOV maxVoltage, W4
00047A  808A45     MOV 0x1148, W5
00047C  808A10     MOV minVoltage, W0
00047E  808A21     MOV 0x1144, W1
000480  BE0100     MOV.D W0, W2
000482  BE0004     MOV.D W4, W0
000484  07098E     RCALL ___subsf3
000486  BE8F00     MOV.D W0, [W14]
65:                
66:                    ris = (d * ADC1BUF0)/MAX_ADC1BUF0;
000488  801800     MOV ADC1BUF0, W0
00048A  200001     MOV #0x0, W1
00048C  070A7A     RCALL ___floatunsisf
00048E  BE011E     MOV.D [W14], W2
000490  070ACD     RCALL ___mulsf3
000492  BE0400     MOV.D W0, W8
000494  86A470     MOV 0xD48E, W0
000496  DE80CF     ASR W0, #15, W1
000498  070A71     RCALL ___floatsisf
00049A  BE0100     MOV.D W0, W2
00049C  BE0008     MOV.D W8, W0
00049E  0709DF     RCALL ___divsf3
0004A0  980720     MOV W0, [W14+4]
0004A2  980731     MOV W1, [W14+6]
67:                
68:                    return ris;
0004A4  90002E     MOV [W14+4], W0
0004A6  9000BE     MOV [W14+6], W1
69:                }
0004A8  BE044F     MOV.D [--W15], W8
0004AA  FA8000     ULNK
0004AC  060000     RETURN
70:                
71:                inline voltage10bits_t getActBUFADC1 ()
72:                {
0004AE  FA0000     LNK #0x0
73:                    return ADC1BUF0;
0004B0  801800     MOV ADC1BUF0, W0
74:                }
0004B2  FA8000     ULNK
0004B4  060000     RETURN
75:                
76:                void beginSamplingADC1 ()
77:                {
0004B6  FA0000     LNK #0x0
78:                    AD1CON1bits.DONE = 0;
0004B8  A90320     BCLR AD1CON1, #0
79:                    AD1CON1bits.SAMP = 1;
0004BA  A82320     BSET AD1CON1, #1
80:                
81:                    while (AD1CON1bits.SAMP == 1);
0004BC  000000     NOP
0004BE  801900     MOV AD1CON1, W0
0004C0  600062     AND W0, #0x2, W0
0004C2  500FE0     SUB W0, #0x0, [W15]
0004C4  3AFFFC     BRA NZ, 0x4BE
82:                }
0004C6  FA8000     ULNK
0004C8  060000     RETURN
83:                
84:                int doneADC1 ()
85:                {
0004CA  FA0000     LNK #0x0
86:                    return AD1CON1bits.DONE;
0004CC  801900     MOV AD1CON1, W0
0004CE  784000     MOV.B W0, W0
0004D0  604061     AND.B W0, #0x1, W0
0004D2  FB8000     ZE W0, W0
87:                }
0004D4  FA8000     ULNK
0004D6  060000     RETURN
88:                
89:                long int power (int num, int exponent)
90:                {
0004D8  FA000C     LNK #0xC
0004DA  980740     MOV W0, [W14+8]
0004DC  980751     MOV W1, [W14+10]
91:                    long int ris = 1, i;
0004DE  200010     MOV #0x1, W0
0004E0  200001     MOV #0x0, W1
0004E2  BE8F00     MOV.D W0, [W14]
92:                
93:                    for (i = 0; i < exponent; i++)
0004E4  B80060     MUL.UU W0, #0, W0
0004E6  980720     MOV W0, [W14+4]
0004E8  980731     MOV W1, [W14+6]
0004EA  370015     BRA 0x516
00050A  90002E     MOV [W14+4], W0
00050C  9000BE     MOV [W14+6], W1
00050E  400061     ADD W0, #0x1, W0
000510  4880E0     ADDC W1, #0x0, W1
000512  980720     MOV W0, [W14+4]
000514  980731     MOV W1, [W14+6]
000516  90005E     MOV [W14+10], W0
000518  B90161     MUL.SU W0, #1, W2
00051A  90002E     MOV [W14+4], W0
00051C  9000BE     MOV [W14+6], W1
00051E  510F80     SUB W2, W0, [W15]
000520  598F81     SUBB W3, W1, [W15]
000522  3CFFE4     BRA GT, 0x4EC
94:                        ris *= num;
0004EC  90004E     MOV [W14+8], W0
0004EE  DE80CF     ASR W0, #15, W1
0004F0  90011E     MOV [W14+2], W2
0004F2  B99100     MUL.SS W2, W0, W2
0004F4  780102     MOV W2, W2
0004F6  78019E     MOV [W14], W3
0004F8  B99A01     MUL.SS W3, W1, W4
0004FA  780184     MOV W4, W3
0004FC  410103     ADD W2, W3, W2
0004FE  78019E     MOV [W14], W3
000500  B81800     MUL.UU W3, W0, W0
000502  410101     ADD W2, W1, W2
000504  780082     MOV W2, W1
000506  BE8F00     MOV.D W0, [W14]
000508  BE8F00     MOV.D W0, [W14]
95:                
96:                    return ris;
000524  BE001E     MOV.D [W14], W0
97:                }
000526  FA8000     ULNK
000528  060000     RETURN
98:                
99:                void setInputPinADC1 (int pin)
100:               {
00052A  FA0002     LNK #0x2
00052C  BE9F88     MOV.D W8, [W15++]
00052E  780F00     MOV W0, [W14]
101:                   if (AD1PCFGL != ~(power(2, pin)))
000530  801960     MOV AD1PCFGL, W0
000532  B80461     MUL.UU W0, #1, W8
000534  78009E     MOV [W14], W1
000536  200020     MOV #0x2, W0
000538  07FFCF     RCALL power
00053A  EA8000     COM W0, W0
00053C  EA8081     COM W1, W1
00053E  540F80     SUB W8, W0, [W15]
000540  5C8F81     SUBB W9, W1, [W15]
000542  320022     BRA Z, 0x588
102:                   {
103:                       AD1CON1bits.ADON = 0;
000544  A9E321     BCLR 0x321, #7
104:               
105:                       AD1PCFGL = ~(power(2, pin));
000546  78009E     MOV [W14], W1
000548  200020     MOV #0x2, W0
00054A  07FFC6     RCALL power
00054C  780000     MOV W0, W0
00054E  EA8000     COM W0, W0
000550  881960     MOV W0, AD1PCFGL
106:               
107:                       AD1CHS0bits.CH0SB = pin;
000552  78001E     MOV [W14], W0
000554  784000     MOV.B W0, W0
000556  60407F     AND.B W0, #0x1F, W0
000558  FB8000     ZE W0, W0
00055A  60007F     AND W0, #0x1F, W0
00055C  DD0048     SL W0, #8, W0
00055E  801942     MOV AD1CHS0, W2
000560  2E0FF1     MOV #0xE0FF, W1
000562  610081     AND W2, W1, W1
000564  708000     IOR W1, W0, W0
000566  881940     MOV W0, AD1CHS0
108:                       AD1CHS0bits.CH0SA = pin;
000568  78001E     MOV [W14], W0
00056A  784000     MOV.B W0, W0
00056C  60407F     AND.B W0, #0x1F, W0
00056E  FB8000     ZE W0, W0
000570  60007F     AND W0, #0x1F, W0
000572  801942     MOV AD1CHS0, W2
000574  2FFE01     MOV #0xFFE0, W1
000576  610081     AND W2, W1, W1
000578  708000     IOR W1, W0, W0
00057A  881940     MOV W0, AD1CHS0
109:               
110:                       AD1CSSL = power(2, pin);
00057C  78009E     MOV [W14], W1
00057E  200020     MOV #0x2, W0
000580  07FFAB     RCALL power
000582  780000     MOV W0, W0
000584  881980     MOV W0, AD1CSSL
111:               
112:                       AD1CON1bits.ADON = 1;
000586  A8E321     BSET 0x321, #7
113:                   }
114:               }
000588  BE044F     MOV.D [--W15], W8
00058A  FA8000     ULNK
00058C  060000     RETURN
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/TextEntry.c  ---------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library
3:                  *  GOL Layer 
4:                  *  TextEntry
5:                  *****************************************************************************
6:                  * FileName:        Textentry.c
7:                  * Dependencies:    Textentry.h
8:                  * Processor:       PIC24F, PIC24H, dsPIC, PIC32
9:                  * Compiler:       	MPLAB C30 Version 3.00, C32
10:                 * Linker:          MPLAB LINK30, LINK32
11:                 * Company:         Microchip Technology Incorporated
12:                 *
13:                 * Software License Agreement
14:                 *
15:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
16:                 * Microchip licenses to you the right to use, modify, copy and distribute
17:                 * Software only when embedded on a Microchip microcontroller or digital
18:                 * signal controller, which is integrated into your product or third party
19:                 * product (pursuant to the sublicense terms in the accompanying license
20:                 * agreement).  
21:                 *
22:                 * You should refer to the license agreement accompanying this Software
23:                 * for additional information regarding your rights and obligations.
24:                 *
25:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
26:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
27:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
28:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
29:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
30:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
32:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
33:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
34:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
35:                 * OR OTHER SIMILAR COSTS.
36:                 *
37:                 * Date        Comment
38:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:                 * 10/24/08	    ...
40:                 * 07/01/09	    Updated for 2D accelerated primitive support.
41:                 * 04/15/10	    Corrected TeSetBuffer() issue on string max size.
42:                 * 08/04/11     Modified widget draw states to correct flow of rendering.
43:                 *              Added check on the Bar() calls in cases when the non-blocking
44:                 *              is used.
45:                 * 12/02/11     Fix memory leak issue when TeCreateKeyMembers fails to allocate
46:                 *              memory for all keys.
47:                 * 12/13/11     Fix issue when displaying string with length equal to max size.
48:                 * 03/05/12     - Added Gradient feature.
49:                 *              - Enabled use of rounded buttons. User can now specify the rounded
50:                 *                edge radius in the GraphicsConfing.h file. 
51:                *                 (See TE_ROUNDEDBUTTON_RADIUS macro for deatils).
52:                 *****************************************************************************/
53:                #include "Graphics/Graphics.h"
54:                
55:                #ifdef USE_TEXTENTRY
56:                
57:                /*********************************************************************
58:                * Function: TEXTENTRY *TeCreate(WORD ID, SHORT left, SHORT top, SHORT right, SHORT bottom, WORD state
59:                *					SHORT horizontalKeys, SHORT verticalKeys, XCHAR *pText[], 
60:                *					void *pBuffer, WORD bufferLength, void *pDisplayFont, 
61:                *					GOL_SCHEME *pScheme)
62:                *
63:                *
64:                * Notes: 
65:                *
66:                ********************************************************************/
67:                TEXTENTRY *TeCreate
68:                (
69:                    WORD        ID,
70:                    SHORT       left,
71:                    SHORT       top,
72:                    SHORT       right,
73:                    SHORT       bottom,
74:                    WORD        state,
75:                    SHORT       horizontalKeys,
76:                    SHORT       verticalKeys,
77:                    XCHAR       *pText[],
78:                    void        *pBuffer,
79:                    WORD        bufferLength,
80:                    void        *pDisplayFont,
81:                    GOL_SCHEME  *pScheme
82:                )
83:                {
006C7A  FA0012     LNK #0x12
006C7C  980710     MOV W0, [W14+2]
006C7E  980721     MOV W1, [W14+4]
006C80  980732     MOV W2, [W14+6]
006C82  980743     MOV W3, [W14+8]
006C84  980754     MOV W4, [W14+10]
006C86  980765     MOV W5, [W14+12]
006C88  980776     MOV W6, [W14+14]
006C8A  980F07     MOV W7, [W14+16]
84:                    TEXTENTRY   *pTe = NULL;                    //Text entry
006C8C  EB0000     CLR W0
006C8E  780F00     MOV W0, [W14]
85:                    pTe = (TEXTENTRY *)GFX_malloc(sizeof(TEXTENTRY));
006C90  2002A0     MOV #0x2A, W0
006C92  07D95E     RCALL _malloc
006C94  780F00     MOV W0, [W14]
86:                    if(pTe == NULL)
006C96  78001E     MOV [W14], W0
006C98  500FE0     SUB W0, #0x0, [W15]
006C9A  3A0002     BRA NZ, 0x6CA0
87:                        return (NULL);
006C9C  EB0000     CLR W0
006C9E  370062     BRA 0x6D64
88:                
89:                    pTe->hdr.ID = ID;
006CA0  78001E     MOV [W14], W0
006CA2  90009E     MOV [W14+2], W1
006CA4  780801     MOV W1, [W0]
90:                    pTe->hdr.pNxtObj = NULL;
006CA6  78001E     MOV [W14], W0
006CA8  EB0080     CLR W1
006CAA  980011     MOV W1, [W0+2]
91:                    pTe->hdr.type = OBJ_TEXTENTRY;              // set object type
006CAC  78001E     MOV [W14], W0
006CAE  200101     MOV #0x10, W1
006CB0  980021     MOV W1, [W0+4]
92:                    pTe->hdr.left = left;                       // left parameter of the text-entry
006CB2  78001E     MOV [W14], W0
006CB4  9000AE     MOV [W14+4], W1
006CB6  980041     MOV W1, [W0+8]
93:                    pTe->hdr.top = top;                         // top parameter of the text-entry
006CB8  78001E     MOV [W14], W0
006CBA  9000BE     MOV [W14+6], W1
006CBC  980051     MOV W1, [W0+10]
94:                    pTe->hdr.right = right;                     // right parameter of the text-entry
006CBE  78001E     MOV [W14], W0
006CC0  9000CE     MOV [W14+8], W1
006CC2  980061     MOV W1, [W0+12]
95:                    pTe->hdr.bottom = bottom;                   // bottom parameter of the text-entry
006CC4  78001E     MOV [W14], W0
006CC6  9000DE     MOV [W14+10], W1
006CC8  980071     MOV W1, [W0+14]
96:                    pTe->hdr.state = state;                     // State of the Text-Entry
006CCA  78001E     MOV [W14], W0
006CCC  9000EE     MOV [W14+12], W1
006CCE  980031     MOV W1, [W0+6]
97:                    pTe->horizontalKeys = horizontalKeys;       // number of horizontal keys
006CD0  78001E     MOV [W14], W0
006CD2  9000FE     MOV [W14+14], W1
006CD4  980851     MOV W1, [W0+26]
98:                    pTe->verticalKeys = verticalKeys;           // number of vertical keys
006CD6  78001E     MOV [W14], W0
006CD8  90088E     MOV [W14+16], W1
006CDA  980861     MOV W1, [W0+28]
99:                    pTe->CurrentLength = 0;                     // current length of text
006CDC  78001E     MOV [W14], W0
006CDE  EB0080     CLR W1
006CE0  981001     MOV W1, [W0+32]
100:                   pTe->pHeadOfList = NULL;
006CE2  78001E     MOV [W14], W0
006CE4  EB0080     CLR W1
006CE6  981031     MOV W1, [W0+38]
101:                   TeSetBuffer(pTe, pBuffer, bufferLength);    // set the text to be displayed buffer length is also initialized in this call
006CE8  97B83E     MOV [W14-10], W0
006CEA  97B92E     MOV [W14-12], W2
006CEC  780080     MOV W0, W1
006CEE  78001E     MOV [W14], W0
006CF0  070411     RCALL TeSetBuffer
102:                   pTe->pActiveKey = NULL;
006CF2  78001E     MOV [W14], W0
006CF4  EB0080     CLR W1
006CF6  981021     MOV W1, [W0+36]
103:                   pTe->hdr.DrawObj = TeDraw;					// draw function
006CF8  78001E     MOV [W14], W0
006CFA  26D681     MOV #0x6D68, W1
006CFC  980811     MOV W1, [W0+18]
104:                   pTe->hdr.MsgObj = TeTranslateMsg;			// message function
006CFE  78001E     MOV [W14], W0
006D00  272801     MOV #0x7280, W1
006D02  980831     MOV W1, [W0+22]
105:                   pTe->hdr.MsgDefaultObj = TeMsgDefault;		// default message function
006D04  78001E     MOV [W14], W0
006D06  274241     MOV #0x7424, W1
006D08  980841     MOV W1, [W0+24]
106:                   pTe->hdr.FreeObj = TeDelKeyMembers;			// free function
006D0A  78001E     MOV [W14], W0
006D0C  277B21     MOV #0x77B2, W1
006D0E  980821     MOV W1, [W0+20]
107:               
108:                   // Set the color scheme to be used
109:                   if(pScheme == NULL)
006D10  97B80E     MOV [W14-16], W0
006D12  500FE0     SUB W0, #0x0, [W15]
006D14  3A0004     BRA NZ, 0x6D1E
110:                       pTe->hdr.pGolScheme = _pDefaultGolScheme;
006D16  808B41     MOV 0x1168, W1
006D18  78001E     MOV [W14], W0
006D1A  980801     MOV W1, [W0+16]
006D1C  370003     BRA 0x6D24
111:                   else
112:                       pTe->hdr.pGolScheme = (GOL_SCHEME *)pScheme;
006D1E  78001E     MOV [W14], W0
006D20  97B88E     MOV [W14-16], W1
006D22  980801     MOV W1, [W0+16]
113:               
114:                   // Set the font to be used
115:                   if(pDisplayFont == NULL)
006D24  97B81E     MOV [W14-14], W0
006D26  500FE0     SUB W0, #0x0, [W15]
006D28  3A0004     BRA NZ, 0x6D32
116:                       pTe->pDisplayFont = (void *) &FONTDEFAULT;
006D2A  78001E     MOV [W14], W0
006D2C  2C5461     MOV #0xC546, W1
006D2E  981041     MOV W1, [W0+40]
006D30  370003     BRA 0x6D38
117:                   else
118:                       pTe->pDisplayFont = pDisplayFont;
006D32  78001E     MOV [W14], W0
006D34  97B89E     MOV [W14-14], W1
006D36  981041     MOV W1, [W0+40]
119:               
120:                   //check if either values of horizontal keys and vertical keys are equal to zero
121:                   if((pTe->horizontalKeys != 0) || (pTe->verticalKeys != 0))
006D38  78001E     MOV [W14], W0
006D3A  900850     MOV [W0+26], W0
006D3C  500FE0     SUB W0, #0x0, [W15]
006D3E  3A0004     BRA NZ, 0x6D48
006D40  78001E     MOV [W14], W0
006D42  900860     MOV [W0+28], W0
006D44  500FE0     SUB W0, #0x0, [W15]
006D46  32000B     BRA Z, 0x6D5E
122:                   {
123:               
124:                       //create the key members, return null if not successful
125:                       if(TeCreateKeyMembers(pTe, pText) == NULL)
006D48  97B8CE     MOV [W14-8], W1
006D4A  78001E     MOV [W14], W0
006D4C  070478     RCALL TeCreateKeyMembers
006D4E  500FE0     SUB W0, #0x0, [W15]
006D50  3A0006     BRA NZ, 0x6D5E
126:                       {
127:                           TeDelKeyMembers(pTe);
006D52  78001E     MOV [W14], W0
006D54  07052E     RCALL TeDelKeyMembers
128:                           GFX_free(pTe);
006D56  78001E     MOV [W14], W0
006D58  07D996     RCALL _free
129:                           return (NULL);
006D5A  EB0000     CLR W0
006D5C  370003     BRA 0x6D64
130:                       }
131:                   }
132:               
133:                   //Add this new widget object to the GOL list	
134:                   GOLAddObject((OBJ_HEADER *)pTe);
006D5E  78001E     MOV [W14], W0
006D60  070C59     RCALL GOLAddObject
135:                   return (pTe);
006D62  78001E     MOV [W14], W0
136:               }   //end TeCreate()
006D64  FA8000     ULNK
006D66  060000     RETURN
137:               
138:               /*********************************************************************
139:               * Function: WORD TeDraw(void *pObj)
140:               *
141:               * Notes: This function draws the keys with their appropriate text
142:               *
143:               ********************************************************************/
144:               WORD TeDraw(void *pObj)
145:               {
006D68  FA0006     LNK #0x6
006D6A  781F88     MOV W8, [W15++]
006D6C  980720     MOV W0, [W14+4]
146:                   static GFX_COLOR    faceClr, embossLtClr, embossDkClr;
147:                   static WORD         xText, yText;
148:                   static XCHAR        XcharTmp;
149:                   static KEYMEMBER    *pKeyTemp = NULL;
150:               
151:                   static WORD         CountOfKeys = 0;
152:                   static WORD         counter = 0;
153:                   static XCHAR        hideChar[2] = {0x2A, 0x00};
154:                   
155:                   GFX_COLOR           color1, color2;
156:               
157:                   typedef enum
158:                   {
159:                       TE_START,
160:                       TE_HIDE_WIDGET,
161:                       TE_DRAW_PANEL,
162:                       TE_INIT_DRAW_EDITBOX,
163:                       TE_DRAW_EDITBOX,
164:                       TE_DRAW_KEY_INIT,
165:                       TE_DRAW_KEY_SET_PANEL,
166:                       TE_DRAW_KEY_DRAW_PANEL,
167:                       TE_DRAW_KEY_TEXT,
168:                       TE_DRAW_KEY_UPDATE,
169:                       TE_UPDATE_STRING_INIT,
170:                       TE_UPDATE_STRING,
171:                       TE_WAIT_ERASE_EBOX_AREA,
172:                       TE_UPDATE_CHARACTERS,
173:                   } TE_DRAW_STATES;
174:               
175:                   static TE_DRAW_STATES state = TE_START;
176:                   TEXTENTRY *pTe;
177:               
178:                   pTe = (TEXTENTRY *)pObj;
006D6E  90002E     MOV [W14+4], W0
006D70  780F00     MOV W0, [W14]
006D72  370001     BRA 0x6D76
179:               
180:               	while(1)
181:               	{
182:               		if(IsDeviceBusy())
006D76  072ACD     RCALL IsDeviceBusy
006D78  500FE0     SUB W0, #0x0, [W15]
006D7A  320002     BRA Z, 0x6D80
183:               			return (0);
006D7C  EB0000     CLR W0
006D7E  37027D     BRA 0x727A
184:               
185:               		switch(state)
006D80  808810     MOV state, W0
006D82  200001     MOV #0x0, W1
006D84  2000D2     MOV #0xD, W2
006D86  200003     MOV #0x0, W3
006D88  500F82     SUB W0, W2, [W15]
006D8A  588F83     SUBB W1, W3, [W15]
006D8C  3EFFF3     BRA GTU, 0x6D74
006D8E  016000     BRA W0
006D90  37000D     BRA 0x6DAC
006D92  370054     BRA 0x6E3C
006D94  370064     BRA 0x6E5E
006D96  37006A     BRA 0x6E6C
006D98  37008E     BRA 0x6EB6
006D9A  370094     BRA 0x6EC4
006D9C  3700BD     BRA 0x6F18
006D9E  37011B     BRA 0x6FD6
006DA0  37015E     BRA 0x705E
006DA2  370166     BRA 0x7070
006DA4  37016E     BRA 0x7082
006DA6  37023B     BRA 0x721E
006DA8  3701E7     BRA 0x7178
006DAA  37025B     BRA 0x7262
186:               		{
187:               			case TE_START:
188:               
189:               				if(GetState(pTe, TE_HIDE))
006DAC  78001E     MOV [W14], W0
006DAE  900030     MOV [W0+6], W0
006DB0  500FE0     SUB W0, #0x0, [W15]
006DB2  3D0007     BRA GE, 0x6DC2
190:               				{
191:               					SetColor(pTe->hdr.pGolScheme->CommonBkColor);
006DB4  78001E     MOV [W14], W0
006DB6  900800     MOV [W0+16], W0
006DB8  904800     MOV.B [W0+8], W0
006DBA  B7F13E     MOV.B WREG, _color
192:               					state = TE_HIDE_WIDGET;
006DBC  200010     MOV #0x1, W0
006DBE  888810     MOV W0, state
006DC0  37003D     BRA 0x6E3C
193:               					// no break here so it falls through to the TE_HIDE_WIDGET state.
194:               				}
195:               				else
196:               				{
197:               					if(GetState(pTe, TE_DRAW))
006DC2  78001E     MOV [W14], W0
006DC4  9000B0     MOV [W0+6], W1
006DC6  240000     MOV #0x4000, W0
006DC8  608000     AND W1, W0, W0
006DCA  500FE0     SUB W0, #0x0, [W15]
006DCC  320025     BRA Z, 0x6E18
198:               					{
199:                                       if (TE_ROUNDEDBUTTON_RADIUS == 0)
200:                                       {
201:                                           color1 = pTe->hdr.pGolScheme->EmbossDkColor;
006DCE  78001E     MOV [W14], W0
006DD0  900800     MOV [W0+16], W0
006DD2  784090     MOV.B [W0], W1
006DD4  984721     MOV.B W1, [W14+2]
202:                                           color2 = pTe->hdr.pGolScheme->EmbossLtColor;
006DD6  78001E     MOV [W14], W0
006DD8  900800     MOV [W0+16], W0
006DDA  904090     MOV.B [W0+1], W1
006DDC  984731     MOV.B W1, [W14+3]
203:                                       }
204:                                       else
205:                                       {                    
206:                                           color1 = pTe->hdr.pGolScheme->Color0;
207:                                           color2 = pTe->hdr.pGolScheme->Color0;
208:                                       }
209:               
210:               						/************DRAW THE WIDGET PANEL*****************************/
211:               						GOLPanelDraw
006DDE  78001E     MOV [W14], W0
006DE0  900040     MOV [W0+8], W0
006DE2  8888A0     MOV W0, _rpnlX1
006DE4  78001E     MOV [W14], W0
006DE6  900050     MOV [W0+10], W0
006DE8  8888B0     MOV W0, _rpnlY1
006DEA  78001E     MOV [W14], W0
006DEC  900060     MOV [W0+12], W0
006DEE  8888C0     MOV W0, _rpnlX2
006DF0  78001E     MOV [W14], W0
006DF2  900070     MOV [W0+14], W0
006DF4  8888D0     MOV W0, _rpnlY2
006DF6  EB0000     CLR W0
006DF8  8888E0     MOV W0, _rpnlR
006DFA  78001E     MOV [W14], W0
006DFC  900800     MOV [W0+16], W0
006DFE  904050     MOV.B [W0+5], W0
006E00  B7F11E     MOV.B WREG, _rpnlFaceColor
006E02  90402E     MOV.B [W14+2], W0
006E04  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
006E06  90403E     MOV.B [W14+3], W0
006E08  B7F120     MOV.B WREG, _rpnlEmbossDkColor
006E0A  EB0000     CLR W0
006E0C  888B60     MOV W0, 0x116C
006E0E  B3C030     MOV #0x3, W0
006E10  B7F121     MOV.B WREG, _rpnlEmbossSize
212:               						(
213:               							pTe->hdr.left,
214:               							pTe->hdr.top,
215:               							pTe->hdr.right,
216:               							pTe->hdr.bottom,
217:               							0,
218:               							pTe->hdr.pGolScheme->Color0,        //face color of panel
219:               							color1, //emboss dark color
220:               							color2, //emboss light color
221:               							NULL,
222:               							GOL_EMBOSS_SIZE
223:               						);
224:               						state = TE_DRAW_PANEL;
006E12  200020     MOV #0x2, W0
006E14  888810     MOV W0, state
225:               						break;
006E16  370230     BRA 0x7278
226:               					}
227:               
228:               					// update the keys (if TE_UPDATE_TEXT is also set it will also be redrawn)
229:               					// at the states after the keys are updated
230:               					else if(GetState(pTe, TE_UPDATE_KEY))
006E18  78001E     MOV [W14], W0
006E1A  9000B0     MOV [W0+6], W1
006E1C  220000     MOV #0x2000, W0
006E1E  608000     AND W1, W0, W0
006E20  500FE0     SUB W0, #0x0, [W15]
006E22  320003     BRA Z, 0x6E2A
231:               					{
232:               						state = TE_DRAW_KEY_INIT;
006E24  200050     MOV #0x5, W0
006E26  888810     MOV W0, state
233:               						break;
006E28  370227     BRA 0x7278
234:               					}
235:               
236:               					// check if updating only the text displayed
237:               					else if(GetState(pTe, TE_UPDATE_TEXT))
006E2A  78001E     MOV [W14], W0
006E2C  9000B0     MOV [W0+6], W1
006E2E  210000     MOV #0x1000, W0
006E30  608000     AND W1, W0, W0
006E32  500FE0     SUB W0, #0x0, [W15]
006E34  320003     BRA Z, 0x6E3C
238:               					{
239:               						state = TE_UPDATE_STRING_INIT;
006E36  2000A0     MOV #0xA, W0
006E38  888810     MOV W0, state
240:               						break;
006E3A  37021E     BRA 0x7278
241:               					}
242:               				}
243:               
244:               			/*hide the widget*/
245:               			case TE_HIDE_WIDGET:
246:               			    // this state only gets entered if IsDeviceBusy() immediately after while(1) returns a 0.
247:               				if (!Bar(pTe->hdr.left, pTe->hdr.top, pTe->hdr.right, pTe->hdr.bottom))
006E3C  78001E     MOV [W14], W0
006E3E  9001F0     MOV [W0+14], W3
006E40  78001E     MOV [W14], W0
006E42  900160     MOV [W0+12], W2
006E44  78001E     MOV [W14], W0
006E46  9000D0     MOV [W0+10], W1
006E48  78001E     MOV [W14], W0
006E4A  900040     MOV [W0+8], W0
006E4C  07F337     RCALL Bar
006E4E  500FE0     SUB W0, #0x0, [W15]
006E50  3A0002     BRA NZ, 0x6E56
248:                                   return (0);
006E52  EB0000     CLR W0
006E54  370212     BRA 0x727A
249:                               else 
250:                               {
251:                   				state = TE_START;
006E56  EB0000     CLR W0
006E58  888810     MOV W0, state
252:               	    			return (1);
006E5A  200010     MOV #0x1, W0
006E5C  37020E     BRA 0x727A
253:                               }
254:               
255:               			/*Draw the widget of the Text-Entry*/
256:               			case TE_DRAW_PANEL:
257:               				if(!GOLPanelDrawTsk()) 
006E5E  070CC6     RCALL GOLPanelDrawTsk
006E60  500FE0     SUB W0, #0x0, [W15]
006E62  3A0002     BRA NZ, 0x6E68
258:               					return (0);
006E64  EB0000     CLR W0
006E66  370209     BRA 0x727A
259:               				state = TE_INIT_DRAW_EDITBOX;
006E68  200030     MOV #0x3, W0
006E6A  888810     MOV W0, state
260:               
261:               			case TE_INIT_DRAW_EDITBOX:
262:               
263:               				//Draw the editbox
264:               				GOLPanelDraw
006E6C  78001E     MOV [W14], W0
006E6E  900040     MOV [W0+8], W0
006E70  8888A0     MOV W0, _rpnlX1
006E72  78001E     MOV [W14], W0
006E74  900050     MOV [W0+10], W0
006E76  8888B0     MOV W0, _rpnlY1
006E78  78001E     MOV [W14], W0
006E7A  900060     MOV [W0+12], W0
006E7C  8888C0     MOV W0, _rpnlX2
006E7E  78001E     MOV [W14], W0
006E80  900450     MOV [W0+10], W8
006E82  78001E     MOV [W14], W0
006E84  901040     MOV [W0+40], W0
006E86  07FBE4     RCALL GetTextHeight
006E88  440000     ADD W8, W0, W0
006E8A  400063     ADD W0, #0x3, W0
006E8C  8888D0     MOV W0, _rpnlY2
006E8E  EB0000     CLR W0
006E90  8888E0     MOV W0, _rpnlR
006E92  78001E     MOV [W14], W0
006E94  900800     MOV [W0+16], W0
006E96  904060     MOV.B [W0+6], W0
006E98  B7F11E     MOV.B WREG, _rpnlFaceColor
006E9A  78001E     MOV [W14], W0
006E9C  900800     MOV [W0+16], W0
006E9E  784010     MOV.B [W0], W0
006EA0  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
006EA2  78001E     MOV [W14], W0
006EA4  900800     MOV [W0+16], W0
006EA6  904010     MOV.B [W0+1], W0
006EA8  B7F120     MOV.B WREG, _rpnlEmbossDkColor
006EAA  EB0000     CLR W0
006EAC  888B60     MOV W0, 0x116C
006EAE  B3C030     MOV #0x3, W0
006EB0  B7F121     MOV.B WREG, _rpnlEmbossSize
265:               				(
266:               					pTe->hdr.left,
267:               					pTe->hdr.top,
268:               					pTe->hdr.right,
269:               					pTe->hdr.top + GetTextHeight(pTe->pDisplayFont) + GOL_EMBOSS_SIZE,
270:               					0,
271:               					pTe->hdr.pGolScheme->Color1; ,
272:               					pTe->hdr.pGolScheme->EmbossDkColor,
273:               					pTe->hdr.pGolScheme->EmbossLtColor,
274:               					NULL,
275:               					GOL_EMBOSS_SIZE
276:               				);
277:               
278:               				state = TE_DRAW_EDITBOX;
006EB2  200040     MOV #0x4, W0
006EB4  888810     MOV W0, state
279:               
280:               			case TE_DRAW_EDITBOX:
281:               				if(!GOLPanelDrawTsk())
006EB6  070C9A     RCALL GOLPanelDrawTsk
006EB8  500FE0     SUB W0, #0x0, [W15]
006EBA  3A0002     BRA NZ, 0x6EC0
282:               					return (0);
006EBC  EB0000     CLR W0
006EBE  3701DD     BRA 0x727A
283:               				state = TE_DRAW_KEY_INIT;
006EC0  200050     MOV #0x5, W0
006EC2  888810     MOV W0, state
284:               
285:               			/* ********************************************************************* */
286:               			/*                  Update the keys                                      */
287:               			/* ********************************************************************* */
288:               			case TE_DRAW_KEY_INIT:
289:               				embossLtClr = pTe->hdr.pGolScheme->EmbossLtColor;
006EC4  78001E     MOV [W14], W0
006EC6  900800     MOV [W0+16], W0
006EC8  904010     MOV.B [W0+1], W0
006ECA  B7F104     MOV.B WREG, embossLtClr
290:               				embossDkClr = pTe->hdr.pGolScheme->EmbossDkColor;
006ECC  78001E     MOV [W14], W0
006ECE  900800     MOV [W0+16], W0
006ED0  784010     MOV.B [W0], W0
006ED2  B7F105     MOV.B WREG, embossDkClr
291:               				faceClr = pTe->hdr.pGolScheme->Color0;
006ED4  78001E     MOV [W14], W0
006ED6  900800     MOV [W0+16], W0
006ED8  904050     MOV.B [W0+5], W0
006EDA  B7F106     MOV.B WREG, faceClr
292:               
293:               				// if the active key update flag is set, only one needs to be redrawn
294:               				if((GetState(pTe, TE_DRAW) != TE_DRAW) && (pTe->pActiveKey->update == TRUE))
006EDC  78001E     MOV [W14], W0
006EDE  9000B0     MOV [W0+6], W1
006EE0  240000     MOV #0x4000, W0
006EE2  608000     AND W1, W0, W0
006EE4  500FE0     SUB W0, #0x0, [W15]
006EE6  3A0011     BRA NZ, 0x6F0A
006EE8  78001E     MOV [W14], W0
006EEA  901020     MOV [W0+36], W0
006EEC  900060     MOV [W0+12], W0
006EEE  500FE1     SUB W0, #0x1, [W15]
006EF0  3A000C     BRA NZ, 0x6F0A
295:               				{
296:               					CountOfKeys = (pTe->horizontalKeys * pTe->verticalKeys) -
006EF2  78001E     MOV [W14], W0
006EF4  9008D0     MOV [W0+26], W1
006EF6  78001E     MOV [W14], W0
006EF8  900860     MOV [W0+28], W0
006EFA  B98800     MUL.SS W1, W0, W0
006EFC  780000     MOV W0, W0
006EFE  E90000     DEC W0, W0
006F00  888840     MOV W0, CountOfKeys
297:               					1;
298:               					pKeyTemp = pTe->pActiveKey;
006F02  78001E     MOV [W14], W0
006F04  901020     MOV [W0+36], W0
006F06  888850     MOV W0, pKeyTemp
006F08  370005     BRA 0x6F14
299:               				}
300:               				else
301:               				{
302:               					CountOfKeys = 0;
006F0A  EB0000     CLR W0
006F0C  888840     MOV W0, CountOfKeys
303:               					pKeyTemp = pTe->pHeadOfList;
006F0E  78001E     MOV [W14], W0
006F10  901030     MOV [W0+38], W0
006F12  888850     MOV W0, pKeyTemp
304:               				}
305:               
306:               				state = TE_DRAW_KEY_SET_PANEL;
006F14  200060     MOV #0x6, W0
006F16  888810     MOV W0, state
307:               
308:               			case TE_DRAW_KEY_SET_PANEL:
309:               				if(CountOfKeys < (pTe->horizontalKeys * pTe->verticalKeys))
006F18  78001E     MOV [W14], W0
006F1A  9008D0     MOV [W0+26], W1
006F1C  78001E     MOV [W14], W0
006F1E  900860     MOV [W0+28], W0
006F20  B98800     MUL.SS W1, W0, W0
006F22  780000     MOV W0, W0
006F24  780080     MOV W0, W1
006F26  808840     MOV CountOfKeys, W0
006F28  508F80     SUB W1, W0, [W15]
006F2A  360052     BRA LEU, 0x6FD0
310:               				{
311:               
312:               					// check if we need to draw the panel
313:               					if(GetState(pTe, TE_DRAW) != TE_DRAW)
006F2C  78001E     MOV [W14], W0
006F2E  9000B0     MOV [W0+6], W1
006F30  240000     MOV #0x4000, W0
006F32  608000     AND W1, W0, W0
006F34  500FE0     SUB W0, #0x0, [W15]
006F36  3A0026     BRA NZ, 0x6F84
314:               					{
315:               						if(pKeyTemp->update == TRUE)
006F38  808850     MOV pKeyTemp, W0
006F3A  900060     MOV [W0+12], W0
006F3C  500FE1     SUB W0, #0x1, [W15]
006F3E  3A001F     BRA NZ, 0x6F7E
316:               						{
317:               
318:               							// set the colors needed
319:               							if(GetState(pTe, TE_KEY_PRESSED))
006F40  78001E     MOV [W14], W0
006F42  900030     MOV [W0+6], W0
006F44  600064     AND W0, #0x4, W0
006F46  500FE0     SUB W0, #0x0, [W15]
006F48  32000D     BRA Z, 0x6F64
320:               							{
321:               								embossLtClr = pTe->hdr.pGolScheme->EmbossDkColor;
006F4A  78001E     MOV [W14], W0
006F4C  900800     MOV [W0+16], W0
006F4E  784010     MOV.B [W0], W0
006F50  B7F104     MOV.B WREG, embossLtClr
322:               								embossDkClr = pTe->hdr.pGolScheme->EmbossLtColor;
006F52  78001E     MOV [W14], W0
006F54  900800     MOV [W0+16], W0
006F56  904010     MOV.B [W0+1], W0
006F58  B7F105     MOV.B WREG, embossDkClr
323:               								faceClr = pTe->hdr.pGolScheme->Color1;
006F5A  78001E     MOV [W14], W0
006F5C  900800     MOV [W0+16], W0
006F5E  904060     MOV.B [W0+6], W0
006F60  B7F106     MOV.B WREG, faceClr
006F62  370010     BRA 0x6F84
324:               							}
325:               							else
326:               							{
327:               								embossLtClr = pTe->hdr.pGolScheme->EmbossLtColor;
006F64  78001E     MOV [W14], W0
006F66  900800     MOV [W0+16], W0
006F68  904010     MOV.B [W0+1], W0
006F6A  B7F104     MOV.B WREG, embossLtClr
328:               								embossDkClr = pTe->hdr.pGolScheme->EmbossDkColor;
006F6C  78001E     MOV [W14], W0
006F6E  900800     MOV [W0+16], W0
006F70  784010     MOV.B [W0], W0
006F72  B7F105     MOV.B WREG, embossDkClr
329:               								faceClr = pTe->hdr.pGolScheme->Color0;
006F74  78001E     MOV [W14], W0
006F76  900800     MOV [W0+16], W0
006F78  904050     MOV.B [W0+5], W0
006F7A  B7F106     MOV.B WREG, faceClr
006F7C  370003     BRA 0x6F84
330:               							}
331:               						}
332:               						else
333:               						{
334:               							state = TE_DRAW_KEY_UPDATE;
006F7E  200090     MOV #0x9, W0
006F80  888810     MOV W0, state
335:               							break;
006F82  37017A     BRA 0x7278
336:               						}
337:               					}
338:               
339:               					if(GetState(pTe, TE_DISABLED) == TE_DISABLED)
006F84  78001E     MOV [W14], W0
006F86  900030     MOV [W0+6], W0
006F88  600062     AND W0, #0x2, W0
006F8A  500FE0     SUB W0, #0x0, [W15]
006F8C  320006     BRA Z, 0x6F9A
340:               					{
341:               						faceClr = SetColor(pTe->hdr.pGolScheme->ColorDisabled);
006F8E  78001E     MOV [W14], W0
006F90  900800     MOV [W0+16], W0
006F92  904070     MOV.B [W0+7], W0
006F94  B7F13E     MOV.B WREG, _color
006F96  BFD13E     MOV.B _color, WREG
006F98  B7F106     MOV.B WREG, faceClr
342:               					}
343:               
344:               #ifdef USE_GRADIENT
345:                                   // set the gradient parameters
346:                                   GOLGradientPanelDraw(pTe->hdr.pGolScheme);                
347:               #endif
348:               
349:               					// set up the panel
350:               					GOLPanelDraw
006F9A  808850     MOV pKeyTemp, W0
006F9C  780010     MOV [W0], W0
006F9E  8888A0     MOV W0, _rpnlX1
006FA0  808850     MOV pKeyTemp, W0
006FA2  900010     MOV [W0+2], W0
006FA4  8888B0     MOV W0, _rpnlY1
006FA6  808850     MOV pKeyTemp, W0
006FA8  900020     MOV [W0+4], W0
006FAA  8888C0     MOV W0, _rpnlX2
006FAC  808850     MOV pKeyTemp, W0
006FAE  900030     MOV [W0+6], W0
006FB0  8888D0     MOV W0, _rpnlY2
006FB2  EB0000     CLR W0
006FB4  8888E0     MOV W0, _rpnlR
006FB6  BFD106     MOV.B faceClr, WREG
006FB8  B7F11E     MOV.B WREG, _rpnlFaceColor
006FBA  BFD104     MOV.B embossLtClr, WREG
006FBC  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
006FBE  BFD105     MOV.B embossDkClr, WREG
006FC0  B7F120     MOV.B WREG, _rpnlEmbossDkColor
006FC2  EB0000     CLR W0
006FC4  888B60     MOV W0, 0x116C
006FC6  B3C030     MOV #0x3, W0
006FC8  B7F121     MOV.B WREG, _rpnlEmbossSize
351:               					(
352:               						pKeyTemp->left+TE_ROUNDEDBUTTON_RADIUS,
353:               						pKeyTemp->top+TE_ROUNDEDBUTTON_RADIUS,
354:               						pKeyTemp->right-TE_ROUNDEDBUTTON_RADIUS,
355:               						pKeyTemp->bottom-TE_ROUNDEDBUTTON_RADIUS,
356:               						TE_ROUNDEDBUTTON_RADIUS,
357:               						faceClr,
358:               						embossLtClr,
359:               						embossDkClr,
360:               						NULL,
361:               						GOL_EMBOSS_SIZE
362:               					);
363:               
364:               					state = TE_DRAW_KEY_DRAW_PANEL;
006FCA  200070     MOV #0x7, W0
006FCC  888810     MOV W0, state
006FCE  370003     BRA 0x6FD6
365:               				}
366:               				else
367:               				{
368:               					state = TE_UPDATE_STRING_INIT;
006FD0  2000A0     MOV #0xA, W0
006FD2  888810     MOV W0, state
369:               					break;
006FD4  370151     BRA 0x7278
370:               				}
371:               
372:               			case TE_DRAW_KEY_DRAW_PANEL:
373:               				if(!GOLPanelDrawTsk())
006FD6  070C0A     RCALL GOLPanelDrawTsk
006FD8  500FE0     SUB W0, #0x0, [W15]
006FDA  3A0002     BRA NZ, 0x6FE0
374:               					return (0);
006FDC  EB0000     CLR W0
006FDE  37014D     BRA 0x727A
375:               
376:               				// reset the update flag since the key panel is already redrawn   	
377:               				pKeyTemp->update = FALSE;
006FE0  808850     MOV pKeyTemp, W0
006FE2  EB0080     CLR W1
006FE4  980061     MOV W1, [W0+12]
378:               
379:               				//set the text coordinates of the drawn key
380:               				xText = ((pKeyTemp->left) + (pKeyTemp->right) - (pKeyTemp->textWidth)) >> 1;
006FE6  808850     MOV pKeyTemp, W0
006FE8  780090     MOV [W0], W1
006FEA  808850     MOV pKeyTemp, W0
006FEC  900020     MOV [W0+4], W0
006FEE  408080     ADD W1, W0, W1
006FF0  808850     MOV pKeyTemp, W0
006FF2  900810     MOV [W0+18], W0
006FF4  508000     SUB W1, W0, W0
006FF6  D18000     ASR W0, W0
006FF8  888860     MOV W0, xText
381:               				yText = ((pKeyTemp->bottom) + (pKeyTemp->top) - (pKeyTemp->textHeight)) >> 1;
006FFA  808850     MOV pKeyTemp, W0
006FFC  9000B0     MOV [W0+6], W1
006FFE  808850     MOV pKeyTemp, W0
007000  900010     MOV [W0+2], W0
007002  408080     ADD W1, W0, W1
007004  808850     MOV pKeyTemp, W0
007006  900820     MOV [W0+20], W0
007008  508000     SUB W1, W0, W0
00700A  D18000     ASR W0, W0
00700C  888870     MOV W0, yText
382:               
383:               				//set color of text
384:               				// if the object is disabled, draw the disabled colors
385:               				if(GetState(pTe, TE_DISABLED) == TE_DISABLED)
00700E  78001E     MOV [W14], W0
007010  900030     MOV [W0+6], W0
007012  600062     AND W0, #0x2, W0
007014  500FE0     SUB W0, #0x0, [W15]
007016  320005     BRA Z, 0x7022
386:               				{
387:               					SetColor(pTe->hdr.pGolScheme->TextColorDisabled);
007018  78001E     MOV [W14], W0
00701A  900800     MOV [W0+16], W0
00701C  904040     MOV.B [W0+4], W0
00701E  B7F13E     MOV.B WREG, _color
007020  370014     BRA 0x704A
388:               				}
389:               				else
390:               				{
391:               					if((GetState(pTe, TE_DRAW) != TE_DRAW) && (GetState(pTe, TE_KEY_PRESSED)) == TE_KEY_PRESSED)
007022  78001E     MOV [W14], W0
007024  9000B0     MOV [W0+6], W1
007026  240000     MOV #0x4000, W0
007028  608000     AND W1, W0, W0
00702A  500FE0     SUB W0, #0x0, [W15]
00702C  3A000A     BRA NZ, 0x7042
00702E  78001E     MOV [W14], W0
007030  900030     MOV [W0+6], W0
007032  600064     AND W0, #0x4, W0
007034  500FE0     SUB W0, #0x0, [W15]
007036  320005     BRA Z, 0x7042
392:               					{
393:               						SetColor(pTe->hdr.pGolScheme->TextColor1);
007038  78001E     MOV [W14], W0
00703A  900800     MOV [W0+16], W0
00703C  904030     MOV.B [W0+3], W0
00703E  B7F13E     MOV.B WREG, _color
007040  370004     BRA 0x704A
394:               					}
395:               					else
396:               					{
397:               						SetColor(pTe->hdr.pGolScheme->TextColor0);
007042  78001E     MOV [W14], W0
007044  900800     MOV [W0+16], W0
007046  904020     MOV.B [W0+2], W0
007048  B7F13E     MOV.B WREG, _color
398:               					}
399:               				}
400:               
401:               				//output the text
402:               				MoveTo(xText, yText);
00704A  808860     MOV xText, W0
00704C  888260     MOV W0, _cursorX
00704E  808870     MOV yText, W0
007050  888270     MOV W0, _cursorY
403:               
404:               				// set the font to be used
405:               				SetFont(pTe->hdr.pGolScheme->pFont);
007052  78001E     MOV [W14], W0
007054  900800     MOV [W0+16], W0
007056  900050     MOV [W0+10], W0
007058  07F8FF     RCALL SetFont
406:               
407:               				state = TE_DRAW_KEY_TEXT;
00705A  200080     MOV #0x8, W0
00705C  888810     MOV W0, state
408:               
409:               			case TE_DRAW_KEY_TEXT:
410:               				if(!OutText(pKeyTemp->pKeyName))
00705E  808850     MOV pKeyTemp, W0
007060  900800     MOV [W0+16], W0
007062  07FA50     RCALL OutText
007064  500FE0     SUB W0, #0x0, [W15]
007066  3A0002     BRA NZ, 0x706C
411:               					return (0);
007068  EB0000     CLR W0
00706A  370107     BRA 0x727A
412:               				state = TE_DRAW_KEY_UPDATE;
00706C  200090     MOV #0x9, W0
00706E  888810     MOV W0, state
413:               
414:               			case TE_DRAW_KEY_UPDATE:
415:               
416:               				// update loop variables
417:               				CountOfKeys++;
007070  808840     MOV CountOfKeys, W0
007072  E80000     INC W0, W0
007074  888840     MOV W0, CountOfKeys
418:               				pKeyTemp = pKeyTemp->pNextKey;
007076  808850     MOV pKeyTemp, W0
007078  900830     MOV [W0+22], W0
00707A  888850     MOV W0, pKeyTemp
419:               
420:               				state = TE_DRAW_KEY_SET_PANEL;
00707C  200060     MOV #0x6, W0
00707E  888810     MOV W0, state
421:               				break;
007080  3700FB     BRA 0x7278
422:               
423:               			/* ********************************************************************* */
424:               			/*                  Update the displayed string                          */
425:               			/* ********************************************************************* */
426:               			case TE_UPDATE_STRING_INIT:
427:               
428:               				// check if there are characters to remove
429:               				if(pTe->pActiveKey != NULL)
007082  78001E     MOV [W14], W0
007084  901020     MOV [W0+36], W0
007086  500FE0     SUB W0, #0x0, [W15]
007088  32000D     BRA Z, 0x70A4
430:               				{
431:               					if(pTe->pActiveKey->command == TE_DELETE_COM)
00708A  78001E     MOV [W14], W0
00708C  901020     MOV [W0+36], W0
00708E  900070     MOV [W0+14], W0
007090  500FE1     SUB W0, #0x1, [W15]
007092  3A0018     BRA NZ, 0x70C4
432:               					{
433:               						if(pTe->CurrentLength == 0)
007094  78001E     MOV [W14], W0
007096  901000     MOV [W0+32], W0
007098  500FE0     SUB W0, #0x0, [W15]
00709A  3A0014     BRA NZ, 0x70C4
434:               						{
435:               							state = TE_START;
00709C  EB0000     CLR W0
00709E  888810     MOV W0, state
436:               							return (1);
0070A0  200010     MOV #0x1, W0
0070A2  3700EB     BRA 0x727A
437:               						}
438:               					}
439:               				}
440:               				else
441:               				{
442:               
443:               					// check if text indeed needs to be updated
444:               					if((pTe->CurrentLength == pTe->outputLenMax) && (GetState(pTe, TE_UPDATE_TEXT)))
0070A4  78001E     MOV [W14], W0
0070A6  901080     MOV [W0+32], W1
0070A8  78001E     MOV [W14], W0
0070AA  901010     MOV [W0+34], W0
0070AC  508F80     SUB W1, W0, [W15]
0070AE  3A000A     BRA NZ, 0x70C4
0070B0  78001E     MOV [W14], W0
0070B2  9000B0     MOV [W0+6], W1
0070B4  210000     MOV #0x1000, W0
0070B6  608000     AND W1, W0, W0
0070B8  500FE0     SUB W0, #0x0, [W15]
0070BA  320004     BRA Z, 0x70C4
445:               					{
446:               						state = TE_START;
0070BC  EB0000     CLR W0
0070BE  888810     MOV W0, state
447:               						return (1);
0070C0  200010     MOV #0x1, W0
0070C2  3700DB     BRA 0x727A
448:               					}
449:               				}
450:               
451:               				//set the clipping region
452:               				SetClipRgn
453:               				(
0070E4  07F1D5     RCALL SetClipRgn
454:               					pTe->hdr.left + GOL_EMBOSS_SIZE,
0070DE  78001E     MOV [W14], W0
0070E0  900040     MOV [W0+8], W0
0070E2  400063     ADD W0, #0x3, W0
455:               					pTe->hdr.top + GOL_EMBOSS_SIZE,
0070D8  78001E     MOV [W14], W0
0070DA  900050     MOV [W0+10], W0
0070DC  4000E3     ADD W0, #0x3, W1
456:               					pTe->hdr.right - GOL_EMBOSS_SIZE,
0070D2  78001E     MOV [W14], W0
0070D4  900060     MOV [W0+12], W0
0070D6  500163     SUB W0, #0x3, W2
457:               					pTe->hdr.top + GOL_EMBOSS_SIZE + GetTextHeight(pTe->pDisplayFont)
0070C4  78001E     MOV [W14], W0
0070C6  900050     MOV [W0+10], W0
0070C8  400463     ADD W0, #0x3, W8
0070CA  78001E     MOV [W14], W0
0070CC  901040     MOV [W0+40], W0
0070CE  07FAC0     RCALL GetTextHeight
0070D0  440180     ADD W8, W0, W3
458:               				);
459:               
460:               				SetClip(1);     //set the clipping
0070E6  B3C010     MOV #0x1, W0
0070E8  07F1E2     RCALL SetClip
461:               				if(GetState(pTe, TE_DRAW))
0070EA  78001E     MOV [W14], W0
0070EC  9000B0     MOV [W0+6], W1
0070EE  240000     MOV #0x4000, W0
0070F0  608000     AND W1, W0, W0
0070F2  500FE0     SUB W0, #0x0, [W15]
0070F4  320029     BRA Z, 0x7148
462:               				{
463:               
464:               					// update only the displayed text
465:               					// position the string rendering on the right position
466:               					if(GetState(pTe, TE_ECHO_HIDE))
0070F6  78001E     MOV [W14], W0
0070F8  900030     MOV [W0+6], W0
0070FA  600068     AND W0, #0x8, W0
0070FC  500FE0     SUB W0, #0x0, [W15]
0070FE  320015     BRA Z, 0x712A
467:               					{
468:               
469:               						// fill the area with '*' character so we use the width of this character
470:               						MoveTo
007100  78001E     MOV [W14], W0
007102  900060     MOV [W0+12], W0
007104  780400     MOV W0, W8
007106  78001E     MOV [W14], W0
007108  901040     MOV [W0+40], W0
00710A  780080     MOV W0, W1
00710C  2118C0     MOV #0x118C, W0
00710E  07FA85     RCALL GetTextWidth
007110  780080     MOV W0, W1
007112  78001E     MOV [W14], W0
007114  901000     MOV [W0+32], W0
007116  B98800     MUL.SS W1, W0, W0
007118  780000     MOV W0, W0
00711A  540000     SUB W8, W0, W0
00711C  500067     SUB W0, #0x7, W0
00711E  888260     MOV W0, _cursorX
007120  78001E     MOV [W14], W0
007122  900050     MOV [W0+10], W0
007124  400063     ADD W0, #0x3, W0
007126  888270     MOV W0, _cursorY
007128  370022     BRA 0x716E
471:               						(
472:               							pTe->hdr.right - 4 - GOL_EMBOSS_SIZE - (GetTextWidth(hideChar, pTe->pDisplayFont) * pTe->CurrentLength),
473:               							pTe->hdr.top + GOL_EMBOSS_SIZE
474:               						);
475:               					}
476:               					else
477:               					{
478:               						MoveTo
00712A  78001E     MOV [W14], W0
00712C  900060     MOV [W0+12], W0
00712E  500467     SUB W0, #0x7, W8
007130  78001E     MOV [W14], W0
007132  9010C0     MOV [W0+40], W1
007134  78001E     MOV [W14], W0
007136  900870     MOV [W0+30], W0
007138  07FA70     RCALL GetTextWidth
00713A  540000     SUB W8, W0, W0
00713C  888260     MOV W0, _cursorX
00713E  78001E     MOV [W14], W0
007140  900050     MOV [W0+10], W0
007142  400063     ADD W0, #0x3, W0
007144  888270     MOV W0, _cursorY
007146  370013     BRA 0x716E
479:               						(
480:               							pTe->hdr.right - 4 - GOL_EMBOSS_SIZE - GetTextWidth(pTe->pTeOutput, pTe->pDisplayFont),
481:               							pTe->hdr.top + GOL_EMBOSS_SIZE
482:               						);
483:               					}
484:               				}
485:               				else if(GetState(pTe, TE_UPDATE_TEXT))
007148  78001E     MOV [W14], W0
00714A  9000B0     MOV [W0+6], W1
00714C  210000     MOV #0x1000, W0
00714E  608000     AND W1, W0, W0
007150  500FE0     SUB W0, #0x0, [W15]
007152  320007     BRA Z, 0x7162
486:               				{
487:               
488:               					// erase the current text by drawing a bar over the edit box area
489:               					SetColor(pTe->hdr.pGolScheme->Color1);
007154  78001E     MOV [W14], W0
007156  900800     MOV [W0+16], W0
007158  904060     MOV.B [W0+6], W0
00715A  B7F13E     MOV.B WREG, _color
490:               
491:               					// we have to make sure we finish the Bar() first before we continue.
492:               					state = TE_WAIT_ERASE_EBOX_AREA;
00715C  2000C0     MOV #0xC, W0
00715E  888810     MOV W0, state
493:               					break;
007160  37008B     BRA 0x7278
494:               				}
495:               				else
496:               				{
497:               					SetClip(0); //reset the clipping
007162  EB4000     CLR.B W0
007164  07F1A4     RCALL SetClip
498:               					state = TE_START;
007166  EB0000     CLR W0
007168  888810     MOV W0, state
499:               					return (1);
00716A  200010     MOV #0x1, W0
00716C  370086     BRA 0x727A
500:               				}
501:               
502:               				counter = 0;
00716E  EB0000     CLR W0
007170  888880     MOV W0, counter
503:               				state = TE_UPDATE_STRING;
007172  2000B0     MOV #0xB, W0
007174  888810     MOV W0, state
504:               				break;
007176  370080     BRA 0x7278
505:               
506:               			case TE_WAIT_ERASE_EBOX_AREA:
507:                               if (!Bar
00719A  500FE0     SUB W0, #0x0, [W15]
00719C  3A0002     BRA NZ, 0x71A2
508:               					(
007198  07F191     RCALL Bar
509:               						pTe->hdr.left + GOL_EMBOSS_SIZE,
007192  78001E     MOV [W14], W0
007194  900040     MOV [W0+8], W0
007196  400063     ADD W0, #0x3, W0
510:               						pTe->hdr.top + GOL_EMBOSS_SIZE,
00718C  78001E     MOV [W14], W0
00718E  900050     MOV [W0+10], W0
007190  4000E3     ADD W0, #0x3, W1
511:               						pTe->hdr.right - GOL_EMBOSS_SIZE,
007186  78001E     MOV [W14], W0
007188  900060     MOV [W0+12], W0
00718A  500163     SUB W0, #0x3, W2
512:               						pTe->hdr.top + GOL_EMBOSS_SIZE + GetTextHeight(pTe->pDisplayFont)
007178  78001E     MOV [W14], W0
00717A  900050     MOV [W0+10], W0
00717C  400463     ADD W0, #0x3, W8
00717E  78001E     MOV [W14], W0
007180  901040     MOV [W0+40], W0
007182  07FA66     RCALL GetTextHeight
007184  440180     ADD W8, W0, W3
513:               					))
514:                                   return 0;
00719E  EB0000     CLR W0
0071A0  37006C     BRA 0x727A
515:               
516:               				// check if the command given is delete a character
517:               				if(pTe->pActiveKey->command == TE_DELETE_COM)
0071A2  78001E     MOV [W14], W0
0071A4  901020     MOV [W0+36], W0
0071A6  900070     MOV [W0+14], W0
0071A8  500FE1     SUB W0, #0x1, [W15]
0071AA  3A000C     BRA NZ, 0x71C4
518:               				{
519:               					*(pTe->pTeOutput + (--pTe->CurrentLength)) = 0;
0071AC  78001E     MOV [W14], W0
0071AE  9008F0     MOV [W0+30], W1
0071B0  78001E     MOV [W14], W0
0071B2  901000     MOV [W0+32], W0
0071B4  E90100     DEC W0, W2
0071B6  78001E     MOV [W14], W0
0071B8  981002     MOV W2, [W0+32]
0071BA  78001E     MOV [W14], W0
0071BC  901000     MOV [W0+32], W0
0071BE  408080     ADD W1, W0, W1
0071C0  EB4000     CLR.B W0
0071C2  784880     MOV.B W0, [W1]
520:               				}
521:               
522:               				// position the cursor to the start of string rendering
523:               				// notice that we need to remove the characters first before we position the cursor when
524:               				// deleting characters
525:               				if(GetState(pTe, TE_ECHO_HIDE))
0071C4  78001E     MOV [W14], W0
0071C6  900030     MOV [W0+6], W0
0071C8  600068     AND W0, #0x8, W0
0071CA  500FE0     SUB W0, #0x0, [W15]
0071CC  320015     BRA Z, 0x71F8
526:               				{
527:               
528:               					// fill the area with '*' character so we use the width of this character
529:               					MoveTo
0071CE  78001E     MOV [W14], W0
0071D0  900060     MOV [W0+12], W0
0071D2  780400     MOV W0, W8
0071D4  78001E     MOV [W14], W0
0071D6  901040     MOV [W0+40], W0
0071D8  780080     MOV W0, W1
0071DA  2118C0     MOV #0x118C, W0
0071DC  07FA1E     RCALL GetTextWidth
0071DE  780080     MOV W0, W1
0071E0  78001E     MOV [W14], W0
0071E2  901000     MOV [W0+32], W0
0071E4  B98800     MUL.SS W1, W0, W0
0071E6  780000     MOV W0, W0
0071E8  540000     SUB W8, W0, W0
0071EA  500067     SUB W0, #0x7, W0
0071EC  888260     MOV W0, _cursorX
0071EE  78001E     MOV [W14], W0
0071F0  900050     MOV [W0+10], W0
0071F2  400063     ADD W0, #0x3, W0
0071F4  888270     MOV W0, _cursorY
0071F6  37000E     BRA 0x7214
530:               					(
531:               						pTe->hdr.right - 4 - GOL_EMBOSS_SIZE - (GetTextWidth(hideChar, pTe->pDisplayFont) * (pTe->CurrentLength)),
532:               						pTe->hdr.top + GOL_EMBOSS_SIZE
533:               					);
534:               				}
535:               				else
536:               				{
537:               					MoveTo
0071F8  78001E     MOV [W14], W0
0071FA  900060     MOV [W0+12], W0
0071FC  500467     SUB W0, #0x7, W8
0071FE  78001E     MOV [W14], W0
007200  9010C0     MOV [W0+40], W1
007202  78001E     MOV [W14], W0
007204  900870     MOV [W0+30], W0
007206  07FA09     RCALL GetTextWidth
007208  540000     SUB W8, W0, W0
00720A  888260     MOV W0, _cursorX
00720C  78001E     MOV [W14], W0
00720E  900050     MOV [W0+10], W0
007210  400063     ADD W0, #0x3, W0
007212  888270     MOV W0, _cursorY
538:               					(
539:               						pTe->hdr.right - 4 - GOL_EMBOSS_SIZE - GetTextWidth(pTe->pTeOutput, pTe->pDisplayFont),
540:               						pTe->hdr.top + GOL_EMBOSS_SIZE
541:               					);
542:               				}
543:               
544:               				counter = 0;
007214  EB0000     CLR W0
007216  888880     MOV W0, counter
545:               				state = TE_UPDATE_STRING;
007218  2000B0     MOV #0xB, W0
00721A  888810     MOV W0, state
546:                               // add a break here to force a check of IsDeviceBusy() so when last Bar() function is still 
547:                               // ongoing it will wait for it to finish.
548:                               break;
00721C  37002D     BRA 0x7278
549:               
550:               			case TE_UPDATE_STRING:
551:               
552:               				//output the text
553:               				SetColor(pTe->hdr.pGolScheme->TextColor1);
00721E  78001E     MOV [W14], W0
007220  900800     MOV [W0+16], W0
007222  904030     MOV.B [W0+3], W0
007224  B7F13E     MOV.B WREG, _color
554:               				SetFont(pTe->pDisplayFont);
007226  78001E     MOV [W14], W0
007228  901040     MOV [W0+40], W0
00722A  07F816     RCALL SetFont
555:               
556:               				// this is manually doing the OutText() function but with the capability to replace the
557:               				// characters to the * character when hide echo is enabled.							
558:               				XcharTmp = *((pTe->pTeOutput) + counter);
00722C  78001E     MOV [W14], W0
00722E  9008F0     MOV [W0+30], W1
007230  808880     MOV counter, W0
007232  408000     ADD W1, W0, W0
007234  784010     MOV.B [W0], W0
007236  B7F112     MOV.B WREG, XcharTmp
559:               				if(XcharTmp < (XCHAR)15)
007238  BFD112     MOV.B XcharTmp, WREG
00723A  504FEE     SUB.B W0, #0xE, [W15]
00723C  3C0006     BRA GT, 0x724A
560:               				{
561:               
562:               					// update is done time to return to start and exit with success
563:               					SetClip(0); //reset the clipping								
00723E  EB4000     CLR.B W0
007240  07F136     RCALL SetClip
564:               					state = TE_START;
007242  EB0000     CLR W0
007244  888810     MOV W0, state
565:               					return (1);
007246  200010     MOV #0x1, W0
007248  370018     BRA 0x727A
566:               				}
567:               				else
568:               				{
569:               					if(GetState(pTe, TE_ECHO_HIDE))
00724A  78001E     MOV [W14], W0
00724C  900030     MOV [W0+6], W0
00724E  600068     AND W0, #0x8, W0
007250  500FE0     SUB W0, #0x0, [W15]
007252  320003     BRA Z, 0x725A
570:               						OutChar(0x2A);
007254  B3C2A0     MOV #0x2A, W0
007256  07F91A     RCALL OutChar
007258  370002     BRA 0x725E
571:               					else
572:               						OutChar(XcharTmp);
00725A  BFD112     MOV.B XcharTmp, WREG
00725C  07F917     RCALL OutChar
573:               					state = TE_UPDATE_CHARACTERS;
00725E  2000D0     MOV #0xD, W0
007260  888810     MOV W0, state
574:               				}
575:               
576:               			case TE_UPDATE_CHARACTERS:
577:               				if(IsDeviceBusy()) return (0);
007262  072857     RCALL IsDeviceBusy
007264  500FE0     SUB W0, #0x0, [W15]
007266  320002     BRA Z, 0x726C
007268  EB0000     CLR W0
00726A  370007     BRA 0x727A
578:               				counter++;
00726C  808880     MOV counter, W0
00726E  E80000     INC W0, W0
007270  888880     MOV W0, counter
579:               				state = TE_UPDATE_STRING;
007272  2000B0     MOV #0xB, W0
007274  888810     MOV W0, state
580:               				break;
007276  000000     NOP
581:               		} //end switch
582:               	} // end of while(1)
006D74  000000     NOP
007278  37FD7E     BRA 0x6D76
583:               } //end TeDraw()
00727A  78044F     MOV [--W15], W8
00727C  FA8000     ULNK
00727E  060000     RETURN
584:               
585:               /*********************************************************************
586:               * Function: TeTranslateMsg(void *pObj, GOL_MSG *pMsg)
587:               *
588:               * Notes: Function to check which key was pressed/released
589:               *
590:               ********************************************************************/
591:               WORD TeTranslateMsg(void *pObj, GOL_MSG *pMsg)
592:               {
007280  FA000E     LNK #0xE
007282  781F88     MOV W8, [W15++]
007284  980750     MOV W0, [W14+10]
007286  980761     MOV W1, [W14+12]
593:                   SHORT       NumberOfKeys, param1, param2;
594:                   KEYMEMBER   *pKeyTemp = NULL;
007288  EB0000     CLR W0
00728A  780F00     MOV W0, [W14]
595:                   TEXTENTRY *pTe;
596:               
597:                   pTe = (TEXTENTRY *)pObj;
00728C  90005E     MOV [W14+10], W0
00728E  980710     MOV W0, [W14+2]
598:               
599:                   // Check if disabled first
600:                   if(GetState(pTe, TE_DISABLED))
007290  90001E     MOV [W14+2], W0
007292  900030     MOV [W0+6], W0
007294  600062     AND W0, #0x2, W0
007296  500FE0     SUB W0, #0x0, [W15]
007298  320002     BRA Z, 0x729E
601:                       return (OBJ_MSG_INVALID);
00729A  EB0000     CLR W0
00729C  3700C0     BRA 0x741E
602:               
603:                       #ifdef USE_TOUCHSCREEN
604:               
605:                   //find the total number of keys
606:                   NumberOfKeys = (pTe->horizontalKeys) * (pTe->verticalKeys);
00729E  90001E     MOV [W14+2], W0
0072A0  9008D0     MOV [W0+26], W1
0072A2  90001E     MOV [W14+2], W0
0072A4  900860     MOV [W0+28], W0
0072A6  B98800     MUL.SS W1, W0, W0
0072A8  780000     MOV W0, W0
0072AA  980720     MOV W0, [W14+4]
607:                   param1 = pMsg->param1;
0072AC  90006E     MOV [W14+12], W0
0072AE  900090     MOV [W0+2], W1
0072B0  980731     MOV W1, [W14+6]
608:                   param2 = pMsg->param2;
0072B2  90006E     MOV [W14+12], W0
0072B4  9000A0     MOV [W0+4], W1
0072B6  980741     MOV W1, [W14+8]
609:               
610:                   if((pMsg->type == TYPE_TOUCHSCREEN))
0072B8  90006E     MOV [W14+12], W0
0072BA  784010     MOV.B [W0], W0
0072BC  504FE2     SUB.B W0, #0x2, [W15]
0072BE  3A00AE     BRA NZ, 0x741C
611:                   {
612:               
613:                       // Check if it falls in the panel of the TextEntry
614:                       if
615:                       (
0072C8  508F80     SUB W1, W0, [W15]
0072CA  3D0099     BRA GE, 0x73FE
0073FC  37000F     BRA 0x741C
616:                           (pTe->hdr.left < pMsg->param1) &&
0072C0  90001E     MOV [W14+2], W0
0072C2  9000C0     MOV [W0+8], W1
0072C4  90006E     MOV [W14+12], W0
0072C6  900010     MOV [W0+2], W0
0072D4  508F80     SUB W1, W0, [W15]
0072D6  340093     BRA LE, 0x73FE
617:                           (pTe->hdr.right > pMsg->param1) &&
0072CC  90001E     MOV [W14+2], W0
0072CE  9000E0     MOV [W0+12], W1
0072D0  90006E     MOV [W14+12], W0
0072D2  900010     MOV [W0+2], W0
0072EA  508F80     SUB W1, W0, [W15]
0072EC  3D0088     BRA GE, 0x73FE
618:                           (pTe->hdr.top + (GetTextHeight(pTe->pDisplayFont) + (GOL_EMBOSS_SIZE << 1)) < pMsg->param2) &&
0072D8  90001E     MOV [W14+2], W0
0072DA  900450     MOV [W0+10], W8
0072DC  90001E     MOV [W14+2], W0
0072DE  901040     MOV [W0+40], W0
0072E0  07F9B7     RCALL GetTextHeight
0072E2  400066     ADD W0, #0x6, W0
0072E4  440080     ADD W8, W0, W1
0072E6  90006E     MOV [W14+12], W0
0072E8  900020     MOV [W0+4], W0
0072F6  508F80     SUB W1, W0, [W15]
0072F8  340082     BRA LE, 0x73FE
619:                           (pTe->hdr.bottom > pMsg->param2)
0072EE  90001E     MOV [W14+2], W0
0072F0  9000F0     MOV [W0+14], W1
0072F2  90006E     MOV [W14+12], W0
0072F4  900020     MOV [W0+4], W0
620:                       )
621:                       {
622:               
623:                           /* If it fell inside the TextEntry panel, go through the link list and check which one was pressed
624:               			   At this point the touch screen event is either EVENT_MOVE or EVENT_PRESS.   
625:               			*/
626:               
627:                           //point to the head of the link list
628:                           pKeyTemp = pTe->pHeadOfList;
0072FA  90001E     MOV [W14+2], W0
0072FC  9010B0     MOV [W0+38], W1
0072FE  780F01     MOV W1, [W14]
629:               
630:                           while(pKeyTemp != NULL)
007300  37007A     BRA 0x73F6
0073F6  78001E     MOV [W14], W0
0073F8  500FE0     SUB W0, #0x0, [W15]
0073FA  3AFF83     BRA NZ, 0x7302
631:                           {
632:                               if
633:                               (
007306  90003E     MOV [W14+6], W0
007308  508F80     SUB W1, W0, [W15]
00730A  3D0065     BRA GE, 0x73D6
634:                                   (pKeyTemp->left < param1) &&
007302  78001E     MOV [W14], W0
007304  780090     MOV [W0], W1
007310  90003E     MOV [W14+6], W0
007312  508F80     SUB W1, W0, [W15]
007314  340060     BRA LE, 0x73D6
635:                                   (pKeyTemp->right > param1) &&
00730C  78001E     MOV [W14], W0
00730E  9000A0     MOV [W0+4], W1
00731A  90004E     MOV [W14+8], W0
00731C  508F80     SUB W1, W0, [W15]
00731E  3D005B     BRA GE, 0x73D6
636:                                   (pKeyTemp->top < param2) &&
007316  78001E     MOV [W14], W0
007318  900090     MOV [W0+2], W1
007324  90004E     MOV [W14+8], W0
007326  508F80     SUB W1, W0, [W15]
007328  340056     BRA LE, 0x73D6
637:                                   (pKeyTemp->bottom > param2)
007320  78001E     MOV [W14], W0
007322  9000B0     MOV [W0+6], W1
638:                               )
639:                               {
640:                                   if(pMsg->uiEvent == EVENT_RELEASE)
00732A  90006E     MOV [W14+12], W0
00732C  904010     MOV.B [W0+1], W0
00732E  504FE4     SUB.B W0, #0x4, [W15]
007330  3A0025     BRA NZ, 0x737C
0073EE  000000     NOP
641:                                   {
642:                                       pTe->pActiveKey = pKeyTemp;
007332  90001E     MOV [W14+2], W0
007334  78009E     MOV [W14], W1
007336  981021     MOV W1, [W0+36]
643:                                       pKeyTemp->update = TRUE;
007338  78001E     MOV [W14], W0
00733A  200011     MOV #0x1, W1
00733C  980061     MOV W1, [W0+12]
644:               
645:                                       if(pTe->pActiveKey->state == TE_KEY_PRESSED)
00733E  90001E     MOV [W14+2], W0
007340  901020     MOV [W0+36], W0
007342  900050     MOV [W0+10], W0
007344  500FE4     SUB W0, #0x4, [W15]
007346  3A0018     BRA NZ, 0x7378
646:                                       {
647:                                           if(pKeyTemp->command == 0)
007348  78001E     MOV [W14], W0
00734A  900070     MOV [W0+14], W0
00734C  500FE0     SUB W0, #0x0, [W15]
00734E  3A0002     BRA NZ, 0x7354
648:                                               return (TE_MSG_ADD_CHAR);
007350  200240     MOV #0x24, W0
007352  370065     BRA 0x741E
649:               
650:                                           //command for a TE_DELETE_COM key
651:                                           if(pKeyTemp->command == TE_DELETE_COM)
007354  78001E     MOV [W14], W0
007356  900070     MOV [W0+14], W0
007358  500FE1     SUB W0, #0x1, [W15]
00735A  3A0002     BRA NZ, 0x7360
652:                                               return (TE_MSG_DELETE);
00735C  200250     MOV #0x25, W0
00735E  37005F     BRA 0x741E
653:               
654:                                           //command for a TE_SPACE_COM key 0x20	
655:                                           if(pKeyTemp->command == TE_SPACE_COM)
007360  78001E     MOV [W14], W0
007362  900070     MOV [W0+14], W0
007364  500FE2     SUB W0, #0x2, [W15]
007366  3A0002     BRA NZ, 0x736C
656:                                               return (TE_MSG_SPACE);
007368  200260     MOV #0x26, W0
00736A  370059     BRA 0x741E
657:               
658:                                           //command for a TE_ENTER_COM key        	
659:                                           if(pKeyTemp->command == TE_ENTER_COM)
00736C  78001E     MOV [W14], W0
00736E  900070     MOV [W0+14], W0
007370  500FE3     SUB W0, #0x3, [W15]
007372  3A0002     BRA NZ, 0x7378
660:                                               return (TE_MSG_ENTER);
007374  200270     MOV #0x27, W0
007376  370053     BRA 0x741E
661:                                       }
662:               
663:                                       // this is a catch all backup
664:                                       return (TE_MSG_RELEASED);
007378  200220     MOV #0x22, W0
00737A  370051     BRA 0x741E
665:                                   }
666:                                   else
667:                                   {
668:               
669:                                       // to shift the press to another key make sure that there are no other
670:                                       // keys currently pressed. If there is one it must be released first.
671:                                       // check if there are previously pressed keys
672:                                       if(GetState(pTe, TE_KEY_PRESSED))
00737C  90001E     MOV [W14+2], W0
00737E  900030     MOV [W0+6], W0
007380  600064     AND W0, #0x4, W0
007382  500FE0     SUB W0, #0x0, [W15]
007384  32000D     BRA Z, 0x73A0
673:                                       {
674:               
675:                                           // there is a key being pressed.
676:                                           if(pKeyTemp->index != pTe->pActiveKey->index)
007386  78001E     MOV [W14], W0
007388  9000C0     MOV [W0+8], W1
00738A  90001E     MOV [W14+2], W0
00738C  901020     MOV [W0+36], W0
00738E  900040     MOV [W0+8], W0
007390  508F80     SUB W1, W0, [W15]
007392  32002D     BRA Z, 0x73EE
677:                                           {
678:               
679:                                               // release the currently pressed key first
680:                                               pTe->pActiveKey->update = TRUE;
007394  90001E     MOV [W14+2], W0
007396  901020     MOV [W0+36], W0
007398  200011     MOV #0x1, W1
00739A  980061     MOV W1, [W0+12]
681:                                               return (TE_MSG_RELEASED);
00739C  200220     MOV #0x22, W0
00739E  37003F     BRA 0x741E
682:                                           }
683:                                       }
684:                                       else
685:                                       {
686:               
687:                                           // check if the active key is not pressed
688:                                           // if not, set to press since the current touch event
689:                                           // is either move or press
690:                                           // check if there is an active key already set
691:                                           // if none, set the current key as active and return a pressed mesage
692:                                           if(pTe->pActiveKey == NULL)
0073A0  90001E     MOV [W14+2], W0
0073A2  901020     MOV [W0+36], W0
0073A4  500FE0     SUB W0, #0x0, [W15]
0073A6  3A0008     BRA NZ, 0x73B8
693:                                           {
694:                                               pTe->pActiveKey = pKeyTemp;
0073A8  90001E     MOV [W14+2], W0
0073AA  78009E     MOV [W14], W1
0073AC  981021     MOV W1, [W0+36]
695:                                               pKeyTemp->update = TRUE;
0073AE  78001E     MOV [W14], W0
0073B0  200011     MOV #0x1, W1
0073B2  980061     MOV W1, [W0+12]
696:                                               return (TE_MSG_PRESSED);
0073B4  200230     MOV #0x23, W0
0073B6  370033     BRA 0x741E
697:                                           }
698:               
699:                                           if(pTe->pActiveKey->state != TE_KEY_PRESSED)
0073B8  90001E     MOV [W14+2], W0
0073BA  901020     MOV [W0+36], W0
0073BC  900050     MOV [W0+10], W0
0073BE  500FE4     SUB W0, #0x4, [W15]
0073C0  320008     BRA Z, 0x73D2
700:                                           {
701:                                               pTe->pActiveKey = pKeyTemp;
0073C2  90001E     MOV [W14+2], W0
0073C4  78009E     MOV [W14], W1
0073C6  981021     MOV W1, [W0+36]
702:                                               pKeyTemp->update = TRUE;
0073C8  78001E     MOV [W14], W0
0073CA  200011     MOV #0x1, W1
0073CC  980061     MOV W1, [W0+12]
703:                                               return (TE_MSG_PRESSED);
0073CE  200230     MOV #0x23, W0
0073D0  370026     BRA 0x741E
704:                                           }
705:                                           else
706:                                           {
707:                                               return (OBJ_MSG_INVALID);
0073D2  EB0000     CLR W0
0073D4  370024     BRA 0x741E
708:                                           }
709:                                       }
710:                                   }
711:                               }
712:                               else
713:                               {
714:               
715:                                   // if the key is in the pressed state and current touch is not here
716:                                   // then it has to be redrawn
717:                                   if(pKeyTemp->state == TE_KEY_PRESSED)
0073D6  78001E     MOV [W14], W0
0073D8  900050     MOV [W0+10], W0
0073DA  500FE4     SUB W0, #0x4, [W15]
0073DC  3A0009     BRA NZ, 0x73F0
718:                                   {
719:                                       pTe->pActiveKey = pKeyTemp;
0073DE  90001E     MOV [W14+2], W0
0073E0  78009E     MOV [W14], W1
0073E2  981021     MOV W1, [W0+36]
720:                                       pKeyTemp->update = TRUE;
0073E4  78001E     MOV [W14], W0
0073E6  200011     MOV #0x1, W1
0073E8  980061     MOV W1, [W0+12]
721:                                       return (TE_MSG_RELEASED);
0073EA  200220     MOV #0x22, W0
0073EC  370018     BRA 0x741E
722:                                   }
723:                               }
724:               
725:                               //access the next link list
726:                               pKeyTemp = pKeyTemp->pNextKey;
0073F0  78001E     MOV [W14], W0
0073F2  900830     MOV [W0+22], W0
0073F4  780F00     MOV W0, [W14]
727:                           }   //end while
728:                       }
729:                       else
730:                       {
731:                           if((pMsg->uiEvent == EVENT_MOVE) && (GetState(pTe, TE_KEY_PRESSED)))
0073FE  90006E     MOV [W14+12], W0
007400  904010     MOV.B [W0+1], W0
007402  504FE1     SUB.B W0, #0x1, [W15]
007404  3A000B     BRA NZ, 0x741C
007406  90001E     MOV [W14+2], W0
007408  900030     MOV [W0+6], W0
00740A  600064     AND W0, #0x4, W0
00740C  500FE0     SUB W0, #0x0, [W15]
00740E  320006     BRA Z, 0x741C
732:                           {
733:                               pTe->pActiveKey->update = TRUE;
007410  90001E     MOV [W14+2], W0
007412  901020     MOV [W0+36], W0
007414  200011     MOV #0x1, W1
007416  980061     MOV W1, [W0+12]
734:                               return (TE_MSG_RELEASED);
007418  200220     MOV #0x22, W0
00741A  370001     BRA 0x741E
735:                           }
736:                       }
737:                   }
738:               
739:                   return (OBJ_MSG_INVALID);
00741C  EB0000     CLR W0
740:                       #endif // USE_TOUCHSCREEN		
741:               }               //end TeTranslateMsg()
00741E  78044F     MOV [--W15], W8
007420  FA8000     ULNK
007422  060000     RETURN
742:               
743:               /*********************************************************************
744:               * Function: TeMsgDefault(WORD translatedMsg, void *pObj, GOL_MSG* pMsg)
745:               *
746:               *
747:               * Notes: This the default operation to change the state of the key.
748:               *		 Called inside GOLMsg() when GOLMsgCallback() returns a 1.
749:               *
750:               ********************************************************************/
751:               void TeMsgDefault(WORD translatedMsg, void *pObj, GOL_MSG *pMsg)
752:               {
007424  FA0008     LNK #0x8
007426  980710     MOV W0, [W14+2]
007428  980721     MOV W1, [W14+4]
00742A  980732     MOV W2, [W14+6]
753:                   TEXTENTRY *pTe;
754:               
755:                   pTe = (TEXTENTRY *)pObj;
00742C  90002E     MOV [W14+4], W0
00742E  780F00     MOV W0, [W14]
756:               
757:                   switch(translatedMsg)
007430  90001E     MOV [W14+2], W0
007432  B80161     MUL.UU W0, #1, W2
007434  2FFDE0     MOV #0xFFDE, W0
007436  2FFFF1     MOV #0xFFFF, W1
007438  400002     ADD W0, W2, W0
00743A  488083     ADDC W1, W3, W1
00743C  200052     MOV #0x5, W2
00743E  200003     MOV #0x0, W3
007440  500F82     SUB W0, W2, [W15]
007442  588F83     SUBB W1, W3, [W15]
007444  3E0043     BRA GTU, 0x74CC
007446  016000     BRA W0
007448  370030     BRA 0x74AA
00744A  370024     BRA 0x7494
00744C  37001A     BRA 0x7482
00744E  370002     BRA 0x7454
007450  370008     BRA 0x7462
007452  370010     BRA 0x7474
758:                   {
759:                       case TE_MSG_DELETE:
760:                           SetState(pTe, TE_UPDATE_KEY | TE_UPDATE_TEXT);
007454  78001E     MOV [W14], W0
007456  78009E     MOV [W14], W1
007458  900131     MOV [W1+6], W2
00745A  230001     MOV #0x3000, W1
00745C  710081     IOR W2, W1, W1
00745E  980031     MOV W1, [W0+6]
761:                           break;
007460  370035     BRA 0x74CC
762:               
763:                       case TE_MSG_SPACE:
764:                           TeSpaceChar(pTe);
007462  78001E     MOV [W14], W0
007464  0701BD     RCALL TeSpaceChar
765:                           SetState(pTe, TE_UPDATE_KEY | TE_UPDATE_TEXT);
007466  78001E     MOV [W14], W0
007468  78009E     MOV [W14], W1
00746A  900131     MOV [W1+6], W2
00746C  230001     MOV #0x3000, W1
00746E  710081     IOR W2, W1, W1
007470  980031     MOV W1, [W0+6]
766:                           break;
007472  37002C     BRA 0x74CC
767:               
768:                       case TE_MSG_ENTER:
769:                           SetState(pTe, TE_UPDATE_KEY);
007474  78001E     MOV [W14], W0
007476  78009E     MOV [W14], W1
007478  900131     MOV [W1+6], W2
00747A  220001     MOV #0x2000, W1
00747C  710081     IOR W2, W1, W1
00747E  980031     MOV W1, [W0+6]
770:                           break;
007480  370025     BRA 0x74CC
771:               
772:                       case TE_MSG_ADD_CHAR:
773:                           TeAddChar(pTe);
007482  78001E     MOV [W14], W0
007484  0701CB     RCALL TeAddChar
774:                           SetState(pTe, TE_UPDATE_KEY | TE_UPDATE_TEXT);
007486  78001E     MOV [W14], W0
007488  78009E     MOV [W14], W1
00748A  900131     MOV [W1+6], W2
00748C  230001     MOV #0x3000, W1
00748E  710081     IOR W2, W1, W1
007490  980031     MOV W1, [W0+6]
775:                           break;
007492  37001C     BRA 0x74CC
776:               
777:                       case TE_MSG_PRESSED:
778:                           (pTe->pActiveKey)->state = TE_KEY_PRESSED;
007494  78001E     MOV [W14], W0
007496  901020     MOV [W0+36], W0
007498  200041     MOV #0x4, W1
00749A  980051     MOV W1, [W0+10]
779:                           SetState(pTe, TE_KEY_PRESSED | TE_UPDATE_KEY);
00749C  78001E     MOV [W14], W0
00749E  78009E     MOV [W14], W1
0074A0  900131     MOV [W1+6], W2
0074A2  220041     MOV #0x2004, W1
0074A4  710081     IOR W2, W1, W1
0074A6  980031     MOV W1, [W0+6]
780:                           return;
0074A8  37001F     BRA 0x74E8
781:               
782:                       case TE_MSG_RELEASED:
783:                           (pTe->pActiveKey)->state = 0;
0074AA  78001E     MOV [W14], W0
0074AC  901020     MOV [W0+36], W0
0074AE  EB0080     CLR W1
0074B0  980051     MOV W1, [W0+10]
784:                           ClrState(pTe, TE_KEY_PRESSED);  // reset pressed
0074B2  78001E     MOV [W14], W0
0074B4  78009E     MOV [W14], W1
0074B6  900131     MOV [W1+6], W2
0074B8  2FFFB1     MOV #0xFFFB, W1
0074BA  610081     AND W2, W1, W1
0074BC  980031     MOV W1, [W0+6]
785:                           SetState(pTe, TE_UPDATE_KEY);   // redraw
0074BE  78001E     MOV [W14], W0
0074C0  78009E     MOV [W14], W1
0074C2  900131     MOV [W1+6], W2
0074C4  220001     MOV #0x2000, W1
0074C6  710081     IOR W2, W1, W1
0074C8  980031     MOV W1, [W0+6]
786:                           return;
0074CA  37000E     BRA 0x74E8
787:                   }
788:               
789:                   if(pTe->pActiveKey != NULL)
0074CC  78001E     MOV [W14], W0
0074CE  901020     MOV [W0+36], W0
0074D0  500FE0     SUB W0, #0x0, [W15]
0074D2  320004     BRA Z, 0x74DC
790:                       (pTe->pActiveKey)->state = 0;
0074D4  78001E     MOV [W14], W0
0074D6  901020     MOV [W0+36], W0
0074D8  EB0080     CLR W1
0074DA  980051     MOV W1, [W0+10]
791:                   ClrState(pTe, TE_KEY_PRESSED);
0074DC  78001E     MOV [W14], W0
0074DE  78009E     MOV [W14], W1
0074E0  900131     MOV [W1+6], W2
0074E2  2FFFB1     MOV #0xFFFB, W1
0074E4  610081     AND W2, W1, W1
0074E6  980031     MOV W1, [W0+6]
792:               }
0074E8  FA8000     ULNK
0074EA  060000     RETURN
793:               
794:               /*********************************************************************
795:               * Function: void TeClearBuffer(TEXTENTRY *pTe)
796:               *
797:               * Notes: This function will clear the edibox and the buffer.
798:               *		 You must set the drawing state bit TE_UPDATE_TEXT 
799:               *		 to update the TEXTENTRY on the screen.
800:               *
801:               ********************************************************************/
802:               void TeClearBuffer(TEXTENTRY *pTe)
803:               {
0074EC  FA0004     LNK #0x4
0074EE  980710     MOV W0, [W14+2]
804:                   WORD    i;
805:               
806:                   //clear the buffer
807:                   for(i = 0; i < (pTe->outputLenMax); i++)
0074F0  EB0000     CLR W0
0074F2  780F00     MOV W0, [W14]
0074F4  370006     BRA 0x7502
007500  E80F1E     INC [W14], [W14]
007502  90001E     MOV [W14+2], W0
007504  901010     MOV [W0+34], W0
007506  500F9E     SUB W0, [W14], [W15]
007508  3EFFF6     BRA GTU, 0x74F6
808:                   {
809:                       *(pTe->pTeOutput + i) = 0;
0074F6  90001E     MOV [W14+2], W0
0074F8  900870     MOV [W0+30], W0
0074FA  40009E     ADD W0, [W14], W1
0074FC  EB4000     CLR.B W0
0074FE  784880     MOV.B W0, [W1]
810:                   }
811:               
812:                   pTe->CurrentLength = 0;
00750A  90001E     MOV [W14+2], W0
00750C  EB0080     CLR W1
00750E  981001     MOV W1, [W0+32]
813:               }
007510  FA8000     ULNK
007512  060000     RETURN
814:               
815:               /*********************************************************************
816:               * Function: void TeSetBuffer(TEXTENTRY *pTe, XCHAR *pText, WORD size)
817:               *
818:               * Notes: This function will replace the currently used buffer.
819:               *		 MaxSize defines the length of the buffer. Buffer must be
820:               *		 a NULL terminated string.
821:               *
822:               ********************************************************************/
823:               void TeSetBuffer(TEXTENTRY *pTe, XCHAR *pText, WORD MaxSize)
824:               {
007514  FA000A     LNK #0xA
007516  980720     MOV W0, [W14+4]
007518  980731     MOV W1, [W14+6]
00751A  980742     MOV W2, [W14+8]
825:                   WORD    count = 0;
00751C  EB0000     CLR W0
00751E  780F00     MOV W0, [W14]
826:                   XCHAR   *pTemp;
827:               
828:                   pTemp = pText;
007520  90003E     MOV [W14+6], W0
007522  980710     MOV W0, [W14+2]
829:               
830:                   while(*pTemp != 0)
007524  370008     BRA 0x7536
007536  90001E     MOV [W14+2], W0
007538  784010     MOV.B [W0], W0
00753A  504FE0     SUB.B W0, #0x0, [W15]
00753C  3AFFF4     BRA NZ, 0x7526
00753E  370001     BRA 0x7542
831:                   {
832:                       if(count >= MaxSize)
007526  90004E     MOV [W14+8], W0
007528  78009E     MOV [W14], W1
00752A  508F80     SUB W1, W0, [W15]
00752C  310009     BRA C, 0x7540
833:                           break;
007540  000000     NOP
834:                       pTemp++;
00752E  90001E     MOV [W14+2], W0
007530  E80000     INC W0, W0
007532  980710     MOV W0, [W14+2]
835:                       count++;
007534  E80F1E     INC [W14], [W14]
836:                   }
837:               
838:                   // terminate the string
839:                   *pTemp = 0;
007542  90009E     MOV [W14+2], W1
007544  EB4000     CLR.B W0
007546  784880     MOV.B W0, [W1]
840:               
841:                   pTe->CurrentLength = count;
007548  90002E     MOV [W14+4], W0
00754A  78009E     MOV [W14], W1
00754C  981001     MOV W1, [W0+32]
842:                   pTe->outputLenMax = MaxSize-1;
00754E  90004E     MOV [W14+8], W0
007550  E90080     DEC W0, W1
007552  90002E     MOV [W14+4], W0
007554  981011     MOV W1, [W0+34]
843:                   pTe->pTeOutput = pText;
007556  90002E     MOV [W14+4], W0
007558  9000BE     MOV [W14+6], W1
00755A  980871     MOV W1, [W0+30]
844:               }
00755C  FA8000     ULNK
00755E  060000     RETURN
845:               
846:               /*********************************************************************
847:               * Function: BOOL TeIsKeyPressed(TEXTENTRY *pTe,WORD index)
848:               *
849:               * Notes: This function will check if the key was pressed. If no 
850:               *		 key was pressed it will return FALSE.
851:               *
852:               ********************************************************************/
853:               BOOL TeIsKeyPressed(TEXTENTRY *pTe, WORD index)
854:               {
007560  FA0006     LNK #0x6
007562  980710     MOV W0, [W14+2]
007564  980721     MOV W1, [W14+4]
855:                   KEYMEMBER   *pTemp;
856:               
857:                   pTemp = pTe->pHeadOfList;
007566  90001E     MOV [W14+2], W0
007568  9010B0     MOV [W0+38], W1
00756A  780F01     MOV W1, [W14]
858:               
859:                   //search the key using the given index
860:                   while(index != pTemp->index)
00756C  370008     BRA 0x757E
00757E  78001E     MOV [W14], W0
007580  900040     MOV [W0+8], W0
007582  780080     MOV W0, W1
007584  90002E     MOV [W14+4], W0
007586  508F80     SUB W1, W0, [W15]
007588  3AFFF2     BRA NZ, 0x756E
861:                   {
862:               
863:                       // catch all check
864:                       if(pTemp == NULL)
00756E  78001E     MOV [W14], W0
007570  500FE0     SUB W0, #0x0, [W15]
007572  3A0002     BRA NZ, 0x7578
865:                           return (FALSE);
007574  EB0000     CLR W0
007576  370010     BRA 0x7598
866:                       pTemp = pTemp->pNextKey;
007578  78001E     MOV [W14], W0
00757A  900830     MOV [W0+22], W0
00757C  780F00     MOV W0, [W14]
867:                   }
868:               
869:                   if(pTemp->state == TE_KEY_PRESSED)
00758A  78001E     MOV [W14], W0
00758C  900050     MOV [W0+10], W0
00758E  500FE4     SUB W0, #0x4, [W15]
007590  3A0002     BRA NZ, 0x7596
870:                   {
871:                       return (TRUE);
007592  200010     MOV #0x1, W0
007594  370001     BRA 0x7598
872:                   }
873:                   else
874:                   {
875:                       return (FALSE);
007596  EB0000     CLR W0
876:                   }
877:               }
007598  FA8000     ULNK
00759A  060000     RETURN
878:               
879:               /*********************************************************************
880:               * Function: BOOL TeSetKeyCommand(TEXTENTRY *pTe,WORD index,WORD command)
881:               *
882:               * Notes: This function will assign a command to a particular key. 
883:               *		 Returns TRUE if sucessful and FALSE if not.
884:               *
885:               ********************************************************************/
886:               BOOL TeSetKeyCommand(TEXTENTRY *pTe, WORD index, WORD command)
887:               {
00759C  FA0008     LNK #0x8
00759E  980710     MOV W0, [W14+2]
0075A0  980721     MOV W1, [W14+4]
0075A2  980732     MOV W2, [W14+6]
888:                   KEYMEMBER   *pTemp;
889:               
890:                   pTemp = pTe->pHeadOfList;
0075A4  90001E     MOV [W14+2], W0
0075A6  9010B0     MOV [W0+38], W1
0075A8  780F01     MOV W1, [W14]
891:               
892:                   //search the key using the given index
893:                   while(index != pTemp->index)
0075AA  370008     BRA 0x75BC
0075BC  78001E     MOV [W14], W0
0075BE  900040     MOV [W0+8], W0
0075C0  780080     MOV W0, W1
0075C2  90002E     MOV [W14+4], W0
0075C4  508F80     SUB W1, W0, [W15]
0075C6  3AFFF2     BRA NZ, 0x75AC
894:                   {
895:               
896:                       // catch all check
897:                       if(pTemp == NULL)
0075AC  78001E     MOV [W14], W0
0075AE  500FE0     SUB W0, #0x0, [W15]
0075B0  3A0002     BRA NZ, 0x75B6
898:                           return (FALSE);
0075B2  EB0000     CLR W0
0075B4  37000D     BRA 0x75D0
899:                       pTemp = pTemp->pNextKey;
0075B6  78001E     MOV [W14], W0
0075B8  900830     MOV [W0+22], W0
0075BA  780F00     MOV W0, [W14]
900:                   }
901:               
902:                   pTemp->command = command;
0075C8  78001E     MOV [W14], W0
0075CA  9000BE     MOV [W14+6], W1
0075CC  980071     MOV W1, [W0+14]
903:                   return (TRUE);
0075CE  200010     MOV #0x1, W0
904:               }
0075D0  FA8000     ULNK
0075D2  060000     RETURN
905:               
906:               /*********************************************************************
907:               * Function: TeGetKeyCommand(pTe, index)  
908:               *				
909:               * Notes: This function will return the currently used command by a key 
910:               *		 with the given index.
911:               *
912:               ********************************************************************/
913:               WORD TeGetKeyCommand(TEXTENTRY *pTe, WORD index)
914:               {
0075D4  FA0006     LNK #0x6
0075D6  980710     MOV W0, [W14+2]
0075D8  980721     MOV W1, [W14+4]
915:                   KEYMEMBER   *pTemp;
916:               
917:                   pTemp = pTe->pHeadOfList;
0075DA  90001E     MOV [W14+2], W0
0075DC  9010B0     MOV [W0+38], W1
0075DE  780F01     MOV W1, [W14]
918:               
919:                   //search the key using the given index
920:                   while(index != pTemp->index)
0075E0  370008     BRA 0x75F2
0075F2  78001E     MOV [W14], W0
0075F4  900040     MOV [W0+8], W0
0075F6  780080     MOV W0, W1
0075F8  90002E     MOV [W14+4], W0
0075FA  508F80     SUB W1, W0, [W15]
0075FC  3AFFF2     BRA NZ, 0x75E2
921:                   {
922:               
923:                       // catch all check
924:                       if(pTemp == NULL)
0075E2  78001E     MOV [W14], W0
0075E4  500FE0     SUB W0, #0x0, [W15]
0075E6  3A0002     BRA NZ, 0x75EC
925:                           return (0);
0075E8  EB0000     CLR W0
0075EA  37000B     BRA 0x7602
926:                       pTemp = pTemp->pNextKey;
0075EC  78001E     MOV [W14], W0
0075EE  900830     MOV [W0+22], W0
0075F0  780F00     MOV W0, [W14]
927:                   }
928:               
929:                   return (pTemp->command);
0075FE  78001E     MOV [W14], W0
007600  900070     MOV [W0+14], W0
930:               }
007602  FA8000     ULNK
007604  060000     RETURN
931:               
932:               /*********************************************************************
933:               * Function: BOOL TeSetKeyText(TEXTENTRY *pTe,WORD index, XCHAR *pText)
934:               *
935:               * Notes: This function will set the string associated with the key 
936:               *		 with the new string pText. The key to be modified is determined 
937:               *        by the index. Returns TRUE if sucessful and FALSE if not.
938:               *
939:               ********************************************************************/
940:               BOOL TeSetKeyText(TEXTENTRY *pTe, WORD index, XCHAR *pText)
941:               {
007606  FA0008     LNK #0x8
007608  980710     MOV W0, [W14+2]
00760A  980721     MOV W1, [W14+4]
00760C  980732     MOV W2, [W14+6]
942:                   KEYMEMBER   *pTemp;
943:               
944:                   pTemp = pTe->pHeadOfList;
00760E  90001E     MOV [W14+2], W0
007610  9010B0     MOV [W0+38], W1
007612  780F01     MOV W1, [W14]
945:               
946:                   //search the key using the given index
947:                   while(index != pTemp->index)
007614  370008     BRA 0x7626
007626  78001E     MOV [W14], W0
007628  900040     MOV [W0+8], W0
00762A  780080     MOV W0, W1
00762C  90002E     MOV [W14+4], W0
00762E  508F80     SUB W1, W0, [W15]
007630  3AFFF2     BRA NZ, 0x7616
948:                   {
949:                       // catch all check
950:                       if(pTemp == NULL)
007616  78001E     MOV [W14], W0
007618  500FE0     SUB W0, #0x0, [W15]
00761A  3A0002     BRA NZ, 0x7620
951:                           return (FALSE);
00761C  EB0000     CLR W0
00761E  37000D     BRA 0x763A
952:                       pTemp = pTemp->pNextKey;
007620  78001E     MOV [W14], W0
007622  900830     MOV [W0+22], W0
007624  780F00     MOV W0, [W14]
953:                   }
954:               
955:               	// Set the the text 
956:                   pTemp->pKeyName = pText;
007632  78001E     MOV [W14], W0
007634  9000BE     MOV [W14+6], W1
007636  980801     MOV W1, [W0+16]
957:               
958:                   return (TRUE);
007638  200010     MOV #0x1, W0
959:               }
00763A  FA8000     ULNK
00763C  060000     RETURN
960:               
961:               
962:               /*********************************************************************
963:               * Function: KEYMEMBER *TeCreateKeyMembers(TEXTENTRY *pTe,XCHAR *pText[])
964:               *
965:               * Notes: This function will create the members of the list
966:               *
967:               ********************************************************************/
968:               KEYMEMBER *TeCreateKeyMembers(TEXTENTRY *pTe, XCHAR *pText[])
969:               {
00763E  FA0018     LNK #0x18
007640  781F88     MOV W8, [W15++]
007642  980F20     MOV W0, [W14+20]
007644  980F31     MOV W1, [W14+22]
970:                   SHORT       NumberOfKeys, width, height;
971:                   SHORT       keyTop, keyLeft;
972:                   WORD        rowcount, colcount;
973:                   WORD        index = 0;
007646  EB0000     CLR W0
007648  980720     MOV W0, [W14+4]
974:               
975:                   KEYMEMBER   *pKl = NULL;    //link list
00764A  EB0000     CLR W0
00764C  980730     MOV W0, [W14+6]
976:                   KEYMEMBER   *pTail = NULL;
00764E  EB0000     CLR W0
007650  980740     MOV W0, [W14+8]
977:               
978:                   // determine starting positions of the keys
979:                   keyTop = pTe->hdr.top + GetTextHeight(pTe->pDisplayFont) + (GOL_EMBOSS_SIZE << 1);
007652  90082E     MOV [W14+20], W0
007654  900450     MOV [W0+10], W8
007656  90082E     MOV [W14+20], W0
007658  901040     MOV [W0+40], W0
00765A  07F7FA     RCALL GetTextHeight
00765C  440000     ADD W8, W0, W0
00765E  400066     ADD W0, #0x6, W0
007660  980750     MOV W0, [W14+10]
980:                   keyLeft = pTe->hdr.left;    
007662  90082E     MOV [W14+20], W0
007664  9000C0     MOV [W0+8], W1
007666  980761     MOV W1, [W14+12]
981:               
982:                   //calculate the total number of keys, and width and height of each key
983:                   NumberOfKeys = pTe->horizontalKeys * pTe->verticalKeys;
007668  90082E     MOV [W14+20], W0
00766A  9008D0     MOV [W0+26], W1
00766C  90082E     MOV [W14+20], W0
00766E  900860     MOV [W0+28], W0
007670  B98800     MUL.SS W1, W0, W0
007672  780000     MOV W0, W0
007674  980770     MOV W0, [W14+14]
984:                   width = (pTe->hdr.right - keyLeft + 1) / pTe->horizontalKeys;
007676  90082E     MOV [W14+20], W0
007678  9000E0     MOV [W0+12], W1
00767A  90006E     MOV [W14+12], W0
00767C  508000     SUB W1, W0, W0
00767E  E80080     INC W0, W1
007680  90082E     MOV [W14+20], W0
007682  900850     MOV [W0+26], W0
007684  780100     MOV W0, W2
007686  090011     REPEAT #0x11
007688  D80082     DIV.SW W1, W2
00768A  980F00     MOV W0, [W14+16]
985:                   height = (pTe->hdr.bottom - keyTop + 1) / pTe->verticalKeys;
00768C  90082E     MOV [W14+20], W0
00768E  9000F0     MOV [W0+14], W1
007690  90005E     MOV [W14+10], W0
007692  508000     SUB W1, W0, W0
007694  E80080     INC W0, W1
007696  90082E     MOV [W14+20], W0
007698  900860     MOV [W0+28], W0
00769A  780100     MOV W0, W2
00769C  090011     REPEAT #0x11
00769E  D80082     DIV.SW W1, W2
0076A0  980F10     MOV W0, [W14+18]
986:               
987:                   /*create the list and calculate the coordinates of each bottom, and the textwidth/textheight of each font*/
988:               
989:                   //Add a list for each key
990:                   for(colcount = 0; colcount < pTe->verticalKeys; colcount++)
0076A2  EB0000     CLR W0
0076A4  980710     MOV W0, [W14+2]
0076A6  370078     BRA 0x7798
007792  90001E     MOV [W14+2], W0
007794  E80000     INC W0, W0
007796  980710     MOV W0, [W14+2]
007798  90082E     MOV [W14+20], W0
00779A  900860     MOV [W0+28], W0
00779C  780080     MOV W0, W1
00779E  90001E     MOV [W14+2], W0
0077A0  508F80     SUB W1, W0, [W15]
0077A2  3EFF82     BRA GTU, 0x76A8
991:                   {
992:                       for(rowcount = 0; rowcount < pTe->horizontalKeys; rowcount++)
0076A8  EB0000     CLR W0
0076AA  780F00     MOV W0, [W14]
0076AC  37006E     BRA 0x778A
007788  E80F1E     INC [W14], [W14]
00778A  90082E     MOV [W14+20], W0
00778C  900850     MOV [W0+26], W0
00778E  500F9E     SUB W0, [W14], [W15]
007790  3EFF8E     BRA GTU, 0x76AE
993:                       {
994:               
995:                           //get storage for new entry
996:                           pKl = (KEYMEMBER *)GFX_malloc(sizeof(KEYMEMBER));
0076AE  200180     MOV #0x18, W0
0076B0  07D44F     RCALL _malloc
0076B2  980730     MOV W0, [W14+6]
997:                           if(pKl == NULL)
0076B4  90003E     MOV [W14+6], W0
0076B6  500FE0     SUB W0, #0x0, [W15]
0076B8  3A0004     BRA NZ, 0x76C2
998:               			{
999:               				TeDelKeyMembers(pTe);
0076BA  90082E     MOV [W14+20], W0
0076BC  07007A     RCALL TeDelKeyMembers
1000:                              return (NULL);
0076BE  EB0000     CLR W0
0076C0  370075     BRA 0x77AC
1001:              			}	
1002:                          if(pTe->pHeadOfList == NULL)
0076C2  90082E     MOV [W14+20], W0
0076C4  901030     MOV [W0+38], W0
0076C6  500FE0     SUB W0, #0x0, [W15]
0076C8  3A0003     BRA NZ, 0x76D0
1003:                              pTe->pHeadOfList = pKl;
0076CA  90082E     MOV [W14+20], W0
0076CC  9000BE     MOV [W14+6], W1
0076CE  981031     MOV W1, [W0+38]
1004:                          if(pTail == NULL)
0076D0  90004E     MOV [W14+8], W0
0076D2  500FE0     SUB W0, #0x0, [W15]
0076D4  3A0003     BRA NZ, 0x76DC
1005:                          {
1006:                              pTail = pKl;
0076D6  90013E     MOV [W14+6], W2
0076D8  980742     MOV W2, [W14+8]
0076DA  370006     BRA 0x76E8
1007:                          }
1008:                          else
1009:                          {
1010:                              pTail->pNextKey = pKl;
0076DC  90004E     MOV [W14+8], W0
0076DE  9000BE     MOV [W14+6], W1
0076E0  980831     MOV W1, [W0+22]
1011:                              pTail = pTail->pNextKey;
0076E2  90004E     MOV [W14+8], W0
0076E4  900830     MOV [W0+22], W0
0076E6  980740     MOV W0, [W14+8]
1012:                          }
1013:              
1014:                          //set the index for the new list
1015:                          pKl->index = index;
0076E8  9000AE     MOV [W14+4], W1
0076EA  90003E     MOV [W14+6], W0
0076EC  980041     MOV W1, [W0+8]
1016:              
1017:                          // set update flag to off
1018:                          pKl->update = FALSE;
0076EE  90003E     MOV [W14+6], W0
0076F0  EB0080     CLR W1
0076F2  980061     MOV W1, [W0+12]
1019:              
1020:                          //calculate the x-y coordinate for each key
1021:                          pKl->left 	= keyLeft + (rowcount * width);
0076F4  90088E     MOV [W14+16], W1
0076F6  78001E     MOV [W14], W0
0076F8  B98800     MUL.SS W1, W0, W0
0076FA  780080     MOV W0, W1
0076FC  90006E     MOV [W14+12], W0
0076FE  408000     ADD W1, W0, W0
007700  780080     MOV W0, W1
007702  90003E     MOV [W14+6], W0
007704  780801     MOV W1, [W0]
1022:                          pKl->top 	= keyTop  + (colcount * height);
007706  90089E     MOV [W14+18], W1
007708  90001E     MOV [W14+2], W0
00770A  B98800     MUL.SS W1, W0, W0
00770C  780080     MOV W0, W1
00770E  90005E     MOV [W14+10], W0
007710  408000     ADD W1, W0, W0
007712  780080     MOV W0, W1
007714  90003E     MOV [W14+6], W0
007716  980011     MOV W1, [W0+2]
1023:                          pKl->right 	= keyLeft + ((rowcount + 1) * width);
007718  E8009E     INC [W14], W1
00771A  90080E     MOV [W14+16], W0
00771C  B98800     MUL.SS W1, W0, W0
00771E  780080     MOV W0, W1
007720  90006E     MOV [W14+12], W0
007722  408000     ADD W1, W0, W0
007724  780080     MOV W0, W1
007726  90003E     MOV [W14+6], W0
007728  980021     MOV W1, [W0+4]
1024:                          pKl->bottom = keyTop  + ((colcount + 1) * height);
00772A  90001E     MOV [W14+2], W0
00772C  E80080     INC W0, W1
00772E  90081E     MOV [W14+18], W0
007730  B98800     MUL.SS W1, W0, W0
007732  780080     MOV W0, W1
007734  90005E     MOV [W14+10], W0
007736  408000     ADD W1, W0, W0
007738  780080     MOV W0, W1
00773A  90003E     MOV [W14+6], W0
00773C  980031     MOV W1, [W0+6]
1025:              
1026:                          //Add the text to the list and increase the index
1027:                          pKl->pKeyName = pText[index++];
00773E  90002E     MOV [W14+4], W0
007740  400000     ADD W0, W0, W0
007742  9008BE     MOV [W14+22], W1
007744  408000     ADD W1, W0, W0
007746  780090     MOV [W0], W1
007748  90003E     MOV [W14+6], W0
00774A  980801     MOV W1, [W0+16]
00774C  90002E     MOV [W14+4], W0
00774E  E80000     INC W0, W0
007750  980720     MOV W0, [W14+4]
1028:              
1029:                          //set the COMMAND to NULL for all keys
1030:                          pKl->command = 0;
007752  90003E     MOV [W14+6], W0
007754  EB0080     CLR W1
007756  980071     MOV W1, [W0+14]
1031:              
1032:                          //calculate the textwidth, textheight
1033:                          pKl->textWidth = 0;
007758  90003E     MOV [W14+6], W0
00775A  EB0080     CLR W1
00775C  980811     MOV W1, [W0+18]
1034:                          pKl->textHeight = 0;
00775E  90003E     MOV [W14+6], W0
007760  EB0080     CLR W1
007762  980821     MOV W1, [W0+20]
1035:                          if(pKl->pKeyName != NULL)
007764  90003E     MOV [W14+6], W0
007766  900800     MOV [W0+16], W0
007768  500FE0     SUB W0, #0x0, [W15]
00776A  32000E     BRA Z, 0x7788
1036:                          {
1037:              
1038:                              // Calculate the text width & height
1039:                              pKl->textWidth = GetTextWidth(pKl->pKeyName, pTe->hdr.pGolScheme->pFont);
00776C  90082E     MOV [W14+20], W0
00776E  900800     MOV [W0+16], W0
007770  9000D0     MOV [W0+10], W1
007772  90003E     MOV [W14+6], W0
007774  900800     MOV [W0+16], W0
007776  07F751     RCALL GetTextWidth
007778  9000BE     MOV [W14+6], W1
00777A  980890     MOV W0, [W1+18]
1040:                              pKl->textHeight = GetTextHeight(pTe->hdr.pGolScheme->pFont);
00777C  90082E     MOV [W14+20], W0
00777E  900800     MOV [W0+16], W0
007780  900050     MOV [W0+10], W0
007782  07F766     RCALL GetTextHeight
007784  9000BE     MOV [W14+6], W1
007786  9808A0     MOV W0, [W1+20]
1041:                          } //end if
1042:                      } //end for	
1043:                  } //end for	
1044:              
1045:                  pTail->pNextKey = NULL;
0077A4  90004E     MOV [W14+8], W0
0077A6  EB0080     CLR W1
0077A8  980831     MOV W1, [W0+22]
1046:              
1047:                  return (pKl);
0077AA  90003E     MOV [W14+6], W0
1048:              }
0077AC  78044F     MOV [--W15], W8
0077AE  FA8000     ULNK
0077B0  060000     RETURN
1049:              
1050:              /*********************************************************************
1051:              * Function: void TeDelKeyMembers(void *pObj)
1052:              *
1053:              * Notes: This function will delete the members of the list
1054:              ********************************************************************/
1055:              void TeDelKeyMembers(void *pObj)
1056:              {
0077B2  FA0008     LNK #0x8
0077B4  980730     MOV W0, [W14+6]
1057:                  KEYMEMBER   *pCurItem;
1058:                  KEYMEMBER   *pItem;
1059:                  TEXTENTRY *pTe;
1060:              
1061:                  pTe = (TEXTENTRY *)pObj;
0077B6  90003E     MOV [W14+6], W0
0077B8  980710     MOV W0, [W14+2]
1062:              
1063:                  pCurItem = pTe->pHeadOfList;
0077BA  90001E     MOV [W14+2], W0
0077BC  9010B0     MOV [W0+38], W1
0077BE  780F01     MOV W1, [W14]
1064:              
1065:                  while(pCurItem != NULL)
0077C0  370007     BRA 0x77D0
0077D0  78001E     MOV [W14], W0
0077D2  500FE0     SUB W0, #0x0, [W15]
0077D4  3AFFF6     BRA NZ, 0x77C2
1066:                  {
1067:                      pItem = pCurItem;
0077C2  78001E     MOV [W14], W0
0077C4  980720     MOV W0, [W14+4]
1068:                      pCurItem = pCurItem->pNextKey;
0077C6  78001E     MOV [W14], W0
0077C8  900830     MOV [W0+22], W0
0077CA  780F00     MOV W0, [W14]
1069:                      GFX_free(pItem);
0077CC  90002E     MOV [W14+4], W0
0077CE  07D45B     RCALL _free
1070:                  }
1071:              
1072:                  pTe->pHeadOfList = NULL;
0077D6  90001E     MOV [W14+2], W0
0077D8  EB0080     CLR W1
0077DA  981031     MOV W1, [W0+38]
1073:              }
0077DC  FA8000     ULNK
0077DE  060000     RETURN
1074:              
1075:              /*********************************************************************
1076:              * Function: void TeSpaceChar(TEXTENTRY *pTe)
1077:              *
1078:              * Notes: This function will add a space to the buffer/editbox
1079:              ********************************************************************/
1080:              void TeSpaceChar(TEXTENTRY *pTe)
1081:              {
0077E0  FA0002     LNK #0x2
0077E2  780F00     MOV W0, [W14]
1082:              
1083:                  //first determine if the array has not overflown
1084:                  if((pTe->CurrentLength) < pTe->outputLenMax)
0077E4  78001E     MOV [W14], W0
0077E6  901080     MOV [W0+32], W1
0077E8  78001E     MOV [W14], W0
0077EA  901010     MOV [W0+34], W0
0077EC  508F80     SUB W1, W0, [W15]
0077EE  31000F     BRA C, 0x780E
1085:                  {
1086:                      *(pTe->pTeOutput + (pTe->CurrentLength)) = 0x20;
0077F0  78001E     MOV [W14], W0
0077F2  9008F0     MOV [W0+30], W1
0077F4  78001E     MOV [W14], W0
0077F6  901000     MOV [W0+32], W0
0077F8  408080     ADD W1, W0, W1
0077FA  B3C200     MOV #0x20, W0
0077FC  784880     MOV.B W0, [W1]
1087:                      *(pTe->pTeOutput + (pTe->CurrentLength) + 1) = 0;
0077FE  78001E     MOV [W14], W0
007800  9008F0     MOV [W0+30], W1
007802  78001E     MOV [W14], W0
007804  901000     MOV [W0+32], W0
007806  E80000     INC W0, W0
007808  408080     ADD W1, W0, W1
00780A  EB4000     CLR.B W0
00780C  784880     MOV.B W0, [W1]
1088:                  }   //end if	
1089:                  (pTe->CurrentLength)++;
00780E  78001E     MOV [W14], W0
007810  901000     MOV [W0+32], W0
007812  E80080     INC W0, W1
007814  78001E     MOV [W14], W0
007816  981001     MOV W1, [W0+32]
1090:              }
007818  FA8000     ULNK
00781A  060000     RETURN
1091:              
1092:              /*********************************************************************
1093:              * Function: void TeAddChar(TEXTENTRY *pTe)
1094:              *
1095:              * Notes: This function will add a character to the buffer/editbox
1096:              ********************************************************************/
1097:              void TeAddChar(TEXTENTRY *pTe)
1098:              {
00781C  FA0004     LNK #0x4
00781E  980710     MOV W0, [W14+2]
1099:                  XCHAR   *pPoint;
1100:              
1101:                  //first determine if the array has not overflown
1102:                  if((pTe->CurrentLength) < pTe->outputLenMax)
007820  90001E     MOV [W14+2], W0
007822  901080     MOV [W0+32], W1
007824  90001E     MOV [W14+2], W0
007826  901010     MOV [W0+34], W0
007828  508F80     SUB W1, W0, [W15]
00782A  31001F     BRA C, 0x786A
1103:                  {
1104:                      pPoint = (pTe->pActiveKey)->pKeyName;
00782C  90001E     MOV [W14+2], W0
00782E  901020     MOV [W0+36], W0
007830  900880     MOV [W0+16], W1
007832  780F01     MOV W1, [W14]
1105:                      while(*(pPoint) != 0)
007834  370009     BRA 0x7848
007848  78001E     MOV [W14], W0
00784A  784010     MOV.B [W0], W0
00784C  504FE0     SUB.B W0, #0x0, [W15]
00784E  3AFFF3     BRA NZ, 0x7836
1106:                      {
1107:                          *(pTe->pTeOutput + (pTe->CurrentLength)) = *(pPoint)++;
007836  90001E     MOV [W14+2], W0
007838  9008F0     MOV [W0+30], W1
00783A  90001E     MOV [W14+2], W0
00783C  901000     MOV [W0+32], W0
00783E  408080     ADD W1, W0, W1
007840  78001E     MOV [W14], W0
007842  784010     MOV.B [W0], W0
007844  784880     MOV.B W0, [W1]
007846  E80F1E     INC [W14], [W14]
1108:                      }
1109:                  }   //end if
1110:                  else
1111:                  {
1112:              
1113:                      // it is full ignore the added key
1114:                      return;
00786A  000000     NOP
1115:                  }
1116:              
1117:                  (pTe->CurrentLength)++;
007850  90001E     MOV [W14+2], W0
007852  901000     MOV [W0+32], W0
007854  E80080     INC W0, W1
007856  90001E     MOV [W14+2], W0
007858  981001     MOV W1, [W0+32]
1118:                  // add the string terminator 
1119:                  *(pTe->pTeOutput + pTe->CurrentLength) = 0;
00785A  90001E     MOV [W14+2], W0
00785C  9008F0     MOV [W0+30], W1
00785E  90001E     MOV [W14+2], W0
007860  901000     MOV [W0+32], W0
007862  408080     ADD W1, W0, W1
007864  EB4000     CLR.B W0
007866  784880     MOV.B W0, [W1]
007868  370001     BRA 0x786C
1120:              }
00786C  FA8000     ULNK
00786E  060000     RETURN
1121:              
1122:              #endif // USE_TEXTENTRY
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/StaticText.c  --------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library 
3:                  *  GOL Layer 
4:                  *  Static Text
5:                  *****************************************************************************
6:                  * FileName:        StaticText.c
7:                  * Dependencies:    None 
8:                  * Processor:       PIC24F, PIC24H, dsPIC, PIC32
9:                  * Compiler:       	MPLAB C30 V3.00, MPLAB C32
10:                 * Linker:          MPLAB LINK30, MPLAB LINK32
11:                 * Company:         Microchip Technology Incorporated
12:                 *
13:                 * Software License Agreement
14:                 *
15:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
16:                 * Microchip licenses to you the right to use, modify, copy and distribute
17:                 * Software only when embedded on a Microchip microcontroller or digital
18:                 * signal controller, which is integrated into your product or third party
19:                 * product (pursuant to the sublicense terms in the accompanying license
20:                 * agreement).  
21:                 *
22:                 * You should refer to the license agreement accompanying this Software
23:                 * for additional information regarding your rights and obligations.
24:                 *
25:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
26:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
27:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
28:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
29:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
30:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
32:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
33:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
34:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
35:                 * OR OTHER SIMILAR COSTS.
36:                 *
37:                 * Date        Comment
38:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:                 * 11/12/07	   Version 1.0 release
40:                 * 11/12/07	   Fixed clipping enabling location
41:                 * 08/04/11    Fixed rendering to check IsDeviceBusy() if not exiting the
42:                 *             draw routine.
43:                *****************************************************************************/
44:                #include "Graphics/Graphics.h"
45:                
46:                #ifdef USE_STATICTEXT
47:                
48:                /*********************************************************************
49:                * Function: STATICTEXT  *StCreate(WORD ID, SHORT left, SHORT top, SHORT right, SHORT bottom, 
50:                *								  WORD state , XCHAR *pText, GOL_SCHEME *pScheme)
51:                *
52:                * Notes: Creates a STATICTEXT object and adds it to the current active list.
53:                *        If the creation is successful, the pointer to the created Object 
54:                *        is returned. If not successful, NULL is returned.
55:                *
56:                ********************************************************************/
57:                STATICTEXT *StCreate
58:                (
59:                    WORD        ID,
60:                    SHORT       left,
61:                    SHORT       top,
62:                    SHORT       right,
63:                    SHORT       bottom,
64:                    WORD        state,
65:                    XCHAR       *pText,
66:                    GOL_SCHEME  *pScheme
67:                )
68:                {
00AE6C  FA0012     LNK #0x12
00AE6E  980710     MOV W0, [W14+2]
00AE70  980721     MOV W1, [W14+4]
00AE72  980732     MOV W2, [W14+6]
00AE74  980743     MOV W3, [W14+8]
00AE76  980754     MOV W4, [W14+10]
00AE78  980765     MOV W5, [W14+12]
00AE7A  980776     MOV W6, [W14+14]
00AE7C  980F07     MOV W7, [W14+16]
69:                    STATICTEXT  *pSt = NULL;
00AE7E  EB0000     CLR W0
00AE80  780F00     MOV W0, [W14]
70:                
71:                    pSt = (STATICTEXT *)GFX_malloc(sizeof(STATICTEXT));
00AE82  2001E0     MOV #0x1E, W0
00AE84  07B865     RCALL _malloc
00AE86  780F00     MOV W0, [W14]
72:                    if(pSt == NULL)
00AE88  78001E     MOV [W14], W0
00AE8A  500FE0     SUB W0, #0x0, [W15]
00AE8C  3A0002     BRA NZ, 0xAE92
73:                        return (pSt);
00AE8E  78001E     MOV [W14], W0
00AE90  370041     BRA 0xAF14
74:                
75:                    pSt->hdr.ID = ID;               // unique id assigned for referencing
00AE92  78001E     MOV [W14], W0
00AE94  90009E     MOV [W14+2], W1
00AE96  780801     MOV W1, [W0]
76:                    pSt->hdr.pNxtObj = NULL;        // initialize pointer to NULL
00AE98  78001E     MOV [W14], W0
00AE9A  EB0080     CLR W1
00AE9C  980011     MOV W1, [W0+2]
77:                    pSt->hdr.type = OBJ_STATICTEXT; // set object type
00AE9E  78001E     MOV [W14], W0
00AEA0  200081     MOV #0x8, W1
00AEA2  980021     MOV W1, [W0+4]
78:                    pSt->hdr.left = left;           // left,top corner
00AEA4  78001E     MOV [W14], W0
00AEA6  9000AE     MOV [W14+4], W1
00AEA8  980041     MOV W1, [W0+8]
79:                    pSt->hdr.top = top;
00AEAA  78001E     MOV [W14], W0
00AEAC  9000BE     MOV [W14+6], W1
00AEAE  980051     MOV W1, [W0+10]
80:                    pSt->hdr.right = right;         // right buttom corner
00AEB0  78001E     MOV [W14], W0
00AEB2  9000CE     MOV [W14+8], W1
00AEB4  980061     MOV W1, [W0+12]
81:                    pSt->hdr.bottom = bottom;
00AEB6  78001E     MOV [W14], W0
00AEB8  9000DE     MOV [W14+10], W1
00AEBA  980071     MOV W1, [W0+14]
82:                    pSt->pText = pText;             // location of the text
00AEBC  78001E     MOV [W14], W0
00AEBE  9000FE     MOV [W14+14], W1
00AEC0  980861     MOV W1, [W0+28]
83:                    pSt->hdr.state = state;
00AEC2  78001E     MOV [W14], W0
00AEC4  9000EE     MOV [W14+12], W1
00AEC6  980031     MOV W1, [W0+6]
84:                    pSt->hdr.DrawObj = StDraw;			// draw function
00AEC8  78001E     MOV [W14], W0
00AECA  2AF8E1     MOV #0xAF8E, W1
00AECC  980811     MOV W1, [W0+18]
85:                    pSt->hdr.MsgObj = StTranslateMsg;   // message function
00AECE  78001E     MOV [W14], W0
00AED0  2AF341     MOV #0xAF34, W1
00AED2  980831     MOV W1, [W0+22]
86:                    pSt->hdr.MsgDefaultObj = NULL;		// default message function
00AED4  78001E     MOV [W14], W0
00AED6  EB0080     CLR W1
00AED8  980841     MOV W1, [W0+24]
87:                    pSt->hdr.FreeObj = NULL;			// free function
00AEDA  78001E     MOV [W14], W0
00AEDC  EB0080     CLR W1
00AEDE  980821     MOV W1, [W0+20]
88:                
89:                    // Set the color scheme to be used
90:                    if(pScheme == NULL)
00AEE0  90080E     MOV [W14+16], W0
00AEE2  500FE0     SUB W0, #0x0, [W15]
00AEE4  3A0004     BRA NZ, 0xAEEE
91:                        pSt->hdr.pGolScheme = _pDefaultGolScheme;
00AEE6  808B41     MOV 0x1168, W1
00AEE8  78001E     MOV [W14], W0
00AEEA  980801     MOV W1, [W0+16]
00AEEC  370003     BRA 0xAEF4
92:                    else
93:                        pSt->hdr.pGolScheme = (GOL_SCHEME *)pScheme;
00AEEE  78001E     MOV [W14], W0
00AEF0  90088E     MOV [W14+16], W1
00AEF2  980801     MOV W1, [W0+16]
94:                
95:                    pSt->textHeight = 0;
00AEF4  78001E     MOV [W14], W0
00AEF6  EB0080     CLR W1
00AEF8  980851     MOV W1, [W0+26]
96:                    if(pSt->pText != NULL)
00AEFA  78001E     MOV [W14], W0
00AEFC  900860     MOV [W0+28], W0
00AEFE  500FE0     SUB W0, #0x0, [W15]
00AF00  320006     BRA Z, 0xAF0E
97:                    {
98:                
99:                        // Set the text height
100:                       pSt->textHeight = GetTextHeight(pSt->hdr.pGolScheme->pFont);
00AF02  78001E     MOV [W14], W0
00AF04  900800     MOV [W0+16], W0
00AF06  900050     MOV [W0+10], W0
00AF08  07DBA3     RCALL GetTextHeight
00AF0A  78009E     MOV [W14], W1
00AF0C  9808D0     MOV W0, [W1+26]
101:                   }
102:               
103:                   GOLAddObject((OBJ_HEADER *)pSt);
00AF0E  78001E     MOV [W14], W0
00AF10  07EB81     RCALL GOLAddObject
104:                   return (pSt);
00AF12  78001E     MOV [W14], W0
105:               }
00AF14  FA8000     ULNK
00AF16  060000     RETURN
106:               
107:               /*********************************************************************
108:               * Function: StSetText(STATICTEXT *pSt, XCHAR *pText)
109:               *
110:               * Notes: Sets the string that will be used.
111:               *
112:               ********************************************************************/
113:               void StSetText(STATICTEXT *pSt, XCHAR *pText)
114:               {
00AF18  FA0004     LNK #0x4
00AF1A  780F00     MOV W0, [W14]
00AF1C  980711     MOV W1, [W14+2]
115:                   pSt->pText = pText;
00AF1E  78001E     MOV [W14], W0
00AF20  90009E     MOV [W14+2], W1
00AF22  980861     MOV W1, [W0+28]
116:                   pSt->textHeight = GetTextHeight(pSt->hdr.pGolScheme->pFont);
00AF24  78001E     MOV [W14], W0
00AF26  900800     MOV [W0+16], W0
00AF28  900050     MOV [W0+10], W0
00AF2A  07DB92     RCALL GetTextHeight
00AF2C  78009E     MOV [W14], W1
00AF2E  9808D0     MOV W0, [W1+26]
117:               }
00AF30  FA8000     ULNK
00AF32  060000     RETURN
118:               
119:               /*********************************************************************
120:               * Function: WORD StTranslateMsg(void *pObj, GOL_MSG *pMsg)
121:               *
122:               * Notes: Evaluates the message if the object will be affected by the 
123:               *		 message or not.
124:               *
125:               ********************************************************************/
126:               WORD StTranslateMsg(void *pObj, GOL_MSG *pMsg)
127:               {
00AF34  FA0006     LNK #0x6
00AF36  980710     MOV W0, [W14+2]
00AF38  980721     MOV W1, [W14+4]
128:               
129:                   STATICTEXT *pSt;
130:               
131:                   pSt = (STATICTEXT *)pObj;
00AF3A  90001E     MOV [W14+2], W0
00AF3C  780F00     MOV W0, [W14]
132:               
133:               
134:                   // Evaluate if the message is for the static text
135:                   // Check if disabled first
136:                   if(GetState(pSt, ST_DISABLED))
00AF3E  78001E     MOV [W14], W0
00AF40  900030     MOV [W0+6], W0
00AF42  600062     AND W0, #0x2, W0
00AF44  500FE0     SUB W0, #0x0, [W15]
00AF46  320002     BRA Z, 0xAF4C
137:                       return (OBJ_MSG_INVALID);
00AF48  EB0000     CLR W0
00AF4A  37001F     BRA 0xAF8A
138:               
139:                       #ifdef USE_TOUCHSCREEN
140:                   if(pMsg->type == TYPE_TOUCHSCREEN)
00AF4C  90002E     MOV [W14+4], W0
00AF4E  784010     MOV.B [W0], W0
00AF50  504FE2     SUB.B W0, #0x2, [W15]
00AF52  3A001A     BRA NZ, 0xAF88
141:                   {
142:               
143:                       // Check if it falls in static text control borders
144:                       if
145:                       (
00AF5C  508F80     SUB W1, W0, [W15]
00AF5E  3D0014     BRA GE, 0xAF88
146:                           (pSt->hdr.left < pMsg->param1) &&
00AF54  78001E     MOV [W14], W0
00AF56  9000C0     MOV [W0+8], W1
00AF58  90002E     MOV [W14+4], W0
00AF5A  900010     MOV [W0+2], W0
00AF68  508F80     SUB W1, W0, [W15]
00AF6A  34000E     BRA LE, 0xAF88
147:                           (pSt->hdr.right > pMsg->param1) &&
00AF60  78001E     MOV [W14], W0
00AF62  9000E0     MOV [W0+12], W1
00AF64  90002E     MOV [W14+4], W0
00AF66  900010     MOV [W0+2], W0
00AF74  508F80     SUB W1, W0, [W15]
00AF76  3D0008     BRA GE, 0xAF88
148:                           (pSt->hdr.top < pMsg->param2) &&
00AF6C  78001E     MOV [W14], W0
00AF6E  9000D0     MOV [W0+10], W1
00AF70  90002E     MOV [W14+4], W0
00AF72  900020     MOV [W0+4], W0
00AF80  508F80     SUB W1, W0, [W15]
00AF82  340002     BRA LE, 0xAF88
149:                           (pSt->hdr.bottom > pMsg->param2)
00AF78  78001E     MOV [W14], W0
00AF7A  9000F0     MOV [W0+14], W1
00AF7C  90002E     MOV [W14+4], W0
00AF7E  900020     MOV [W0+4], W0
150:                       )
151:                       {
152:                           return (ST_MSG_SELECTED);
00AF84  2000F0     MOV #0xF, W0
00AF86  370001     BRA 0xAF8A
153:                       }
154:                   }
155:               
156:                       #endif
157:                   return (OBJ_MSG_INVALID);
00AF88  EB0000     CLR W0
158:               }
00AF8A  FA8000     ULNK
00AF8C  060000     RETURN
159:               
160:               /*********************************************************************
161:               * Function: WORD StDraw(void *pObj)
162:               *
163:               * Notes: This is the state machine to draw the static text.
164:               *
165:               ********************************************************************/
166:               WORD StDraw(void *pObj)
167:               {
00AF8E  FA0008     LNK #0x8
00AF90  980730     MOV W0, [W14+6]
168:                   typedef enum
169:                   {
170:                       ST_STATE_IDLE,
171:                       ST_STATE_CLEANAREA,
172:                       ST_STATE_INIT,
173:                       ST_STATE_SETALIGN,
174:                       ST_STATE_DRAWTEXT
175:                   } ST_DRAW_STATES;
176:               
177:                   static ST_DRAW_STATES state = ST_STATE_IDLE;
178:                   static SHORT charCtr = 0, lineCtr = 0;
179:                   static XCHAR *pCurLine = NULL;
180:                   SHORT textWidth;
181:                   XCHAR ch = 0;
00AF92  EB4000     CLR.B W0
00AF94  784F00     MOV.B W0, [W14]
182:                   STATICTEXT *pSt;
183:               
184:                   pSt = (STATICTEXT *)pObj;
00AF96  90003E     MOV [W14+6], W0
00AF98  980710     MOV W0, [W14+2]
00AF9A  370001     BRA 0xAF9E
185:               
186:                   while(1)
187:                   {
188:                       if(IsDeviceBusy())
00AF9E  0709B9     RCALL IsDeviceBusy
00AFA0  500FE0     SUB W0, #0x0, [W15]
00AFA2  320002     BRA Z, 0xAFA8
189:                           return (0);
00AFA4  EB0000     CLR W0
00AFA6  37012B     BRA 0xB1FE
190:                   
191:                       switch(state)
00AFA8  808B70     MOV state, W0
00AFAA  200001     MOV #0x0, W1
00AFAC  200042     MOV #0x4, W2
00AFAE  200003     MOV #0x0, W3
00AFB0  500F82     SUB W0, W2, [W15]
00AFB2  588F83     SUBB W1, W3, [W15]
00AFB4  3EFFF3     BRA GTU, 0xAF9C
00AFB6  016000     BRA W0
00AFB8  370004     BRA 0xAFC2
00AFBA  370068     BRA 0xB08C
00AFBC  37008B     BRA 0xB0D4
00AFBE  3700A6     BRA 0xB10C
00AFC0  3700EA     BRA 0xB196
192:                       {
193:                           case ST_STATE_IDLE:
194:                               SetClip(CLIP_DISABLE);
00AFC2  EB4000     CLR.B W0
00AFC4  07D274     RCALL SetClip
195:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
196:                               GFX_DRIVER_SetupDrawUpdate( pSt->hdr.left,
197:                                                           pSt->hdr.top,
198:                                                           pSt->hdr.right,
199:                                                           pSt->hdr.bottom);
200:               #endif
201:                   
202:                               if(GetState(pSt, ST_HIDE))
00AFC6  90001E     MOV [W14+2], W0
00AFC8  900030     MOV [W0+6], W0
00AFCA  500FE0     SUB W0, #0x0, [W15]
00AFCC  3D0013     BRA GE, 0xAFF4
203:                               {
204:                                   SetColor(pSt->hdr.pGolScheme->CommonBkColor);
00AFCE  90001E     MOV [W14+2], W0
00AFD0  900800     MOV [W0+16], W0
00AFD2  904800     MOV.B [W0+8], W0
00AFD4  B7F13E     MOV.B WREG, _color
205:                                   if(!Bar(pSt->hdr.left, pSt->hdr.top, pSt->hdr.right, pSt->hdr.bottom))
00AFD6  90001E     MOV [W14+2], W0
00AFD8  9001F0     MOV [W0+14], W3
00AFDA  90001E     MOV [W14+2], W0
00AFDC  900160     MOV [W0+12], W2
00AFDE  90001E     MOV [W14+2], W0
00AFE0  9000D0     MOV [W0+10], W1
00AFE2  90001E     MOV [W14+2], W0
00AFE4  900040     MOV [W0+8], W0
00AFE6  07D26A     RCALL Bar
00AFE8  500FE0     SUB W0, #0x0, [W15]
00AFEA  3A0002     BRA NZ, 0xAFF0
206:                                       return (0);
00AFEC  EB0000     CLR W0
00AFEE  370107     BRA 0xB1FE
207:                   
208:                                   // State is still IDLE STATE so no need to set state
209:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
210:                                   GFX_DRIVER_CompleteDrawUpdate(   pSt->hdr.left,
211:                                                                   pSt->hdr.top,
212:                                                                   pSt->hdr.right,
213:                                                                   pSt->hdr.bottom);
214:               #endif
215:                                   return (1);
00AFF0  200010     MOV #0x1, W0
00AFF2  370105     BRA 0xB1FE
216:                               }
217:                   
218:                               if(GetState(pSt, ST_DRAW))
00AFF4  90001E     MOV [W14+2], W0
00AFF6  9000B0     MOV [W0+6], W1
00AFF8  240000     MOV #0x4000, W0
00AFFA  608000     AND W1, W0, W0
00AFFC  500FE0     SUB W0, #0x0, [W15]
00AFFE  320044     BRA Z, 0xB088
219:                               {
220:                                   // show frame if specified to be shown
221:                                   SetLineType(SOLID_LINE);
00B000  EB0000     CLR W0
00B002  888240     MOV W0, _lineType
222:                                   SetLineThickness(NORMAL_LINE);
00B004  EB4000     CLR.B W0
00B006  B7F04A     MOV.B WREG, _lineThickness
223:                   
224:                                   if(GetState(pSt, ST_FRAME))
00B008  90001E     MOV [W14+2], W0
00B00A  900030     MOV [W0+6], W0
00B00C  600070     AND W0, #0x10, W0
00B00E  500FE0     SUB W0, #0x0, [W15]
00B010  320029     BRA Z, 0xB064
225:                                   {
226:                   
227:                                       if(!GetState(pSt, ST_DISABLED))
00B012  90001E     MOV [W14+2], W0
00B014  900030     MOV [W0+6], W0
00B016  600062     AND W0, #0x2, W0
00B018  500FE0     SUB W0, #0x0, [W15]
00B01A  3A0012     BRA NZ, 0xB040
228:                                       {
229:                   
230:                                           // show enabled color
231:                                           SetColor(pSt->hdr.pGolScheme->Color1);
00B01C  90001E     MOV [W14+2], W0
00B01E  900800     MOV [W0+16], W0
00B020  904060     MOV.B [W0+6], W0
00B022  B7F13E     MOV.B WREG, _color
232:                                           if(!Rectangle(pSt->hdr.left, pSt->hdr.top, pSt->hdr.right, pSt->hdr.bottom))
00B024  90001E     MOV [W14+2], W0
00B026  9001F0     MOV [W0+14], W3
00B028  90001E     MOV [W14+2], W0
00B02A  900160     MOV [W0+12], W2
00B02C  90001E     MOV [W14+2], W0
00B02E  9000D0     MOV [W0+10], W1
00B030  90001E     MOV [W14+2], W0
00B032  900040     MOV [W0+8], W0
00B034  EB0200     CLR W4
00B036  07D622     RCALL Bevel
00B038  500FE0     SUB W0, #0x0, [W15]
00B03A  3A0026     BRA NZ, 0xB088
233:                                               return (0);
00B03C  EB0000     CLR W0
00B03E  3700DF     BRA 0xB1FE
234:                                       }
235:                                       else
236:                                       {
237:                   
238:                                           // show disabled color
239:                                           SetColor(pSt->hdr.pGolScheme->ColorDisabled);
00B040  90001E     MOV [W14+2], W0
00B042  900800     MOV [W0+16], W0
00B044  904070     MOV.B [W0+7], W0
00B046  B7F13E     MOV.B WREG, _color
240:                                           if(!Rectangle(pSt->hdr.left, pSt->hdr.top, pSt->hdr.right, pSt->hdr.bottom))
00B048  90001E     MOV [W14+2], W0
00B04A  9001F0     MOV [W0+14], W3
00B04C  90001E     MOV [W14+2], W0
00B04E  900160     MOV [W0+12], W2
00B050  90001E     MOV [W14+2], W0
00B052  9000D0     MOV [W0+10], W1
00B054  90001E     MOV [W14+2], W0
00B056  900040     MOV [W0+8], W0
00B058  EB0200     CLR W4
00B05A  07D610     RCALL Bevel
00B05C  500FE0     SUB W0, #0x0, [W15]
00B05E  3A0014     BRA NZ, 0xB088
241:                                               return (0);
00B060  EB0000     CLR W0
00B062  3700CD     BRA 0xB1FE
242:                                       }
243:                                   }
244:                                   else
245:                                   {
246:                                       // show enabled color
247:                                       SetColor(pSt->hdr.pGolScheme->CommonBkColor);
00B064  90001E     MOV [W14+2], W0
00B066  900800     MOV [W0+16], W0
00B068  904800     MOV.B [W0+8], W0
00B06A  B7F13E     MOV.B WREG, _color
248:                                       if(!Rectangle(pSt->hdr.left, pSt->hdr.top, pSt->hdr.right, pSt->hdr.bottom))
00B06C  90001E     MOV [W14+2], W0
00B06E  9001F0     MOV [W0+14], W3
00B070  90001E     MOV [W14+2], W0
00B072  900160     MOV [W0+12], W2
00B074  90001E     MOV [W14+2], W0
00B076  9000D0     MOV [W0+10], W1
00B078  90001E     MOV [W14+2], W0
00B07A  900040     MOV [W0+8], W0
00B07C  EB0200     CLR W4
00B07E  07D5FE     RCALL Bevel
00B080  500FE0     SUB W0, #0x0, [W15]
00B082  3A0002     BRA NZ, 0xB088
249:                                       	return (0);
00B084  EB0000     CLR W0
00B086  3700BB     BRA 0xB1FE
250:                   	                
251:                   	            } 
252:                               }
253:                   
254:                               state = ST_STATE_CLEANAREA;
00B088  200010     MOV #0x1, W0
00B08A  888B70     MOV W0, state
255:                   
256:                           case ST_STATE_CLEANAREA:
257:                   
258:                               // clean area where text will be placed.
259:                               SetColor(pSt->hdr.pGolScheme->CommonBkColor);
00B08C  90001E     MOV [W14+2], W0
00B08E  900800     MOV [W0+16], W0
00B090  904800     MOV.B [W0+8], W0
00B092  B7F13E     MOV.B WREG, _color
260:                               if(!Bar(pSt->hdr.left + 1, pSt->hdr.top + 1, pSt->hdr.right - 1, pSt->hdr.bottom - 1))
00B094  90001E     MOV [W14+2], W0
00B096  900070     MOV [W0+14], W0
00B098  E90180     DEC W0, W3
00B09A  90001E     MOV [W14+2], W0
00B09C  900060     MOV [W0+12], W0
00B09E  E90100     DEC W0, W2
00B0A0  90001E     MOV [W14+2], W0
00B0A2  900050     MOV [W0+10], W0
00B0A4  E80080     INC W0, W1
00B0A6  90001E     MOV [W14+2], W0
00B0A8  900040     MOV [W0+8], W0
00B0AA  E80000     INC W0, W0
00B0AC  07D207     RCALL Bar
00B0AE  500FE0     SUB W0, #0x0, [W15]
00B0B0  3A0002     BRA NZ, 0xB0B6
261:                                   return (0);
00B0B2  EB0000     CLR W0
00B0B4  3700A4     BRA 0xB1FE
262:                   
263:                               // set clipping area, text will only appear inside the static text area.
264:                               SetClip(CLIP_ENABLE);
00B0B6  B3C010     MOV #0x1, W0
00B0B8  07D1FA     RCALL SetClip
265:                               SetClipRgn(pSt->hdr.left + ST_INDENT, pSt->hdr.top, pSt->hdr.right - ST_INDENT, pSt->hdr.bottom);
00B0BA  90001E     MOV [W14+2], W0
00B0BC  9001F0     MOV [W0+14], W3
00B0BE  90001E     MOV [W14+2], W0
00B0C0  900060     MOV [W0+12], W0
00B0C2  E98100     DEC2 W0, W2
00B0C4  90001E     MOV [W14+2], W0
00B0C6  9000D0     MOV [W0+10], W1
00B0C8  90001E     MOV [W14+2], W0
00B0CA  900040     MOV [W0+8], W0
00B0CC  E88000     INC2 W0, W0
00B0CE  07D1E0     RCALL SetClipRgn
266:                               state = ST_STATE_INIT;
00B0D0  200020     MOV #0x2, W0
00B0D2  888B70     MOV W0, state
267:                   
268:                           case ST_STATE_INIT:
269:                               if(IsDeviceBusy())
00B0D4  07091E     RCALL IsDeviceBusy
00B0D6  500FE0     SUB W0, #0x0, [W15]
00B0D8  320002     BRA Z, 0xB0DE
270:                                   return (0);
00B0DA  EB0000     CLR W0
00B0DC  370090     BRA 0xB1FE
271:                   
272:                               // set the text color
273:                               if(!GetState(pSt, ST_DISABLED))
00B0DE  90001E     MOV [W14+2], W0
00B0E0  900030     MOV [W0+6], W0
00B0E2  600062     AND W0, #0x2, W0
00B0E4  500FE0     SUB W0, #0x0, [W15]
00B0E6  3A0005     BRA NZ, 0xB0F2
274:                               {
275:                                   SetColor(pSt->hdr.pGolScheme->TextColor0);
00B0E8  90001E     MOV [W14+2], W0
00B0EA  900800     MOV [W0+16], W0
00B0EC  904020     MOV.B [W0+2], W0
00B0EE  B7F13E     MOV.B WREG, _color
00B0F0  370004     BRA 0xB0FA
276:                               }
277:                               else
278:                               {
279:                                   SetColor(pSt->hdr.pGolScheme->TextColorDisabled);
00B0F2  90001E     MOV [W14+2], W0
00B0F4  900800     MOV [W0+16], W0
00B0F6  904040     MOV.B [W0+4], W0
00B0F8  B7F13E     MOV.B WREG, _color
280:                               }
281:                   
282:                               // use the font specified in the object
283:                               SetFont(pSt->hdr.pGolScheme->pFont);
00B0FA  90001E     MOV [W14+2], W0
00B0FC  900800     MOV [W0+16], W0
00B0FE  900050     MOV [W0+10], W0
00B100  07D8AB     RCALL SetFont
284:                               pCurLine = pSt->pText;                  // get first line of text
00B102  90001E     MOV [W14+2], W0
00B104  900860     MOV [W0+28], W0
00B106  888B80     MOV W0, pCurLine
285:                               state = ST_STATE_SETALIGN;              // go to drawing of text
00B108  200030     MOV #0x3, W0
00B10A  888B70     MOV W0, state
286:                   
287:                           case ST_STATE_SETALIGN:
288:                               if(charCtr == 0)
00B10C  808B90     MOV charCtr, W0
00B10E  500FE0     SUB W0, #0x0, [W15]
00B110  3A0040     BRA NZ, 0xB192
289:                               {
290:                   
291:                                   // set position of the next character (based on alignment and next character)
292:                                   textWidth = GetTextWidth(pCurLine, pSt->hdr.pGolScheme->pFont);
00B112  90001E     MOV [W14+2], W0
00B114  900800     MOV [W0+16], W0
00B116  9000D0     MOV [W0+10], W1
00B118  808B80     MOV pCurLine, W0
00B11A  07DA7F     RCALL GetTextWidth
00B11C  980720     MOV W0, [W14+4]
293:                   
294:                                   // Display text with center alignment
295:                                   if(GetState(pSt, (ST_CENTER_ALIGN)))
00B11E  90001E     MOV [W14+2], W0
00B120  900030     MOV [W0+6], W0
00B122  600068     AND W0, #0x8, W0
00B124  500FE0     SUB W0, #0x0, [W15]
00B126  320013     BRA Z, 0xB14E
296:                                   {
297:                                       MoveTo((pSt->hdr.left + pSt->hdr.right - textWidth) >> 1, pSt->hdr.top + (lineCtr * pSt->textHeight));
00B128  90001E     MOV [W14+2], W0
00B12A  9000C0     MOV [W0+8], W1
00B12C  90001E     MOV [W14+2], W0
00B12E  900060     MOV [W0+12], W0
00B130  408080     ADD W1, W0, W1
00B132  90002E     MOV [W14+4], W0
00B134  508000     SUB W1, W0, W0
00B136  D18000     ASR W0, W0
00B138  888260     MOV W0, _cursorX
00B13A  90001E     MOV [W14+2], W0
00B13C  900150     MOV [W0+10], W2
00B13E  90001E     MOV [W14+2], W0
00B140  9008D0     MOV [W0+26], W1
00B142  808BA0     MOV lineCtr, W0
00B144  B98800     MUL.SS W1, W0, W0
00B146  780000     MOV W0, W0
00B148  410000     ADD W2, W0, W0
00B14A  888270     MOV W0, _cursorY
00B14C  370022     BRA 0xB192
298:                                   }
299:                   
300:                                   // Display text with right alignment
301:                                   else if(GetState(pSt, (ST_RIGHT_ALIGN)))
00B14E  90001E     MOV [W14+2], W0
00B150  900030     MOV [W0+6], W0
00B152  600064     AND W0, #0x4, W0
00B154  500FE0     SUB W0, #0x0, [W15]
00B156  320010     BRA Z, 0xB178
302:                                   {
303:                                       MoveTo((pSt->hdr.right - textWidth - ST_INDENT), pSt->hdr.top + (lineCtr * pSt->textHeight));
00B158  90001E     MOV [W14+2], W0
00B15A  9000E0     MOV [W0+12], W1
00B15C  90002E     MOV [W14+4], W0
00B15E  508000     SUB W1, W0, W0
00B160  E98000     DEC2 W0, W0
00B162  888260     MOV W0, _cursorX
00B164  90001E     MOV [W14+2], W0
00B166  900150     MOV [W0+10], W2
00B168  90001E     MOV [W14+2], W0
00B16A  9008D0     MOV [W0+26], W1
00B16C  808BA0     MOV lineCtr, W0
00B16E  B98800     MUL.SS W1, W0, W0
00B170  780000     MOV W0, W0
00B172  410000     ADD W2, W0, W0
00B174  888270     MOV W0, _cursorY
00B176  37000D     BRA 0xB192
304:                                   }
305:                   
306:                                   // Display text with left alignment
307:                                   else
308:                                   {
309:                                       MoveTo(pSt->hdr.left + ST_INDENT, pSt->hdr.top + (lineCtr * pSt->textHeight));
00B178  90001E     MOV [W14+2], W0
00B17A  900040     MOV [W0+8], W0
00B17C  E88000     INC2 W0, W0
00B17E  888260     MOV W0, _cursorX
00B180  90001E     MOV [W14+2], W0
00B182  900150     MOV [W0+10], W2
00B184  90001E     MOV [W14+2], W0
00B186  9008D0     MOV [W0+26], W1
00B188  808BA0     MOV lineCtr, W0
00B18A  B98800     MUL.SS W1, W0, W0
00B18C  780000     MOV W0, W0
00B18E  410000     ADD W2, W0, W0
00B190  888270     MOV W0, _cursorY
310:                                   }
311:                               }
312:                   
313:                               state = ST_STATE_DRAWTEXT;
00B192  200040     MOV #0x4, W0
00B194  888B70     MOV W0, state
314:                   
315:                           case ST_STATE_DRAWTEXT:
316:                               ch = *(pCurLine + charCtr);
00B196  808B81     MOV pCurLine, W1
00B198  808B90     MOV charCtr, W0
00B19A  408000     ADD W1, W0, W0
00B19C  784F10     MOV.B [W0], [W14]
317:                   
318:                               // output one character at time until a newline character or a NULL character is sampled
319:                               while((0x0000 != ch) && (0x000A != ch))
00B19E  37000D     BRA 0xB1BA
00B1BA  78401E     MOV.B [W14], W0
00B1BC  504FE0     SUB.B W0, #0x0, [W15]
00B1BE  320003     BRA Z, 0xB1C6
00B1C0  78401E     MOV.B [W14], W0
00B1C2  504FEA     SUB.B W0, #0xA, [W15]
00B1C4  3AFFED     BRA NZ, 0xB1A0
320:                               {
321:                                   if(!OutChar(ch))
00B1A0  78401E     MOV.B [W14], W0
00B1A2  07D974     RCALL OutChar
00B1A4  500FE0     SUB W0, #0x0, [W15]
00B1A6  3A0002     BRA NZ, 0xB1AC
322:                                       return (0);                     // render the character
00B1A8  EB0000     CLR W0
00B1AA  370029     BRA 0xB1FE
323:                                   charCtr++;                          // update to next character
00B1AC  808B90     MOV charCtr, W0
00B1AE  E80000     INC W0, W0
00B1B0  888B90     MOV W0, charCtr
324:                                   ch = *(pCurLine + charCtr);
00B1B2  808B81     MOV pCurLine, W1
00B1B4  808B90     MOV charCtr, W0
00B1B6  408000     ADD W1, W0, W0
00B1B8  784F10     MOV.B [W0], [W14]
325:                               }
326:                   
327:                               // pCurText is updated for the next line
328:                               if(ch == 0x000A)
00B1C6  78401E     MOV.B [W14], W0
00B1C8  504FEA     SUB.B W0, #0xA, [W15]
00B1CA  3A000E     BRA NZ, 0xB1E8
329:                               {                                       // new line character
330:                                   pCurLine = pCurLine + charCtr + 1;  // go to first char of next line
00B1CC  808B81     MOV pCurLine, W1
00B1CE  808B90     MOV charCtr, W0
00B1D0  E80000     INC W0, W0
00B1D2  408000     ADD W1, W0, W0
00B1D4  888B80     MOV W0, pCurLine
331:                                   lineCtr++;                          // update line counter
00B1D6  808BA0     MOV lineCtr, W0
00B1D8  E80000     INC W0, W0
00B1DA  888BA0     MOV W0, lineCtr
332:                                   charCtr = 0;                        // reset char counter
00B1DC  EB0000     CLR W0
00B1DE  888B90     MOV W0, charCtr
333:                                   state = ST_STATE_SETALIGN;          // continue to next line
00B1E0  200030     MOV #0x3, W0
00B1E2  888B70     MOV W0, state
334:                                   break;
00B1E4  000000     NOP
335:                               }
336:                   
337:                               // end of text string is reached no more lines to display
338:                               else
339:                               {
340:                                   pCurLine = NULL;                    // reset static variables
00B1E8  EB0000     CLR W0
00B1EA  888B80     MOV W0, pCurLine
341:                                   lineCtr = 0;
00B1EC  EB0000     CLR W0
00B1EE  888BA0     MOV W0, lineCtr
342:                                   charCtr = 0;
00B1F0  EB0000     CLR W0
00B1F2  888B90     MOV W0, charCtr
343:                                   SetClip(CLIP_DISABLE);              // remove clipping
00B1F4  EB4000     CLR.B W0
00B1F6  07D15B     RCALL SetClip
344:                                   state = ST_STATE_IDLE;              // go back to IDLE state
00B1F8  EB0000     CLR W0
00B1FA  888B70     MOV W0, state
345:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
346:                                   GFX_DRIVER_CompleteDrawUpdate(   pSt->hdr.left,
347:                                                                   pSt->hdr.top,
348:                                                                   pSt->hdr.right,
349:                                                                   pSt->hdr.bottom);
350:               #endif
351:                                   return (1);
00B1FC  200010     MOV #0x1, W0
352:                               }
353:                       } // end of switch()
354:                   } // end of while(1)    
00AF9C  000000     NOP
00B1E6  37FEDB     BRA 0xAF9E
355:               }
00B1FE  FA8000     ULNK
00B200  060000     RETURN
356:               
357:               #endif // USE_STATICTEXT
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/Slider.c  ------------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library
3:                  *  GOL Layer 
4:                  *  Slider
5:                  *****************************************************************************
6:                  * FileName:        Slider.c
7:                  * Dependencies:    None 
8:                  * Processor:       PIC24F, PIC24H, dsPIC, PIC32
9:                  * Compiler:       	MPLAB C30 V3.00, MPLAB C32
10:                 * Linker:          MPLAB LINK30, MPLAB LINK32
11:                 * Company:         Microchip Technology Incorporated
12:                 *
13:                 * Software License Agreement
14:                 *
15:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
16:                 * Microchip licenses to you the right to use, modify, copy and distribute
17:                 * Software only when embedded on a Microchip microcontroller or digital
18:                 * signal controller, which is integrated into your product or third party
19:                 * product (pursuant to the sublicense terms in the accompanying license
20:                 * agreement).  
21:                 *
22:                 * You should refer to the license agreement accompanying this Software
23:                 * for additional information regarding your rights and obligations.
24:                 *
25:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
26:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
27:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
28:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
29:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
30:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
32:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
33:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
34:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
35:                 * OR OTHER SIMILAR COSTS.
36:                 *
37:                 * Date         Comment
38:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:                 * 11/12/07	    Version 1.0 release
40:                 * 04/29/10	    - Added OBJ_MSG_PASSIVE message to detect event on the slider 
41:                 *                but with no action.
42:                 *				- fixed the swapped message translation in the 
43:                 *                SldTranslateMsg() when keyboard event is detected.
44:                 * 02/23/11     Removed references to BLACK and WHITE colors. Replaced
45:                 *              with emboss dark and light colors. These are used
46:                 *              in rendering the thumb path.
47:                 * 04/20/11     Fixed KEYBOARD bug on object ID and GOL_MSG param1 comparison.
48:                 * 07/29/11     Fixed state transition when hiding the slider.
49:                 * 05/10/12     Added Alpha Blending Support
50:                 *****************************************************************************/
51:                #include "Graphics/Graphics.h"
52:                
53:                #ifdef USE_SLIDER
54:                
55:                /* Internal Functions */
56:                SHORT   SldSetThumbSize(SLIDER *pSld, SHORT high, SHORT low);
57:                void    SldGetMinMaxPos(SLIDER *pSld, WORD *minPos, WORD *maxPos);
58:                WORD    SldGetWidth(SLIDER *pSld);
59:                WORD    SldGetHeight(SLIDER *pSld);
60:                
61:                /*********************************************************************
62:                * Function: SLIDER *SldCreate(WORD ID, SHORT left, SHORT top, SHORT right, 
63:                *							  SHORT bottom, WORD state, SHORT range, 
64:                *							  SHORT page, SHORT pos, GOL_SCHEME *pScheme)
65:                *
66:                * Notes: Creates a SLIDER object and adds it to the current active list.
67:                *        If the creation is successful, the pointer to the created Object 
68:                *        is returned. If not successful, NULL is returned.
69:                *
70:                ********************************************************************/
71:                SLIDER *SldCreate
72:                (
73:                    WORD        ID,
74:                    SHORT       left,
75:                    SHORT       top,
76:                    SHORT       right,
77:                    SHORT       bottom,
78:                    WORD        state,
79:                    WORD        range,
80:                    WORD        page,
81:                    WORD        pos,
82:                    GOL_SCHEME  *pScheme
83:                )
84:                {
007870  FA0012     LNK #0x12
007872  980710     MOV W0, [W14+2]
007874  980721     MOV W1, [W14+4]
007876  980732     MOV W2, [W14+6]
007878  980743     MOV W3, [W14+8]
00787A  980754     MOV W4, [W14+10]
00787C  980765     MOV W5, [W14+12]
00787E  980776     MOV W6, [W14+14]
007880  980F07     MOV W7, [W14+16]
85:                    SLIDER  *pSld = NULL;
007882  EB0000     CLR W0
007884  780F00     MOV W0, [W14]
86:                
87:                    pSld = (SLIDER *)GFX_malloc(sizeof(SLIDER));
007886  200280     MOV #0x28, W0
007888  07D363     RCALL _malloc
00788A  780F00     MOV W0, [W14]
88:                    if(pSld == NULL)
00788C  78001E     MOV [W14], W0
00788E  500FE0     SUB W0, #0x0, [W15]
007890  3A0002     BRA NZ, 0x7896
89:                        return (pSld);
007892  78001E     MOV [W14], W0
007894  370042     BRA 0x791A
90:                
91:                    pSld->hdr.ID        = ID;                           // unique id assigned for referencing
007896  78001E     MOV [W14], W0
007898  90009E     MOV [W14+2], W1
00789A  780801     MOV W1, [W0]
92:                    pSld->hdr.pNxtObj   = NULL;
00789C  78001E     MOV [W14], W0
00789E  EB0080     CLR W1
0078A0  980011     MOV W1, [W0+2]
93:                    pSld->hdr.type      = OBJ_SLIDER;                   // set object type
0078A2  78001E     MOV [W14], W0
0078A4  200061     MOV #0x6, W1
0078A6  980021     MOV W1, [W0+4]
94:                    pSld->hdr.left      = left;                         // left and right should be equal when oriented vertically
0078A8  78001E     MOV [W14], W0
0078AA  9000AE     MOV [W14+4], W1
0078AC  980041     MOV W1, [W0+8]
95:                    pSld->hdr.top       = top;                          // top and bottom should be equal when oriented horizontally
0078AE  78001E     MOV [W14], W0
0078B0  9000BE     MOV [W14+6], W1
0078B2  980051     MOV W1, [W0+10]
96:                    pSld->hdr.right     = right;
0078B4  78001E     MOV [W14], W0
0078B6  9000CE     MOV [W14+8], W1
0078B8  980061     MOV W1, [W0+12]
97:                    pSld->hdr.bottom    = bottom;
0078BA  78001E     MOV [W14], W0
0078BC  9000DE     MOV [W14+10], W1
0078BE  980071     MOV W1, [W0+14]
98:                    pSld->hdr.state     = state;
0078C0  78001E     MOV [W14], W0
0078C2  9000EE     MOV [W14+12], W1
0078C4  980031     MOV W1, [W0+6]
99:                    pSld->hdr.DrawObj      = SldDraw;     				// draw function
0078C6  78001E     MOV [W14], W0
0078C8  27EC41     MOV #0x7EC4, W1
0078CA  980811     MOV W1, [W0+18]
100:                   pSld->hdr.MsgObj         = SldTranslateMsg;       	// message function
0078CC  78001E     MOV [W14], W0
0078CE  27DCE1     MOV #0x7DCE, W1
0078D0  980831     MOV W1, [W0+22]
101:                   pSld->hdr.MsgDefaultObj  = SldMsgDefault;  			// default message function
0078D2  78001E     MOV [W14], W0
0078D4  27C341     MOV #0x7C34, W1
0078D6  980841     MOV W1, [W0+24]
102:                   pSld->hdr.FreeObj  = NULL;  						// default free function
0078D8  78001E     MOV [W14], W0
0078DA  EB0080     CLR W1
0078DC  980821     MOV W1, [W0+20]
103:               
104:                   // Parameters in the user defined range system (pos, page and range)
105:                   pSld->range = range;                            // range of the slider movement (always measured from 0 to range)
0078DE  78001E     MOV [W14], W0
0078E0  9000FE     MOV [W14+14], W1
0078E2  980871     MOV W1, [W0+30]
106:               
107:                   // 0 refers to pSld->minPos and
108:                   // range refers to pSld->maxpos where: minPos and maxPos are
109:                   // the coordinate equivalent of 0 and range value
110:                   pSld->page = page;                              // set the resolution
0078E4  78001E     MOV [W14], W0
0078E6  90088E     MOV [W14+16], W1
0078E8  981011     MOV W1, [W0+34]
111:                   pSld->pos = pos;                                // set the initial position
0078EA  78001E     MOV [W14], W0
0078EC  97B8CE     MOV [W14-8], W1
0078EE  981001     MOV W1, [W0+32]
112:               
113:                   // calculate the thumb width and height
114:                   pSld->thWidth = SldGetWidth(pSld);
0078F0  78001E     MOV [W14], W0
0078F2  070032     RCALL SldGetWidth
0078F4  78009E     MOV [W14], W1
0078F6  9810A0     MOV W0, [W1+36]
115:                   pSld->thHeight = SldGetHeight(pSld);
0078F8  78001E     MOV [W14], W0
0078FA  070063     RCALL SldGetHeight
0078FC  78009E     MOV [W14], W1
0078FE  9810B0     MOV W0, [W1+38]
116:               
117:                   // Set the color scheme to be used
118:                   if(pScheme == NULL)
007900  97B83E     MOV [W14-10], W0
007902  500FE0     SUB W0, #0x0, [W15]
007904  3A0004     BRA NZ, 0x790E
119:                       pSld->hdr.pGolScheme = _pDefaultGolScheme;  // use default scheme
007906  808B41     MOV 0x1168, W1
007908  78001E     MOV [W14], W0
00790A  980801     MOV W1, [W0+16]
00790C  370003     BRA 0x7914
120:                   else
121:                       pSld->hdr.pGolScheme = (GOL_SCHEME *)pScheme;   // user defined scheme
00790E  78001E     MOV [W14], W0
007910  97B8BE     MOV [W14-10], W1
007912  980801     MOV W1, [W0+16]
122:               
123:                   GOLAddObject((OBJ_HEADER *)pSld);                   // add the new object to the current list
007914  78001E     MOV [W14], W0
007916  07067E     RCALL GOLAddObject
124:                   return (pSld);
007918  78001E     MOV [W14], W0
125:               }
00791A  FA8000     ULNK
00791C  060000     RETURN
126:               
127:               /*********************************************************************
128:               * Function: SHORT SldSetThumbSize(SLIDER *pSld, SHORT high, SHORT low)
129:               *
130:               * Notes: An INTERNAL function used to compute for the width or 
131:               *        height of the thumb. This function is created to save
132:               *        code size. This function is called only to dynamically
133:               *        compute for the thumb size. Used only when slider is 
134:               * 		 type Scrollbar. Parameter are defined as:
135:               *		 pSld - pointer to the object
136:               *        high - higher value to be used
137:               *        low  - lower value to be used
138:               *
139:               ********************************************************************/
140:               SHORT SldSetThumbSize(SLIDER *pSld, SHORT high, SHORT low)
141:               {
00791E  FA0008     LNK #0x8
007920  980710     MOV W0, [W14+2]
007922  980721     MOV W1, [W14+4]
007924  980732     MOV W2, [W14+6]
142:                   WORD    temp;
143:               
144:                   temp = (pSld->range / pSld->page);
007926  90001E     MOV [W14+2], W0
007928  9008F0     MOV [W0+30], W1
00792A  90001E     MOV [W14+2], W0
00792C  901010     MOV [W0+34], W0
00792E  780100     MOV W0, W2
007930  090011     REPEAT #0x11
007932  D88082     DIV.UW W1, W2
007934  780F00     MOV W0, [W14]
145:                   temp = (high - low) / temp;
007936  9000AE     MOV [W14+4], W1
007938  90003E     MOV [W14+6], W0
00793A  508000     SUB W1, W0, W0
00793C  780080     MOV W0, W1
00793E  78001E     MOV [W14], W0
007940  780100     MOV W0, W2
007942  090011     REPEAT #0x11
007944  D88082     DIV.UW W1, W2
007946  780F00     MOV W0, [W14]
146:               
147:                   // when size is less than half of emboss size, set the
148:                   // size to half the emboss size. This is to make sure
149:                   // thumb will always have a size.
150:                   if(temp < (GOL_EMBOSS_SIZE << 1))
007948  78001E     MOV [W14], W0
00794A  500FE5     SUB W0, #0x5, [W15]
00794C  3E0002     BRA GTU, 0x7952
151:                       temp = (GOL_EMBOSS_SIZE << 1);
00794E  200060     MOV #0x6, W0
007950  780F00     MOV W0, [W14]
152:               
153:                   return (SHORT) temp;
007952  78001E     MOV [W14], W0
154:               }
007954  FA8000     ULNK
007956  060000     RETURN
155:               
156:               /*********************************************************************
157:               * Function: WORD SldGetWidth(SLIDER *pSld)
158:               *
159:               * Notes: An INTERNAL function that computes for the width  
160:               *        of the thumb. This function is created to save
161:               *        code size. This function is called only to dynamically
162:               *        compute for the thumb size. 
163:               *
164:               ********************************************************************/
165:               WORD SldGetWidth(SLIDER *pSld)
166:               {
007958  FA0004     LNK #0x4
00795A  980710     MOV W0, [W14+2]
167:                   WORD    temp;
168:               
169:                   /*
170:               		Calculating the width is dependent on the mode type.
171:               		If type Scrollbar, width is dependent on the ratio of the
172:               		page/range = width/max-min (see SetThumbSize())
173:               		if type is Slider, width is dependent on height*3/8
174:               		
175:               		When horizontal width is dynamic, height is contant.
176:               	
177:               	*/
178:                   if(GetState(pSld, SLD_VERTICAL))
00795C  90001E     MOV [W14+2], W0
00795E  900030     MOV [W0+6], W0
007960  600064     AND W0, #0x4, W0
007962  500FE0     SUB W0, #0x0, [W15]
007964  320011     BRA Z, 0x7988
179:                   {
180:                       temp = pSld->hdr.right - pSld->hdr.left;
007966  90001E     MOV [W14+2], W0
007968  9000E0     MOV [W0+12], W1
00796A  90001E     MOV [W14+2], W0
00796C  900040     MOV [W0+8], W0
00796E  508000     SUB W1, W0, W0
007970  780F00     MOV W0, [W14]
181:                       if(GetState(pSld, SLD_SCROLLBAR))
007972  90001E     MOV [W14+2], W0
007974  900030     MOV [W0+6], W0
007976  600070     AND W0, #0x10, W0
007978  500FE0     SUB W0, #0x0, [W15]
00797A  320003     BRA Z, 0x7982
182:                       {
183:                           temp = temp - (GOL_EMBOSS_SIZE << 1);
00797C  78001E     MOV [W14], W0
00797E  500F66     SUB W0, #0x6, [W14]
007980  37001C     BRA 0x79BA
184:                       }
185:                       else
186:                       {
187:                           temp = temp - (GOL_EMBOSS_SIZE << 1) - 2;
007982  78001E     MOV [W14], W0
007984  500F68     SUB W0, #0x8, [W14]
007986  370019     BRA 0x79BA
188:                       }
189:                   }
190:                   else
191:                   {
192:                       if(GetState(pSld, SLD_SCROLLBAR))
007988  90001E     MOV [W14+2], W0
00798A  900030     MOV [W0+6], W0
00798C  600070     AND W0, #0x10, W0
00798E  500FE0     SUB W0, #0x0, [W15]
007990  32000A     BRA Z, 0x79A6
193:                       {
194:                           temp = SldSetThumbSize(pSld, pSld->hdr.right, pSld->hdr.left);
007992  90001E     MOV [W14+2], W0
007994  9000C0     MOV [W0+8], W1
007996  90001E     MOV [W14+2], W0
007998  900060     MOV [W0+12], W0
00799A  780101     MOV W1, W2
00799C  780080     MOV W0, W1
00799E  90001E     MOV [W14+2], W0
0079A0  07FFBE     RCALL SldSetThumbSize
0079A2  780F00     MOV W0, [W14]
0079A4  37000A     BRA 0x79BA
195:                       }
196:                       else
197:                       {
198:                           temp = (((pSld->hdr.bottom - pSld->hdr.top) - (GOL_EMBOSS_SIZE << 1) - 2) * 3) >> 3;
0079A6  90001E     MOV [W14+2], W0
0079A8  9000F0     MOV [W0+14], W1
0079AA  90001E     MOV [W14+2], W0
0079AC  900050     MOV [W0+10], W0
0079AE  508000     SUB W1, W0, W0
0079B0  B90063     MUL.SU W0, #3, W0
0079B2  780000     MOV W0, W0
0079B4  500078     SUB W0, #0x18, W0
0079B6  DE8043     ASR W0, #3, W0
0079B8  780F00     MOV W0, [W14]
199:                       }
200:                   }
201:               
202:                   // to avoid calculations of dividing by two, we store half the width value
203:                   return (temp >> 1);
0079BA  78001E     MOV [W14], W0
0079BC  D10000     LSR W0, W0
204:               }
0079BE  FA8000     ULNK
0079C0  060000     RETURN
205:               
206:               /*********************************************************************
207:               * Function: WORD SldGetHeight(SLIDER *pSld)
208:               *
209:               * Notes: An INTERNAL function that computes for the height  
210:               *        of the thumb. This function is created to save
211:               *        code size. This function is called only to dynamically
212:               *        compute for the thumb size.
213:               *
214:               ********************************************************************/
215:               WORD SldGetHeight(SLIDER *pSld)
216:               {
0079C2  FA0004     LNK #0x4
0079C4  980710     MOV W0, [W14+2]
217:                   WORD    temp;
218:               
219:                   /*
220:               		Calculating the height is dependent on the mode type.
221:               		If type Scrollbar, width is dependent on the ratio of the
222:               		page/range = width/max-min (see SetThumbSize())
223:               		if type is Slider, width is dependent on width*3/8
224:               	
225:               		When vertical height is dynamic, width is contant.
226:               	*/
227:                   if(GetState(pSld, SLD_VERTICAL))
0079C6  90001E     MOV [W14+2], W0
0079C8  900030     MOV [W0+6], W0
0079CA  600064     AND W0, #0x4, W0
0079CC  500FE0     SUB W0, #0x0, [W15]
0079CE  32001A     BRA Z, 0x7A04
228:                   {
229:                       if(GetState(pSld, SLD_SCROLLBAR))
0079D0  90001E     MOV [W14+2], W0
0079D2  900030     MOV [W0+6], W0
0079D4  600070     AND W0, #0x10, W0
0079D6  500FE0     SUB W0, #0x0, [W15]
0079D8  32000A     BRA Z, 0x79EE
230:                       {
231:                           temp = SldSetThumbSize(pSld, pSld->hdr.bottom, pSld->hdr.top);
0079DA  90001E     MOV [W14+2], W0
0079DC  9000D0     MOV [W0+10], W1
0079DE  90001E     MOV [W14+2], W0
0079E0  900070     MOV [W0+14], W0
0079E2  780101     MOV W1, W2
0079E4  780080     MOV W0, W1
0079E6  90001E     MOV [W14+2], W0
0079E8  07FF9A     RCALL SldSetThumbSize
0079EA  780F00     MOV W0, [W14]
0079EC  37001B     BRA 0x7A24
232:                       }
233:                       else
234:                       {
235:                           temp = (((pSld->hdr.right - pSld->hdr.left) - (GOL_EMBOSS_SIZE << 1) - 2) * 3) >> 3;
0079EE  90001E     MOV [W14+2], W0
0079F0  9000E0     MOV [W0+12], W1
0079F2  90001E     MOV [W14+2], W0
0079F4  900040     MOV [W0+8], W0
0079F6  508000     SUB W1, W0, W0
0079F8  B90063     MUL.SU W0, #3, W0
0079FA  780000     MOV W0, W0
0079FC  500078     SUB W0, #0x18, W0
0079FE  DE8043     ASR W0, #3, W0
007A00  780F00     MOV W0, [W14]
007A02  370010     BRA 0x7A24
236:                       }
237:                   }
238:                   else
239:                   {
240:                       temp = pSld->hdr.bottom - pSld->hdr.top;
007A04  90001E     MOV [W14+2], W0
007A06  9000F0     MOV [W0+14], W1
007A08  90001E     MOV [W14+2], W0
007A0A  900050     MOV [W0+10], W0
007A0C  508000     SUB W1, W0, W0
007A0E  780F00     MOV W0, [W14]
241:                       if(GetState(pSld, SLD_SCROLLBAR))
007A10  90001E     MOV [W14+2], W0
007A12  900030     MOV [W0+6], W0
007A14  600070     AND W0, #0x10, W0
007A16  500FE0     SUB W0, #0x0, [W15]
007A18  320003     BRA Z, 0x7A20
242:                       {
243:                           temp = temp - (GOL_EMBOSS_SIZE << 1);
007A1A  78001E     MOV [W14], W0
007A1C  500F66     SUB W0, #0x6, [W14]
007A1E  370002     BRA 0x7A24
244:                       }
245:                       else
246:                       {
247:                           temp = temp - (GOL_EMBOSS_SIZE << 1) - 2;
007A20  78001E     MOV [W14], W0
007A22  500F68     SUB W0, #0x8, [W14]
248:                       }
249:                   }
250:               
251:                   // to avoid calculations of dividing by two, we store half the height value
252:                   return (temp >> 1);
007A24  78001E     MOV [W14], W0
007A26  D10000     LSR W0, W0
253:               }
007A28  FA8000     ULNK
007A2A  060000     RETURN
254:               
255:               /*********************************************************************
256:               * Function: void SldGetMinMaxPos(SLIDER *pSld, WORD *min, WORD *max)
257:               *
258:               * Notes:  An INTERNAL function that computes for the minimum
259:               *         and maximum pixel position in the screen. This function is 
260:               *         created to save code size. Used to define the minimum 
261:               *         & maximum position of the thumb when sliding. Parameters
262:               *		  used are defined as:
263:               *		  pSld - pointer to the object
264:               *         min  - pointer to the minimum variable
265:               *         max  - pointer to the maximum variable
266:               *
267:               ********************************************************************/
268:               void SldGetMinMaxPos(SLIDER *pSld, WORD *min, WORD *max)
269:               {
007A2C  FA0008     LNK #0x8
007A2E  980710     MOV W0, [W14+2]
007A30  980721     MOV W1, [W14+4]
007A32  980732     MOV W2, [W14+6]
270:                   WORD    temp;
271:               
272:                   // calculate maximum and minimum position	
273:                   if(GetState(pSld, SLD_VERTICAL))
007A34  90001E     MOV [W14+2], W0
007A36  900030     MOV [W0+6], W0
007A38  600064     AND W0, #0x4, W0
007A3A  500FE0     SUB W0, #0x0, [W15]
007A3C  32000E     BRA Z, 0x7A5A
274:                   {
275:                       temp = pSld->thHeight + GOL_EMBOSS_SIZE;
007A3E  90001E     MOV [W14+2], W0
007A40  901030     MOV [W0+38], W0
007A42  400F63     ADD W0, #0x3, [W14]
276:                       *min = pSld->hdr.top + temp;
007A44  90001E     MOV [W14+2], W0
007A46  900050     MOV [W0+10], W0
007A48  40009E     ADD W0, [W14], W1
007A4A  90002E     MOV [W14+4], W0
007A4C  780801     MOV W1, [W0]
277:                       *max = pSld->hdr.bottom - temp;
007A4E  90001E     MOV [W14+2], W0
007A50  900070     MOV [W0+14], W0
007A52  50009E     SUB W0, [W14], W1
007A54  90003E     MOV [W14+6], W0
007A56  780801     MOV W1, [W0]
007A58  37000D     BRA 0x7A74
278:                   }
279:                   else
280:                   {
281:                       temp = pSld->thWidth + GOL_EMBOSS_SIZE;
007A5A  90001E     MOV [W14+2], W0
007A5C  901020     MOV [W0+36], W0
007A5E  400F63     ADD W0, #0x3, [W14]
282:                       *min = pSld->hdr.left + temp;
007A60  90001E     MOV [W14+2], W0
007A62  900040     MOV [W0+8], W0
007A64  40009E     ADD W0, [W14], W1
007A66  90002E     MOV [W14+4], W0
007A68  780801     MOV W1, [W0]
283:                       *max = pSld->hdr.right - temp;
007A6A  90001E     MOV [W14+2], W0
007A6C  900060     MOV [W0+12], W0
007A6E  50009E     SUB W0, [W14], W1
007A70  90003E     MOV [W14+6], W0
007A72  780801     MOV W1, [W0]
284:                   }
285:               
286:                   // for aestetics.
287:                   if(!GetState(pSld, SLD_SCROLLBAR))
007A74  90001E     MOV [W14+2], W0
007A76  900030     MOV [W0+6], W0
007A78  600070     AND W0, #0x10, W0
007A7A  500FE0     SUB W0, #0x0, [W15]
007A7C  3A000A     BRA NZ, 0x7A92
288:                   {
289:                       *min = *min + 2;
007A7E  90002E     MOV [W14+4], W0
007A80  780010     MOV [W0], W0
007A82  E88080     INC2 W0, W1
007A84  90002E     MOV [W14+4], W0
007A86  780801     MOV W1, [W0]
290:                       *max = *max - 2;
007A88  90003E     MOV [W14+6], W0
007A8A  780010     MOV [W0], W0
007A8C  E98080     DEC2 W0, W1
007A8E  90003E     MOV [W14+6], W0
007A90  780801     MOV W1, [W0]
291:                   }
292:               }
007A92  FA8000     ULNK
007A94  060000     RETURN
293:               
294:               /*********************************************************************
295:               * Function: void SldSetRange(SLIDER *pSld, SHORT newRange)
296:               *
297:               * Notes:  Sets the new range value of the slider or scrollbar.
298:               *         Object must be redrawn after this function is called to 
299:               *         reflect the changes to the object.
300:               *
301:               ********************************************************************/
302:               void SldSetRange(SLIDER *pSld, SHORT newRange)
303:               {
007A96  FA000A     LNK #0xA
007A98  980730     MOV W0, [W14+6]
007A9A  980741     MOV W1, [W14+8]
304:                   WORD        newPos;
305:                   DWORD_VAL   dTemp;
306:               
307:                   // this checks for limits of the range (minimum is 2)
308:                   if(newRange <= 2)
007A9C  90004E     MOV [W14+8], W0
007A9E  500FE2     SUB W0, #0x2, [W15]
007AA0  3C0002     BRA GT, 0x7AA6
309:                       newRange = 2;
007AA2  200020     MOV #0x2, W0
007AA4  980740     MOV W0, [W14+8]
310:               
311:                   if((WORD) newRange > (WORD) 0x7FFF)
007AA6  90004E     MOV [W14+8], W0
007AA8  500FE0     SUB W0, #0x0, [W15]
007AAA  3D0002     BRA GE, 0x7AB0
312:                       newRange = 0x7FFF;
007AAC  27FFF0     MOV #0x7FFF, W0
007AAE  980740     MOV W0, [W14+8]
313:               
314:                   dTemp.Val = newRange * pSld->pos;
007AB0  90003E     MOV [W14+6], W0
007AB2  901080     MOV [W0+32], W1
007AB4  90004E     MOV [W14+8], W0
007AB6  B98800     MUL.SS W1, W0, W0
007AB8  780000     MOV W0, W0
007ABA  200001     MOV #0x0, W1
007ABC  980710     MOV W0, [W14+2]
007ABE  980721     MOV W1, [W14+4]
315:                   dTemp.Val = dTemp.Val / pSld->range;
007AC0  90021E     MOV [W14+2], W4
007AC2  9002AE     MOV [W14+4], W5
007AC4  90003E     MOV [W14+6], W0
007AC6  900870     MOV [W0+30], W0
007AC8  200001     MOV #0x0, W1
007ACA  BE0100     MOV.D W0, W2
007ACC  BE0004     MOV.D W4, W0
007ACE  07D0C5     RCALL ___udivsi3
007AD0  980710     MOV W0, [W14+2]
007AD2  980721     MOV W1, [W14+4]
316:               
317:                   // get new range
318:                   newPos = dTemp.w[0];
007AD4  90001E     MOV [W14+2], W0
007AD6  780F00     MOV W0, [W14]
319:               
320:                   // set the new range
321:                   pSld->range = newRange;
007AD8  9000CE     MOV [W14+8], W1
007ADA  90003E     MOV [W14+6], W0
007ADC  980871     MOV W1, [W0+30]
322:               
323:                   // now check the page, adjust when necessary
324:                   // page maximum limit is range/2, minimum is 1
325:                   if(pSld->page > ((pSld->range) >> 1))
007ADE  90003E     MOV [W14+6], W0
007AE0  901090     MOV [W0+34], W1
007AE2  90003E     MOV [W14+6], W0
007AE4  900870     MOV [W0+30], W0
007AE6  D10000     LSR W0, W0
007AE8  508F80     SUB W1, W0, [W15]
007AEA  36000E     BRA LEU, 0x7B08
326:                   {
327:                       if(!((pSld->range) >> 1))
007AEC  90003E     MOV [W14+6], W0
007AEE  900870     MOV [W0+30], W0
007AF0  D10000     LSR W0, W0
007AF2  500FE0     SUB W0, #0x0, [W15]
007AF4  3A0004     BRA NZ, 0x7AFE
328:                           pSld->page = 1;
007AF6  90003E     MOV [W14+6], W0
007AF8  200011     MOV #0x1, W1
007AFA  981011     MOV W1, [W0+34]
007AFC  370005     BRA 0x7B08
329:                       else
330:                           pSld->page = (pSld->range) >> 1;
007AFE  90003E     MOV [W14+6], W0
007B00  900870     MOV [W0+30], W0
007B02  D10080     LSR W0, W1
007B04  90003E     MOV [W14+6], W0
007B06  981011     MOV W1, [W0+34]
331:                   }
332:               
333:                   // calculate new thumb width and height
334:                   pSld->thWidth = SldGetWidth(pSld);
007B08  90003E     MOV [W14+6], W0
007B0A  07FF26     RCALL SldGetWidth
007B0C  9000BE     MOV [W14+6], W1
007B0E  9810A0     MOV W0, [W1+36]
335:                   pSld->thHeight = SldGetHeight(pSld);
007B10  90003E     MOV [W14+6], W0
007B12  07FF57     RCALL SldGetHeight
007B14  9000BE     MOV [W14+6], W1
007B16  9810B0     MOV W0, [W1+38]
336:                   SldSetPos(pSld, newPos);
007B18  78001E     MOV [W14], W0
007B1A  780080     MOV W0, W1
007B1C  90003E     MOV [W14+6], W0
007B1E  070022     RCALL SldSetPos
337:               }
007B20  FA8000     ULNK
007B22  060000     RETURN
338:               
339:               /*********************************************************************
340:               * Function: void SldSetPage(SLIDER *pSld, WORD newPage) 
341:               *
342:               * Notes: Sets the new page value of the slider or scrollbar.
343:               *        The page maximum limit is range/2, minimum is 1
344:               *
345:               ********************************************************************/
346:               void SldSetPage(SLIDER *pSld, WORD newPage)
347:               {
007B24  FA0004     LNK #0x4
007B26  780F00     MOV W0, [W14]
007B28  980711     MOV W1, [W14+2]
348:                   if(newPage < 1)
007B2A  90001E     MOV [W14+2], W0
007B2C  500FE0     SUB W0, #0x0, [W15]
007B2E  3A0003     BRA NZ, 0x7B36
349:                       newPage = 1;
007B30  200010     MOV #0x1, W0
007B32  980710     MOV W0, [W14+2]
007B34  37000A     BRA 0x7B4A
350:                   else if(newPage > ((pSld->range) >> 1))
007B36  78001E     MOV [W14], W0
007B38  900870     MOV [W0+30], W0
007B3A  D10080     LSR W0, W1
007B3C  90001E     MOV [W14+2], W0
007B3E  508F80     SUB W1, W0, [W15]
007B40  310004     BRA C, 0x7B4A
351:                       newPage = (pSld->range) >> 1;
007B42  78001E     MOV [W14], W0
007B44  900870     MOV [W0+30], W0
007B46  D10000     LSR W0, W0
007B48  980710     MOV W0, [W14+2]
352:                   pSld->page = newPage;
007B4A  78001E     MOV [W14], W0
007B4C  90009E     MOV [W14+2], W1
007B4E  981011     MOV W1, [W0+34]
353:               
354:                   // calculate new thumb width and height
355:                   pSld->thWidth = SldGetWidth(pSld);
007B50  78001E     MOV [W14], W0
007B52  07FF02     RCALL SldGetWidth
007B54  78009E     MOV [W14], W1
007B56  9810A0     MOV W0, [W1+36]
356:                   pSld->thHeight = SldGetHeight(pSld);
007B58  78001E     MOV [W14], W0
007B5A  07FF33     RCALL SldGetHeight
007B5C  78009E     MOV [W14], W1
007B5E  9810B0     MOV W0, [W1+38]
357:               }
007B60  FA8000     ULNK
007B62  060000     RETURN
358:               
359:               /*********************************************************************
360:               * Function: SldSetPos(SLIDER *pSld, SHORT newPos)
361:               *
362:               * Notes: Sets the thumb to the new position. Checking is first 
363:               *        preformed if the new position is within the range (0 to range)
364:               *        of the slider. Object must be redrawn after this function is called to 
365:               *        reflect the changes to the object.
366:               *
367:               ********************************************************************/
368:               void SldSetPos(SLIDER *pSld, SHORT newPos)
369:               {
007B64  FA000E     LNK #0xE
007B66  980750     MOV W0, [W14+10]
007B68  980761     MOV W1, [W14+12]
370:                   WORD        minPos, maxPos, relPos;
371:                   DWORD_VAL   dTemp;
372:               
373:                   // get minimum and maximum positions
374:                   SldGetMinMaxPos(pSld, &minPos, &maxPos);
007B6A  4700E4     ADD W14, #0x4, W1
007B6C  E8800E     INC2 W14, W0
007B6E  780101     MOV W1, W2
007B70  780080     MOV W0, W1
007B72  90005E     MOV [W14+10], W0
007B74  07FF5B     RCALL SldGetMinMaxPos
375:                   dTemp.Val = 0;
007B76  B80060     MUL.UU W0, #0, W0
007B78  980730     MOV W0, [W14+6]
007B7A  980741     MOV W1, [W14+8]
376:               
377:                       #ifndef SLD_INVERT_VERTICAL
378:               
379:                   // check if the new value is still in range
380:                   if(newPos <= 0)
007B7C  90006E     MOV [W14+12], W0
007B7E  500FE0     SUB W0, #0x0, [W15]
007B80  3C0010     BRA GT, 0x7BA2
381:                   {
382:                       pSld->pos = 0;                                  // set to zero in range domain
007B82  90005E     MOV [W14+10], W0
007B84  EB0080     CLR W1
007B86  981001     MOV W1, [W0+32]
383:                       if(GetState(pSld, SLD_VERTICAL))
007B88  90005E     MOV [W14+10], W0
007B8A  900030     MOV [W0+6], W0
007B8C  600064     AND W0, #0x4, W0
007B8E  500FE0     SUB W0, #0x0, [W15]
007B90  320004     BRA Z, 0x7B9A
384:                       {                                               // min and max in vertical is inverted
385:                           pSld->currPos = maxPos;                     // minimum position is the bottom position in
007B92  9000AE     MOV [W14+4], W1
007B94  90005E     MOV [W14+10], W0
007B96  980851     MOV W1, [W0+26]
007B98  37004B     BRA 0x7C30
386:                       }                                               // coordinate domain
387:                       else
388:                           pSld->currPos = minPos;                     // minimum is left most position in coordinate domain
007B9A  90009E     MOV [W14+2], W1
007B9C  90005E     MOV [W14+10], W0
007B9E  980851     MOV W1, [W0+26]
007BA0  370047     BRA 0x7C30
389:                   }
390:                   else if(newPos >= pSld->range)
007BA2  9000EE     MOV [W14+12], W1
007BA4  90005E     MOV [W14+10], W0
007BA6  900870     MOV [W0+30], W0
007BA8  508F80     SUB W1, W0, [W15]
007BAA  390011     BRA NC, 0x7BCE
391:                   {
392:                       pSld->pos = pSld->range;                        // set to maximum value in range domain
007BAC  90005E     MOV [W14+10], W0
007BAE  9008F0     MOV [W0+30], W1
007BB0  90005E     MOV [W14+10], W0
007BB2  981001     MOV W1, [W0+32]
393:                       if(GetState(pSld, SLD_VERTICAL))
007BB4  90005E     MOV [W14+10], W0
007BB6  900030     MOV [W0+6], W0
007BB8  600064     AND W0, #0x4, W0
007BBA  500FE0     SUB W0, #0x0, [W15]
007BBC  320004     BRA Z, 0x7BC6
394:                       {                                               // min and max in vertical is inverted
395:                           pSld->currPos = minPos;                     // maximum position is the top position in
007BBE  90009E     MOV [W14+2], W1
007BC0  90005E     MOV [W14+10], W0
007BC2  980851     MOV W1, [W0+26]
007BC4  370035     BRA 0x7C30
396:                       }                                               // coordinate domain
397:                       else
398:                           pSld->currPos = maxPos;                     // maximum is right most position in coordinate domain
007BC6  9000AE     MOV [W14+4], W1
007BC8  90005E     MOV [W14+10], W0
007BCA  980851     MOV W1, [W0+26]
007BCC  370031     BRA 0x7C30
399:                   }
400:                   else
401:                   {
402:                       pSld->pos = newPos;                             // get new position in range domain
007BCE  9000EE     MOV [W14+12], W1
007BD0  90005E     MOV [W14+10], W0
007BD2  981001     MOV W1, [W0+32]
403:                       dTemp.w[1] = newPos;
007BD4  90006E     MOV [W14+12], W0
007BD6  980740     MOV W0, [W14+8]
404:                       dTemp.Val = dTemp.Val / pSld->range;
007BD8  90023E     MOV [W14+6], W4
007BDA  9002CE     MOV [W14+8], W5
007BDC  90005E     MOV [W14+10], W0
007BDE  900870     MOV [W0+30], W0
007BE0  200001     MOV #0x0, W1
007BE2  BE0100     MOV.D W0, W2
007BE4  BE0004     MOV.D W4, W0
007BE6  07D039     RCALL ___udivsi3
007BE8  980730     MOV W0, [W14+6]
007BEA  980741     MOV W1, [W14+8]
405:                       dTemp.Val = (maxPos - minPos) * dTemp.Val;
007BEC  9000AE     MOV [W14+4], W1
007BEE  90001E     MOV [W14+2], W0
007BF0  508000     SUB W1, W0, W0
007BF2  B80161     MUL.UU W0, #1, W2
007BF4  90003E     MOV [W14+6], W0
007BF6  9000CE     MOV [W14+8], W1
007BF8  B99A00     MUL.SS W3, W0, W4
007BFA  780204     MOV W4, W4
007BFC  B98B02     MUL.SS W1, W2, W6
007BFE  780286     MOV W6, W5
007C00  420205     ADD W4, W5, W4
007C02  B81000     MUL.UU W2, W0, W0
007C04  420201     ADD W4, W1, W4
007C06  780084     MOV W4, W1
007C08  980730     MOV W0, [W14+6]
007C0A  980741     MOV W1, [W14+8]
406:               
407:                       // set current position in coordinate domain
408:                       relPos = dTemp.w[1] + minPos;
007C0C  9000CE     MOV [W14+8], W1
007C0E  90001E     MOV [W14+2], W0
007C10  408F00     ADD W1, W0, [W14]
409:               
410:                       if(GetState(pSld, SLD_VERTICAL))
007C12  90005E     MOV [W14+10], W0
007C14  900030     MOV [W0+6], W0
007C16  600064     AND W0, #0x4, W0
007C18  500FE0     SUB W0, #0x0, [W15]
007C1A  320007     BRA Z, 0x7C2A
411:                       {                                               // test if we need to transform min and max position
412:                           pSld->currPos = maxPos - (relPos - minPos); // min and max position is swapped in coordinate domain
007C1C  90001E     MOV [W14+2], W0
007C1E  50009E     SUB W0, [W14], W1
007C20  90002E     MOV [W14+4], W0
007C22  408080     ADD W1, W0, W1
007C24  90005E     MOV [W14+10], W0
007C26  980851     MOV W1, [W0+26]
007C28  370003     BRA 0x7C30
413:                       }
414:                       else
415:                           pSld->currPos = relPos;                     // use position
007C2A  90005E     MOV [W14+10], W0
007C2C  78009E     MOV [W14], W1
007C2E  980851     MOV W1, [W0+26]
416:                   }
417:               
418:                       #else
419:               
420:                   // check if the new value is still in range
421:                   if(newPos <= 0)
422:                   {
423:                       pSld->pos = 0;              // set to zero in range domain
424:                       pSld->currPos = minPos;     // set to minimum in coordinate domain
425:                   }
426:                   else if(newPos >= pSld->range)
427:                   {
428:                       pSld->pos = pSld->range;    // set to maximum value in range domain
429:                       pSld->currPos = maxPos;     // set to minimum in coordinate domain
430:                   }
431:                   else
432:                   {
433:                       pSld->pos = newPos;         // get new position in range domain
434:                       dTemp.w[1] = newPos;
435:                       dTemp.Val = dTemp.Val / pSld->range;
436:                       dTemp.Val = (maxPos - minPos) * dTemp.Val;
437:               
438:                       // set current position in coordinate domain
439:                       pSld->currPos = dTemp.w[1] + minPos;
440:                   }
441:               
442:                       #endif // ifndef SLD_INVERT_VERTICAL
443:               }
007C30  FA8000     ULNK
007C32  060000     RETURN
444:               
445:               /*********************************************************************
446:               * Function: void SldMsgDefault(WORD translatedMsg, void *pObj, 
447:               *							   GOL_MSG* pMsg)
448:               *
449:               * Notes: This the default operation to change the state of the button.
450:               *		 Called inside GOLMsg() when GOLMsgCallback() returns a 1.
451:               *
452:               ********************************************************************/
453:               void SldMsgDefault(WORD translatedMsg, void *pObj, GOL_MSG *pMsg)
454:               {
007C34  FA0012     LNK #0x12
007C36  980760     MOV W0, [W14+12]
007C38  980771     MOV W1, [W14+14]
007C3A  980F02     MOV W2, [W14+16]
455:                   SLIDER *pSld;
456:               
457:                   pSld = (SLIDER *)pObj;
007C3C  90007E     MOV [W14+14], W0
007C3E  980710     MOV W0, [W14+2]
458:               
459:                       #ifdef USE_TOUCHSCREEN
460:               
461:                   WORD        newPos, minPos, maxPos;
462:                   DWORD_VAL   dTemp;
463:               
464:                           #ifdef USE_FOCUS
465:                   if(pMsg->type == TYPE_TOUCHSCREEN)
007C40  90080E     MOV [W14+16], W0
007C42  784010     MOV.B [W0], W0
007C44  504FE2     SUB.B W0, #0x2, [W15]
007C46  3A0007     BRA NZ, 0x7C56
466:                   {
467:                       if(!GetState(pSld, SLD_FOCUSED))
007C48  90001E     MOV [W14+2], W0
007C4A  900030     MOV [W0+6], W0
007C4C  600061     AND W0, #0x1, W0
007C4E  500FE0     SUB W0, #0x0, [W15]
007C50  3A0002     BRA NZ, 0x7C56
468:                       {
469:                           GOLSetFocus((OBJ_HEADER *)pSld);
007C52  90001E     MOV [W14+2], W0
007C54  07040E     RCALL GOLSetFocus
470:                       }
471:                   }
472:               
473:                           #endif // USE_FOCUS
474:               
475:               	// if message was passive do not do anything
476:               	if (translatedMsg == OBJ_MSG_PASSIVE)
007C56  9000EE     MOV [W14+12], W1
007C58  2002A0     MOV #0x2A, W0
007C5A  508F80     SUB W1, W0, [W15]
007C5C  3200B1     BRA Z, 0x7DC0
477:               		return;
007DC0  000000     NOP
007DC2  370003     BRA 0x7DCA
478:               		
479:                   // get the min and max positions
480:                   SldGetMinMaxPos(pSld, &minPos, &maxPos);
007C5E  4700E6     ADD W14, #0x6, W1
007C60  470064     ADD W14, #0x4, W0
007C62  780101     MOV W1, W2
007C64  780080     MOV W0, W1
007C66  90001E     MOV [W14+2], W0
007C68  07FEE1     RCALL SldGetMinMaxPos
481:               
482:                   if(pMsg->type == TYPE_TOUCHSCREEN)
007C6A  90080E     MOV [W14+16], W0
007C6C  784010     MOV.B [W0], W0
007C6E  504FE2     SUB.B W0, #0x2, [W15]
007C70  3A006A     BRA NZ, 0x7D46
483:                   {
484:                       if((translatedMsg == SLD_MSG_DEC) || (translatedMsg == SLD_MSG_INC))
007C72  90006E     MOV [W14+12], W0
007C74  500FEE     SUB W0, #0xE, [W15]
007C76  320003     BRA Z, 0x7C7E
007C78  90006E     MOV [W14+12], W0
007C7A  500FED     SUB W0, #0xD, [W15]
007C7C  3A00A3     BRA NZ, 0x7DC4
485:                       {
486:               
487:                           // newPos in this context is used in the coordinate domain
488:                           if(!GetState(pSld, SLD_VERTICAL))
007C7E  90001E     MOV [W14+2], W0
007C80  900030     MOV [W0+6], W0
007C82  600064     AND W0, #0x4, W0
007C84  500FE0     SUB W0, #0x0, [W15]
007C86  3A0016     BRA NZ, 0x7CB4
489:                           {                               // check if Horizontal or Vertical orientation
490:                               if(pMsg->param1 <= minPos)
007C88  90080E     MOV [W14+16], W0
007C8A  900010     MOV [W0+2], W0
007C8C  780080     MOV W0, W1
007C8E  90002E     MOV [W14+4], W0
007C90  508F80     SUB W1, W0, [W15]
007C92  3E0003     BRA GTU, 0x7C9A
491:                               {                           // Horizontal orientation: test x position	
492:                                   newPos = minPos;        // beyond minimum, use min position
007C94  90002E     MOV [W14+4], W0
007C96  780F00     MOV W0, [W14]
007C98  370022     BRA 0x7CDE
493:                               }
494:                               else if(pMsg->param1 >= maxPos)
007C9A  90080E     MOV [W14+16], W0
007C9C  900010     MOV [W0+2], W0
007C9E  780080     MOV W0, W1
007CA0  90003E     MOV [W14+6], W0
007CA2  508F80     SUB W1, W0, [W15]
007CA4  390003     BRA NC, 0x7CAC
495:                               {
496:                                   newPos = maxPos;        // beyond maximum, use max position
007CA6  90003E     MOV [W14+6], W0
007CA8  780F00     MOV W0, [W14]
007CAA  370019     BRA 0x7CDE
497:                               }
498:                               else
499:                               {
500:                                   newPos = pMsg->param1;  // within range: use x position given
007CAC  90080E     MOV [W14+16], W0
007CAE  900010     MOV [W0+2], W0
007CB0  780F00     MOV W0, [W14]
007CB2  370015     BRA 0x7CDE
501:                               }
502:                           }
503:                           else
504:                           {
505:                               if(pMsg->param2 <= minPos)
007CB4  90080E     MOV [W14+16], W0
007CB6  900020     MOV [W0+4], W0
007CB8  780080     MOV W0, W1
007CBA  90002E     MOV [W14+4], W0
007CBC  508F80     SUB W1, W0, [W15]
007CBE  3E0003     BRA GTU, 0x7CC6
506:                               {                           // Vertical orientation: test y position
507:                                   newPos = minPos;        // beyond minimum, use min position
007CC0  90002E     MOV [W14+4], W0
007CC2  780F00     MOV W0, [W14]
007CC4  37000C     BRA 0x7CDE
508:                               }
509:                               else if(pMsg->param2 >= maxPos)
007CC6  90080E     MOV [W14+16], W0
007CC8  900020     MOV [W0+4], W0
007CCA  780080     MOV W0, W1
007CCC  90003E     MOV [W14+6], W0
007CCE  508F80     SUB W1, W0, [W15]
007CD0  390003     BRA NC, 0x7CD8
510:                               {
511:                                   newPos = maxPos;        // beyond maximum, use max position
007CD2  90003E     MOV [W14+6], W0
007CD4  780F00     MOV W0, [W14]
007CD6  370003     BRA 0x7CDE
512:                               }
513:                               else
514:                               {
515:                                   newPos = pMsg->param2;  // within range: use y position given
007CD8  90080E     MOV [W14+16], W0
007CDA  900020     MOV [W0+4], W0
007CDC  780F00     MOV W0, [W14]
516:                               }
517:                           }
518:               
519:                           if(newPos != pSld->currPos)
007CDE  90001E     MOV [W14+2], W0
007CE0  900850     MOV [W0+26], W0
007CE2  500F9E     SUB W0, [W14], [W15]
007CE4  320071     BRA Z, 0x7DC8
007D44  000000     NOP
520:                           {                               // check if we need to redraw thumb
521:                               // yes redraw is needed, translate newPos into range domain
522:                               // first get new position in range domain
523:                               dTemp.Val = (DWORD) (newPos - minPos) * (DWORD) pSld->range;
007CE6  90002E     MOV [W14+4], W0
007CE8  10001E     SUBR W0, [W14], W0
007CEA  B80161     MUL.UU W0, #1, W2
007CEC  90001E     MOV [W14+2], W0
007CEE  900870     MOV [W0+30], W0
007CF0  200001     MOV #0x0, W1
007CF2  B99A00     MUL.SS W3, W0, W4
007CF4  780204     MOV W4, W4
007CF6  B98B02     MUL.SS W1, W2, W6
007CF8  780286     MOV W6, W5
007CFA  420205     ADD W4, W5, W4
007CFC  B81000     MUL.UU W2, W0, W0
007CFE  420201     ADD W4, W1, W4
007D00  780084     MOV W4, W1
007D02  980740     MOV W0, [W14+8]
007D04  980751     MOV W1, [W14+10]
524:                               dTemp.Val = dTemp.Val / (maxPos - minPos);
007D06  90024E     MOV [W14+8], W4
007D08  9002DE     MOV [W14+10], W5
007D0A  9000BE     MOV [W14+6], W1
007D0C  90002E     MOV [W14+4], W0
007D0E  508000     SUB W1, W0, W0
007D10  200001     MOV #0x0, W1
007D12  BE0100     MOV.D W0, W2
007D14  BE0004     MOV.D W4, W0
007D16  07CFA1     RCALL ___udivsi3
007D18  980740     MOV W0, [W14+8]
007D1A  980751     MOV W1, [W14+10]
525:                               newPos = dTemp.w[0];
007D1C  90004E     MOV [W14+8], W0
007D1E  780F00     MOV W0, [W14]
526:               
527:                                       #ifndef SLD_INVERT_VERTICAL
528:                               if(GetState(pSld, SLD_VERTICAL))
007D20  90001E     MOV [W14+2], W0
007D22  900030     MOV [W0+6], W0
007D24  600064     AND W0, #0x4, W0
007D26  500FE0     SUB W0, #0x0, [W15]
007D28  320003     BRA Z, 0x7D30
529:                               {                           // check if we need to swap min and max in vertical
530:                                   newPos = pSld->range - newPos;  // min and max is swapped in vertical orientation
007D2A  90001E     MOV [W14+2], W0
007D2C  900870     MOV [W0+30], W0
007D2E  500F1E     SUB W0, [W14], [W14]
531:                               }
532:               
533:                                       #endif
534:                               SldSetPos(pSld, newPos);            // set to new position	
007D30  78001E     MOV [W14], W0
007D32  780080     MOV W0, W1
007D34  90001E     MOV [W14+2], W0
007D36  07FF16     RCALL SldSetPos
535:                               SetState(pSld, SLD_DRAW_THUMB);     // redraw the thumb only
007D38  90001E     MOV [W14+2], W0
007D3A  90009E     MOV [W14+2], W1
007D3C  900131     MOV [W1+6], W2
007D3E  210001     MOV #0x1000, W1
007D40  710081     IOR W2, W1, W1
007D42  980031     MOV W1, [W0+6]
536:                           }
537:                           else
538:                               return;
007DC8  000000     NOP
539:                       }
540:                       else
541:                           return;
007DC4  000000     NOP
007DC6  370001     BRA 0x7DCA
542:                   }
543:               
544:                       #endif // USE_TOUCHSCREEN
545:                       #ifdef USE_KEYBOARD
546:                   if(pMsg->type == TYPE_KEYBOARD)
007D46  90080E     MOV [W14+16], W0
007D48  784010     MOV.B [W0], W0
007D4A  504FE1     SUB.B W0, #0x1, [W15]
007D4C  3A003E     BRA NZ, 0x7DCA
547:                   {                           // for keyboard
548:                       if(translatedMsg == SLD_MSG_INC)
007D4E  90006E     MOV [W14+12], W0
007D50  500FED     SUB W0, #0xD, [W15]
007D52  3A001A     BRA NZ, 0x7D88
549:                       {
550:                           SldIncPos(pSld);    // increment is requested
007D54  90001E     MOV [W14+2], W0
007D56  901000     MOV [W0+32], W0
007D58  B80161     MUL.UU W0, #1, W2
007D5A  90001E     MOV [W14+2], W0
007D5C  901010     MOV [W0+34], W0
007D5E  200001     MOV #0x0, W1
007D60  400102     ADD W0, W2, W2
007D62  488183     ADDC W1, W3, W3
007D64  90001E     MOV [W14+2], W0
007D66  900870     MOV [W0+30], W0
007D68  200001     MOV #0x0, W1
007D6A  510F80     SUB W2, W0, [W15]
007D6C  598F81     SUBB W3, W1, [W15]
007D6E  3E0006     BRA GTU, 0x7D7C
007D70  90001E     MOV [W14+2], W0
007D72  901080     MOV [W0+32], W1
007D74  90001E     MOV [W14+2], W0
007D76  901010     MOV [W0+34], W0
007D78  408000     ADD W1, W0, W0
007D7A  370002     BRA 0x7D80
007D7C  90001E     MOV [W14+2], W0
007D7E  900870     MOV [W0+30], W0
007D80  780080     MOV W0, W1
007D82  90001E     MOV [W14+2], W0
007D84  07FEEF     RCALL SldSetPos
007D86  370015     BRA 0x7DB2
551:                       }
552:                       else
553:                       {
554:                           SldDecPos(pSld);    // decrement is requested
007D88  90001E     MOV [W14+2], W0
007D8A  901000     MOV [W0+32], W0
007D8C  B80161     MUL.UU W0, #1, W2
007D8E  90001E     MOV [W14+2], W0
007D90  901010     MOV [W0+34], W0
007D92  200001     MOV #0x0, W1
007D94  510000     SUB W2, W0, W0
007D96  598081     SUBB W3, W1, W1
007D98  500FE0     SUB W0, #0x0, [W15]
007D9A  588FE0     SUBB W1, #0x0, [W15]
007D9C  350006     BRA LT, 0x7DAA
007D9E  90001E     MOV [W14+2], W0
007DA0  901080     MOV [W0+32], W1
007DA2  90001E     MOV [W14+2], W0
007DA4  901010     MOV [W0+34], W0
007DA6  508000     SUB W1, W0, W0
007DA8  370001     BRA 0x7DAC
007DAA  EB0000     CLR W0
007DAC  780080     MOV W0, W1
007DAE  90001E     MOV [W14+2], W0
007DB0  07FED9     RCALL SldSetPos
555:                       }
556:               
557:                       SetState(pSld, SLD_DRAW_THUMB); // redraw the thumb only
007DB2  90001E     MOV [W14+2], W0
007DB4  90009E     MOV [W14+2], W1
007DB6  900131     MOV [W1+6], W2
007DB8  210001     MOV #0x1000, W1
007DBA  710081     IOR W2, W1, W1
007DBC  980031     MOV W1, [W0+6]
007DBE  370005     BRA 0x7DCA
558:                   }
559:               
560:                       #endif // USE_KEYBOARD
561:               }
007DCA  FA8000     ULNK
007DCC  060000     RETURN
562:               
563:               /*********************************************************************
564:               * Function: WORD SldTranslateMsg(void *pObj, GOL_MSG *pMsg)
565:               *
566:               * Notes: Evaluates the message if the object will be affected by the 
567:               *		 message or not.
568:               *
569:               ********************************************************************/
570:               WORD SldTranslateMsg(void *pObj, GOL_MSG *pMsg)
571:               {
007DCE  FA0006     LNK #0x6
007DD0  980710     MOV W0, [W14+2]
007DD2  980721     MOV W1, [W14+4]
572:               
573:                   SLIDER *pSld;
574:               
575:                   pSld = (SLIDER *)pObj;
007DD4  90001E     MOV [W14+2], W0
007DD6  780F00     MOV W0, [W14]
576:               
577:                   // Evaluate if the message is for the slider
578:                   // Check if disabled first
579:                   if(GetState(pSld, SLD_DISABLED))
007DD8  78001E     MOV [W14], W0
007DDA  900030     MOV [W0+6], W0
007DDC  600062     AND W0, #0x2, W0
007DDE  500FE0     SUB W0, #0x0, [W15]
007DE0  320002     BRA Z, 0x7DE6
580:                       return (OBJ_MSG_INVALID);
007DE2  EB0000     CLR W0
007DE4  37006D     BRA 0x7EC0
581:               
582:                       #ifdef USE_TOUCHSCREEN
583:                   if(pMsg->type == TYPE_TOUCHSCREEN)
007DE6  90002E     MOV [W14+4], W0
007DE8  784010     MOV.B [W0], W0
007DEA  504FE2     SUB.B W0, #0x2, [W15]
007DEC  3A0041     BRA NZ, 0x7E70
584:                   {
585:               
586:                       // Check if it falls to the left or right of the center of the thumb's face
587:                       if((pMsg->uiEvent == EVENT_PRESS) || (pMsg->uiEvent == EVENT_MOVE))
007DEE  90002E     MOV [W14+4], W0
007DF0  904010     MOV.B [W0+1], W0
007DF2  504FE2     SUB.B W0, #0x2, [W15]
007DF4  320004     BRA Z, 0x7DFE
007DF6  90002E     MOV [W14+4], W0
007DF8  904010     MOV.B [W0+1], W0
007DFA  504FE1     SUB.B W0, #0x1, [W15]
007DFC  3A0031     BRA NZ, 0x7E60
588:                       {
589:                           if
590:                           (
007E06  508F80     SUB W1, W0, [W15]
007E08  3D002B     BRA GE, 0x7E60
591:                               (pSld->hdr.left < pMsg->param1) &&
007DFE  78001E     MOV [W14], W0
007E00  9000C0     MOV [W0+8], W1
007E02  90002E     MOV [W14+4], W0
007E04  900010     MOV [W0+2], W0
007E12  508F80     SUB W1, W0, [W15]
007E14  340025     BRA LE, 0x7E60
592:                               (pSld->hdr.right > pMsg->param1) &&
007E0A  78001E     MOV [W14], W0
007E0C  9000E0     MOV [W0+12], W1
007E0E  90002E     MOV [W14+4], W0
007E10  900010     MOV [W0+2], W0
007E1E  508F80     SUB W1, W0, [W15]
007E20  3D001F     BRA GE, 0x7E60
593:                               (pSld->hdr.top < pMsg->param2) &&
007E16  78001E     MOV [W14], W0
007E18  9000D0     MOV [W0+10], W1
007E1A  90002E     MOV [W14+4], W0
007E1C  900020     MOV [W0+4], W0
007E2A  508F80     SUB W1, W0, [W15]
007E2C  340019     BRA LE, 0x7E60
594:                               (pSld->hdr.bottom > pMsg->param2)
007E22  78001E     MOV [W14], W0
007E24  9000F0     MOV [W0+14], W1
007E26  90002E     MOV [W14+4], W0
007E28  900020     MOV [W0+4], W0
595:                           )
596:                           {
597:                               if(GetState(pSld, SLD_VERTICAL)) 
007E2E  78001E     MOV [W14], W0
007E30  900030     MOV [W0+6], W0
007E32  600064     AND W0, #0x4, W0
007E34  500FE0     SUB W0, #0x0, [W15]
007E36  32000A     BRA Z, 0x7E4C
598:               				{
599:                                   if(pSld->currPos < pMsg->param2)
007E38  78001E     MOV [W14], W0
007E3A  9008D0     MOV [W0+26], W1
007E3C  90002E     MOV [W14+4], W0
007E3E  900020     MOV [W0+4], W0
007E40  508F80     SUB W1, W0, [W15]
007E42  310002     BRA C, 0x7E48
600:                                       return (SLD_MSG_INC);
007E44  2000D0     MOV #0xD, W0
007E46  37003C     BRA 0x7EC0
601:                                   else
602:                                       return (SLD_MSG_DEC);
007E48  2000E0     MOV #0xE, W0
007E4A  37003A     BRA 0x7EC0
603:               				}
604:                               else 
605:               				{
606:                               	if(pSld->currPos < pMsg->param1)
007E4C  78001E     MOV [W14], W0
007E4E  9008D0     MOV [W0+26], W1
007E50  90002E     MOV [W14+4], W0
007E52  900010     MOV [W0+2], W0
007E54  508F80     SUB W1, W0, [W15]
007E56  310002     BRA C, 0x7E5C
607:                                   	return (SLD_MSG_INC);
007E58  2000D0     MOV #0xD, W0
007E5A  370032     BRA 0x7EC0
608:                               	else
609:                                   	return (SLD_MSG_DEC);
007E5C  2000E0     MOV #0xE, W0
007E5E  370030     BRA 0x7EC0
610:               				}
611:                           }
612:                       }   // end of if((pMsg->uiEvent == EVENT_PRESS) || (pMsg->uiEvent == EVENT_MOVE))
613:                       
614:                       // when the event is release emit OBJ_MSG_PASSIVE this can be used to
615:                       // detect that the release event happened on the slider.
616:                       if(pMsg->uiEvent == EVENT_RELEASE)
007E60  90002E     MOV [W14+4], W0
007E62  904010     MOV.B [W0+1], W0
007E64  504FE4     SUB.B W0, #0x4, [W15]
007E66  3A0002     BRA NZ, 0x7E6C
617:                       	return OBJ_MSG_PASSIVE;
007E68  2002A0     MOV #0x2A, W0
007E6A  37002A     BRA 0x7EC0
618:                       	
619:                       return (OBJ_MSG_INVALID);
007E6C  EB0000     CLR W0
007E6E  370028     BRA 0x7EC0
620:                   }       // end of if(pMsg->type == TYPE_TOUCHSCREEN
621:                       #endif
622:                       #ifdef USE_KEYBOARD
623:                   if(pMsg->type == TYPE_KEYBOARD)
007E70  90002E     MOV [W14+4], W0
007E72  784010     MOV.B [W0], W0
007E74  504FE1     SUB.B W0, #0x1, [W15]
007E76  3A0023     BRA NZ, 0x7EBE
624:                   {
625:                       if((WORD)pMsg->param1 == pSld->hdr.ID)
007E78  90002E     MOV [W14+4], W0
007E7A  900010     MOV [W0+2], W0
007E7C  780080     MOV W0, W1
007E7E  78001E     MOV [W14], W0
007E80  780010     MOV [W0], W0
007E82  508F80     SUB W1, W0, [W15]
007E84  3A001C     BRA NZ, 0x7EBE
626:                       {
627:                           if(pMsg->uiEvent == EVENT_KEYSCAN)
007E86  90002E     MOV [W14+4], W0
007E88  904010     MOV.B [W0+1], W0
007E8A  504FE5     SUB.B W0, #0x5, [W15]
007E8C  3A0018     BRA NZ, 0x7EBE
628:                           {
629:                               if((pMsg->param2 == SCAN_RIGHT_PRESSED) || (pMsg->param2 == SCAN_UP_PRESSED))
007E8E  90002E     MOV [W14+4], W0
007E90  9000A0     MOV [W0+4], W1
007E92  2004D0     MOV #0x4D, W0
007E94  508F80     SUB W1, W0, [W15]
007E96  320005     BRA Z, 0x7EA2
007E98  90002E     MOV [W14+4], W0
007E9A  9000A0     MOV [W0+4], W1
007E9C  200480     MOV #0x48, W0
007E9E  508F80     SUB W1, W0, [W15]
007EA0  3A0002     BRA NZ, 0x7EA6
630:                               {
631:                                   return (SLD_MSG_INC);
007EA2  2000D0     MOV #0xD, W0
007EA4  37000D     BRA 0x7EC0
632:                               }
633:               
634:                               if((pMsg->param2 == SCAN_LEFT_PRESSED) || (pMsg->param2 == SCAN_DOWN_PRESSED))
007EA6  90002E     MOV [W14+4], W0
007EA8  9000A0     MOV [W0+4], W1
007EAA  2004B0     MOV #0x4B, W0
007EAC  508F80     SUB W1, W0, [W15]
007EAE  320005     BRA Z, 0x7EBA
007EB0  90002E     MOV [W14+4], W0
007EB2  9000A0     MOV [W0+4], W1
007EB4  200500     MOV #0x50, W0
007EB6  508F80     SUB W1, W0, [W15]
007EB8  3A0002     BRA NZ, 0x7EBE
635:                               {
636:                                   return (SLD_MSG_DEC);
007EBA  2000E0     MOV #0xE, W0
007EBC  370001     BRA 0x7EC0
637:                               }    
638:                           }
639:                       }
640:                   }
641:               
642:                       #endif
643:                   return (OBJ_MSG_INVALID);
007EBE  EB0000     CLR W0
644:               }
007EC0  FA8000     ULNK
007EC2  060000     RETURN
645:               
646:               /*********************************************************************
647:               * Function: WORD SldDraw(void *pObj)
648:               *
649:               * Notes: This is the state machine to draw the slider or scrollbar.
650:               *
651:               ********************************************************************/
652:               WORD SldDraw(void *pObj)
653:               {
007EC4  FA0004     LNK #0x4
007EC6  980710     MOV W0, [W14+2]
654:                   typedef enum
655:                   {
656:                       SLD_STATE_IDLE,
657:                       SLD_STATE_HIDE,
658:                       SLD_STATE_PANEL,
659:                       SLD_STATE_THUMBPATH1,
660:                       SLD_STATE_THUMBPATH2,
661:                       SLD_STATE_CLEARTHUMB,
662:                       SLD_STATE_REDRAWPATH1,
663:                       SLD_STATE_REDRAWPATH2,
664:                       SLD_STATE_THUMB,
665:                       SLD_STATE_THUMBPANEL,
666:                       SLD_STATE_FOCUS
667:                   } SLD_DRAW_STATES;
668:               
669:                   static GFX_COLOR colorTemp = 0;
670:               
671:                   static SLD_DRAW_STATES state = SLD_STATE_IDLE;
672:                   static WORD left, top, right, bottom;
673:                   static WORD midPoint, thWidth, thHeight;
674:                   static WORD minPos, maxPos;
675:                   SLIDER *pSld;
676:               
677:                   pSld = (SLIDER *)pObj;
007EC8  90001E     MOV [W14+2], W0
007ECA  780F00     MOV W0, [W14]
007ECC  370001     BRA 0x7ED0
678:               
679:               	#ifdef USE_ALPHABLEND
680:               	if(pSld->hdr.pGolScheme->AlphaValue != 100) 						     
681:               			CopyPageWindow(_GFXActivePage, 
682:               					   _GFXBackgroundPage, 
683:                                      pSld->hdr.left, pSld->hdr.top,pSld->hdr.left, pSld->hdr.top,
684:               					   pSld->hdr.right - pSld->hdr.left, 
685:               					   pSld->hdr.bottom - pSld->hdr.top);
686:               	#endif
687:               
688:               	while(1)
689:               	{
690:               		if(IsDeviceBusy())
007ED0  072220     RCALL IsDeviceBusy
007ED2  500FE0     SUB W0, #0x0, [W15]
007ED4  320002     BRA Z, 0x7EDA
691:               			return (0);
007ED6  EB0000     CLR W0
007ED8  370269     BRA 0x83AC
692:               
693:               		switch(state)
007EDA  8086D0     MOV state, W0
007EDC  200001     MOV #0x0, W1
007EDE  2000A2     MOV #0xA, W2
007EE0  200003     MOV #0x0, W3
007EE2  500F82     SUB W0, W2, [W15]
007EE4  588F83     SUBB W1, W3, [W15]
007EE6  3EFFF3     BRA GTU, 0x7ECE
007EE8  016000     BRA W0
007EEA  37000A     BRA 0x7F00
007EEC  370086     BRA 0x7FFA
007EEE  370096     BRA 0x801C
007EF0  3700A4     BRA 0x803A
007EF2  3700C6     BRA 0x8080
007EF4  3700F5     BRA 0x80E0
007EF6  370140     BRA 0x8178
007EF8  37019E     BRA 0x8236
007EFA  3701C4     BRA 0x8284
007EFC  37020C     BRA 0x8316
007EFE  370229     BRA 0x8352
694:               		{
695:               			case SLD_STATE_IDLE:
696:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
697:                           GFX_DRIVER_SetupDrawUpdate( pSld->hdr.left,
698:                                                       pSld->hdr.top,
699:                                                       pSld->hdr.right,
700:                                                       pSld->hdr.bottom);
701:               #endif
702:               				if(GetState(pSld, SLD_HIDE))
007F00  78001E     MOV [W14], W0
007F02  900030     MOV [W0+6], W0
007F04  500FE0     SUB W0, #0x0, [W15]
007F06  3D0007     BRA GE, 0x7F16
703:               				{
704:               					SetColor(pSld->hdr.pGolScheme->CommonBkColor);      // set to common BK Color
007F08  78001E     MOV [W14], W0
007F0A  900800     MOV [W0+16], W0
007F0C  904800     MOV.B [W0+8], W0
007F0E  B7F13E     MOV.B WREG, _color
705:               					state = SLD_STATE_HIDE;
007F10  200010     MOV #0x1, W0
007F12  8886D0     MOV W0, state
007F14  370072     BRA 0x7FFA
706:                                   // no break here so it falls through to SLD_STATE_HIDE
707:               				}
708:                               else 
709:                               {    
710:                   				if(!GetState(pSld, SLD_DISABLED))
007F16  78001E     MOV [W14], W0
007F18  900030     MOV [W0+6], W0
007F1A  600062     AND W0, #0x2, W0
007F1C  500FE0     SUB W0, #0x0, [W15]
007F1E  3A0005     BRA NZ, 0x7F2A
711:                   				{
712:                   					colorTemp = pSld->hdr.pGolScheme->Color0;           // select enabled color
007F20  78001E     MOV [W14], W0
007F22  900800     MOV [W0+16], W0
007F24  904050     MOV.B [W0+5], W0
007F26  B7F0DC     MOV.B WREG, colorTemp
007F28  370004     BRA 0x7F32
713:                   				}
714:                   				else
715:                   				{
716:                   					colorTemp = pSld->hdr.pGolScheme->ColorDisabled;    // select disabled color
007F2A  78001E     MOV [W14], W0
007F2C  900800     MOV [W0+16], W0
007F2E  904070     MOV.B [W0+7], W0
007F30  B7F0DC     MOV.B WREG, colorTemp
717:                   				}
718:                   
719:                   				SldGetMinMaxPos(pSld, &minPos, &maxPos);
007F32  210E02     MOV #0x10E0, W2
007F34  210DE1     MOV #0x10DE, W1
007F36  78001E     MOV [W14], W0
007F38  07FD79     RCALL SldGetMinMaxPos
720:                   
721:                   				midPoint = GetState(pSld, SLD_VERTICAL) ? (pSld->hdr.left + pSld->hdr.right) >> 1 : (pSld->hdr.top + pSld->hdr.bottom) >> 1;
007F3A  78001E     MOV [W14], W0
007F3C  900030     MOV [W0+6], W0
007F3E  600064     AND W0, #0x4, W0
007F40  500FE0     SUB W0, #0x0, [W15]
007F42  320007     BRA Z, 0x7F52
007F44  78001E     MOV [W14], W0
007F46  9000C0     MOV [W0+8], W1
007F48  78001E     MOV [W14], W0
007F4A  900060     MOV [W0+12], W0
007F4C  408000     ADD W1, W0, W0
007F4E  D18000     ASR W0, W0
007F50  370006     BRA 0x7F5E
007F52  78001E     MOV [W14], W0
007F54  9000D0     MOV [W0+10], W1
007F56  78001E     MOV [W14], W0
007F58  900070     MOV [W0+14], W0
007F5A  408000     ADD W1, W0, W0
007F5C  D18000     ASR W0, W0
007F5E  888710     MOV W0, midPoint
722:                   
723:                   				// calculate the thumb width and height Actually gets the half value
724:                   				// (see calculation of width and height) SldGetWidth() and SldGetHeight()
725:                   				thWidth = pSld->thWidth;                                // gets half the width
007F60  78001E     MOV [W14], W0
007F62  901020     MOV [W0+36], W0
007F64  888720     MOV W0, thWidth
726:                   				thHeight = pSld->thHeight;                              // gets half the height
007F66  78001E     MOV [W14], W0
007F68  901030     MOV [W0+38], W0
007F6A  888730     MOV W0, thHeight
727:                   				SetLineThickness(NORMAL_LINE);
007F6C  EB4000     CLR.B W0
007F6E  B7F04A     MOV.B WREG, _lineThickness
728:                   				SetLineType(SOLID_LINE);
007F70  EB0000     CLR W0
007F72  888240     MOV W0, _lineType
729:                   				if(GetState(pSld, SLD_DRAW))
007F74  78001E     MOV [W14], W0
007F76  9000B0     MOV [W0+6], W1
007F78  240000     MOV #0x4000, W0
007F7A  608000     AND W1, W0, W0
007F7C  500FE0     SUB W0, #0x0, [W15]
007F7E  32003A     BRA Z, 0x7FF4
730:                   				{   // draw the panel for the slider	
731:                   					// modify the color setting if scroll bar mode or slider mode
732:                   					GOLPanelDraw
007F80  78001E     MOV [W14], W0
007F82  900040     MOV [W0+8], W0
007F84  8888A0     MOV W0, _rpnlX1
007F86  78001E     MOV [W14], W0
007F88  900050     MOV [W0+10], W0
007F8A  8888B0     MOV W0, _rpnlY1
007F8C  78001E     MOV [W14], W0
007F8E  900060     MOV [W0+12], W0
007F90  8888C0     MOV W0, _rpnlX2
007F92  78001E     MOV [W14], W0
007F94  900070     MOV [W0+14], W0
007F96  8888D0     MOV W0, _rpnlY2
007F98  EB0000     CLR W0
007F9A  8888E0     MOV W0, _rpnlR
007F9C  BFD0DC     MOV.B colorTemp, WREG
007F9E  B7F11E     MOV.B WREG, _rpnlFaceColor
007FA0  78001E     MOV [W14], W0
007FA2  900030     MOV [W0+6], W0
007FA4  600070     AND W0, #0x10, W0
007FA6  500FE0     SUB W0, #0x0, [W15]
007FA8  320004     BRA Z, 0x7FB2
007FAA  78001E     MOV [W14], W0
007FAC  900800     MOV [W0+16], W0
007FAE  784010     MOV.B [W0], W0
007FB0  370003     BRA 0x7FB8
007FB2  78001E     MOV [W14], W0
007FB4  900800     MOV [W0+16], W0
007FB6  904010     MOV.B [W0+1], W0
007FB8  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
007FBA  78001E     MOV [W14], W0
007FBC  900030     MOV [W0+6], W0
007FBE  600070     AND W0, #0x10, W0
007FC0  500FE0     SUB W0, #0x0, [W15]
007FC2  320004     BRA Z, 0x7FCC
007FC4  78001E     MOV [W14], W0
007FC6  900800     MOV [W0+16], W0
007FC8  904010     MOV.B [W0+1], W0
007FCA  370003     BRA 0x7FD2
007FCC  78001E     MOV [W14], W0
007FCE  900800     MOV [W0+16], W0
007FD0  784010     MOV.B [W0], W0
007FD2  B7F120     MOV.B WREG, _rpnlEmbossDkColor
007FD4  EB0000     CLR W0
007FD6  888B60     MOV W0, 0x116C
007FD8  B3C030     MOV #0x3, W0
007FDA  B7F121     MOV.B WREG, _rpnlEmbossSize
733:                   					(
734:                   						pSld->hdr.left,
735:                   						pSld->hdr.top,
736:                   						pSld->hdr.right,
737:                   						pSld->hdr.bottom,
738:                   						0,
739:                   						colorTemp,
740:                   						(GetState(pSld, SLD_SCROLLBAR)) ? pSld->hdr.pGolScheme->EmbossDkColor : pSld->hdr.pGolScheme->EmbossLtColor,
741:                   						(GetState(pSld, SLD_SCROLLBAR)) ? pSld->hdr.pGolScheme->EmbossLtColor : pSld->hdr.pGolScheme->EmbossDkColor,
742:                   						NULL,
743:                   						GOL_EMBOSS_SIZE
744:                   					);
745:                   
746:                   					// initialize current and previous position
747:                   					SldSetPos(pSld, pSld->pos);
007FDC  78001E     MOV [W14], W0
007FDE  901000     MOV [W0+32], W0
007FE0  780080     MOV W0, W1
007FE2  78001E     MOV [W14], W0
007FE4  07FDBF     RCALL SldSetPos
748:                   					pSld->prevPos = pSld->currPos;
007FE6  78001E     MOV [W14], W0
007FE8  9008D0     MOV [W0+26], W1
007FEA  78001E     MOV [W14], W0
007FEC  980861     MOV W1, [W0+28]
749:                   
750:                   					state = SLD_STATE_PANEL;
007FEE  200020     MOV #0x2, W0
007FF0  8886D0     MOV W0, state
751:                   					break;
007FF2  3701DB     BRA 0x83AA
752:                   				}
753:                   				else 
754:                   				{   // we do not need to draw the whole object
755:                   					state = SLD_STATE_CLEARTHUMB;   // go to thumb drawing
007FF4  200050     MOV #0x5, W0
007FF6  8886D0     MOV W0, state
756:                   					break;
007FF8  3701D8     BRA 0x83AA
757:                   				}
758:                               }
759:               
760:               			case SLD_STATE_HIDE:
761:               				if (!Bar(pSld->hdr.left, pSld->hdr.top, pSld->hdr.right, pSld->hdr.bottom))
007FFA  78001E     MOV [W14], W0
007FFC  9001F0     MOV [W0+14], W3
007FFE  78001E     MOV [W14], W0
008000  900160     MOV [W0+12], W2
008002  78001E     MOV [W14], W0
008004  9000D0     MOV [W0+10], W1
008006  78001E     MOV [W14], W0
008008  900040     MOV [W0+8], W0
00800A  07EA58     RCALL Bar
00800C  500FE0     SUB W0, #0x0, [W15]
00800E  3A0002     BRA NZ, 0x8014
762:               					return (0);
008010  EB0000     CLR W0
008012  3701CC     BRA 0x83AC
763:               				state = SLD_STATE_IDLE;
008014  EB0000     CLR W0
008016  8886D0     MOV W0, state
764:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
765:                               GFX_DRIVER_CompleteDrawUpdate(   pSld->hdr.left,
766:                                                               pSld->hdr.top,
767:                                                               pSld->hdr.right,
768:                                                               pSld->hdr.bottom);
769:               #endif
770:               #ifdef USE_ALPHABLEND
771:                               if(pSld->hdr.pGolScheme->AlphaValue != 100) 
772:                               {
773:               		           AlphaBlendWindow(_GFXActivePage, pSld->hdr.left, pSld->hdr.top,
774:               						            _GFXBackgroundPage, pSld->hdr.left, pSld->hdr.top,
775:               						            _GFXActivePage, pSld->hdr.left, pSld->hdr.top,
776:               					                pSld->hdr.right - pSld->hdr.left, 
777:               					                pSld->hdr.bottom - pSld->hdr.top,  	
778:               					                pSld->hdr.pGolScheme->AlphaValue);
779:                               }
780:                #endif
781:               				return (1);
008018  200010     MOV #0x1, W0
00801A  3701C8     BRA 0x83AC
782:               				
783:               			case SLD_STATE_PANEL:
784:               				if(!GOLPanelDrawTsk())          // draw the panel of the slider
00801C  0703E7     RCALL GOLPanelDrawTsk
00801E  500FE0     SUB W0, #0x0, [W15]
008020  3A0002     BRA NZ, 0x8026
785:               					return (0);
008022  EB0000     CLR W0
008024  3701C3     BRA 0x83AC
786:               				if(GetState(pSld, SLD_SCROLLBAR))
008026  78001E     MOV [W14], W0
008028  900030     MOV [W0+6], W0
00802A  600070     AND W0, #0x10, W0
00802C  500FE0     SUB W0, #0x0, [W15]
00802E  320003     BRA Z, 0x8036
787:               				{                               // check if slider or scroll bar
788:               					state = SLD_STATE_THUMB;    // scrollbar: go directly to thumb drawing
008030  200080     MOV #0x8, W0
008032  8886D0     MOV W0, state
789:               					break;                      // thumb path is not drawn in scrollbar
008034  3701BA     BRA 0x83AA
790:               				}
791:               				else
792:               				{
793:               					state = SLD_STATE_THUMBPATH1;   // slider: draw thumb path next
008036  200030     MOV #0x3, W0
008038  8886D0     MOV W0, state
794:               				}
795:               
796:               			case SLD_STATE_THUMBPATH1:
797:               				SetColor(pSld->hdr.pGolScheme->EmbossDkColor);
00803A  78001E     MOV [W14], W0
00803C  900800     MOV [W0+16], W0
00803E  784010     MOV.B [W0], W0
008040  B7F13E     MOV.B WREG, _color
798:               				if(!GetState(pSld, SLD_VERTICAL))
008042  78001E     MOV [W14], W0
008044  900030     MOV [W0+6], W0
008046  600064     AND W0, #0x4, W0
008048  500FE0     SUB W0, #0x0, [W15]
00804A  3A000C     BRA NZ, 0x8064
799:               				{
800:               					if(!Line(minPos, midPoint, maxPos, midPoint))
00804C  808710     MOV midPoint, W0
00804E  780180     MOV W0, W3
008050  808700     MOV maxPos, W0
008052  780100     MOV W0, W2
008054  808710     MOV midPoint, W0
008056  780080     MOV W0, W1
008058  8086F0     MOV minPos, W0
00805A  07EA53     RCALL Line
00805C  500FE0     SUB W0, #0x0, [W15]
00805E  3A000E     BRA NZ, 0x807C
801:               						return (0);
008060  EB0000     CLR W0
008062  3701A4     BRA 0x83AC
802:               				}
803:               				else
804:               				{
805:               					if(!Line(midPoint, minPos, midPoint, maxPos))
008064  808700     MOV maxPos, W0
008066  780180     MOV W0, W3
008068  808710     MOV midPoint, W0
00806A  780100     MOV W0, W2
00806C  8086F0     MOV minPos, W0
00806E  780080     MOV W0, W1
008070  808710     MOV midPoint, W0
008072  07EA47     RCALL Line
008074  500FE0     SUB W0, #0x0, [W15]
008076  3A0002     BRA NZ, 0x807C
806:               						return (0);
008078  EB0000     CLR W0
00807A  370198     BRA 0x83AC
807:               				}
808:               
809:               				state = SLD_STATE_THUMBPATH2;
00807C  200040     MOV #0x4, W0
00807E  8886D0     MOV W0, state
810:               
811:               			case SLD_STATE_THUMBPATH2:
812:               				SetColor(pSld->hdr.pGolScheme->EmbossLtColor);
008080  78001E     MOV [W14], W0
008082  900800     MOV [W0+16], W0
008084  904010     MOV.B [W0+1], W0
008086  B7F13E     MOV.B WREG, _color
813:               				if(!GetState(pSld, SLD_VERTICAL))
008088  78001E     MOV [W14], W0
00808A  900030     MOV [W0+6], W0
00808C  600064     AND W0, #0x4, W0
00808E  500FE0     SUB W0, #0x0, [W15]
008090  3A000E     BRA NZ, 0x80AE
814:               				{
815:               					if(!Line(minPos, midPoint + 1, maxPos, midPoint + 1))
008092  808710     MOV midPoint, W0
008094  E80000     INC W0, W0
008096  780180     MOV W0, W3
008098  808700     MOV maxPos, W0
00809A  780100     MOV W0, W2
00809C  808710     MOV midPoint, W0
00809E  E80000     INC W0, W0
0080A0  780080     MOV W0, W1
0080A2  8086F0     MOV minPos, W0
0080A4  07EA2E     RCALL Line
0080A6  500FE0     SUB W0, #0x0, [W15]
0080A8  3A0010     BRA NZ, 0x80CA
816:               						return (0);
0080AA  EB0000     CLR W0
0080AC  37017F     BRA 0x83AC
817:               				}
818:               				else
819:               				{
820:               					if(!Line(midPoint + 1, minPos, midPoint + 1, maxPos))
0080AE  808700     MOV maxPos, W0
0080B0  780180     MOV W0, W3
0080B2  808710     MOV midPoint, W0
0080B4  E80000     INC W0, W0
0080B6  780100     MOV W0, W2
0080B8  8086F0     MOV minPos, W0
0080BA  780080     MOV W0, W1
0080BC  808710     MOV midPoint, W0
0080BE  E80000     INC W0, W0
0080C0  07EA20     RCALL Line
0080C2  500FE0     SUB W0, #0x0, [W15]
0080C4  3A0002     BRA NZ, 0x80CA
821:               						return (0);
0080C6  EB0000     CLR W0
0080C8  370171     BRA 0x83AC
822:               				}
823:               
824:               				if(GetState(pSld, SLD_DRAW))
0080CA  78001E     MOV [W14], W0
0080CC  9000B0     MOV [W0+6], W1
0080CE  240000     MOV #0x4000, W0
0080D0  608000     AND W1, W0, W0
0080D2  500FE0     SUB W0, #0x0, [W15]
0080D4  320003     BRA Z, 0x80DC
825:               				{                               // if drawing the whole slider
826:               					state = SLD_STATE_THUMB;    // go straight to drawing the thumb
0080D6  200080     MOV #0x8, W0
0080D8  8886D0     MOV W0, state
827:               					break; 
0080DA  370167     BRA 0x83AA
828:               				}
829:               				else
830:               					// if just drawing the thumb
831:               					state = SLD_STATE_CLEARTHUMB;   // go to state to remove current position
0080DC  200050     MOV #0x5, W0
0080DE  8886D0     MOV W0, state
832:               
833:               			case SLD_STATE_CLEARTHUMB:              // this removes the current thumb
834:               				if(IsDeviceBusy()) 
0080E0  072118     RCALL IsDeviceBusy
0080E2  500FE0     SUB W0, #0x0, [W15]
0080E4  320002     BRA Z, 0x80EA
835:               				    return (0);
0080E6  EB0000     CLR W0
0080E8  370161     BRA 0x83AC
836:               
837:               				if(!GetState(pSld, SLD_DRAW_THUMB))
0080EA  78001E     MOV [W14], W0
0080EC  9000B0     MOV [W0+6], W1
0080EE  210000     MOV #0x1000, W0
0080F0  608000     AND W1, W0, W0
0080F2  500FE0     SUB W0, #0x0, [W15]
0080F4  3A0003     BRA NZ, 0x80FC
838:               				{                               // SLD_DRAW_THUMB is only set when
839:               					state = SLD_STATE_FOCUS;    // object type is SLIDER
0080F6  2000A0     MOV #0xA, W0
0080F8  8886D0     MOV W0, state
840:               					break; 
0080FA  370157     BRA 0x83AA
841:               				}
842:               
843:               				SetColor(colorTemp);
0080FC  BFD0DC     MOV.B colorTemp, WREG
0080FE  B7F13E     MOV.B WREG, _color
844:               
845:               				// Remove the current thumb by drawing a bar with background color
846:               				if(!GetState(pSld, SLD_VERTICAL))
008100  78001E     MOV [W14], W0
008102  900030     MOV [W0+6], W0
008104  600064     AND W0, #0x4, W0
008106  500FE0     SUB W0, #0x0, [W15]
008108  3A0016     BRA NZ, 0x8136
847:               				{
848:               					if(!Bar(pSld->prevPos - thWidth, midPoint - thHeight, pSld->prevPos + thWidth, midPoint + thHeight))
00810A  808711     MOV midPoint, W1
00810C  808730     MOV thHeight, W0
00810E  408000     ADD W1, W0, W0
008110  780180     MOV W0, W3
008112  78001E     MOV [W14], W0
008114  9008E0     MOV [W0+28], W1
008116  808720     MOV thWidth, W0
008118  408000     ADD W1, W0, W0
00811A  780100     MOV W0, W2
00811C  808711     MOV midPoint, W1
00811E  808730     MOV thHeight, W0
008120  508000     SUB W1, W0, W0
008122  780080     MOV W0, W1
008124  78001E     MOV [W14], W0
008126  900A60     MOV [W0+28], W4
008128  808720     MOV thWidth, W0
00812A  520000     SUB W4, W0, W0
00812C  07E9C7     RCALL Bar
00812E  500FE0     SUB W0, #0x0, [W15]
008130  3A0018     BRA NZ, 0x8162
849:               						return (0);
008132  EB0000     CLR W0
008134  37013B     BRA 0x83AC
850:               				}
851:               				else
852:               				{
853:               					if(!Bar(midPoint - thWidth, pSld->prevPos - thHeight, midPoint + thWidth, pSld->prevPos + thHeight))
008136  78001E     MOV [W14], W0
008138  9008E0     MOV [W0+28], W1
00813A  808730     MOV thHeight, W0
00813C  408000     ADD W1, W0, W0
00813E  780180     MOV W0, W3
008140  808711     MOV midPoint, W1
008142  808720     MOV thWidth, W0
008144  408000     ADD W1, W0, W0
008146  780100     MOV W0, W2
008148  78001E     MOV [W14], W0
00814A  9008E0     MOV [W0+28], W1
00814C  808730     MOV thHeight, W0
00814E  508000     SUB W1, W0, W0
008150  780080     MOV W0, W1
008152  808714     MOV midPoint, W4
008154  808720     MOV thWidth, W0
008156  520000     SUB W4, W0, W0
008158  07E9B1     RCALL Bar
00815A  500FE0     SUB W0, #0x0, [W15]
00815C  3A0002     BRA NZ, 0x8162
854:               						return (0);
00815E  EB0000     CLR W0
008160  370125     BRA 0x83AC
855:               				}
856:               
857:               				if(!GetState(pSld, SLD_SCROLLBAR))
008162  78001E     MOV [W14], W0
008164  900030     MOV [W0+6], W0
008166  600070     AND W0, #0x10, W0
008168  500FE0     SUB W0, #0x0, [W15]
00816A  3A0003     BRA NZ, 0x8172
858:               				{                               // check if slider or scroll bar
859:               					state = SLD_STATE_REDRAWPATH1;
00816C  200060     MOV #0x6, W0
00816E  8886D0     MOV W0, state
008170  370003     BRA 0x8178
860:               				}
861:               				else
862:               				{
863:               					state = SLD_STATE_THUMB;    // go directly to thumb drawing
008172  200080     MOV #0x8, W0
008174  8886D0     MOV W0, state
864:               					break;                      // thumb path is not drawn in scrollbar
008176  370119     BRA 0x83AA
865:               				}
866:               
867:               			case SLD_STATE_REDRAWPATH1:         // redraws the lines that it covered
868:               				SetColor(pSld->hdr.pGolScheme->EmbossDkColor);
008178  78001E     MOV [W14], W0
00817A  900800     MOV [W0+16], W0
00817C  784010     MOV.B [W0], W0
00817E  B7F13E     MOV.B WREG, _color
869:               
870:               				// Check if the redraw area exceeds the actual dimension. This will
871:               				// adjust the redrawing area to just within the parameters
872:               				if(!GetState(pSld, SLD_VERTICAL))
008180  78001E     MOV [W14], W0
008182  900030     MOV [W0+6], W0
008184  600064     AND W0, #0x4, W0
008186  500FE0     SUB W0, #0x0, [W15]
008188  3A002A     BRA NZ, 0x81DE
873:               				{
874:               					if(minPos + thWidth > pSld->prevPos)
00818A  8086F1     MOV minPos, W1
00818C  808720     MOV thWidth, W0
00818E  408080     ADD W1, W0, W1
008190  78001E     MOV [W14], W0
008192  900860     MOV [W0+28], W0
008194  508F80     SUB W1, W0, [W15]
008196  360003     BRA LEU, 0x819E
875:               						left = minPos;
008198  8086F0     MOV minPos, W0
00819A  888740     MOV W0, left
00819C  370005     BRA 0x81A8
876:               					else
877:               						left = pSld->prevPos - thWidth;
00819E  78001E     MOV [W14], W0
0081A0  9008E0     MOV [W0+28], W1
0081A2  808720     MOV thWidth, W0
0081A4  508000     SUB W1, W0, W0
0081A6  888740     MOV W0, left
878:               
879:               					if(maxPos - thWidth < pSld->prevPos)
0081A8  808701     MOV maxPos, W1
0081AA  808720     MOV thWidth, W0
0081AC  508080     SUB W1, W0, W1
0081AE  78001E     MOV [W14], W0
0081B0  900860     MOV [W0+28], W0
0081B2  508F80     SUB W1, W0, [W15]
0081B4  310003     BRA C, 0x81BC
880:               						right = maxPos;
0081B6  808700     MOV maxPos, W0
0081B8  888750     MOV W0, right
0081BA  370005     BRA 0x81C6
881:               					else
882:               						right = pSld->prevPos + thWidth;
0081BC  78001E     MOV [W14], W0
0081BE  9008E0     MOV [W0+28], W1
0081C0  808720     MOV thWidth, W0
0081C2  408000     ADD W1, W0, W0
0081C4  888750     MOV W0, right
883:               
884:               					if(!Line(left, midPoint, right, midPoint))
0081C6  808710     MOV midPoint, W0
0081C8  780180     MOV W0, W3
0081CA  808750     MOV right, W0
0081CC  780100     MOV W0, W2
0081CE  808710     MOV midPoint, W0
0081D0  780080     MOV W0, W1
0081D2  808740     MOV left, W0
0081D4  07E996     RCALL Line
0081D6  500FE0     SUB W0, #0x0, [W15]
0081D8  3A002C     BRA NZ, 0x8232
885:               						return (0);
0081DA  EB0000     CLR W0
0081DC  3700E7     BRA 0x83AC
886:               				}
887:               				else
888:               				{
889:               					if(minPos + thHeight > pSld->prevPos)
0081DE  8086F1     MOV minPos, W1
0081E0  808730     MOV thHeight, W0
0081E2  408080     ADD W1, W0, W1
0081E4  78001E     MOV [W14], W0
0081E6  900860     MOV [W0+28], W0
0081E8  508F80     SUB W1, W0, [W15]
0081EA  360003     BRA LEU, 0x81F2
890:               						top = minPos;
0081EC  8086F0     MOV minPos, W0
0081EE  888760     MOV W0, top
0081F0  370005     BRA 0x81FC
891:               					else
892:               						top = pSld->prevPos - thHeight;
0081F2  78001E     MOV [W14], W0
0081F4  9008E0     MOV [W0+28], W1
0081F6  808730     MOV thHeight, W0
0081F8  508000     SUB W1, W0, W0
0081FA  888760     MOV W0, top
893:               					
894:               					if(maxPos - thHeight < pSld->prevPos)
0081FC  808701     MOV maxPos, W1
0081FE  808730     MOV thHeight, W0
008200  508080     SUB W1, W0, W1
008202  78001E     MOV [W14], W0
008204  900860     MOV [W0+28], W0
008206  508F80     SUB W1, W0, [W15]
008208  310003     BRA C, 0x8210
895:               						bottom = maxPos;
00820A  808700     MOV maxPos, W0
00820C  888770     MOV W0, bottom
00820E  370005     BRA 0x821A
896:               					else
897:               						bottom = pSld->prevPos + thHeight;
008210  78001E     MOV [W14], W0
008212  9008E0     MOV [W0+28], W1
008214  808730     MOV thHeight, W0
008216  408000     ADD W1, W0, W0
008218  888770     MOV W0, bottom
898:               					
899:               					if(!Line(midPoint, top, midPoint, bottom))
00821A  808770     MOV bottom, W0
00821C  780180     MOV W0, W3
00821E  808710     MOV midPoint, W0
008220  780100     MOV W0, W2
008222  808760     MOV top, W0
008224  780080     MOV W0, W1
008226  808710     MOV midPoint, W0
008228  07E96C     RCALL Line
00822A  500FE0     SUB W0, #0x0, [W15]
00822C  3A0002     BRA NZ, 0x8232
900:               						return (0);
00822E  EB0000     CLR W0
008230  3700BD     BRA 0x83AC
901:               				}
902:               
903:               				state = SLD_STATE_REDRAWPATH2;
008232  200070     MOV #0x7, W0
008234  8886D0     MOV W0, state
904:               
905:               			case SLD_STATE_REDRAWPATH2:
906:               				SetColor(pSld->hdr.pGolScheme->EmbossLtColor);
008236  78001E     MOV [W14], W0
008238  900800     MOV [W0+16], W0
00823A  904010     MOV.B [W0+1], W0
00823C  B7F13E     MOV.B WREG, _color
907:               				if(!GetState(pSld, SLD_VERTICAL))
00823E  78001E     MOV [W14], W0
008240  900030     MOV [W0+6], W0
008242  600064     AND W0, #0x4, W0
008244  500FE0     SUB W0, #0x0, [W15]
008246  3A000E     BRA NZ, 0x8264
908:               				{
909:               					if(!Line(left, midPoint + 1, right, midPoint + 1))
008248  808710     MOV midPoint, W0
00824A  E80000     INC W0, W0
00824C  780180     MOV W0, W3
00824E  808750     MOV right, W0
008250  780100     MOV W0, W2
008252  808710     MOV midPoint, W0
008254  E80000     INC W0, W0
008256  780080     MOV W0, W1
008258  808740     MOV left, W0
00825A  07E953     RCALL Line
00825C  500FE0     SUB W0, #0x0, [W15]
00825E  3A0010     BRA NZ, 0x8280
910:               						return (0);
008260  EB0000     CLR W0
008262  3700A4     BRA 0x83AC
911:               				}
912:               				else
913:               				{
914:               					if(!Line(midPoint + 1, top, midPoint + 1, bottom))
008264  808770     MOV bottom, W0
008266  780180     MOV W0, W3
008268  808710     MOV midPoint, W0
00826A  E80000     INC W0, W0
00826C  780100     MOV W0, W2
00826E  808760     MOV top, W0
008270  780080     MOV W0, W1
008272  808710     MOV midPoint, W0
008274  E80000     INC W0, W0
008276  07E945     RCALL Line
008278  500FE0     SUB W0, #0x0, [W15]
00827A  3A0002     BRA NZ, 0x8280
915:               						return (0);
00827C  EB0000     CLR W0
00827E  370096     BRA 0x83AC
916:               				}
917:               
918:               				state = SLD_STATE_THUMB;
008280  200080     MOV #0x8, W0
008282  8886D0     MOV W0, state
919:               
920:               			case SLD_STATE_THUMB:
921:               				if(IsDeviceBusy()) 
008284  072046     RCALL IsDeviceBusy
008286  500FE0     SUB W0, #0x0, [W15]
008288  320002     BRA Z, 0x828E
922:               				    return (0);
00828A  EB0000     CLR W0
00828C  37008F     BRA 0x83AC
923:               				if(!GetState(pSld, SLD_VERTICAL))
00828E  78001E     MOV [W14], W0
008290  900030     MOV [W0+6], W0
008292  600064     AND W0, #0x4, W0
008294  500FE0     SUB W0, #0x0, [W15]
008296  3A0013     BRA NZ, 0x82BE
924:               				{                               // Draw the slider thumb based on the
925:               					// current position
926:               					left = pSld->currPos - thWidth;
008298  78001E     MOV [W14], W0
00829A  9008D0     MOV [W0+26], W1
00829C  808720     MOV thWidth, W0
00829E  508000     SUB W1, W0, W0
0082A0  888740     MOV W0, left
927:               					top = midPoint - thHeight;
0082A2  808711     MOV midPoint, W1
0082A4  808730     MOV thHeight, W0
0082A6  508000     SUB W1, W0, W0
0082A8  888760     MOV W0, top
928:               					right = pSld->currPos + thWidth;
0082AA  78001E     MOV [W14], W0
0082AC  9008D0     MOV [W0+26], W1
0082AE  808720     MOV thWidth, W0
0082B0  408000     ADD W1, W0, W0
0082B2  888750     MOV W0, right
929:               					bottom = midPoint + thHeight;
0082B4  808711     MOV midPoint, W1
0082B6  808730     MOV thHeight, W0
0082B8  408000     ADD W1, W0, W0
0082BA  888770     MOV W0, bottom
0082BC  370012     BRA 0x82E2
930:               				}
931:               				else
932:               				{
933:               					left = midPoint - thWidth;
0082BE  808711     MOV midPoint, W1
0082C0  808720     MOV thWidth, W0
0082C2  508000     SUB W1, W0, W0
0082C4  888740     MOV W0, left
934:               					top = pSld->currPos - thHeight;
0082C6  78001E     MOV [W14], W0
0082C8  9008D0     MOV [W0+26], W1
0082CA  808730     MOV thHeight, W0
0082CC  508000     SUB W1, W0, W0
0082CE  888760     MOV W0, top
935:               					right = midPoint + thWidth;
0082D0  808711     MOV midPoint, W1
0082D2  808720     MOV thWidth, W0
0082D4  408000     ADD W1, W0, W0
0082D6  888750     MOV W0, right
936:               					bottom = pSld->currPos + thHeight;
0082D8  78001E     MOV [W14], W0
0082DA  9008D0     MOV [W0+26], W1
0082DC  808730     MOV thHeight, W0
0082DE  408000     ADD W1, W0, W0
0082E0  888770     MOV W0, bottom
937:               				}
938:               
939:               				GOLPanelDraw
0082E2  808740     MOV left, W0
0082E4  8888A0     MOV W0, _rpnlX1
0082E6  808760     MOV top, W0
0082E8  8888B0     MOV W0, _rpnlY1
0082EA  808750     MOV right, W0
0082EC  8888C0     MOV W0, _rpnlX2
0082EE  808770     MOV bottom, W0
0082F0  8888D0     MOV W0, _rpnlY2
0082F2  EB0000     CLR W0
0082F4  8888E0     MOV W0, _rpnlR
0082F6  BFD0DC     MOV.B colorTemp, WREG
0082F8  B7F11E     MOV.B WREG, _rpnlFaceColor
0082FA  78001E     MOV [W14], W0
0082FC  900800     MOV [W0+16], W0
0082FE  904010     MOV.B [W0+1], W0
008300  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
008302  78001E     MOV [W14], W0
008304  900800     MOV [W0+16], W0
008306  784010     MOV.B [W0], W0
008308  B7F120     MOV.B WREG, _rpnlEmbossDkColor
00830A  EB0000     CLR W0
00830C  888B60     MOV W0, 0x116C
00830E  B3C020     MOV #0x2, W0
008310  B7F121     MOV.B WREG, _rpnlEmbossSize
940:               				(
941:               					left,
942:               					top,
943:               					right,
944:               					bottom,
945:               					0,                          // set the parameters of the thumb	
946:               					colorTemp,
947:               					pSld->hdr.pGolScheme->EmbossLtColor,
948:               					pSld->hdr.pGolScheme->EmbossDkColor,
949:               					NULL,
950:               					(GOL_EMBOSS_SIZE - 1) ? GOL_EMBOSS_SIZE - 1 : 1
951:               				);
952:               
953:               				state = SLD_STATE_THUMBPANEL;
008312  200090     MOV #0x9, W0
008314  8886D0     MOV W0, state
954:               
955:               			case SLD_STATE_THUMBPANEL:
956:               				if(!GOLPanelDrawTsk())          // draw the panel of the thumb
008316  07026A     RCALL GOLPanelDrawTsk
008318  500FE0     SUB W0, #0x0, [W15]
00831A  3A0002     BRA NZ, 0x8320
957:               					return (0);
00831C  EB0000     CLR W0
00831E  370046     BRA 0x83AC
958:               
959:               				pSld->prevPos = pSld->currPos;  // record the current position as previous
008320  78001E     MOV [W14], W0
008322  9008D0     MOV [W0+26], W1
008324  78001E     MOV [W14], W0
008326  980861     MOV W1, [W0+28]
960:               				if(GetState(pSld, SLD_SCROLLBAR))
008328  78001E     MOV [W14], W0
00832A  900030     MOV [W0+6], W0
00832C  600070     AND W0, #0x10, W0
00832E  500FE0     SUB W0, #0x0, [W15]
008330  320004     BRA Z, 0x833A
961:               				{                               // check if scroll bar focus is not used
962:               					state = SLD_STATE_IDLE;     // go back to idle state
008332  EB0000     CLR W0
008334  8886D0     MOV W0, state
963:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
964:                               GFX_DRIVER_CompleteDrawUpdate(   pSld->hdr.left,
965:                                                               pSld->hdr.top,
966:                                                               pSld->hdr.right,
967:                                                               pSld->hdr.bottom);
968:               #endif
969:               #ifdef USE_ALPHABLEND
970:                               if(pSld->hdr.pGolScheme->AlphaValue != 100) 
971:                               {
972:               		           AlphaBlendWindow(_GFXActivePage, pSld->hdr.left, pSld->hdr.top,
973:               						    _GFXBackgroundPage, pSld->hdr.left, pSld->hdr.top,
974:               						    _GFXActivePage, pSld->hdr.left, pSld->hdr.top,
975:               					          pSld->hdr.right - pSld->hdr.left, 
976:               					          pSld->hdr.bottom - pSld->hdr.top,  	
977:               					          pSld->hdr.pGolScheme->AlphaValue);
978:               
979:                               }
980:                #endif
981:               					return (1);
008336  200010     MOV #0x1, W0
008338  370039     BRA 0x83AC
982:               				}
983:               
984:               				if(!GetState(pSld, SLD_DRAW_FOCUS))
00833A  78001E     MOV [W14], W0
00833C  9000B0     MOV [W0+6], W1
00833E  220000     MOV #0x2000, W0
008340  608000     AND W1, W0, W0
008342  500FE0     SUB W0, #0x0, [W15]
008344  3A0004     BRA NZ, 0x834E
985:               				{
986:               					state = SLD_STATE_IDLE;
008346  EB0000     CLR W0
008348  8886D0     MOV W0, state
987:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
988:                               GFX_DRIVER_CompleteDrawUpdate(   pSld->hdr.left,
989:                                                               pSld->hdr.top,
990:                                                               pSld->hdr.right,
991:                                                               pSld->hdr.bottom);
992:               #endif
993:               #ifdef USE_ALPHABLEND
994:                               if(pSld->hdr.pGolScheme->AlphaValue != 100) 
995:                               {
996:               		           AlphaBlendWindow(_GFXActivePage, pSld->hdr.left, pSld->hdr.top,
997:               						    _GFXBackgroundPage, pSld->hdr.left, pSld->hdr.top,
998:               						    _GFXActivePage, pSld->hdr.left, pSld->hdr.top,
999:               					          pSld->hdr.right - pSld->hdr.left, 
1000:              					          pSld->hdr.bottom - pSld->hdr.top,  	
1001:              					          pSld->hdr.pGolScheme->AlphaValue);
1002:              
1003:                              }
1004:               #endif
1005:              					return (1);
00834A  200010     MOV #0x1, W0
00834C  37002F     BRA 0x83AC
1006:              				}
1007:              
1008:              				state = SLD_STATE_FOCUS;
00834E  2000A0     MOV #0xA, W0
008350  8886D0     MOV W0, state
1009:              
1010:              			case SLD_STATE_FOCUS:
1011:              				if(!GetState(pSld, SLD_SCROLLBAR))
008352  78001E     MOV [W14], W0
008354  900030     MOV [W0+6], W0
008356  600070     AND W0, #0x10, W0
008358  500FE0     SUB W0, #0x0, [W15]
00835A  3A0023     BRA NZ, 0x83A2
1012:              				{                               // do not draw focus when in scroll bar mode
1013:              					SetLineType(FOCUS_LINE);
00835C  200020     MOV #0x2, W0
00835E  888240     MOV W0, _lineType
1014:              					if(GetState(pSld, SLD_FOCUSED))
008360  78001E     MOV [W14], W0
008362  900030     MOV [W0+6], W0
008364  600061     AND W0, #0x1, W0
008366  784000     MOV.B W0, W0
008368  504FE0     SUB.B W0, #0x0, [W15]
00836A  320005     BRA Z, 0x8376
1015:              					{
1016:              						SetColor(pSld->hdr.pGolScheme->TextColor0); // draw the focus box
00836C  78001E     MOV [W14], W0
00836E  900800     MOV [W0+16], W0
008370  904020     MOV.B [W0+2], W0
008372  B7F13E     MOV.B WREG, _color
008374  370002     BRA 0x837A
1017:              					}
1018:              					else
1019:              					{
1020:              						SetColor(colorTemp);                        // remove the focus box, colorTemp
008376  BFD0DC     MOV.B colorTemp, WREG
008378  B7F13E     MOV.B WREG, _color
1021:              					}
1022:              
1023:              					if
1024:              					(
008396  500FE0     SUB W0, #0x0, [W15]
008398  3A0002     BRA NZ, 0x839E
1025:              						!Rectangle
00837A  78001E     MOV [W14], W0
00837C  900070     MOV [W0+14], W0
00837E  5001E3     SUB W0, #0x3, W3
008380  78001E     MOV [W14], W0
008382  900060     MOV [W0+12], W0
008384  500163     SUB W0, #0x3, W2
008386  78001E     MOV [W14], W0
008388  900050     MOV [W0+10], W0
00838A  4000E3     ADD W0, #0x3, W1
00838C  78001E     MOV [W14], W0
00838E  900040     MOV [W0+8], W0
008390  400063     ADD W0, #0x3, W0
008392  EB0200     CLR W4
008394  07EC73     RCALL Bevel
1026:              							(
1027:              								pSld->hdr.left + GOL_EMBOSS_SIZE,
1028:              								pSld->hdr.top + GOL_EMBOSS_SIZE,
1029:              								pSld->hdr.right - GOL_EMBOSS_SIZE,
1030:              								pSld->hdr.bottom - GOL_EMBOSS_SIZE
1031:              							)
1032:              					) return (0);
00839A  EB0000     CLR W0
00839C  370007     BRA 0x83AC
1033:              
1034:              					SetLineType(SOLID_LINE);                        // reset line type
00839E  EB0000     CLR W0
0083A0  888240     MOV W0, _lineType
1035:              				}
1036:              
1037:              				state = SLD_STATE_IDLE;                             // set state to idle
0083A2  EB0000     CLR W0
0083A4  8886D0     MOV W0, state
1038:              #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
1039:                          GFX_DRIVER_CompleteDrawUpdate(   pSld->hdr.left,
1040:                                                          pSld->hdr.top,
1041:                                                          pSld->hdr.right,
1042:                                                          pSld->hdr.bottom);
1043:              #endif
1044:              #ifdef USE_ALPHABLEND
1045:                              if(pSld->hdr.pGolScheme->AlphaValue != 100) 
1046:                              {
1047:              		           AlphaBlendWindow(_GFXActivePage, pSld->hdr.left, pSld->hdr.top,
1048:              						    _GFXBackgroundPage, pSld->hdr.left, pSld->hdr.top,
1049:              						    _GFXActivePage, pSld->hdr.left, pSld->hdr.top,
1050:              					          pSld->hdr.right - pSld->hdr.left, 
1051:              					          pSld->hdr.bottom - pSld->hdr.top,  	
1052:              					          pSld->hdr.pGolScheme->AlphaValue);
1053:              
1054:                              }
1055:               #endif
1056:              				return (1); // return as done
0083A6  200010     MOV #0x1, W0
0083A8  370001     BRA 0x83AC
1057:              		}
1058:                  } // end of while(1)
007ECE  000000     NOP
0083AA  37FD92     BRA 0x7ED0
1059:              }
0083AC  FA8000     ULNK
0083AE  060000     RETURN
1060:              
1061:              #endif // USE_SLIDER
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/ProgressBar.c  -------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library
3:                  *  GOL Layer 
4:                  *  Progress Bar
5:                  *****************************************************************************
6:                  * FileName:        ProgressBar.c
7:                  * Dependencies:    Graphics.h 
8:                  * Processor:       PIC24F, PIC24H, dsPIC, PIC32
9:                  * Compiler:       	MPLAB C30 V3.00, MPLAB C32
10:                 * Linker:          MPLAB LINK30, MPLAB LINK32
11:                 * Company:         Microchip Technology Incorporated
12:                 *
13:                 * Software License Agreement
14:                 *
15:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
16:                 * Microchip licenses to you the right to use, modify, copy and distribute
17:                 * Software only when embedded on a Microchip microcontroller or digital
18:                 * signal controller, which is integrated into your product or third party
19:                 * product (pursuant to the sublicense terms in the accompanying license
20:                 * agreement).  
21:                 *
22:                 * You should refer to the license agreement accompanying this Software
23:                 * for additional information regarding your rights and obligations.
24:                 *
25:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
26:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
27:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
28:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
29:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
30:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
32:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
33:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
34:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
35:                 * OR OTHER SIMILAR COSTS.
36:                 *
37:                 * Date         Comment
38:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:                 * 11/12/07	    Version 1.0 release
40:                 * 08/05/11     Fixed rendering to check IsDeviceBusy() if not exiting the
41:                 *              draw routine. 
42:                 * 11/04/11     Added state bit PB_NOPROGRESS to indicate the progress in 
43:                 *              text will not be shown.
44:                 *****************************************************************************/
45:                #include "Graphics/Graphics.h"
46:                
47:                #ifdef USE_PROGRESSBAR
48:                
49:                /*********************************************************************
50:                * Function: void PbWordToString(WORD value, XCHAR* buffer)
51:                *
52:                * Input: value  - value to be converted (from 0 - 100)
53:                *        buffer - buffer receiving string (must be at least 5 bytes)
54:                *
55:                * Output: none
56:                *
57:                * Overview: converts SHORT into string with % at the end
58:                *
59:                ********************************************************************/
60:                void PbWordToString(WORD value, XCHAR *buffer)
61:                {
009370  FA0008     LNK #0x8
009372  980720     MOV W0, [W14+4]
009374  980731     MOV W1, [W14+6]
62:                    WORD    result;
63:                    BYTE    pos;
64:                
65:                    if(value > 99)
009376  9000AE     MOV [W14+4], W1
009378  200630     MOV #0x63, W0
00937A  508F80     SUB W1, W0, [W15]
00937C  360014     BRA LEU, 0x93A6
66:                    {
67:                        buffer[0] = '1';
00937E  9000BE     MOV [W14+6], W1
009380  B3C310     MOV #0x31, W0
009382  784880     MOV.B W0, [W1]
68:                        buffer[1] = '0';
009384  90003E     MOV [W14+6], W0
009386  E80080     INC W0, W1
009388  B3C300     MOV #0x30, W0
00938A  784880     MOV.B W0, [W1]
69:                        buffer[2] = '0';
00938C  90003E     MOV [W14+6], W0
00938E  E88080     INC2 W0, W1
009390  B3C300     MOV #0x30, W0
009392  784880     MOV.B W0, [W1]
70:                        buffer[3] = '%';
009394  90003E     MOV [W14+6], W0
009396  4000E3     ADD W0, #0x3, W1
009398  B3C250     MOV #0x25, W0
00939A  784880     MOV.B W0, [W1]
71:                        buffer[4] = 0;
00939C  90003E     MOV [W14+6], W0
00939E  4000E4     ADD W0, #0x4, W1
0093A0  EB4000     CLR.B W0
0093A2  784880     MOV.B W0, [W1]
72:                        return;
0093A4  370031     BRA 0x9408
73:                    }
74:                
75:                    pos = 0;
0093A6  EB4000     CLR.B W0
0093A8  784F00     MOV.B W0, [W14]
76:                    result = value / 10;
0093AA  9000AE     MOV [W14+4], W1
0093AC  2000A0     MOV #0xA, W0
0093AE  780100     MOV W0, W2
0093B0  090011     REPEAT #0x11
0093B2  D88082     DIV.UW W1, W2
0093B4  980710     MOV W0, [W14+2]
77:                    if(result)
0093B6  90001E     MOV [W14+2], W0
0093B8  500FE0     SUB W0, #0x0, [W15]
0093BA  320009     BRA Z, 0x93CE
78:                        buffer[pos++] = result + '0';
0093BC  78409E     MOV.B [W14], W1
0093BE  FB8001     ZE W1, W0
0093C0  9000BE     MOV [W14+6], W1
0093C2  408080     ADD W1, W0, W1
0093C4  90001E     MOV [W14+2], W0
0093C6  784000     MOV.B W0, W0
0093C8  B04300     ADD.B #0x30, W0
0093CA  784880     MOV.B W0, [W1]
0093CC  E84F1E     INC.B [W14], [W14]
79:                    result = value - 10 * result;
0093CE  90001E     MOV [W14+2], W0
0093D0  B9006A     MUL.SU W0, #10, W0
0093D2  780000     MOV W0, W0
0093D4  9000AE     MOV [W14+4], W1
0093D6  508000     SUB W1, W0, W0
0093D8  980710     MOV W0, [W14+2]
80:                
81:                    buffer[pos++] = result + '0';
0093DA  78411E     MOV.B [W14], W2
0093DC  FB8002     ZE W2, W0
0093DE  9000BE     MOV [W14+6], W1
0093E0  408080     ADD W1, W0, W1
0093E2  90001E     MOV [W14+2], W0
0093E4  784000     MOV.B W0, W0
0093E6  B04300     ADD.B #0x30, W0
0093E8  784880     MOV.B W0, [W1]
0093EA  E84F1E     INC.B [W14], [W14]
82:                    buffer[pos++] = '%';
0093EC  78409E     MOV.B [W14], W1
0093EE  FB8001     ZE W1, W0
0093F0  9000BE     MOV [W14+6], W1
0093F2  408080     ADD W1, W0, W1
0093F4  B3C250     MOV #0x25, W0
0093F6  784880     MOV.B W0, [W1]
0093F8  E84F1E     INC.B [W14], [W14]
83:                    buffer[pos++] = 0;
0093FA  78411E     MOV.B [W14], W2
0093FC  FB8002     ZE W2, W0
0093FE  9000BE     MOV [W14+6], W1
009400  408080     ADD W1, W0, W1
009402  EB4000     CLR.B W0
009404  784880     MOV.B W0, [W1]
009406  E84F1E     INC.B [W14], [W14]
84:                }
009408  FA8000     ULNK
00940A  060000     RETURN
85:                
86:                /*********************************************************************
87:                * Function: PROGRESSBAR  *PbCreate(WORD ID, SHORT left, SHORT top, SHORT right, 
88:                *                              SHORT bottom, WORD state, WORD pos, WORD range,
89:                *                              GOL_SCHEME *pScheme)
90:                *
91:                * Overview: creates the progress bar
92:                *
93:                ********************************************************************/
94:                PROGRESSBAR *PbCreate
95:                (
96:                    WORD        ID,
97:                    SHORT       left,
98:                    SHORT       top,
99:                    SHORT       right,
100:                   SHORT       bottom,
101:                   WORD        state,
102:                   WORD        pos,
103:                   WORD        range,
104:                   GOL_SCHEME  *pScheme
105:               )
106:               {
00940C  FA0012     LNK #0x12
00940E  980710     MOV W0, [W14+2]
009410  980721     MOV W1, [W14+4]
009412  980732     MOV W2, [W14+6]
009414  980743     MOV W3, [W14+8]
009416  980754     MOV W4, [W14+10]
009418  980765     MOV W5, [W14+12]
00941A  980776     MOV W6, [W14+14]
00941C  980F07     MOV W7, [W14+16]
107:                   PROGRESSBAR *pPb = NULL;
00941E  EB0000     CLR W0
009420  780F00     MOV W0, [W14]
108:               
109:                   pPb = (PROGRESSBAR *)GFX_malloc(sizeof(PROGRESSBAR));
009422  200200     MOV #0x20, W0
009424  07C595     RCALL _malloc
009426  780F00     MOV W0, [W14]
110:                   if(pPb == NULL)
009428  78001E     MOV [W14], W0
00942A  500FE0     SUB W0, #0x0, [W15]
00942C  3A0002     BRA NZ, 0x9432
111:                       return (pPb);
00942E  78001E     MOV [W14], W0
009430  37003F     BRA 0x94B0
112:               
113:                   pPb->hdr.ID         = ID;
009432  78001E     MOV [W14], W0
009434  90009E     MOV [W14+2], W1
009436  780801     MOV W1, [W0]
114:                   pPb->hdr.pNxtObj    = NULL;
009438  78001E     MOV [W14], W0
00943A  EB0080     CLR W1
00943C  980011     MOV W1, [W0+2]
115:                   pPb->hdr.type       = OBJ_PROGRESSBAR;
00943E  78001E     MOV [W14], W0
009440  200071     MOV #0x7, W1
009442  980021     MOV W1, [W0+4]
116:                   pPb->hdr.left       = left;
009444  78001E     MOV [W14], W0
009446  9000AE     MOV [W14+4], W1
009448  980041     MOV W1, [W0+8]
117:                   pPb->hdr.top        = top;
00944A  78001E     MOV [W14], W0
00944C  9000BE     MOV [W14+6], W1
00944E  980051     MOV W1, [W0+10]
118:                   pPb->hdr.right      = right;
009450  78001E     MOV [W14], W0
009452  9000CE     MOV [W14+8], W1
009454  980061     MOV W1, [W0+12]
119:                   pPb->hdr.bottom     = bottom;
009456  78001E     MOV [W14], W0
009458  9000DE     MOV [W14+10], W1
00945A  980071     MOV W1, [W0+14]
120:                   pPb->pos            = pos;
00945C  78001E     MOV [W14], W0
00945E  9000FE     MOV [W14+14], W1
009460  980851     MOV W1, [W0+26]
121:                   pPb->range          = (range == 0) ? 100 : range;
009462  90080E     MOV [W14+16], W0
009464  500FE0     SUB W0, #0x0, [W15]
009466  320002     BRA Z, 0x946C
009468  90080E     MOV [W14+16], W0
00946A  370001     BRA 0x946E
00946C  200640     MOV #0x64, W0
00946E  78009E     MOV [W14], W1
009470  9808F0     MOV W0, [W1+30]
122:                   pPb->prevPos        = 0;
009472  78001E     MOV [W14], W0
009474  EB0080     CLR W1
009476  980861     MOV W1, [W0+28]
123:                   pPb->hdr.state      = state;
009478  78001E     MOV [W14], W0
00947A  9000EE     MOV [W14+12], W1
00947C  980031     MOV W1, [W0+6]
124:                   pPb->hdr.DrawObj    = PbDraw;   // draw function
00947E  78001E     MOV [W14], W0
009480  2954C1     MOV #0x954C, W1
009482  980811     MOV W1, [W0+18]
125:                   pPb->hdr.MsgObj     = NULL;     // message function
009484  78001E     MOV [W14], W0
009486  EB0080     CLR W1
009488  980831     MOV W1, [W0+22]
126:                   pPb->hdr.MsgDefaultObj = NULL;  // default message function
00948A  78001E     MOV [W14], W0
00948C  EB0080     CLR W1
00948E  980841     MOV W1, [W0+24]
127:                   pPb->hdr.FreeObj    = NULL;		// free function
009490  78001E     MOV [W14], W0
009492  EB0080     CLR W1
009494  980821     MOV W1, [W0+20]
128:               
129:                   // Set the style scheme to be used
130:                   if(pScheme == NULL)
009496  97B84E     MOV [W14-8], W0
009498  500FE0     SUB W0, #0x0, [W15]
00949A  3A0004     BRA NZ, 0x94A4
131:                       pPb->hdr.pGolScheme = _pDefaultGolScheme;
00949C  808B41     MOV 0x1168, W1
00949E  78001E     MOV [W14], W0
0094A0  980801     MOV W1, [W0+16]
0094A2  370003     BRA 0x94AA
132:                   else
133:                       pPb->hdr.pGolScheme = (GOL_SCHEME *)pScheme;
0094A4  78001E     MOV [W14], W0
0094A6  97B8CE     MOV [W14-8], W1
0094A8  980801     MOV W1, [W0+16]
134:               
135:                   GOLAddObject((OBJ_HEADER *)pPb);
0094AA  78001E     MOV [W14], W0
0094AC  07F8B3     RCALL GOLAddObject
136:               
137:                   return (pPb);
0094AE  78001E     MOV [W14], W0
138:               }
0094B0  FA8000     ULNK
0094B2  060000     RETURN
139:               
140:               /*********************************************************************
141:               * Function: void PbSetPos(PROGRESSBAR *pPb, SHORT position)
142:               *
143:               * Overview: sets the current position of the progress bar
144:               *
145:               ********************************************************************/
146:               void PbSetPos(PROGRESSBAR *pPb, WORD position)
147:               {
0094B4  FA0004     LNK #0x4
0094B6  780F00     MOV W0, [W14]
0094B8  980711     MOV W1, [W14+2]
148:                   if(pPb->range < position)
0094BA  78001E     MOV [W14], W0
0094BC  9008F0     MOV [W0+30], W1
0094BE  90001E     MOV [W14+2], W0
0094C0  508F80     SUB W1, W0, [W15]
0094C2  310003     BRA C, 0x94CA
149:                       position = pPb->range;
0094C4  78001E     MOV [W14], W0
0094C6  9008F0     MOV [W0+30], W1
0094C8  980711     MOV W1, [W14+2]
150:               
151:                   pPb->pos = position;
0094CA  78001E     MOV [W14], W0
0094CC  90009E     MOV [W14+2], W1
0094CE  980851     MOV W1, [W0+26]
152:               }
0094D0  FA8000     ULNK
0094D2  060000     RETURN
153:               
154:               /*********************************************************************
155:               * Function: void PbSetRange(PROGRESSBAR *pPb, WORD range)
156:               *
157:               * Overview: sets the range of the progress bar
158:               *
159:               ********************************************************************/
160:               void PbSetRange(PROGRESSBAR *pPb, WORD range)
161:               {
0094D4  FA0004     LNK #0x4
0094D6  780F00     MOV W0, [W14]
0094D8  980711     MOV W1, [W14+2]
162:               
163:                   // range cannot be assigned a zero value
164:                   if(range != 0)
0094DA  90001E     MOV [W14+2], W0
0094DC  500FE0     SUB W0, #0x0, [W15]
0094DE  320003     BRA Z, 0x94E6
165:                       pPb->range = range;
0094E0  78001E     MOV [W14], W0
0094E2  90009E     MOV [W14+2], W1
0094E4  980871     MOV W1, [W0+30]
166:                   pPb->pos = range;
0094E6  78001E     MOV [W14], W0
0094E8  90009E     MOV [W14+2], W1
0094EA  980851     MOV W1, [W0+26]
167:                   pPb->prevPos = 0;
0094EC  78001E     MOV [W14], W0
0094EE  EB0080     CLR W1
0094F0  980861     MOV W1, [W0+28]
168:               }
0094F2  FA8000     ULNK
0094F4  060000     RETURN
169:               
170:               /*********************************************************************
171:               * Function: WORD PbTranslateMsg(PROGRESSBAR *pPb, GOL_MSG *pMsg)
172:               *
173:               * Overview: translates the GOL message for the progress bar
174:               *
175:               ********************************************************************/
176:               WORD PbTranslateMsg(PROGRESSBAR *pPb, GOL_MSG *pMsg)
177:               {
0094F6  FA0004     LNK #0x4
0094F8  780F00     MOV W0, [W14]
0094FA  980711     MOV W1, [W14+2]
178:               
179:                   // Evaluate if the message is for the progress bar
180:                   // Check if disabled first
181:                   if(GetState(pPb, PB_DISABLED))
0094FC  78001E     MOV [W14], W0
0094FE  900030     MOV [W0+6], W0
009500  600062     AND W0, #0x2, W0
009502  500FE0     SUB W0, #0x0, [W15]
009504  320002     BRA Z, 0x950A
182:                       return (OBJ_MSG_INVALID);
009506  EB0000     CLR W0
009508  37001F     BRA 0x9548
183:               
184:                       #ifdef USE_TOUCHSCREEN
185:                   if(pMsg->type == TYPE_TOUCHSCREEN)
00950A  90001E     MOV [W14+2], W0
00950C  784010     MOV.B [W0], W0
00950E  504FE2     SUB.B W0, #0x2, [W15]
009510  3A001A     BRA NZ, 0x9546
186:                   {
187:               
188:                       // Check if it falls in the progress bar border
189:                       if
190:                       (
00951A  508F80     SUB W1, W0, [W15]
00951C  3D0014     BRA GE, 0x9546
191:                           (pPb->hdr.left < pMsg->param1) &&
009512  78001E     MOV [W14], W0
009514  9000C0     MOV [W0+8], W1
009516  90001E     MOV [W14+2], W0
009518  900010     MOV [W0+2], W0
009526  508F80     SUB W1, W0, [W15]
009528  34000E     BRA LE, 0x9546
192:                           (pPb->hdr.right > pMsg->param1) &&
00951E  78001E     MOV [W14], W0
009520  9000E0     MOV [W0+12], W1
009522  90001E     MOV [W14+2], W0
009524  900010     MOV [W0+2], W0
009532  508F80     SUB W1, W0, [W15]
009534  3D0008     BRA GE, 0x9546
193:                           (pPb->hdr.top < pMsg->param2) &&
00952A  78001E     MOV [W14], W0
00952C  9000D0     MOV [W0+10], W1
00952E  90001E     MOV [W14+2], W0
009530  900020     MOV [W0+4], W0
00953E  508F80     SUB W1, W0, [W15]
009540  340002     BRA LE, 0x9546
194:                           (pPb->hdr.bottom > pMsg->param2)
009536  78001E     MOV [W14], W0
009538  9000F0     MOV [W0+14], W1
00953A  90001E     MOV [W14+2], W0
00953C  900020     MOV [W0+4], W0
195:                       )
196:                       {
197:                           return (PB_MSG_SELECTED);
009542  200110     MOV #0x11, W0
009544  370001     BRA 0x9548
198:                       }
199:                   }
200:               
201:                       #endif
202:                   return (OBJ_MSG_INVALID);
009546  EB0000     CLR W0
203:               }
009548  FA8000     ULNK
00954A  060000     RETURN
204:               
205:               /*********************************************************************
206:               * Function: WORD PbDraw(void *pObj)
207:               *
208:               * Output: returns the status of the drawing
209:               *		  0 - not complete
210:               *         1 - done
211:               *
212:               * Overview: draws progress bar
213:               *
214:               ********************************************************************/
215:               WORD PbDraw(void *pObj)
216:               {
00954C  FA0004     LNK #0x4
00954E  781F88     MOV W8, [W15++]
009550  980710     MOV W0, [W14+2]
217:                   typedef enum
218:                   {
219:                       REMOVE,
220:                       BOX_DRAW,
221:                       RUN_DRAW,
222:                       BAR_DRAW_SET,
223:                       BAR_DRAW,
224:                       TEXT_DRAW1,
225:                       TEXT_DRAW2,
226:                       TEXT_DRAW3
227:                   } PB_DRAW_STATES;
228:               
229:                   static PB_DRAW_STATES state = REMOVE;
230:                   static DWORD x1;
231:                   static DWORD x2;
232:                   static WORD  intLeft, intTop, intRight, intBottom;
233:                   static XCHAR text[5] = {'0','0','%',0};
234:                   PROGRESSBAR *pPb;
235:               
236:                   pPb = (PROGRESSBAR *)pObj;
009552  90001E     MOV [W14+2], W0
009554  780F00     MOV W0, [W14]
009556  370001     BRA 0x955A
237:               
238:                   while(1)
239:                   {
240:                       if(IsDeviceBusy())
00955A  0716DB     RCALL IsDeviceBusy
00955C  500FE0     SUB W0, #0x0, [W15]
00955E  320002     BRA Z, 0x9564
241:                           return (0);
009560  EB0000     CLR W0
009562  37024C     BRA 0x99FC
242:                   
243:                       switch(state)
009564  808780     MOV state, W0
009566  200001     MOV #0x0, W1
009568  200072     MOV #0x7, W2
00956A  200003     MOV #0x0, W3
00956C  500F82     SUB W0, W2, [W15]
00956E  588F83     SUBB W1, W3, [W15]
009570  3EFFF3     BRA GTU, 0x9558
009572  016000     BRA W0
009574  37000F     BRA 0x9594
009576  370027     BRA 0x95C6
009578  370005     BRA 0x9584
00957A  37004E     BRA 0x9618
00957C  37013E     BRA 0x97FA
00957E  37019D     BRA 0x98BA
009580  3701EA     BRA 0x9956
009582  37022D     BRA 0x99DE
244:                       {
245:                           case RUN_DRAW:
246:                               if(!GOLPanelDrawTsk())
009584  07F933     RCALL GOLPanelDrawTsk
009586  500FE0     SUB W0, #0x0, [W15]
009588  3A0002     BRA NZ, 0x958E
247:                                   return (0);
00958A  EB0000     CLR W0
00958C  370237     BRA 0x99FC
248:                               state = BAR_DRAW_SET;
00958E  200030     MOV #0x3, W0
009590  888780     MOV W0, state
249:                               break;
009592  370233     BRA 0x99FA
250:               
251:                           case REMOVE:
252:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
253:                           GFX_DRIVER_SetupDrawUpdate( pPb->hdr.left,
254:                                                       pPb->hdr.top,
255:                                                       pPb->hdr.right,
256:                                                       pPb->hdr.bottom);
257:               #endif
258:                               if(GetState(pPb, PB_HIDE))
009594  78001E     MOV [W14], W0
009596  900030     MOV [W0+6], W0
009598  500FE0     SUB W0, #0x0, [W15]
00959A  3D0013     BRA GE, 0x95C2
259:                               {
260:                                   SetColor(pPb->hdr.pGolScheme->CommonBkColor);
00959C  78001E     MOV [W14], W0
00959E  900800     MOV [W0+16], W0
0095A0  904800     MOV.B [W0+8], W0
0095A2  B7F13E     MOV.B WREG, _color
261:                                   if(!Bar(pPb->hdr.left, pPb->hdr.top, pPb->hdr.right, pPb->hdr.bottom))
0095A4  78001E     MOV [W14], W0
0095A6  9001F0     MOV [W0+14], W3
0095A8  78001E     MOV [W14], W0
0095AA  900160     MOV [W0+12], W2
0095AC  78001E     MOV [W14], W0
0095AE  9000D0     MOV [W0+10], W1
0095B0  78001E     MOV [W14], W0
0095B2  900040     MOV [W0+8], W0
0095B4  07DF83     RCALL Bar
0095B6  500FE0     SUB W0, #0x0, [W15]
0095B8  3A0002     BRA NZ, 0x95BE
262:                                       return (0);
0095BA  EB0000     CLR W0
0095BC  37021F     BRA 0x99FC
263:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
264:                               GFX_DRIVER_CompleteDrawUpdate(   pPb->hdr.left,
265:                                                               pPb->hdr.top,
266:                                                               pPb->hdr.right,
267:                                                               pPb->hdr.bottom);
268:               #endif
269:                                   return (1);
0095BE  200010     MOV #0x1, W0
0095C0  37021D     BRA 0x99FC
270:                               }
271:                               state = BOX_DRAW;
0095C2  200010     MOV #0x1, W0
0095C4  888780     MOV W0, state
272:                   
273:                           case BOX_DRAW:
274:                               if(GetState(pPb, PB_DRAW))
0095C6  78001E     MOV [W14], W0
0095C8  9000B0     MOV [W0+6], W1
0095CA  240000     MOV #0x4000, W0
0095CC  608000     AND W1, W0, W0
0095CE  500FE0     SUB W0, #0x0, [W15]
0095D0  320021     BRA Z, 0x9614
275:                               {
276:                                   GOLPanelDraw
0095D2  78001E     MOV [W14], W0
0095D4  900040     MOV [W0+8], W0
0095D6  8888A0     MOV W0, _rpnlX1
0095D8  78001E     MOV [W14], W0
0095DA  900050     MOV [W0+10], W0
0095DC  8888B0     MOV W0, _rpnlY1
0095DE  78001E     MOV [W14], W0
0095E0  900060     MOV [W0+12], W0
0095E2  8888C0     MOV W0, _rpnlX2
0095E4  78001E     MOV [W14], W0
0095E6  900070     MOV [W0+14], W0
0095E8  8888D0     MOV W0, _rpnlY2
0095EA  EB0000     CLR W0
0095EC  8888E0     MOV W0, _rpnlR
0095EE  78001E     MOV [W14], W0
0095F0  900800     MOV [W0+16], W0
0095F2  904050     MOV.B [W0+5], W0
0095F4  B7F11E     MOV.B WREG, _rpnlFaceColor
0095F6  78001E     MOV [W14], W0
0095F8  900800     MOV [W0+16], W0
0095FA  784010     MOV.B [W0], W0
0095FC  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
0095FE  78001E     MOV [W14], W0
009600  900800     MOV [W0+16], W0
009602  904010     MOV.B [W0+1], W0
009604  B7F120     MOV.B WREG, _rpnlEmbossDkColor
009606  EB0000     CLR W0
009608  888B60     MOV W0, 0x116C
00960A  B3C030     MOV #0x3, W0
00960C  B7F121     MOV.B WREG, _rpnlEmbossSize
277:                                   (
278:                                       pPb->hdr.left,
279:                                       pPb->hdr.top,
280:                                       pPb->hdr.right,
281:                                       pPb->hdr.bottom,
282:                                       0,
283:                                       pPb->hdr.pGolScheme->Color0,
284:                                       pPb->hdr.pGolScheme->EmbossDkColor,
285:                                       pPb->hdr.pGolScheme->EmbossLtColor,
286:                                       NULL,
287:                                       GOL_EMBOSS_SIZE
288:                                   );
289:                                   state = RUN_DRAW;
00960E  200020     MOV #0x2, W0
009610  888780     MOV W0, state
290:                                   break;
009612  3701F3     BRA 0x99FA
291:                               } 
292:                               // else progress bar state = PB_DRAW_BAR, refresh only the level
293:                               state = BAR_DRAW_SET;
009614  200030     MOV #0x3, W0
009616  888780     MOV W0, state
294:                   
295:                           case BAR_DRAW_SET:
296:                           	if(GetState(pPb, PB_VERTICAL))
009618  78001E     MOV [W14], W0
00961A  900030     MOV [W0+6], W0
00961C  600064     AND W0, #0x4, W0
00961E  500FE0     SUB W0, #0x0, [W15]
009620  32004B     BRA Z, 0x96B8
297:                               {
298:                   	            x1 = ((DWORD) (pPb->range-pPb->prevPos)) * (pPb->hdr.bottom - pPb->hdr.top - (2 * GOL_EMBOSS_SIZE)) / pPb->range;
009622  78001E     MOV [W14], W0
009624  9008F0     MOV [W0+30], W1
009626  78001E     MOV [W14], W0
009628  900860     MOV [W0+28], W0
00962A  508000     SUB W1, W0, W0
00962C  B80161     MUL.UU W0, #1, W2
00962E  78001E     MOV [W14], W0
009630  9000F0     MOV [W0+14], W1
009632  78001E     MOV [W14], W0
009634  900050     MOV [W0+10], W0
009636  508000     SUB W1, W0, W0
009638  500066     SUB W0, #0x6, W0
00963A  DE80CF     ASR W0, #15, W1
00963C  B99A00     MUL.SS W3, W0, W4
00963E  780204     MOV W4, W4
009640  B98B02     MUL.SS W1, W2, W6
009642  780286     MOV W6, W5
009644  420205     ADD W4, W5, W4
009646  B81000     MUL.UU W2, W0, W0
009648  420201     ADD W4, W1, W4
00964A  780084     MOV W4, W1
00964C  78011E     MOV [W14], W2
00964E  900972     MOV [W2+30], W2
009650  200003     MOV #0x0, W3
009652  07C303     RCALL ___udivsi3
009654  888790     MOV W0, x1
009656  8887A1     MOV W1, 0x10F4
299:                   	            x2 = ((DWORD) (pPb->range-pPb->pos)) * (pPb->hdr.bottom - pPb->hdr.top - (2 * GOL_EMBOSS_SIZE)) / pPb->range;
009658  78001E     MOV [W14], W0
00965A  9008F0     MOV [W0+30], W1
00965C  78001E     MOV [W14], W0
00965E  900850     MOV [W0+26], W0
009660  508000     SUB W1, W0, W0
009662  B80161     MUL.UU W0, #1, W2
009664  78001E     MOV [W14], W0
009666  9000F0     MOV [W0+14], W1
009668  78001E     MOV [W14], W0
00966A  900050     MOV [W0+10], W0
00966C  508000     SUB W1, W0, W0
00966E  500066     SUB W0, #0x6, W0
009670  DE80CF     ASR W0, #15, W1
009672  B99A00     MUL.SS W3, W0, W4
009674  780204     MOV W4, W4
009676  B98B02     MUL.SS W1, W2, W6
009678  780286     MOV W6, W5
00967A  420205     ADD W4, W5, W4
00967C  B81000     MUL.UU W2, W0, W0
00967E  420201     ADD W4, W1, W4
009680  780084     MOV W4, W1
009682  78011E     MOV [W14], W2
009684  900972     MOV [W2+30], W2
009686  200003     MOV #0x0, W3
009688  07C2E8     RCALL ___udivsi3
00968A  8887B0     MOV W0, x2
00968C  8887C1     MOV W1, 0x10F8
300:                   	            x1 += (pPb->hdr.top + GOL_EMBOSS_SIZE);
00968E  78001E     MOV [W14], W0
009690  900050     MOV [W0+10], W0
009692  400063     ADD W0, #0x3, W0
009694  B90161     MUL.SU W0, #1, W2
009696  808790     MOV x1, W0
009698  8087A1     MOV 0x10F4, W1
00969A  400002     ADD W0, W2, W0
00969C  488083     ADDC W1, W3, W1
00969E  888790     MOV W0, x1
0096A0  8887A1     MOV W1, 0x10F4
301:                   	            x2 += (pPb->hdr.top + GOL_EMBOSS_SIZE);	            
0096A2  78001E     MOV [W14], W0
0096A4  900050     MOV [W0+10], W0
0096A6  400063     ADD W0, #0x3, W0
0096A8  B90161     MUL.SU W0, #1, W2
0096AA  8087B0     MOV x2, W0
0096AC  8087C1     MOV 0x10F8, W1
0096AE  400002     ADD W0, W2, W0
0096B0  488083     ADDC W1, W3, W1
0096B2  8887B0     MOV W0, x2
0096B4  8887C1     MOV W1, 0x10F8
0096B6  370044     BRA 0x9740
302:                   	        }
303:                   	        else
304:                   	        { 
305:                   	            x1 = ((DWORD) pPb->pos) * (pPb->hdr.right - pPb->hdr.left - (2 * GOL_EMBOSS_SIZE)) / pPb->range;
0096B8  78001E     MOV [W14], W0
0096BA  900850     MOV [W0+26], W0
0096BC  B80161     MUL.UU W0, #1, W2
0096BE  78001E     MOV [W14], W0
0096C0  9000E0     MOV [W0+12], W1
0096C2  78001E     MOV [W14], W0
0096C4  900040     MOV [W0+8], W0
0096C6  508000     SUB W1, W0, W0
0096C8  500066     SUB W0, #0x6, W0
0096CA  DE80CF     ASR W0, #15, W1
0096CC  B99A00     MUL.SS W3, W0, W4
0096CE  780204     MOV W4, W4
0096D0  B98B02     MUL.SS W1, W2, W6
0096D2  780286     MOV W6, W5
0096D4  420205     ADD W4, W5, W4
0096D6  B81000     MUL.UU W2, W0, W0
0096D8  420201     ADD W4, W1, W4
0096DA  780084     MOV W4, W1
0096DC  78011E     MOV [W14], W2
0096DE  900972     MOV [W2+30], W2
0096E0  200003     MOV #0x0, W3
0096E2  07C2BB     RCALL ___udivsi3
0096E4  888790     MOV W0, x1
0096E6  8887A1     MOV W1, 0x10F4
306:                   	            x2 = ((DWORD) pPb->prevPos) * (pPb->hdr.right - pPb->hdr.left - (2 * GOL_EMBOSS_SIZE)) / pPb->range;
0096E8  78001E     MOV [W14], W0
0096EA  900860     MOV [W0+28], W0
0096EC  B80161     MUL.UU W0, #1, W2
0096EE  78001E     MOV [W14], W0
0096F0  9000E0     MOV [W0+12], W1
0096F2  78001E     MOV [W14], W0
0096F4  900040     MOV [W0+8], W0
0096F6  508000     SUB W1, W0, W0
0096F8  500066     SUB W0, #0x6, W0
0096FA  DE80CF     ASR W0, #15, W1
0096FC  B99A00     MUL.SS W3, W0, W4
0096FE  780204     MOV W4, W4
009700  B98B02     MUL.SS W1, W2, W6
009702  780286     MOV W6, W5
009704  420205     ADD W4, W5, W4
009706  B81000     MUL.UU W2, W0, W0
009708  420201     ADD W4, W1, W4
00970A  780084     MOV W4, W1
00970C  78011E     MOV [W14], W2
00970E  900972     MOV [W2+30], W2
009710  200003     MOV #0x0, W3
009712  07C2A3     RCALL ___udivsi3
009714  8887B0     MOV W0, x2
009716  8887C1     MOV W1, 0x10F8
307:                   	            x1 += (pPb->hdr.left + GOL_EMBOSS_SIZE);
009718  78001E     MOV [W14], W0
00971A  900040     MOV [W0+8], W0
00971C  400063     ADD W0, #0x3, W0
00971E  B90161     MUL.SU W0, #1, W2
009720  808790     MOV x1, W0
009722  8087A1     MOV 0x10F4, W1
009724  400002     ADD W0, W2, W0
009726  488083     ADDC W1, W3, W1
009728  888790     MOV W0, x1
00972A  8887A1     MOV W1, 0x10F4
308:                   	            x2 += (pPb->hdr.left + GOL_EMBOSS_SIZE);
00972C  78001E     MOV [W14], W0
00972E  900040     MOV [W0+8], W0
009730  400063     ADD W0, #0x3, W0
009732  B90161     MUL.SU W0, #1, W2
009734  8087B0     MOV x2, W0
009736  8087C1     MOV 0x10F8, W1
009738  400002     ADD W0, W2, W0
00973A  488083     ADDC W1, W3, W1
00973C  8887B0     MOV W0, x2
00973E  8887C1     MOV W1, 0x10F8
309:                            	}   
310:               
311:                               if(pPb->prevPos > pPb->pos)
009740  78001E     MOV [W14], W0
009742  9008E0     MOV [W0+28], W1
009744  78001E     MOV [W14], W0
009746  900850     MOV [W0+26], W0
009748  508F80     SUB W1, W0, [W15]
00974A  36002B     BRA LEU, 0x97A2
312:                               {
313:                   	            SetColor(pPb->hdr.pGolScheme->Color0);
00974C  78001E     MOV [W14], W0
00974E  900800     MOV [W0+16], W0
009750  904050     MOV.B [W0+5], W0
009752  B7F13E     MOV.B WREG, _color
314:                   	        	if(GetState(pPb, PB_VERTICAL))
009754  78001E     MOV [W14], W0
009756  900030     MOV [W0+6], W0
009758  600064     AND W0, #0x4, W0
00975A  500FE0     SUB W0, #0x0, [W15]
00975C  320011     BRA Z, 0x9780
315:                                   {
316:                                       intLeft   = pPb->hdr.left + GOL_EMBOSS_SIZE; 
00975E  78001E     MOV [W14], W0
009760  900040     MOV [W0+8], W0
009762  400063     ADD W0, #0x3, W0
009764  8887D0     MOV W0, intLeft
317:                                       intTop    = x1;
009766  808790     MOV x1, W0
009768  8087A1     MOV 0x10F4, W1
00976A  780000     MOV W0, W0
00976C  8887E0     MOV W0, intTop
318:                                       intRight  = pPb->hdr.right - GOL_EMBOSS_SIZE;
00976E  78001E     MOV [W14], W0
009770  900060     MOV [W0+12], W0
009772  500063     SUB W0, #0x3, W0
009774  8887F0     MOV W0, intRight
319:                                       intBottom = x2;
009776  8087B0     MOV x2, W0
009778  8087C1     MOV 0x10F8, W1
00977A  780000     MOV W0, W0
00977C  888800     MOV W0, intBottom
00977E  37003B     BRA 0x97F6
320:                                   } 
321:                                   else
322:                                   {
323:                                       intLeft   = x1; 
009780  808790     MOV x1, W0
009782  8087A1     MOV 0x10F4, W1
009784  780000     MOV W0, W0
009786  8887D0     MOV W0, intLeft
324:                                       intTop    = pPb->hdr.top + GOL_EMBOSS_SIZE;
009788  78001E     MOV [W14], W0
00978A  900050     MOV [W0+10], W0
00978C  400063     ADD W0, #0x3, W0
00978E  8887E0     MOV W0, intTop
325:                                       intRight  = x2;
009790  8087B0     MOV x2, W0
009792  8087C1     MOV 0x10F8, W1
009794  780000     MOV W0, W0
009796  8887F0     MOV W0, intRight
326:                                       intBottom = pPb->hdr.bottom - GOL_EMBOSS_SIZE;
009798  78001E     MOV [W14], W0
00979A  900070     MOV [W0+14], W0
00979C  500063     SUB W0, #0x3, W0
00979E  888800     MOV W0, intBottom
0097A0  37002A     BRA 0x97F6
327:                                   }
328:                               }
329:                               else
330:                               {
331:                                   SetColor(pPb->hdr.pGolScheme->Color1);
0097A2  78001E     MOV [W14], W0
0097A4  900800     MOV [W0+16], W0
0097A6  904060     MOV.B [W0+6], W0
0097A8  B7F13E     MOV.B WREG, _color
332:                   	        	if(GetState(pPb, PB_VERTICAL))
0097AA  78001E     MOV [W14], W0
0097AC  900030     MOV [W0+6], W0
0097AE  600064     AND W0, #0x4, W0
0097B0  500FE0     SUB W0, #0x0, [W15]
0097B2  320011     BRA Z, 0x97D6
333:                       	        {
334:                                       intLeft   = pPb->hdr.left + GOL_EMBOSS_SIZE; 
0097B4  78001E     MOV [W14], W0
0097B6  900040     MOV [W0+8], W0
0097B8  400063     ADD W0, #0x3, W0
0097BA  8887D0     MOV W0, intLeft
335:                                       intTop    = x2;
0097BC  8087B0     MOV x2, W0
0097BE  8087C1     MOV 0x10F8, W1
0097C0  780000     MOV W0, W0
0097C2  8887E0     MOV W0, intTop
336:                                       intRight  = pPb->hdr.right - GOL_EMBOSS_SIZE;
0097C4  78001E     MOV [W14], W0
0097C6  900060     MOV [W0+12], W0
0097C8  500063     SUB W0, #0x3, W0
0097CA  8887F0     MOV W0, intRight
337:                                       intBottom = x1;
0097CC  808790     MOV x1, W0
0097CE  8087A1     MOV 0x10F4, W1
0097D0  780000     MOV W0, W0
0097D2  888800     MOV W0, intBottom
0097D4  370010     BRA 0x97F6
338:                   	    	    } 
339:                                   else
340:                                   {
341:                                       intLeft   = x2; 
0097D6  8087B0     MOV x2, W0
0097D8  8087C1     MOV 0x10F8, W1
0097DA  780000     MOV W0, W0
0097DC  8887D0     MOV W0, intLeft
342:                                       intTop    = pPb->hdr.top + GOL_EMBOSS_SIZE;
0097DE  78001E     MOV [W14], W0
0097E0  900050     MOV [W0+10], W0
0097E2  400063     ADD W0, #0x3, W0
0097E4  8887E0     MOV W0, intTop
343:                                       intRight  = x1;
0097E6  808790     MOV x1, W0
0097E8  8087A1     MOV 0x10F4, W1
0097EA  780000     MOV W0, W0
0097EC  8887F0     MOV W0, intRight
344:                                       intBottom = pPb->hdr.bottom - GOL_EMBOSS_SIZE;
0097EE  78001E     MOV [W14], W0
0097F0  900070     MOV [W0+14], W0
0097F2  500063     SUB W0, #0x3, W0
0097F4  888800     MOV W0, intBottom
345:                       	        }     
346:                               }
347:                               state = BAR_DRAW;
0097F6  200040     MOV #0x4, W0
0097F8  888780     MOV W0, state
348:               
349:                           case BAR_DRAW:
350:                  
351:                               if(!Bar(intLeft, intTop, intRight, intBottom))
0097FA  808800     MOV intBottom, W0
0097FC  780180     MOV W0, W3
0097FE  8087F0     MOV intRight, W0
009800  780100     MOV W0, W2
009802  8087E0     MOV intTop, W0
009804  780080     MOV W0, W1
009806  8087D0     MOV intLeft, W0
009808  07DE59     RCALL Bar
00980A  500FE0     SUB W0, #0x0, [W15]
00980C  3A0002     BRA NZ, 0x9812
352:                  	                return (0);
00980E  EB0000     CLR W0
009810  3700F5     BRA 0x99FC
353:                   
354:                               if (GetState(pPb, PB_NOPROGRESS) || (pPb->hdr.pGolScheme->pFont == NULL))
009812  78001E     MOV [W14], W0
009814  900030     MOV [W0+6], W0
009816  600068     AND W0, #0x8, W0
009818  500FE0     SUB W0, #0x0, [W15]
00981A  3A0005     BRA NZ, 0x9826
00981C  78001E     MOV [W14], W0
00981E  900800     MOV [W0+16], W0
009820  900050     MOV [W0+10], W0
009822  500FE0     SUB W0, #0x0, [W15]
009824  3A0008     BRA NZ, 0x9836
355:                               {
356:                                   state = REMOVE;
009826  EB0000     CLR W0
009828  888780     MOV W0, state
357:                                   pPb->prevPos = pPb->pos;
00982A  78001E     MOV [W14], W0
00982C  9008D0     MOV [W0+26], W1
00982E  78001E     MOV [W14], W0
009830  980861     MOV W1, [W0+28]
358:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
359:               	                GFX_DRIVER_CompleteDrawUpdate(   pPb->hdr.left,
360:               	                                                pPb->hdr.top,
361:               	                                                pPb->hdr.right,
362:               	                                                pPb->hdr.bottom);
363:               #endif
364:                                   return (1);
009832  200010     MOV #0x1, W0
009834  3700E3     BRA 0x99FC
365:                               }
366:               
367:                          	    if(GetState(pPb, PB_VERTICAL))
009836  78001E     MOV [W14], W0
009838  900030     MOV [W0+6], W0
00983A  600064     AND W0, #0x4, W0
00983C  500FE0     SUB W0, #0x0, [W15]
00983E  32001D     BRA Z, 0x987A
368:                      	        {
369:                   	            SetColor(pPb->hdr.pGolScheme->Color0);
009840  78001E     MOV [W14], W0
009842  900800     MOV [W0+16], W0
009844  904050     MOV.B [W0+5], W0
009846  B7F13E     MOV.B WREG, _color
370:                                   intLeft   = pPb->hdr.left + GOL_EMBOSS_SIZE;
009848  78001E     MOV [W14], W0
00984A  900040     MOV [W0+8], W0
00984C  400063     ADD W0, #0x3, W0
00984E  8887D0     MOV W0, intLeft
371:                                   intTop    = (pPb->hdr.top + pPb->hdr.bottom - GetTextHeight(pPb->hdr.pGolScheme->pFont)) >> 1;
009850  78001E     MOV [W14], W0
009852  9000D0     MOV [W0+10], W1
009854  78001E     MOV [W14], W0
009856  900070     MOV [W0+14], W0
009858  408400     ADD W1, W0, W8
00985A  78001E     MOV [W14], W0
00985C  900800     MOV [W0+16], W0
00985E  900050     MOV [W0+10], W0
009860  07E6F7     RCALL GetTextHeight
009862  540000     SUB W8, W0, W0
009864  D18000     ASR W0, W0
009866  8887E0     MOV W0, intTop
372:                   	            intRight  = pPb->hdr.right - GOL_EMBOSS_SIZE;
009868  78001E     MOV [W14], W0
00986A  900060     MOV [W0+12], W0
00986C  500063     SUB W0, #0x3, W0
00986E  8887F0     MOV W0, intRight
373:                   	            intBottom = x2;
009870  8087B0     MOV x2, W0
009872  8087C1     MOV 0x10F8, W1
009874  780000     MOV W0, W0
009876  888800     MOV W0, intBottom
009878  37001E     BRA 0x98B6
374:                   			} 
375:                   			else
376:                   			{
377:                   	            SetColor(pPb->hdr.pGolScheme->Color1);
00987A  78001E     MOV [W14], W0
00987C  900800     MOV [W0+16], W0
00987E  904060     MOV.B [W0+6], W0
009880  B7F13E     MOV.B WREG, _color
378:                                   intLeft   = (pPb->hdr.left + pPb->hdr.right - GetTextWidth(text, pPb->hdr.pGolScheme->pFont)) >> 1;
009882  78001E     MOV [W14], W0
009884  9000C0     MOV [W0+8], W1
009886  78001E     MOV [W14], W0
009888  900060     MOV [W0+12], W0
00988A  408400     ADD W1, W0, W8
00988C  78001E     MOV [W14], W0
00988E  900800     MOV [W0+16], W0
009890  900050     MOV [W0+10], W0
009892  780080     MOV W0, W1
009894  211760     MOV #0x1176, W0
009896  07E6C1     RCALL GetTextWidth
009898  540000     SUB W8, W0, W0
00989A  D18000     ASR W0, W0
00989C  8887D0     MOV W0, intLeft
379:                   	            intTop    = pPb->hdr.top + GOL_EMBOSS_SIZE;
00989E  78001E     MOV [W14], W0
0098A0  900050     MOV [W0+10], W0
0098A2  400063     ADD W0, #0x3, W0
0098A4  8887E0     MOV W0, intTop
380:                   	            intRight  = x1;
0098A6  808790     MOV x1, W0
0098A8  8087A1     MOV 0x10F4, W1
0098AA  780000     MOV W0, W0
0098AC  8887F0     MOV W0, intRight
381:                   	            intBottom = pPb->hdr.bottom - GOL_EMBOSS_SIZE;
0098AE  78001E     MOV [W14], W0
0098B0  900070     MOV [W0+14], W0
0098B2  500063     SUB W0, #0x3, W0
0098B4  888800     MOV W0, intBottom
382:                   			}	
383:               
384:                               state = TEXT_DRAW1;
0098B6  200050     MOV #0x5, W0
0098B8  888780     MOV W0, state
385:                   
386:                           case TEXT_DRAW1:
387:                               if(!Bar(intLeft, intTop, intRight, intBottom))
0098BA  808800     MOV intBottom, W0
0098BC  780180     MOV W0, W3
0098BE  8087F0     MOV intRight, W0
0098C0  780100     MOV W0, W2
0098C2  8087E0     MOV intTop, W0
0098C4  780080     MOV W0, W1
0098C6  8087D0     MOV intLeft, W0
0098C8  07DDF9     RCALL Bar
0098CA  500FE0     SUB W0, #0x0, [W15]
0098CC  3A0002     BRA NZ, 0x98D2
388:                  	                return (0);
0098CE  EB0000     CLR W0
0098D0  370095     BRA 0x99FC
389:               
390:                           	if(GetState(pPb, PB_VERTICAL))
0098D2  78001E     MOV [W14], W0
0098D4  900030     MOV [W0+6], W0
0098D6  600064     AND W0, #0x4, W0
0098D8  500FE0     SUB W0, #0x0, [W15]
0098DA  32001D     BRA Z, 0x9916
391:                      	        {
392:                   	            SetColor(pPb->hdr.pGolScheme->Color1);
0098DC  78001E     MOV [W14], W0
0098DE  900800     MOV [W0+16], W0
0098E0  904060     MOV.B [W0+6], W0
0098E2  B7F13E     MOV.B WREG, _color
393:                                   intLeft   = pPb->hdr.left + GOL_EMBOSS_SIZE;
0098E4  78001E     MOV [W14], W0
0098E6  900040     MOV [W0+8], W0
0098E8  400063     ADD W0, #0x3, W0
0098EA  8887D0     MOV W0, intLeft
394:                                   intTop    = x2;
0098EC  8087B0     MOV x2, W0
0098EE  8087C1     MOV 0x10F8, W1
0098F0  780000     MOV W0, W0
0098F2  8887E0     MOV W0, intTop
395:                   	            intRight  = pPb->hdr.right - GOL_EMBOSS_SIZE;
0098F4  78001E     MOV [W14], W0
0098F6  900060     MOV [W0+12], W0
0098F8  500063     SUB W0, #0x3, W0
0098FA  8887F0     MOV W0, intRight
396:                   	            intBottom = (pPb->hdr.top + pPb->hdr.bottom + GetTextHeight(pPb->hdr.pGolScheme->pFont)) >> 1;
0098FC  78001E     MOV [W14], W0
0098FE  9000D0     MOV [W0+10], W1
009900  78001E     MOV [W14], W0
009902  900070     MOV [W0+14], W0
009904  408400     ADD W1, W0, W8
009906  78001E     MOV [W14], W0
009908  900800     MOV [W0+16], W0
00990A  900050     MOV [W0+10], W0
00990C  07E6A1     RCALL GetTextHeight
00990E  440000     ADD W8, W0, W0
009910  D18000     ASR W0, W0
009912  888800     MOV W0, intBottom
009914  37001E     BRA 0x9952
397:                   			}
398:                   			else 
399:                   			{
400:                   	            SetColor(pPb->hdr.pGolScheme->Color0);
009916  78001E     MOV [W14], W0
009918  900800     MOV [W0+16], W0
00991A  904050     MOV.B [W0+5], W0
00991C  B7F13E     MOV.B WREG, _color
401:                                   intLeft   = x1;
00991E  808790     MOV x1, W0
009920  8087A1     MOV 0x10F4, W1
009922  780000     MOV W0, W0
009924  8887D0     MOV W0, intLeft
402:                   	            intTop    = pPb->hdr.top + GOL_EMBOSS_SIZE;
009926  78001E     MOV [W14], W0
009928  900050     MOV [W0+10], W0
00992A  400063     ADD W0, #0x3, W0
00992C  8887E0     MOV W0, intTop
403:                   	            intRight  = (pPb->hdr.left + pPb->hdr.right + GetTextWidth(text, pPb->hdr.pGolScheme->pFont)) >> 1;
00992E  78001E     MOV [W14], W0
009930  9000C0     MOV [W0+8], W1
009932  78001E     MOV [W14], W0
009934  900060     MOV [W0+12], W0
009936  408400     ADD W1, W0, W8
009938  78001E     MOV [W14], W0
00993A  900800     MOV [W0+16], W0
00993C  900050     MOV [W0+10], W0
00993E  780080     MOV W0, W1
009940  211760     MOV #0x1176, W0
009942  07E66B     RCALL GetTextWidth
009944  440000     ADD W8, W0, W0
009946  D18000     ASR W0, W0
009948  8887F0     MOV W0, intRight
404:                   	            intBottom = pPb->hdr.bottom - GOL_EMBOSS_SIZE;
00994A  78001E     MOV [W14], W0
00994C  900070     MOV [W0+14], W0
00994E  500063     SUB W0, #0x3, W0
009950  888800     MOV W0, intBottom
405:                   			}	 
406:                               state = TEXT_DRAW2;
009952  200060     MOV #0x6, W0
009954  888780     MOV W0, state
407:                   
408:                           case TEXT_DRAW2:
409:                               if(!Bar(intLeft, intTop, intRight, intBottom))
009956  808800     MOV intBottom, W0
009958  780180     MOV W0, W3
00995A  8087F0     MOV intRight, W0
00995C  780100     MOV W0, W2
00995E  8087E0     MOV intTop, W0
009960  780080     MOV W0, W1
009962  8087D0     MOV intLeft, W0
009964  07DDAB     RCALL Bar
009966  500FE0     SUB W0, #0x0, [W15]
009968  3A0002     BRA NZ, 0x996E
410:                  	                return (0);
00996A  EB0000     CLR W0
00996C  370047     BRA 0x99FC
411:                   
412:                               PbWordToString((DWORD) pPb->pos * 100 / pPb->range, text);
00996E  78001E     MOV [W14], W0
009970  900850     MOV [W0+26], W0
009972  200001     MOV #0x0, W1
009974  200642     MOV #0x64, W2
009976  B98902     MUL.SS W1, W2, W2
009978  780102     MOV W2, W2
00997A  B90260     MUL.SU W0, #0, W4
00997C  780184     MOV W4, W3
00997E  410103     ADD W2, W3, W2
009980  200643     MOV #0x64, W3
009982  B80003     MUL.UU W0, W3, W0
009984  410101     ADD W2, W1, W2
009986  780082     MOV W2, W1
009988  78011E     MOV [W14], W2
00998A  900972     MOV [W2+30], W2
00998C  200003     MOV #0x0, W3
00998E  07C165     RCALL ___udivsi3
009990  780000     MOV W0, W0
009992  211761     MOV #0x1176, W1
009994  07FCED     RCALL PbWordToString
413:                               SetColor(pPb->hdr.pGolScheme->TextColor0);
009996  78001E     MOV [W14], W0
009998  900800     MOV [W0+16], W0
00999A  904020     MOV.B [W0+2], W0
00999C  B7F13E     MOV.B WREG, _color
414:                   
415:                               MoveTo
00999E  78001E     MOV [W14], W0
0099A0  9000C0     MOV [W0+8], W1
0099A2  78001E     MOV [W14], W0
0099A4  900060     MOV [W0+12], W0
0099A6  408400     ADD W1, W0, W8
0099A8  78001E     MOV [W14], W0
0099AA  900800     MOV [W0+16], W0
0099AC  900050     MOV [W0+10], W0
0099AE  780080     MOV W0, W1
0099B0  211760     MOV #0x1176, W0
0099B2  07E633     RCALL GetTextWidth
0099B4  540000     SUB W8, W0, W0
0099B6  D18000     ASR W0, W0
0099B8  888260     MOV W0, _cursorX
0099BA  78001E     MOV [W14], W0
0099BC  9000D0     MOV [W0+10], W1
0099BE  78001E     MOV [W14], W0
0099C0  900070     MOV [W0+14], W0
0099C2  408400     ADD W1, W0, W8
0099C4  78001E     MOV [W14], W0
0099C6  900800     MOV [W0+16], W0
0099C8  900050     MOV [W0+10], W0
0099CA  07E642     RCALL GetTextHeight
0099CC  540000     SUB W8, W0, W0
0099CE  D18000     ASR W0, W0
0099D0  888270     MOV W0, _cursorY
416:                               (
417:                                   (pPb->hdr.left + pPb->hdr.right - GetTextWidth(text, pPb->hdr.pGolScheme->pFont)) >> 1,
418:                                   (pPb->hdr.top + pPb->hdr.bottom - GetTextHeight(pPb->hdr.pGolScheme->pFont)) >> 1
419:                               );
420:                   
421:                               SetFont(pPb->hdr.pGolScheme->pFont);
0099D2  78001E     MOV [W14], W0
0099D4  900800     MOV [W0+16], W0
0099D6  900050     MOV [W0+10], W0
0099D8  07E43F     RCALL SetFont
422:                               state = TEXT_DRAW3;
0099DA  200070     MOV #0x7, W0
0099DC  888780     MOV W0, state
423:                   
424:                           case TEXT_DRAW3:
425:                               if(!OutText(text))
0099DE  211760     MOV #0x1176, W0
0099E0  07E591     RCALL OutText
0099E2  500FE0     SUB W0, #0x0, [W15]
0099E4  3A0002     BRA NZ, 0x99EA
426:                                   return (0);
0099E6  EB0000     CLR W0
0099E8  370009     BRA 0x99FC
427:                   
428:                               pPb->prevPos = pPb->pos;
0099EA  78001E     MOV [W14], W0
0099EC  9008D0     MOV [W0+26], W1
0099EE  78001E     MOV [W14], W0
0099F0  980861     MOV W1, [W0+28]
429:                               state = REMOVE;
0099F2  EB0000     CLR W0
0099F4  888780     MOV W0, state
430:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
431:                           GFX_DRIVER_CompleteDrawUpdate(   pPb->hdr.left,
432:                                                           pPb->hdr.top,
433:                                                           pPb->hdr.right,
434:                                                           pPb->hdr.bottom);
435:               #endif
436:                               return (1);
0099F6  200010     MOV #0x1, W0
0099F8  370001     BRA 0x99FC
437:                       } // end of switch()
438:                   } // end of while(1)
009558  000000     NOP
0099FA  37FDAF     BRA 0x955A
439:               }
0099FC  78044F     MOV [--W15], W8
0099FE  FA8000     ULNK
009A00  060000     RETURN
440:               
441:               #endif // USE_PROGRESSBAR
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/Primitive.c  ---------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library
3:                  *  Graphic Primitives Layer
4:                  *****************************************************************************
5:                  * FileName:        Primitive.c
6:                  * Processor:       PIC24, dsPIC, PIC32
7:                  * Compiler:       	MPLAB C30, MPLAB C32
8:                  * Company:         Microchip Technology Incorporated
9:                  *
10:                 * Software License Agreement
11:                 *
12:                 * Copyright (c) 2011 Microchip Technology Inc.  All rights reserved.
13:                 * Microchip licenses to you the right to use, modify, copy and distribute
14:                 * Software only when embedded on a Microchip microcontroller or digital
15:                 * signal controller, which is integrated into your product or third party
16:                 * product (pursuant to the sublicense terms in the accompanying license
17:                 * agreement).  
18:                 *
19:                 * You should refer to the license agreement accompanying this Software
20:                 * for additional information regarding your rights and obligations.
21:                 *
22:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
23:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
24:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
25:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
26:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
27:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
28:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
29:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
30:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
31:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
32:                 * OR OTHER SIMILAR COSTS.
33:                 *
34:                 * Date         Comment
35:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
36:                 * 11/12/07     Version 1.0 release
37:                 * 05/11/10     Added dynamic Arc() where start and end
38:                 *									angle can be specified.
39:                 * 03/04/11     - Removed SetColor(WHITE) in InitGraph(). Default color
40:                 *                after InitGraph() is not 0 (BLACK in most displays).
41:                 *              - removed USE_DRV_XX checks, replaced them with 
42:                 *                weak attributes.
43:                 * 05/13/11     Add Transparent Color support in PutImage() and PutImageRLE()
44:                 *              functions defined in this layer. 
45:                 * 05/20/11     Added GetCirclePoint() commonly used in Widgets.
46:                 * 07/05/11     Fixed GetTextHeight() limitation of 127 pixels. Limitation
47:                 *              is now 256 pixels. 
48:                 * 01/05/12     - Removed the _font global pointer and replaced with currentFont
49:                 *                structure to make faster OutChar() rendering. 
50:                 *              - Removed _fontFirstChar, _fontLastChar and _fontHeight globals.
51:                 *                These are now included in currentFont.
52:                 *              - modified OutChar(), GetTextWidth() and GetTextHeight() to 
53:                 *                use of new currentFont structure.
54:                 *              - break up SetFont(), OutChar() and GetTextWidth() to allow
55:                 *                versatility of implementing text rendering functions in drivers.
56:                 *              - added extended glyph support and font anti-aliasing
57:                 * 05/01/12     - Added clipping support commonly used in drivers
58:                 *              - Added putimagepartial support                          
59:                 * 06/11/12     - Added alpha blending support for Bar(), FillBevel(), Arc().
60:                 * 10/16/12     Fixed issue on PutImageRLExBpp() &  PutImageRLExBppExt() when
61:                 *              system level palette is used. 
62:                 *****************************************************************************/
63:                #include "HardwareProfile.h"              // needed to provide values for GetMaxX() and GetMaxY() macros
64:                #include "Graphics/DisplayDriver.h"
65:                #include "Graphics/Primitive.h"
66:                #include "Compiler.h" 
67:                
68:                /////////////////////// LOCAL FUNCTIONS PROTOTYPES ////////////////////////////
69:                #ifdef USE_BITMAP_FLASH
70:                    void    PutImage1BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData);
71:                    void    PutImage4BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData);
72:                    void    PutImage8BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData);
73:                    void    PutImage16BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData);         
74:                
75:                #ifdef USE_COMP_RLE
76:                    void    PutImageRLE4BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch);
77:                    void    PutImageRLE8BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch);
78:                #endif
79:                #endif
80:                
81:                #ifdef USE_BITMAP_EXTERNAL
82:                    void    PutImage1BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData); 
83:                    void    PutImage4BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData); 
84:                    void    PutImage8BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData); 
85:                    void    PutImage16BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData);
86:                
87:                #ifdef USE_COMP_RLE
88:                    void    PutImageRLE4BPPExt(SHORT left, SHORT top, void *image, BYTE stretch);
89:                    void    PutImageRLE8BPPExt(SHORT left, SHORT top, void *image, BYTE stretch);
90:                #endif
91:                #endif
92:                
93:                // Current line type
94:                SHORT   _lineType;
95:                
96:                // Current line thickness
97:                BYTE    _lineThickness;
98:                
99:                // Font orientation
100:               BYTE    _fontOrientation;
101:               
102:               // Current cursor x-coordinates
103:               SHORT   _cursorX;
104:               
105:               // Current cursor y-coordinates
106:               SHORT   _cursorY;
107:               
108:               // information on currently set font
109:               GFX_FONT_CURRENT currentFont;
110:               
111:               
112:               #ifdef USE_ANTIALIASED_FONTS
113:               
114:                   BYTE    _antialiastype;
115:               
116:               	#ifdef USE_PALETTE
117:               
118:               		#error "Antialiasing can not be used when Palette is enabled"
119:               
120:               	#endif
121:               
122:               #endif
123:               
124:               #ifdef USE_PALETTE
125:               
126:                   void    *_palette;
127:               
128:               #endif
129:               
130:               // bevel drawing type (0 = full bevel, 0xF0 - top bevel only, 0x0F - bottom bevel only
131:               BYTE _bevelDrawType; 
132:               
133:               #define COSINETABLEENTRIES	90
134:               // Cosine table used to calculate angles when rendering circular objects and  arcs  
135:               // Make cosine values * 256 instead of 100 for easier math later
136:               const SHORT   _CosineTable[COSINETABLEENTRIES+1] __attribute__((aligned(2))) = 
137:               						{	
138:               							256, 256, 256, 256, 255, 255, 255, 254, 254, 253,
139:               							252, 251, 250, 249, 248, 247, 246, 245, 243, 242,
140:               							241, 239, 237, 236, 234, 232, 230, 228, 226, 224,
141:               							222, 219, 217, 215, 212, 210, 207, 204, 202, 199,
142:               							196, 193, 190, 187, 184, 181, 178, 175, 171, 168,
143:               							165, 161, 158, 154, 150, 147, 143, 139, 136, 132,
144:               							128, 124, 120, 116, 112, 108, 104, 100, 96,  92,
145:               							88,  83,  79,  75,  71,  66,  62,  58,  53,  49,
146:               							44,  40,  36,  31,  27,  22,  18,  13,  9,   4, 
147:               							0 
148:               						};
149:               
150:               #ifdef USE_ALPHABLEND_LITE
151:               GFX_COLOR _prevAlphaColor = BLACK;
152:               BYTE      _alpha = 100;
153:               #endif
154:               
155:               /*********************************************************************
156:               * Function: SetClipRgn(left, top, right, bottom)
157:               *
158:               * Overview: Sets clipping region.
159:               *
160:               * PreCondition: none
161:               *
162:               * Input: left - Defines the left clipping region border.
163:               *		 top - Defines the top clipping region border.
164:               *		 right - Defines the right clipping region border.
165:               *	     bottom - Defines the bottom clipping region border.
166:               *
167:               * Output: none
168:               *
169:               * Side Effects: none
170:               *
171:               ********************************************************************/
172:               void __attribute__((weak)) SetClipRgn(SHORT left, SHORT top, SHORT right, SHORT bottom)
173:               {
005490  FA0008     LNK #0x8
005492  780F00     MOV W0, [W14]
005494  980711     MOV W1, [W14+2]
005496  980722     MOV W2, [W14+4]
005498  980733     MOV W3, [W14+6]
174:                   _clipLeft=left;
00549A  78001E     MOV [W14], W0
00549C  8889B0     MOV W0, _clipLeft
175:                   _clipTop=top;
00549E  90001E     MOV [W14+2], W0
0054A0  8889C0     MOV W0, _clipTop
176:                   _clipRight=right;
0054A2  90002E     MOV [W14+4], W0
0054A4  8889D0     MOV W0, _clipRight
177:                   _clipBottom=bottom;
0054A6  90003E     MOV [W14+6], W0
0054A8  8889E0     MOV W0, _clipBottom
178:               
179:               }
0054AA  FA8000     ULNK
0054AC  060000     RETURN
180:               
181:               /*********************************************************************
182:               * Function: SetClip(control)
183:               *
184:               * Overview: Enables/disables clipping.
185:               *
186:               * PreCondition: none
187:               *
188:               * Input: control - Enables or disables the clipping.
189:               *			- 0: Disable clipping
190:               *			- 1: Enable clipping
191:               *
192:               * Output: none
193:               *
194:               * Side Effects: none
195:               *
196:               ********************************************************************/
197:               void __attribute__((weak)) SetClip(BYTE control)
198:               {
0054AE  FA0002     LNK #0x2
0054B0  784F00     MOV.B W0, [W14]
199:                   _clipRgn=control;
0054B2  78409E     MOV.B [W14], W1
0054B4  FB8001     ZE W1, W0
0054B6  8889A0     MOV W0, _clipRgn
200:               }
0054B8  FA8000     ULNK
0054BA  060000     RETURN
201:               
202:               #ifdef USE_ALPHABLEND_LITE
203:               /*********************************************************************
204:               * Function: void BarAlpha(SHORT left, SHORT top, SHORT right, SHORT bottom)
205:               *
206:               * PreCondition: alphaPercentage > 0
207:               *
208:               * Input: left,top - top left corner coordinates,
209:               *        right,bottom - bottom right corner coordinates
210:               *
211:               * Output: For NON-Blocking configuration:
212:               *         - Returns 0 when device is busy and the shape is not yet completely drawn.
213:               *         - Returns 1 when the shape is completely drawn.
214:               *         For Blocking configuration:
215:               *         - Always return 1.
216:               *
217:               * Side Effects: none
218:               *
219:               * Overview: Draws alpha blended bar. The bar is color is alpha blended to the
220:               *           current pixel colors in the display buffer area set by left, top, right
221:               *           and bottom. The alpha blending percentage used is the value set by 
222:               *           SetAlpha(). 
223:               *
224:               * Note: none
225:               *
226:               ********************************************************************/
227:               WORD __attribute__((weak)) BarAlpha(SHORT left, SHORT top,WORD  right, WORD bottom)
228:               {
229:               
230:                   SHORT x,y;
231:                   GFX_COLOR  fcolor, bcolor, newColor;
232:                   
233:                   // save current color
234:                   newColor = fcolor = GetColor();
235:               
236:                   for(y=top;y<bottom+1;y++)
237:                   {
238:                       if(GetPrevAlphaColor() != BLACK)
239:                       {
240:                           for(x=left;x<right+1;x++)
241:                           {
242:                               bcolor = GetPixel(x,y);
243:                               switch(GetAlpha())
244:                               {
245:                                   case 50: newColor = (bcolor - ConvertColor50(GetPrevAlphaColor())) + ConvertColor50(fcolor);break;
246:                                   case 75: newColor = (bcolor - ConvertColor75(GetPrevAlphaColor())) + ConvertColor75(fcolor);break;
247:                                   case 25: newColor = (bcolor - ConvertColor25(GetPrevAlphaColor())) + ConvertColor25(fcolor);break;
248:                                   default: break;
249:                               }
250:                               SetColor(newColor);
251:                               PutPixel(x,y);
252:                           }     
253:                       }
254:                       else
255:                       {                          
256:                           for(x=left;x<right+1;x++)
257:                           {
258:                               bcolor = GetPixel(x,y);
259:                               switch(GetAlpha())
260:                               {
261:                                   case 50: newColor = ConvertColor50(fcolor) + ConvertColor50(bcolor); break;
262:                                   case 25: newColor = ConvertColor25(fcolor) + ConvertColor75(bcolor); break;
263:                                   case 75: newColor = ConvertColor75(fcolor) + ConvertColor25(bcolor); break;
264:                                   default: break;
265:                               } 
266:                               SetColor(newColor);
267:                               PutPixel(x,y);
268:                           } 
269:                       }        
270:                   }
271:               
272:                   // reset to original _color
273:                   SetColor(fcolor); 
274:                   return (1);
275:               }
276:               #endif
277:               
278:               /*********************************************************************
279:               * Function: WORD Bar(SHORT left, SHORT top, SHORT right, SHORT bottom)
280:               *
281:               * PreCondition: none
282:               *
283:               
284:               * Input: left,top - top left corner coordinates,
285:               *        right,bottom - bottom right corner coordinates
286:               *
287:               * Output: For NON-Blocking configuration:
288:               *         - Returns 0 when device is busy and the shape is not yet completely drawn.
289:               *         - Returns 1 when the shape is completely drawn.
290:               *         For Blocking configuration:
291:               *         - Always return 1.
292:               *
293:               * Side Effects: none
294:               *
295:               * Overview: draws rectangle filled with current color
296:               *
297:               * Note: none
298:               *
299:               ********************************************************************/
300:               WORD __attribute__((weak)) Bar(SHORT left, SHORT top, SHORT right, SHORT bottom)
301:               {
0054BC  FA000C     LNK #0xC
0054BE  980720     MOV W0, [W14+4]
0054C0  980731     MOV W1, [W14+6]
0054C2  980742     MOV W2, [W14+8]
0054C4  980753     MOV W3, [W14+10]
302:                   SHORT   x, y;
303:               
304:               #ifndef USE_NONBLOCKING_CONFIG
305:                   while(IsDeviceBusy() != 0) Nop();
0054C6  370001     BRA 0x54CA
0054C8  000000     NOP
0054CA  073723     RCALL IsDeviceBusy
0054CC  500FE0     SUB W0, #0x0, [W15]
0054CE  3AFFFC     BRA NZ, 0x54C8
306:               
307:                   /* Ready */
308:               #else
309:                   if(IsDeviceBusy() != 0)
310:                       return (0);
311:               #endif
312:               
313:               #ifdef USE_ALPHABLEND_LITE
314:                   // NOTE: Alpha is never set to 0 so no need to check
315:                   if(GetAlpha() != 100) 
316:                   {
317:                       return (BarAlpha(left,top,right,bottom));
318:                   }
319:                   else 
320:                       // if alpha = 100, then just perform the normal Bar() rendering
321:                       // since pixel colors will be replaced by the SetColor()
322:               #endif
323:                   {
324:                       for(y = top; y < bottom + 1; y++)
0054D0  90003E     MOV [W14+6], W0
0054D2  980710     MOV W0, [W14+2]
0054D4  37000E     BRA 0x54F2
0054EC  90001E     MOV [W14+2], W0
0054EE  E80000     INC W0, W0
0054F0  980710     MOV W0, [W14+2]
0054F2  90005E     MOV [W14+10], W0
0054F4  E80080     INC W0, W1
0054F6  90001E     MOV [W14+2], W0
0054F8  508F80     SUB W1, W0, [W15]
0054FA  3CFFED     BRA GT, 0x54D6
325:                           for(x = left; x < right + 1; x++)
0054D6  90002E     MOV [W14+4], W0
0054D8  780F00     MOV W0, [W14]
0054DA  370004     BRA 0x54E4
0054E2  E80F1E     INC [W14], [W14]
0054E4  90004E     MOV [W14+8], W0
0054E6  E80000     INC W0, W0
0054E8  500F9E     SUB W0, [W14], [W15]
0054EA  3CFFF8     BRA GT, 0x54DC
326:                               PutPixel(x, y);
0054DC  90009E     MOV [W14+2], W1
0054DE  78001E     MOV [W14], W0
0054E0  0736E4     RCALL PutPixel
327:                   }
328:                   return (1);
0054FC  200010     MOV #0x1, W0
329:               }
0054FE  FA8000     ULNK
005500  060000     RETURN
330:               
331:               /*********************************************************************
332:               * Function: WORD Line(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
333:               *
334:               * PreCondition: none
335:               *
336:               * Input: x1,y1 - starting coordinates, x2,y2 - ending coordinates
337:               *
338:               * Output: For NON-Blocking configuration:
339:               *         - Returns 0 when device is busy and the shape is not yet completely drawn.
340:               *         - Returns 1 when the shape is completely drawn.
341:               *         For Blocking configuration:
342:               *         - Always return 1.
343:               *
344:               * Side Effects: none
345:               *
346:               * Overview: draws line
347:               *
348:               * Note: none
349:               *
350:               ********************************************************************/
351:               WORD __attribute__((weak)) Line(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
352:               {
005502  FA001E     LNK #0x1E
005504  980F30     MOV W0, [W14+22]
005506  980F41     MOV W1, [W14+24]
005508  980F52     MOV W2, [W14+26]
00550A  980F63     MOV W3, [W14+28]
353:                   SHORT   deltaX, deltaY;
354:                   SHORT   error, stepErrorLT, stepErrorGE;
355:                   SHORT   stepX, stepY;
356:                   SHORT   steep;
357:                   SHORT   temp;
358:                   SHORT   style, type;
359:               
360:                       #ifndef USE_NONBLOCKING_CONFIG
361:                   while(IsDeviceBusy() != 0) Nop();
00550C  370001     BRA 0x5510
00550E  000000     NOP
005510  073700     RCALL IsDeviceBusy
005512  500FE0     SUB W0, #0x0, [W15]
005514  3AFFFC     BRA NZ, 0x550E
362:               
363:                   /* Ready */
364:                       #else
365:                   if(IsDeviceBusy() != 0)
366:                       return (0);
367:                       #endif
368:               
369:                   // Move cursor
370:                   MoveTo(x2, y2);
005516  90085E     MOV [W14+26], W0
005518  888260     MOV W0, _cursorX
00551A  90086E     MOV [W14+28], W0
00551C  888270     MOV W0, _cursorY
371:               
372:                   if(x1 == x2)
00551E  9008BE     MOV [W14+22], W1
005520  90085E     MOV [W14+26], W0
005522  508F80     SUB W1, W0, [W15]
005524  3A0038     BRA NZ, 0x5596
373:                   {
374:                       if(y1 > y2)
005526  9008CE     MOV [W14+24], W1
005528  90086E     MOV [W14+28], W0
00552A  508F80     SUB W1, W0, [W15]
00552C  340006     BRA LE, 0x553A
375:                       {
376:                           temp = y1;
00552E  90084E     MOV [W14+24], W0
005530  980760     MOV W0, [W14+12]
377:                           y1 = y2;
005532  90086E     MOV [W14+28], W0
005534  980F40     MOV W0, [W14+24]
378:                           y2 = temp;
005536  90006E     MOV [W14+12], W0
005538  980F60     MOV W0, [W14+28]
379:                       }
380:               
381:                       style = 0;
00553A  EB0000     CLR W0
00553C  980770     MOV W0, [W14+14]
382:                       type = 1;
00553E  200010     MOV #0x1, W0
005540  980F00     MOV W0, [W14+16]
383:                       for(temp = y1; temp < y2 + 1; temp++)
005542  90084E     MOV [W14+24], W0
005544  980760     MOV W0, [W14+12]
005546  370020     BRA 0x5588
005582  90006E     MOV [W14+12], W0
005584  E80000     INC W0, W0
005586  980760     MOV W0, [W14+12]
005588  90086E     MOV [W14+28], W0
00558A  E80080     INC W0, W1
00558C  90006E     MOV [W14+12], W0
00558E  508F80     SUB W1, W0, [W15]
005590  3CFFDB     BRA GT, 0x5548
384:                       {
385:                           if((++style) == _lineType)
005548  90007E     MOV [W14+14], W0
00554A  E80000     INC W0, W0
00554C  980770     MOV W0, [W14+14]
00554E  808240     MOV _lineType, W0
005550  9000FE     MOV [W14+14], W1
005552  508F80     SUB W1, W0, [W15]
005554  3A0005     BRA NZ, 0x5560
386:                           {
387:                               type ^= 1;
005556  90080E     MOV [W14+16], W0
005558  A20000     BTG W0, #0
00555A  980F00     MOV W0, [W14+16]
388:                               style = 0;
00555C  EB0000     CLR W0
00555E  980770     MOV W0, [W14+14]
389:                           }
390:               
391:                           if(type)
005560  90080E     MOV [W14+16], W0
005562  500FE0     SUB W0, #0x0, [W15]
005564  32000E     BRA Z, 0x5582
392:                           {
393:                               PutPixel(x1, temp);
005566  9000EE     MOV [W14+12], W1
005568  90083E     MOV [W14+22], W0
00556A  07369F     RCALL PutPixel
394:                               if(_lineThickness)
00556C  BFD04A     MOV.B _lineThickness, WREG
00556E  504FE0     SUB.B W0, #0x0, [W15]
005570  320008     BRA Z, 0x5582
395:                               {
396:                                   PutPixel(x1 + 1, temp);
005572  90083E     MOV [W14+22], W0
005574  E80000     INC W0, W0
005576  9000EE     MOV [W14+12], W1
005578  073698     RCALL PutPixel
397:                                   PutPixel(x1 - 1, temp);
00557A  90083E     MOV [W14+22], W0
00557C  E90000     DEC W0, W0
00557E  9000EE     MOV [W14+12], W1
005580  073694     RCALL PutPixel
398:                               }
399:                           }
400:                       }
401:               
402:                       return (1);
005592  200010     MOV #0x1, W0
005594  3700DA     BRA 0x574A
403:                   }
404:               
405:                   if(y1 == y2)
005596  9008CE     MOV [W14+24], W1
005598  90086E     MOV [W14+28], W0
00559A  508F80     SUB W1, W0, [W15]
00559C  3A003A     BRA NZ, 0x5612
406:                   {
407:                       if(x1 > x2)
00559E  9008BE     MOV [W14+22], W1
0055A0  90085E     MOV [W14+26], W0
0055A2  508F80     SUB W1, W0, [W15]
0055A4  340006     BRA LE, 0x55B2
408:                       {
409:                           temp = x1;
0055A6  90083E     MOV [W14+22], W0
0055A8  980760     MOV W0, [W14+12]
410:                           x1 = x2;
0055AA  90085E     MOV [W14+26], W0
0055AC  980F30     MOV W0, [W14+22]
411:                           x2 = temp;
0055AE  90006E     MOV [W14+12], W0
0055B0  980F50     MOV W0, [W14+26]
412:                       }
413:               
414:                       style = 0;
0055B2  EB0000     CLR W0
0055B4  980770     MOV W0, [W14+14]
415:                       type = 1;
0055B6  200010     MOV #0x1, W0
0055B8  980F00     MOV W0, [W14+16]
416:                       for(temp = x1; temp < x2 + 1; temp++)
0055BA  90083E     MOV [W14+22], W0
0055BC  980760     MOV W0, [W14+12]
0055BE  370022     BRA 0x5604
0055FE  90006E     MOV [W14+12], W0
005600  E80000     INC W0, W0
005602  980760     MOV W0, [W14+12]
005604  90085E     MOV [W14+26], W0
005606  E80080     INC W0, W1
005608  90006E     MOV [W14+12], W0
00560A  508F80     SUB W1, W0, [W15]
00560C  3CFFD9     BRA GT, 0x55C0
417:                       {
418:                           if((++style) == _lineType)
0055C0  90007E     MOV [W14+14], W0
0055C2  E80000     INC W0, W0
0055C4  980770     MOV W0, [W14+14]
0055C6  808240     MOV _lineType, W0
0055C8  9000FE     MOV [W14+14], W1
0055CA  508F80     SUB W1, W0, [W15]
0055CC  3A0005     BRA NZ, 0x55D8
419:                           {
420:                               type ^= 1;
0055CE  90080E     MOV [W14+16], W0
0055D0  A20000     BTG W0, #0
0055D2  980F00     MOV W0, [W14+16]
421:                               style = 0;
0055D4  EB0000     CLR W0
0055D6  980770     MOV W0, [W14+14]
422:                           }
423:               
424:                           if(type)
0055D8  90080E     MOV [W14+16], W0
0055DA  500FE0     SUB W0, #0x0, [W15]
0055DC  320010     BRA Z, 0x55FE
425:                           {
426:                               PutPixel(temp, y1);
0055DE  9008CE     MOV [W14+24], W1
0055E0  90006E     MOV [W14+12], W0
0055E2  073663     RCALL PutPixel
427:                               if(_lineThickness)
0055E4  BFD04A     MOV.B _lineThickness, WREG
0055E6  504FE0     SUB.B W0, #0x0, [W15]
0055E8  32000A     BRA Z, 0x55FE
428:                               {
429:                                   PutPixel(temp, y1 + 1);
0055EA  90084E     MOV [W14+24], W0
0055EC  E80000     INC W0, W0
0055EE  780080     MOV W0, W1
0055F0  90006E     MOV [W14+12], W0
0055F2  07365B     RCALL PutPixel
430:                                   PutPixel(temp, y1 - 1);
0055F4  90084E     MOV [W14+24], W0
0055F6  E90000     DEC W0, W0
0055F8  780080     MOV W0, W1
0055FA  90006E     MOV [W14+12], W0
0055FC  073656     RCALL PutPixel
431:                               }
432:                           }
433:                       }
434:               
435:                       return (1);
00560E  200010     MOV #0x1, W0
005610  37009C     BRA 0x574A
436:                   }
437:               
438:                   stepX = 0;
005612  EB0000     CLR W0
005614  980730     MOV W0, [W14+6]
439:                   deltaX = x2 - x1;
005616  9008DE     MOV [W14+26], W1
005618  90083E     MOV [W14+22], W0
00561A  508F00     SUB W1, W0, [W14]
440:                   if(deltaX < 0)
00561C  78001E     MOV [W14], W0
00561E  500FE0     SUB W0, #0x0, [W15]
005620  3D0005     BRA GE, 0x562C
441:                   {
442:                       deltaX = -deltaX;
005622  EA0F1E     NEG [W14], [W14]
443:                       --stepX;
005624  90003E     MOV [W14+6], W0
005626  E90000     DEC W0, W0
005628  980730     MOV W0, [W14+6]
00562A  370003     BRA 0x5632
444:                   }
445:                   else
446:                   {
447:                       ++stepX;
00562C  90003E     MOV [W14+6], W0
00562E  E80000     INC W0, W0
005630  980730     MOV W0, [W14+6]
448:                   }
449:               
450:                   stepY = 0;
005632  EB0000     CLR W0
005634  980740     MOV W0, [W14+8]
451:                   deltaY = y2 - y1;
005636  9008EE     MOV [W14+28], W1
005638  90084E     MOV [W14+24], W0
00563A  508000     SUB W1, W0, W0
00563C  980710     MOV W0, [W14+2]
452:                   if(deltaY < 0)
00563E  90001E     MOV [W14+2], W0
005640  500FE0     SUB W0, #0x0, [W15]
005642  3D0007     BRA GE, 0x5652
453:                   {
454:                       deltaY = -deltaY;
005644  90001E     MOV [W14+2], W0
005646  EA0000     NEG W0, W0
005648  980710     MOV W0, [W14+2]
455:                       --stepY;
00564A  90004E     MOV [W14+8], W0
00564C  E90000     DEC W0, W0
00564E  980740     MOV W0, [W14+8]
005650  370003     BRA 0x5658
456:                   }
457:                   else
458:                   {
459:                       ++stepY;
005652  90004E     MOV [W14+8], W0
005654  E80000     INC W0, W0
005656  980740     MOV W0, [W14+8]
460:                   }
461:               
462:                   steep = 0;
005658  EB0000     CLR W0
00565A  980750     MOV W0, [W14+10]
463:                   if(deltaX < deltaY)
00565C  90001E     MOV [W14+2], W0
00565E  78009E     MOV [W14], W1
005660  508F80     SUB W1, W0, [W15]
005662  3D0019     BRA GE, 0x5696
464:                   {
465:                       ++steep;
005664  90005E     MOV [W14+10], W0
005666  E80000     INC W0, W0
005668  980750     MOV W0, [W14+10]
466:                       temp = deltaX;
00566A  78001E     MOV [W14], W0
00566C  980760     MOV W0, [W14+12]
467:                       deltaX = deltaY;
00566E  90001E     MOV [W14+2], W0
005670  780F00     MOV W0, [W14]
468:                       deltaY = temp;
005672  90006E     MOV [W14+12], W0
005674  980710     MOV W0, [W14+2]
469:                       temp = x1;
005676  90083E     MOV [W14+22], W0
005678  980760     MOV W0, [W14+12]
470:                       x1 = y1;
00567A  90084E     MOV [W14+24], W0
00567C  980F30     MOV W0, [W14+22]
471:                       y1 = temp;
00567E  90006E     MOV [W14+12], W0
005680  980F40     MOV W0, [W14+24]
472:                       temp = stepX;
005682  90003E     MOV [W14+6], W0
005684  980760     MOV W0, [W14+12]
473:                       stepX = stepY;
005686  90004E     MOV [W14+8], W0
005688  980730     MOV W0, [W14+6]
474:                       stepY = temp;
00568A  90006E     MOV [W14+12], W0
00568C  980740     MOV W0, [W14+8]
475:                       PutPixel(y1, x1);
00568E  9008BE     MOV [W14+22], W1
005690  90084E     MOV [W14+24], W0
005692  07360B     RCALL PutPixel
005694  370003     BRA 0x569C
476:                   }
477:                   else
478:                   {
479:                       PutPixel(x1, y1);
005696  9008CE     MOV [W14+24], W1
005698  90083E     MOV [W14+22], W0
00569A  073607     RCALL PutPixel
480:                   }
481:               
482:                   // If the current error greater or equal zero
483:                   stepErrorGE = deltaX << 1;
00569C  78001E     MOV [W14], W0
00569E  400000     ADD W0, W0, W0
0056A0  980F10     MOV W0, [W14+18]
484:               
485:                   // If the current error less than zero
486:                   stepErrorLT = deltaY << 1;
0056A2  90001E     MOV [W14+2], W0
0056A4  400000     ADD W0, W0, W0
0056A6  980F20     MOV W0, [W14+20]
487:               
488:                   // Error for the first pixel
489:                   error = stepErrorLT - deltaX;
0056A8  90082E     MOV [W14+20], W0
0056AA  50001E     SUB W0, [W14], W0
0056AC  980720     MOV W0, [W14+4]
490:               
491:                   style = 0;
0056AE  EB0000     CLR W0
0056B0  980770     MOV W0, [W14+14]
492:                   type = 1;
0056B2  200010     MOV #0x1, W0
0056B4  980F00     MOV W0, [W14+16]
493:               
494:                   while(--deltaX >= 0)
0056B6  370044     BRA 0x5740
005740  E90F1E     DEC [W14], [W14]
005742  78001E     MOV [W14], W0
005744  500FE0     SUB W0, #0x0, [W15]
005746  3DFFB8     BRA GE, 0x56B8
495:                   {
496:                       if(error >= 0)
0056B8  90002E     MOV [W14+4], W0
0056BA  500FE0     SUB W0, #0x0, [W15]
0056BC  350008     BRA LT, 0x56CE
497:                       {
498:                           y1 += stepY;
0056BE  9008CE     MOV [W14+24], W1
0056C0  90004E     MOV [W14+8], W0
0056C2  408000     ADD W1, W0, W0
0056C4  980F40     MOV W0, [W14+24]
499:                           error -= stepErrorGE;
0056C6  9000AE     MOV [W14+4], W1
0056C8  90081E     MOV [W14+18], W0
0056CA  508000     SUB W1, W0, W0
0056CC  980720     MOV W0, [W14+4]
500:                       }
501:               
502:                       x1 += stepX;
0056CE  9008BE     MOV [W14+22], W1
0056D0  90003E     MOV [W14+6], W0
0056D2  408000     ADD W1, W0, W0
0056D4  980F30     MOV W0, [W14+22]
503:                       error += stepErrorLT;
0056D6  9000AE     MOV [W14+4], W1
0056D8  90082E     MOV [W14+20], W0
0056DA  408000     ADD W1, W0, W0
0056DC  980720     MOV W0, [W14+4]
504:               
505:                       if((++style) == _lineType)
0056DE  90007E     MOV [W14+14], W0
0056E0  E80000     INC W0, W0
0056E2  980770     MOV W0, [W14+14]
0056E4  808240     MOV _lineType, W0
0056E6  9000FE     MOV [W14+14], W1
0056E8  508F80     SUB W1, W0, [W15]
0056EA  3A0005     BRA NZ, 0x56F6
506:                       {
507:                           type ^= 1;
0056EC  90080E     MOV [W14+16], W0
0056EE  A20000     BTG W0, #0
0056F0  980F00     MOV W0, [W14+16]
508:                           style = 0;
0056F2  EB0000     CLR W0
0056F4  980770     MOV W0, [W14+14]
509:                       }
510:               
511:                       if(type)
0056F6  90080E     MOV [W14+16], W0
0056F8  500FE0     SUB W0, #0x0, [W15]
0056FA  320022     BRA Z, 0x5740
512:                       {
513:                           if(steep)
0056FC  90005E     MOV [W14+10], W0
0056FE  500FE0     SUB W0, #0x0, [W15]
005700  32000F     BRA Z, 0x5720
514:                           {
515:                               PutPixel(y1, x1);
005702  9008BE     MOV [W14+22], W1
005704  90084E     MOV [W14+24], W0
005706  0735D1     RCALL PutPixel
516:                               if(_lineThickness)
005708  BFD04A     MOV.B _lineThickness, WREG
00570A  504FE0     SUB.B W0, #0x0, [W15]
00570C  320019     BRA Z, 0x5740
517:                               {
518:                                   PutPixel(y1 + 1, x1);
00570E  90084E     MOV [W14+24], W0
005710  E80000     INC W0, W0
005712  9008BE     MOV [W14+22], W1
005714  0735CA     RCALL PutPixel
519:                                   PutPixel(y1 - 1, x1);
005716  90084E     MOV [W14+24], W0
005718  E90000     DEC W0, W0
00571A  9008BE     MOV [W14+22], W1
00571C  0735C6     RCALL PutPixel
00571E  370010     BRA 0x5740
520:                               }
521:                           }
522:                           else
523:                           {
524:                               PutPixel(x1, y1);
005720  9008CE     MOV [W14+24], W1
005722  90083E     MOV [W14+22], W0
005724  0735C2     RCALL PutPixel
525:                               if(_lineThickness)
005726  BFD04A     MOV.B _lineThickness, WREG
005728  504FE0     SUB.B W0, #0x0, [W15]
00572A  32000A     BRA Z, 0x5740
526:                               {
527:                                   PutPixel(x1, y1 + 1);
00572C  90084E     MOV [W14+24], W0
00572E  E80000     INC W0, W0
005730  780080     MOV W0, W1
005732  90083E     MOV [W14+22], W0
005734  0735BA     RCALL PutPixel
528:                                   PutPixel(x1, y1 - 1);
005736  90084E     MOV [W14+24], W0
005738  E90000     DEC W0, W0
00573A  780080     MOV W0, W1
00573C  90083E     MOV [W14+22], W0
00573E  0735B5     RCALL PutPixel
529:                               }
530:                           }
531:                       }
532:                   }   // end of while
533:               
534:                   return (1);
005748  200010     MOV #0x1, W0
535:               }
00574A  FA8000     ULNK
00574C  060000     RETURN
536:               
537:               /*********************************************************************
538:               * Function: void ClearDevice(void)
539:               *
540:               * PreCondition: none
541:               *
542:               * Input: none
543:               *
544:               * Output: none
545:               *
546:               * Side Effects: none
547:               *
548:               * Overview: clears screen with current color and sets cursor to 0,0
549:               *
550:               * Note: none
551:               *
552:               ********************************************************************/
553:               void __attribute__((weak)) ClearDevice(void)
554:               {
00574E  FA0000     LNK #0x0
555:                   while(Bar(0, 0, GetMaxX(), GetMaxY()) == 0);
005750  000000     NOP
005752  2003F3     MOV #0x3F, W3
005754  2007F2     MOV #0x7F, W2
005756  EB0080     CLR W1
005758  EB0000     CLR W0
00575A  07FEB0     RCALL Bar
00575C  500FE0     SUB W0, #0x0, [W15]
00575E  32FFF9     BRA Z, 0x5752
556:                   MoveTo(0, 0);
005760  EB0000     CLR W0
005762  888260     MOV W0, _cursorX
005764  EB0000     CLR W0
005766  888270     MOV W0, _cursorY
557:               }
005768  FA8000     ULNK
00576A  060000     RETURN
558:               
559:               /*********************************************************************
560:               * Function:  void InitGraph(void)
561:               *
562:               * PreCondition: none
563:               *
564:               * Input: none
565:               *
566:               * Output: none
567:               *
568:               * Side Effects: none
569:               *
570:               * Overview: initializes LCD controller,
571:               *           sets cursor position to upper left corner,
572:               *           sets active and visual pages to page 0,
573:               *           clears active page with BLACK,
574:               *           sets color to WHITE,
575:               *           disables clipping
576:               *
577:               * Note: none
578:               *
579:               ********************************************************************/
580:               void InitGraph(void)
581:               {
00576C  FA0000     LNK #0x0
582:               
583:                   // Current line type
584:                   SetLineType(SOLID_LINE);
00576E  EB0000     CLR W0
005770  888240     MOV W0, _lineType
585:               
586:                   // Current line thickness
587:                   SetLineThickness(NORMAL_LINE);
005772  EB4000     CLR.B W0
005774  B7F04A     MOV.B WREG, _lineThickness
588:               
589:                   // Current cursor coordinates to 0,0
590:                   MoveTo(0, 0);
005776  EB0000     CLR W0
005778  888260     MOV W0, _cursorX
00577A  EB0000     CLR W0
00577C  888270     MOV W0, _cursorY
591:               
592:                   // Reset device
593:                   ResetDevice();
00577E  07357B     RCALL ResetDevice
594:               
595:                   // Set color to BLACK
596:                   SetColor(0);
005780  EB4000     CLR.B W0
005782  B7F13E     MOV.B WREG, _color
597:               
598:                   // set the transparent color check to be disabled
599:               #ifdef USE_TRANSPARENT_COLOR
600:                   TransparentColorDisable();
601:               #endif    
602:               
603:               #ifdef USE_ALPHABLEND_LITE
604:                   SetAlpha(100);
605:               #endif
606:               
607:                   // Clear screen
608:                   ClearDevice();
005784  0735CA     RCALL ClearDevice
609:               
610:                   // Disable clipping
611:                   SetClip(CLIP_DISABLE);
005786  EB4000     CLR.B W0
005788  07FE92     RCALL SetClip
612:               
613:                   // Set font orientation
614:                   SetFontOrientation(ORIENT_HOR);
00578A  EB4000     CLR.B W0
00578C  B7F04B     MOV.B WREG, _fontOrientation
615:                   
616:                   // set Bevel drawing 
617:                   SetBevelDrawType(DRAWFULLBEVEL);
00578E  EBC000     SETM.B W0
005790  B7F05A     MOV.B WREG, _bevelDrawType
618:               }
005792  FA8000     ULNK
005794  060000     RETURN
619:               
620:               /*********************************************************************
621:               * Function: WORD Arc(SHORT xL, SHORT yT, SHORT xR, SHORT yB, SHORT r1, SHORT r2, BYTE octant);
622:               *
623:               * PreCondition: none
624:               *
625:               * Input: xL, yT - location of the upper left center in the x,y coordinate
626:               *		 xR, yB - location of the lower right left center in the x,y coordinate
627:               *		 r1, r2 - the two concentric circle radii, r1 as the radius 
628:               *				  of the smaller circle and and r2 as the radius of the 
629:               *				  larger circle.
630:               *		 octant - bitmask of the octant that will be drawn.
631:               *				  Moving in a clockwise direction from x = 0, y = +radius
632:               *                 bit0 : first octant 	bit4 : fifth octant
633:               *                 bit1 : second octant  bit5 : sixth octant
634:               *                 bit2 : third octant   bit6 : seventh octant
635:               *                 bit3 : fourth octant  bit7 : eigth octant
636:               *
637:               * Output: For NON-Blocking configuration:
638:               *         - Returns 0 when device is busy and the shape is not yet completely drawn.
639:               *         - Returns 1 when the shape is completely drawn.
640:               *         For Blocking configuration:
641:               *         - Always return 1.
642:               *
643:               * Side Effects: none
644:               *
645:               * Overview: Draws the octant arc of a beveled figure with given centers, radii
646:               *			and octant mask. When r1 is zero and r2 has some value, a filled 
647:               *			circle is drawn; when the radii have values, an arc of
648:               *			thickness (r2-r1) is drawn; when octant = 0xFF, a full ring 
649:               *			is drawn. When r1 and r2 are zero, a rectangular object is drawn, where
650:               *			xL, yT specifies the left top corner; xR, yB specifies the right bottom
651:               *			corner.
652:               *
653:               * Note: none
654:               *
655:               ********************************************************************/
656:               WORD __attribute__((weak)) Arc(SHORT xL, SHORT yT, SHORT xR, SHORT yB, SHORT r1, SHORT r2, BYTE octant)
657:               {
005796  FA0030     LNK #0x30
005798  981710     MOV W0, [W14+34]
00579A  981721     MOV W1, [W14+36]
00579C  981732     MOV W2, [W14+38]
00579E  981743     MOV W3, [W14+40]
0057A0  981754     MOV W4, [W14+42]
0057A2  981765     MOV W5, [W14+44]
0057A4  986F66     MOV.B W6, [W14+46]
658:               
659:                   // this is using a variant of the Midpoint (Bresenham's) Algorithm
660:                   #ifndef USE_NONBLOCKING_CONFIG
661:               
662:                   SHORT       y1Limit, y2Limit;
663:                   SHORT       x1, x2, y1, y2, ovrlap;
664:                   SHORT       err1, err2;
665:                   SHORT       x1Cur, y1Cur, y1New;
666:                   SHORT       x2Cur, y2Cur, y2New;
667:                   DWORD_VAL   temp;
668:               
669:                   temp.Val = SIN45 * r1;
0057A6  90105E     MOV [W14+42], W0
0057A8  DE80CF     ASR W0, #15, W1
0057AA  2B5052     MOV #0xB505, W2
0057AC  B98902     MUL.SS W1, W2, W2
0057AE  780102     MOV W2, W2
0057B0  B90260     MUL.SU W0, #0, W4
0057B2  780184     MOV W4, W3
0057B4  410103     ADD W2, W3, W2
0057B6  2B5053     MOV #0xB505, W3
0057B8  B80003     MUL.UU W0, W3, W0
0057BA  410101     ADD W2, W1, W2
0057BC  780082     MOV W2, W1
0057BE  980F70     MOV W0, [W14+30]
0057C0  981701     MOV W1, [W14+32]
670:                   y1Limit = temp.w[1];
0057C2  90100E     MOV [W14+32], W0
0057C4  980F30     MOV W0, [W14+22]
671:                   temp.Val = SIN45 * r2;
0057C6  90106E     MOV [W14+44], W0
0057C8  DE80CF     ASR W0, #15, W1
0057CA  2B5052     MOV #0xB505, W2
0057CC  B98902     MUL.SS W1, W2, W2
0057CE  780102     MOV W2, W2
0057D0  B90260     MUL.SU W0, #0, W4
0057D2  780184     MOV W4, W3
0057D4  410103     ADD W2, W3, W2
0057D6  2B5053     MOV #0xB505, W3
0057D8  B80003     MUL.UU W0, W3, W0
0057DA  410101     ADD W2, W1, W2
0057DC  780082     MOV W2, W1
0057DE  980F70     MOV W0, [W14+30]
0057E0  981701     MOV W1, [W14+32]
672:                   y2Limit = temp.w[1];
0057E2  90100E     MOV [W14+32], W0
0057E4  980F40     MOV W0, [W14+24]
673:               
674:                   temp.Val = (DWORD) (ONEP25 - ((LONG) r1 << 16));
0057E6  90105E     MOV [W14+42], W0
0057E8  DE80CF     ASR W0, #15, W1
0057EA  DD00C0     SL W0, #0, W1
0057EC  200000     MOV #0x0, W0
0057EE  240002     MOV #0x4000, W2
0057F0  200013     MOV #0x1, W3
0057F2  510000     SUB W2, W0, W0
0057F4  598081     SUBB W3, W1, W1
0057F6  980F70     MOV W0, [W14+30]
0057F8  981701     MOV W1, [W14+32]
675:                   err1 = (SHORT) (temp.w[1]);
0057FA  90100E     MOV [W14+32], W0
0057FC  980750     MOV W0, [W14+10]
676:               
677:                   temp.Val = (DWORD) (ONEP25 - ((LONG) r2 << 16));
0057FE  90106E     MOV [W14+44], W0
005800  DE80CF     ASR W0, #15, W1
005802  DD00C0     SL W0, #0, W1
005804  200000     MOV #0x0, W0
005806  240002     MOV #0x4000, W2
005808  200013     MOV #0x1, W3
00580A  510000     SUB W2, W0, W0
00580C  598081     SUBB W3, W1, W1
00580E  980F70     MOV W0, [W14+30]
005810  981701     MOV W1, [W14+32]
678:                   err2 = (SHORT) (temp.w[1]);
005812  90100E     MOV [W14+32], W0
005814  980760     MOV W0, [W14+12]
679:               
680:                   x1 = r1;
005816  90105E     MOV [W14+42], W0
005818  780F00     MOV W0, [W14]
681:                   x2 = r2;
00581A  90106E     MOV [W14+44], W0
00581C  980710     MOV W0, [W14+2]
682:                   y1 = 0;
00581E  EB0000     CLR W0
005820  980720     MOV W0, [W14+4]
683:                   y2 = 0;
005822  EB0000     CLR W0
005824  980730     MOV W0, [W14+6]
684:               
685:                   x1Cur = x1;
005826  78001E     MOV [W14], W0
005828  980770     MOV W0, [W14+14]
686:                   y1Cur = y1 + 1;
00582A  90002E     MOV [W14+4], W0
00582C  E80000     INC W0, W0
00582E  980F00     MOV W0, [W14+16]
687:                   y1New = y1;
005830  90002E     MOV [W14+4], W0
005832  980F50     MOV W0, [W14+26]
688:                   x2Cur = x2;
005834  90001E     MOV [W14+2], W0
005836  980F10     MOV W0, [W14+18]
689:                   y2Cur = y2;
005838  90003E     MOV [W14+6], W0
00583A  980F20     MOV W0, [W14+20]
690:                   y2New = y2;
00583C  90003E     MOV [W14+6], W0
00583E  980F60     MOV W0, [W14+28]
691:               
692:                   while(y2 <= y2Limit)
005840  37016F     BRA 0x5B20
005B20  9000BE     MOV [W14+6], W1
005B22  90084E     MOV [W14+24], W0
005B24  508F80     SUB W1, W0, [W15]
005B26  34FE8D     BRA LE, 0x5842
693:                   {   // just watch for y2 limit since outer circle
694:                       // will have greater value.
695:                       // Drawing of the rounded panel is done only when there is a change in the
696:                       // x direction. Bars are drawn to be efficient.
697:                       // detect changes in the x position. Every change will mean a bar will be drawn
698:                       // to cover the previous area. y1New records the last position of y before the
699:                       // change in x position.
700:                       // y1New & y2New records the last y positions, must remember this to
701:                       // draw the correct bars (non-overlapping).
702:                       y1New = y1;
005842  90002E     MOV [W14+4], W0
005844  980F50     MOV W0, [W14+26]
703:                       y2New = y2;
005846  90003E     MOV [W14+6], W0
005848  980F60     MOV W0, [W14+28]
704:               
705:                       if(y1 <= y1Limit)
00584A  9000AE     MOV [W14+4], W1
00584C  90083E     MOV [W14+22], W0
00584E  508F80     SUB W1, W0, [W15]
005850  3C001A     BRA GT, 0x5886
706:                       {
707:                           if(err1 > 0)
005852  90005E     MOV [W14+10], W0
005854  500FE0     SUB W0, #0x0, [W15]
005856  34000B     BRA LE, 0x586E
708:                           {
709:                               x1--;
005858  E90F1E     DEC [W14], [W14]
710:                               err1 += 5;
00585A  90005E     MOV [W14+10], W0
00585C  400065     ADD W0, #0x5, W0
00585E  980750     MOV W0, [W14+10]
711:                               err1 += (y1 - x1) << 1;
005860  90002E     MOV [W14+4], W0
005862  50001E     SUB W0, [W14], W0
005864  400000     ADD W0, W0, W0
005866  9000DE     MOV [W14+10], W1
005868  408000     ADD W1, W0, W0
00586A  980750     MOV W0, [W14+10]
00586C  370008     BRA 0x587E
712:                           }
713:                           else
714:                           {
715:                               err1 += 3;
00586E  90005E     MOV [W14+10], W0
005870  400063     ADD W0, #0x3, W0
005872  980750     MOV W0, [W14+10]
716:                               err1 += y1 << 1;
005874  90002E     MOV [W14+4], W0
005876  400000     ADD W0, W0, W0
005878  9000DE     MOV [W14+10], W1
00587A  408000     ADD W1, W0, W0
00587C  980750     MOV W0, [W14+10]
717:                           }
718:               
719:                           y1++;
00587E  90002E     MOV [W14+4], W0
005880  E80000     INC W0, W0
005882  980720     MOV W0, [W14+4]
005884  370009     BRA 0x5898
720:                       }
721:                       else
722:                       {
723:                           y1++;
005886  90002E     MOV [W14+4], W0
005888  E80000     INC W0, W0
00588A  980720     MOV W0, [W14+4]
724:                           if(x1 < y1)
00588C  90002E     MOV [W14+4], W0
00588E  78009E     MOV [W14], W1
005890  508F80     SUB W1, W0, [W15]
005892  3D0002     BRA GE, 0x5898
725:                               x1 = y1;
005894  90002E     MOV [W14+4], W0
005896  780F00     MOV W0, [W14]
726:                       }
727:               
728:                       if(err2 > 0)
005898  90006E     MOV [W14+12], W0
00589A  500FE0     SUB W0, #0x0, [W15]
00589C  34000E     BRA LE, 0x58BA
729:                       {
730:                           x2--;
00589E  90001E     MOV [W14+2], W0
0058A0  E90000     DEC W0, W0
0058A2  980710     MOV W0, [W14+2]
731:                           err2 += 5;
0058A4  90006E     MOV [W14+12], W0
0058A6  400065     ADD W0, #0x5, W0
0058A8  980760     MOV W0, [W14+12]
732:                           err2 += (y2 - x2) << 1;
0058AA  9000BE     MOV [W14+6], W1
0058AC  90001E     MOV [W14+2], W0
0058AE  508000     SUB W1, W0, W0
0058B0  400000     ADD W0, W0, W0
0058B2  9000EE     MOV [W14+12], W1
0058B4  408000     ADD W1, W0, W0
0058B6  980760     MOV W0, [W14+12]
0058B8  370008     BRA 0x58CA
733:                       }
734:                       else
735:                       {
736:                           err2 += 3;
0058BA  90006E     MOV [W14+12], W0
0058BC  400063     ADD W0, #0x3, W0
0058BE  980760     MOV W0, [W14+12]
737:                           err2 += y2 << 1;
0058C0  90003E     MOV [W14+6], W0
0058C2  400000     ADD W0, W0, W0
0058C4  9000EE     MOV [W14+12], W1
0058C6  408000     ADD W1, W0, W0
0058C8  980760     MOV W0, [W14+12]
738:                       }
739:               
740:                       y2++;
0058CA  90003E     MOV [W14+6], W0
0058CC  E80000     INC W0, W0
0058CE  980730     MOV W0, [W14+6]
741:               
742:                       if((x1Cur != x1) || (x2Cur != x2))
0058D0  90007E     MOV [W14+14], W0
0058D2  500F9E     SUB W0, [W14], [W15]
0058D4  3A0004     BRA NZ, 0x58DE
0058D6  90089E     MOV [W14+18], W1
0058D8  90001E     MOV [W14+2], W0
0058DA  508F80     SUB W1, W0, [W15]
0058DC  320121     BRA Z, 0x5B20
743:                       {
744:                           if(octant & 0x01)
0058DE  90686E     MOV.B [W14+46], W0
0058E0  FB8000     ZE W0, W0
0058E2  600061     AND W0, #0x1, W0
0058E4  784000     MOV.B W0, W0
0058E6  504FE0     SUB.B W0, #0x0, [W15]
0058E8  32001D     BRA Z, 0x5924
745:                           {
746:                               // check overlaps
747:                               if (yT - x1Cur < yT - y1New)
0058EA  9010AE     MOV [W14+36], W1
0058EC  90007E     MOV [W14+14], W0
0058EE  508080     SUB W1, W0, W1
0058F0  90112E     MOV [W14+36], W2
0058F2  90085E     MOV [W14+26], W0
0058F4  510000     SUB W2, W0, W0
0058F6  508F80     SUB W1, W0, [W15]
0058F8  3D0005     BRA GE, 0x5904
748:                                   ovrlap = yT - x1Cur;
0058FA  9010AE     MOV [W14+36], W1
0058FC  90007E     MOV [W14+14], W0
0058FE  508000     SUB W1, W0, W0
005900  980740     MOV W0, [W14+8]
005902  370005     BRA 0x590E
749:                               else    
750:                                   ovrlap = yT - y1New - 1;
005904  9010AE     MOV [W14+36], W1
005906  90085E     MOV [W14+26], W0
005908  508000     SUB W1, W0, W0
00590A  E90000     DEC W0, W0
00590C  980740     MOV W0, [W14+8]
751:                               Bar(xR + y2Cur, yT - x2Cur, xR + y1New, ovrlap);    // 1st octant
00590E  9010BE     MOV [W14+38], W1
005910  90085E     MOV [W14+26], W0
005912  408100     ADD W1, W0, W2
005914  9010AE     MOV [W14+36], W1
005916  90081E     MOV [W14+18], W0
005918  508080     SUB W1, W0, W1
00591A  9011BE     MOV [W14+38], W3
00591C  90082E     MOV [W14+20], W0
00591E  418000     ADD W3, W0, W0
005920  9001CE     MOV [W14+8], W3
005922  07FDCC     RCALL Bar
752:                           }
753:               
754:                           if(octant & 0x02)
005924  90686E     MOV.B [W14+46], W0
005926  FB8000     ZE W0, W0
005928  600062     AND W0, #0x2, W0
00592A  500FE0     SUB W0, #0x0, [W15]
00592C  32001F     BRA Z, 0x596C
755:                           {
756:                               // check overlaps
757:                               if (xR + x1Cur > xR + y1New)
00592E  9010BE     MOV [W14+38], W1
005930  90007E     MOV [W14+14], W0
005932  408080     ADD W1, W0, W1
005934  90113E     MOV [W14+38], W2
005936  90085E     MOV [W14+26], W0
005938  410000     ADD W2, W0, W0
00593A  508F80     SUB W1, W0, [W15]
00593C  340005     BRA LE, 0x5948
758:                                   ovrlap = xR + x1Cur;
00593E  9010BE     MOV [W14+38], W1
005940  90007E     MOV [W14+14], W0
005942  408000     ADD W1, W0, W0
005944  980740     MOV W0, [W14+8]
005946  370004     BRA 0x5950
759:                               else    
760:                                   ovrlap = xR + y1New;
005948  9010BE     MOV [W14+38], W1
00594A  90085E     MOV [W14+26], W0
00594C  408000     ADD W1, W0, W0
00594E  980740     MOV W0, [W14+8]
761:                               Bar(ovrlap, yT - y1New, xR + x2Cur, yT - y2Cur);    // 2nd octant
005950  9010AE     MOV [W14+36], W1
005952  90082E     MOV [W14+20], W0
005954  508100     SUB W1, W0, W2
005956  9010BE     MOV [W14+38], W1
005958  90081E     MOV [W14+18], W0
00595A  408080     ADD W1, W0, W1
00595C  9011AE     MOV [W14+36], W3
00595E  90085E     MOV [W14+26], W0
005960  518000     SUB W3, W0, W0
005962  780182     MOV W2, W3
005964  780101     MOV W1, W2
005966  780080     MOV W0, W1
005968  90004E     MOV [W14+8], W0
00596A  07FDA8     RCALL Bar
762:                           }
763:               
764:                           if(octant & 0x04)
00596C  90686E     MOV.B [W14+46], W0
00596E  FB8000     ZE W0, W0
005970  600064     AND W0, #0x4, W0
005972  500FE0     SUB W0, #0x0, [W15]
005974  32001F     BRA Z, 0x59B4
765:                           {
766:                               // check overlaps
767:                               if (xR + x1Cur > xR + y2New)
005976  9010BE     MOV [W14+38], W1
005978  90007E     MOV [W14+14], W0
00597A  408080     ADD W1, W0, W1
00597C  90113E     MOV [W14+38], W2
00597E  90086E     MOV [W14+28], W0
005980  410000     ADD W2, W0, W0
005982  508F80     SUB W1, W0, [W15]
005984  340005     BRA LE, 0x5990
768:                                   ovrlap = xR + x1Cur;
005986  9010BE     MOV [W14+38], W1
005988  90007E     MOV [W14+14], W0
00598A  408000     ADD W1, W0, W0
00598C  980740     MOV W0, [W14+8]
00598E  370004     BRA 0x5998
769:                               else    
770:                                   ovrlap = xR + y2New;
005990  9010BE     MOV [W14+38], W1
005992  90086E     MOV [W14+28], W0
005994  408000     ADD W1, W0, W0
005996  980740     MOV W0, [W14+8]
771:                               Bar(ovrlap, yB + y1Cur, xR + x2Cur, yB + y2New);    // 3rd octant
005998  9010CE     MOV [W14+40], W1
00599A  90086E     MOV [W14+28], W0
00599C  408100     ADD W1, W0, W2
00599E  9010BE     MOV [W14+38], W1
0059A0  90081E     MOV [W14+18], W0
0059A2  408080     ADD W1, W0, W1
0059A4  9011CE     MOV [W14+40], W3
0059A6  90080E     MOV [W14+16], W0
0059A8  418000     ADD W3, W0, W0
0059AA  780182     MOV W2, W3
0059AC  780101     MOV W1, W2
0059AE  780080     MOV W0, W1
0059B0  90004E     MOV [W14+8], W0
0059B2  07FD84     RCALL Bar
772:                           }
773:               
774:                           if(octant & 0x08)
0059B4  90686E     MOV.B [W14+46], W0
0059B6  FB8000     ZE W0, W0
0059B8  600068     AND W0, #0x8, W0
0059BA  500FE0     SUB W0, #0x0, [W15]
0059BC  32001F     BRA Z, 0x59FC
775:                           {
776:                               // check overlaps
777:                               if (yB + x1Cur > yB + y2New)
0059BE  9010CE     MOV [W14+40], W1
0059C0  90007E     MOV [W14+14], W0
0059C2  408080     ADD W1, W0, W1
0059C4  90114E     MOV [W14+40], W2
0059C6  90086E     MOV [W14+28], W0
0059C8  410000     ADD W2, W0, W0
0059CA  508F80     SUB W1, W0, [W15]
0059CC  340005     BRA LE, 0x59D8
778:                                   ovrlap = yB + x1Cur;
0059CE  9010CE     MOV [W14+40], W1
0059D0  90007E     MOV [W14+14], W0
0059D2  408000     ADD W1, W0, W0
0059D4  980740     MOV W0, [W14+8]
0059D6  370005     BRA 0x59E2
779:                               else    
780:                                   ovrlap = yB + y2New + 1;
0059D8  9010CE     MOV [W14+40], W1
0059DA  90086E     MOV [W14+28], W0
0059DC  408000     ADD W1, W0, W0
0059DE  E80000     INC W0, W0
0059E0  980740     MOV W0, [W14+8]
781:                               Bar(xR + y1Cur, ovrlap, xR + y2New, yB + x2Cur);    // 4th octant
0059E2  9010CE     MOV [W14+40], W1
0059E4  90081E     MOV [W14+18], W0
0059E6  408100     ADD W1, W0, W2
0059E8  9010BE     MOV [W14+38], W1
0059EA  90086E     MOV [W14+28], W0
0059EC  408080     ADD W1, W0, W1
0059EE  9011BE     MOV [W14+38], W3
0059F0  90080E     MOV [W14+16], W0
0059F2  418000     ADD W3, W0, W0
0059F4  780182     MOV W2, W3
0059F6  780101     MOV W1, W2
0059F8  9000CE     MOV [W14+8], W1
0059FA  07FD60     RCALL Bar
782:                           }
783:               
784:                           if(octant & 0x10)
0059FC  90686E     MOV.B [W14+46], W0
0059FE  FB8000     ZE W0, W0
005A00  600070     AND W0, #0x10, W0
005A02  500FE0     SUB W0, #0x0, [W15]
005A04  32001F     BRA Z, 0x5A44
785:                           {
786:                               // check overlaps
787:                               if (yB + x1Cur > yB + y1New)
005A06  9010CE     MOV [W14+40], W1
005A08  90007E     MOV [W14+14], W0
005A0A  408080     ADD W1, W0, W1
005A0C  90114E     MOV [W14+40], W2
005A0E  90085E     MOV [W14+26], W0
005A10  410000     ADD W2, W0, W0
005A12  508F80     SUB W1, W0, [W15]
005A14  340005     BRA LE, 0x5A20
788:                                   ovrlap = yB + x1Cur;
005A16  9010CE     MOV [W14+40], W1
005A18  90007E     MOV [W14+14], W0
005A1A  408000     ADD W1, W0, W0
005A1C  980740     MOV W0, [W14+8]
005A1E  370005     BRA 0x5A2A
789:                               else    
790:                                   ovrlap = yB + y1New + 1;
005A20  9010CE     MOV [W14+40], W1
005A22  90085E     MOV [W14+26], W0
005A24  408000     ADD W1, W0, W0
005A26  E80000     INC W0, W0
005A28  980740     MOV W0, [W14+8]
791:                               Bar(xL - y1New, ovrlap, xL - y2Cur, yB + x2Cur);    // 5th octant
005A2A  9010CE     MOV [W14+40], W1
005A2C  90081E     MOV [W14+18], W0
005A2E  408100     ADD W1, W0, W2
005A30  90109E     MOV [W14+34], W1
005A32  90082E     MOV [W14+20], W0
005A34  508080     SUB W1, W0, W1
005A36  90119E     MOV [W14+34], W3
005A38  90085E     MOV [W14+26], W0
005A3A  518000     SUB W3, W0, W0
005A3C  780182     MOV W2, W3
005A3E  780101     MOV W1, W2
005A40  9000CE     MOV [W14+8], W1
005A42  07FD3C     RCALL Bar
792:                           }
793:               
794:                           if(octant & 0x20)
005A44  90686E     MOV.B [W14+46], W0
005A46  FB8080     ZE W0, W1
005A48  200200     MOV #0x20, W0
005A4A  608000     AND W1, W0, W0
005A4C  500FE0     SUB W0, #0x0, [W15]
005A4E  32001D     BRA Z, 0x5A8A
795:                           {
796:                               // check overlaps
797:                               if (xL - x1Cur < xL - y1New)
005A50  90109E     MOV [W14+34], W1
005A52  90007E     MOV [W14+14], W0
005A54  508080     SUB W1, W0, W1
005A56  90111E     MOV [W14+34], W2
005A58  90085E     MOV [W14+26], W0
005A5A  510000     SUB W2, W0, W0
005A5C  508F80     SUB W1, W0, [W15]
005A5E  3D0005     BRA GE, 0x5A6A
798:                                   ovrlap = xL - x1Cur;
005A60  90109E     MOV [W14+34], W1
005A62  90007E     MOV [W14+14], W0
005A64  508000     SUB W1, W0, W0
005A66  980740     MOV W0, [W14+8]
005A68  370004     BRA 0x5A72
799:                               else    
800:                                   ovrlap = xL - y1New;
005A6A  90109E     MOV [W14+34], W1
005A6C  90085E     MOV [W14+26], W0
005A6E  508000     SUB W1, W0, W0
005A70  980740     MOV W0, [W14+8]
801:                               Bar(xL - x2Cur, yB + y2Cur, ovrlap, yB + y1New);    // 6th octant
005A72  9010CE     MOV [W14+40], W1
005A74  90085E     MOV [W14+26], W0
005A76  408100     ADD W1, W0, W2
005A78  9010CE     MOV [W14+40], W1
005A7A  90082E     MOV [W14+20], W0
005A7C  408080     ADD W1, W0, W1
005A7E  90119E     MOV [W14+34], W3
005A80  90081E     MOV [W14+18], W0
005A82  518000     SUB W3, W0, W0
005A84  780182     MOV W2, W3
005A86  90014E     MOV [W14+8], W2
005A88  07FD19     RCALL Bar
802:                           }
803:               
804:                           if(octant & 0x40)
005A8A  90686E     MOV.B [W14+46], W0
005A8C  FB8080     ZE W0, W1
005A8E  200400     MOV #0x40, W0
005A90  608000     AND W1, W0, W0
005A92  500FE0     SUB W0, #0x0, [W15]
005A94  32001D     BRA Z, 0x5AD0
805:                           {
806:                               // check overlaps
807:                               if (xL - x1Cur < xL - y2New)
005A96  90109E     MOV [W14+34], W1
005A98  90007E     MOV [W14+14], W0
005A9A  508080     SUB W1, W0, W1
005A9C  90111E     MOV [W14+34], W2
005A9E  90086E     MOV [W14+28], W0
005AA0  510000     SUB W2, W0, W0
005AA2  508F80     SUB W1, W0, [W15]
005AA4  3D0005     BRA GE, 0x5AB0
808:                                   ovrlap = xL - x1Cur;
005AA6  90109E     MOV [W14+34], W1
005AA8  90007E     MOV [W14+14], W0
005AAA  508000     SUB W1, W0, W0
005AAC  980740     MOV W0, [W14+8]
005AAE  370004     BRA 0x5AB8
809:                               else    
810:                                   ovrlap = xL - y2New;
005AB0  90109E     MOV [W14+34], W1
005AB2  90086E     MOV [W14+28], W0
005AB4  508000     SUB W1, W0, W0
005AB6  980740     MOV W0, [W14+8]
811:                               Bar(xL - x2Cur, yT - y2New, ovrlap, yT - y1Cur);    // 7th octant
005AB8  9010AE     MOV [W14+36], W1
005ABA  90080E     MOV [W14+16], W0
005ABC  508100     SUB W1, W0, W2
005ABE  9010AE     MOV [W14+36], W1
005AC0  90086E     MOV [W14+28], W0
005AC2  508080     SUB W1, W0, W1
005AC4  90119E     MOV [W14+34], W3
005AC6  90081E     MOV [W14+18], W0
005AC8  518000     SUB W3, W0, W0
005ACA  780182     MOV W2, W3
005ACC  90014E     MOV [W14+8], W2
005ACE  07FCF6     RCALL Bar
812:                           }
813:               
814:                           if(octant & 0x80)
005AD0  90686E     MOV.B [W14+46], W0
005AD2  504FE0     SUB.B W0, #0x0, [W15]
005AD4  3D001D     BRA GE, 0x5B10
815:                           {
816:                               // check overlaps
817:                               if (yT - x1Cur < yT - y2New)
005AD6  9010AE     MOV [W14+36], W1
005AD8  90007E     MOV [W14+14], W0
005ADA  508080     SUB W1, W0, W1
005ADC  90112E     MOV [W14+36], W2
005ADE  90086E     MOV [W14+28], W0
005AE0  510000     SUB W2, W0, W0
005AE2  508F80     SUB W1, W0, [W15]
005AE4  3D0005     BRA GE, 0x5AF0
818:                                   ovrlap = yT - x1Cur;
005AE6  9010AE     MOV [W14+36], W1
005AE8  90007E     MOV [W14+14], W0
005AEA  508000     SUB W1, W0, W0
005AEC  980740     MOV W0, [W14+8]
005AEE  370005     BRA 0x5AFA
819:                               else    
820:                                   ovrlap = yT - y2New - 1;
005AF0  9010AE     MOV [W14+36], W1
005AF2  90086E     MOV [W14+28], W0
005AF4  508000     SUB W1, W0, W0
005AF6  E90000     DEC W0, W0
005AF8  980740     MOV W0, [W14+8]
821:                               Bar(xL - y2New, yT - x2Cur, xL - y1Cur, ovrlap);    // 8th octant
005AFA  90109E     MOV [W14+34], W1
005AFC  90080E     MOV [W14+16], W0
005AFE  508100     SUB W1, W0, W2
005B00  9010AE     MOV [W14+36], W1
005B02  90081E     MOV [W14+18], W0
005B04  508080     SUB W1, W0, W1
005B06  90119E     MOV [W14+34], W3
005B08  90086E     MOV [W14+28], W0
005B0A  518000     SUB W3, W0, W0
005B0C  9001CE     MOV [W14+8], W3
005B0E  07FCD6     RCALL Bar
822:                           }
823:               
824:                           // update current values
825:                           x1Cur = x1;
005B10  78001E     MOV [W14], W0
005B12  980770     MOV W0, [W14+14]
826:                           y1Cur = y1;
005B14  90002E     MOV [W14+4], W0
005B16  980F00     MOV W0, [W14+16]
827:                           x2Cur = x2;
005B18  90001E     MOV [W14+2], W0
005B1A  980F10     MOV W0, [W14+18]
828:                           y2Cur = y2;
005B1C  90003E     MOV [W14+6], W0
005B1E  980F20     MOV W0, [W14+20]
829:               
830:                       }
831:                   }                           // end of while loop
832:               
833:                   // draw the width and height
834:                   if((xR - xL) || (yB - yT))
005B28  9010BE     MOV [W14+38], W1
005B2A  90101E     MOV [W14+34], W0
005B2C  508F80     SUB W1, W0, [W15]
005B2E  3A0004     BRA NZ, 0x5B38
005B30  9010CE     MOV [W14+40], W1
005B32  90102E     MOV [W14+36], W0
005B34  508F80     SUB W1, W0, [W15]
005B36  32009F     BRA Z, 0x5C76
835:                   {
836:                       // draw right
837:                       if(octant & 0x02)
005B38  90686E     MOV.B [W14+46], W0
005B3A  FB8000     ZE W0, W0
005B3C  600062     AND W0, #0x2, W0
005B3E  500FE0     SUB W0, #0x0, [W15]
005B40  32000D     BRA Z, 0x5B5C
838:                       {
839:                           Bar(xR + r1, yT + 1, xR + r2, (yB + yT) >> 1);
005B42  9010CE     MOV [W14+40], W1
005B44  90102E     MOV [W14+36], W0
005B46  408000     ADD W1, W0, W0
005B48  D18180     ASR W0, W3
005B4A  9010BE     MOV [W14+38], W1
005B4C  90106E     MOV [W14+44], W0
005B4E  408100     ADD W1, W0, W2
005B50  90102E     MOV [W14+36], W0
005B52  E80080     INC W0, W1
005B54  90123E     MOV [W14+38], W4
005B56  90105E     MOV [W14+42], W0
005B58  420000     ADD W4, W0, W0
005B5A  07FCB0     RCALL Bar
840:                       }
841:               
842:                       if(octant & 0x04)
005B5C  90686E     MOV.B [W14+46], W0
005B5E  FB8000     ZE W0, W0
005B60  600064     AND W0, #0x4, W0
005B62  500FE0     SUB W0, #0x0, [W15]
005B64  32000D     BRA Z, 0x5B80
843:                       {
844:                           Bar(xR + r1, ((yB + yT) >> 1) + 1, xR + r2, yB);
005B66  9010BE     MOV [W14+38], W1
005B68  90106E     MOV [W14+44], W0
005B6A  408100     ADD W1, W0, W2
005B6C  9010CE     MOV [W14+40], W1
005B6E  90102E     MOV [W14+36], W0
005B70  408000     ADD W1, W0, W0
005B72  D18000     ASR W0, W0
005B74  E80080     INC W0, W1
005B76  9011BE     MOV [W14+38], W3
005B78  90105E     MOV [W14+42], W0
005B7A  418000     ADD W3, W0, W0
005B7C  9011CE     MOV [W14+40], W3
005B7E  07FC9E     RCALL Bar
845:                       }
846:               
847:                       // draw bottom
848:                       if(octant & 0x10)
005B80  90686E     MOV.B [W14+46], W0
005B82  FB8000     ZE W0, W0
005B84  600070     AND W0, #0x10, W0
005B86  500FE0     SUB W0, #0x0, [W15]
005B88  32000D     BRA Z, 0x5BA4
849:                       {
850:                           Bar(xL + 1, yB + r1, ((xR + xL) >> 1), yB + r2);
005B8A  9010CE     MOV [W14+40], W1
005B8C  90106E     MOV [W14+44], W0
005B8E  408180     ADD W1, W0, W3
005B90  9010BE     MOV [W14+38], W1
005B92  90101E     MOV [W14+34], W0
005B94  408000     ADD W1, W0, W0
005B96  D18100     ASR W0, W2
005B98  9010CE     MOV [W14+40], W1
005B9A  90105E     MOV [W14+42], W0
005B9C  408080     ADD W1, W0, W1
005B9E  90101E     MOV [W14+34], W0
005BA0  E80000     INC W0, W0
005BA2  07FC8C     RCALL Bar
851:                       }
852:               
853:                       if(octant & 0x08)
005BA4  90686E     MOV.B [W14+46], W0
005BA6  FB8000     ZE W0, W0
005BA8  600068     AND W0, #0x8, W0
005BAA  500FE0     SUB W0, #0x0, [W15]
005BAC  32000E     BRA Z, 0x5BCA
854:                       {
855:                           Bar(((xR + xL) >> 1) + 1, yB + r1, xR, yB + r2);
005BAE  9010CE     MOV [W14+40], W1
005BB0  90106E     MOV [W14+44], W0
005BB2  408100     ADD W1, W0, W2
005BB4  9010CE     MOV [W14+40], W1
005BB6  90105E     MOV [W14+42], W0
005BB8  408080     ADD W1, W0, W1
005BBA  9011BE     MOV [W14+38], W3
005BBC  90101E     MOV [W14+34], W0
005BBE  418000     ADD W3, W0, W0
005BC0  D18000     ASR W0, W0
005BC2  E80000     INC W0, W0
005BC4  780182     MOV W2, W3
005BC6  90113E     MOV [W14+38], W2
005BC8  07FC79     RCALL Bar
856:                       }
857:               
858:                       if(xR - xL)
005BCA  9010BE     MOV [W14+38], W1
005BCC  90101E     MOV [W14+34], W0
005BCE  508F80     SUB W1, W0, [W15]
005BD0  320026     BRA Z, 0x5C1E
859:                       {
860:               
861:                           // draw top
862:                           if(octant & 0x80)
005BD2  90686E     MOV.B [W14+46], W0
005BD4  504FE0     SUB.B W0, #0x0, [W15]
005BD6  3D000F     BRA GE, 0x5BF6
863:                           {
864:                               Bar(xL, yT - r2, ((xR + xL) >> 1), yT - r1);
005BD8  9010AE     MOV [W14+36], W1
005BDA  90105E     MOV [W14+42], W0
005BDC  508100     SUB W1, W0, W2
005BDE  9010BE     MOV [W14+38], W1
005BE0  90101E     MOV [W14+34], W0
005BE2  408000     ADD W1, W0, W0
005BE4  D18080     ASR W0, W1
005BE6  9011AE     MOV [W14+36], W3
005BE8  90106E     MOV [W14+44], W0
005BEA  518000     SUB W3, W0, W0
005BEC  780182     MOV W2, W3
005BEE  780101     MOV W1, W2
005BF0  780080     MOV W0, W1
005BF2  90101E     MOV [W14+34], W0
005BF4  07FC63     RCALL Bar
865:                           }
866:               
867:                           if(octant & 0x01)
005BF6  90686E     MOV.B [W14+46], W0
005BF8  FB8000     ZE W0, W0
005BFA  600061     AND W0, #0x1, W0
005BFC  784000     MOV.B W0, W0
005BFE  504FE0     SUB.B W0, #0x0, [W15]
005C00  32000E     BRA Z, 0x5C1E
868:                           {
869:                               Bar(((xR + xL) >> 1) + 1, yT - r2, xR - 1, yT - r1);
005C02  9010AE     MOV [W14+36], W1
005C04  90105E     MOV [W14+42], W0
005C06  508180     SUB W1, W0, W3
005C08  90103E     MOV [W14+38], W0
005C0A  E90100     DEC W0, W2
005C0C  9010AE     MOV [W14+36], W1
005C0E  90106E     MOV [W14+44], W0
005C10  508080     SUB W1, W0, W1
005C12  90123E     MOV [W14+38], W4
005C14  90101E     MOV [W14+34], W0
005C16  420000     ADD W4, W0, W0
005C18  D18000     ASR W0, W0
005C1A  E80000     INC W0, W0
005C1C  07FC4F     RCALL Bar
870:                           }
871:                       }
872:               
873:                       if(yT - yB)
005C1E  9010AE     MOV [W14+36], W1
005C20  90104E     MOV [W14+40], W0
005C22  508F80     SUB W1, W0, [W15]
005C24  320028     BRA Z, 0x5C76
874:                       {
875:               
876:                           // draw left
877:                           if(octant & 0x40)
005C26  90686E     MOV.B [W14+46], W0
005C28  FB8080     ZE W0, W1
005C2A  200400     MOV #0x40, W0
005C2C  608000     AND W1, W0, W0
005C2E  500FE0     SUB W0, #0x0, [W15]
005C30  32000E     BRA Z, 0x5C4E
878:                           {
879:                               Bar(xL - r2, yT, xL - r1, ((yB + yT) >> 1));
005C32  9010CE     MOV [W14+40], W1
005C34  90102E     MOV [W14+36], W0
005C36  408000     ADD W1, W0, W0
005C38  D18100     ASR W0, W2
005C3A  90109E     MOV [W14+34], W1
005C3C  90105E     MOV [W14+42], W0
005C3E  508080     SUB W1, W0, W1
005C40  90119E     MOV [W14+34], W3
005C42  90106E     MOV [W14+44], W0
005C44  518000     SUB W3, W0, W0
005C46  780182     MOV W2, W3
005C48  780101     MOV W1, W2
005C4A  9010AE     MOV [W14+36], W1
005C4C  07FC37     RCALL Bar
880:                           }
881:               
882:                           if(octant & 0x20)
005C4E  90686E     MOV.B [W14+46], W0
005C50  FB8080     ZE W0, W1
005C52  200200     MOV #0x20, W0
005C54  608000     AND W1, W0, W0
005C56  500FE0     SUB W0, #0x0, [W15]
005C58  32000E     BRA Z, 0x5C76
883:                           {
884:                               Bar(xL - r2, ((yB + yT) >> 1) + 1, xL - r1, yB - 1);
005C5A  90104E     MOV [W14+40], W0
005C5C  E90180     DEC W0, W3
005C5E  90109E     MOV [W14+34], W1
005C60  90105E     MOV [W14+42], W0
005C62  508100     SUB W1, W0, W2
005C64  9010CE     MOV [W14+40], W1
005C66  90102E     MOV [W14+36], W0
005C68  408000     ADD W1, W0, W0
005C6A  D18000     ASR W0, W0
005C6C  E80080     INC W0, W1
005C6E  90121E     MOV [W14+34], W4
005C70  90106E     MOV [W14+44], W0
005C72  520000     SUB W4, W0, W0
005C74  07FC23     RCALL Bar
885:                           }
886:                       }
887:                   }
888:               
889:                   return (1);
005C76  200010     MOV #0x1, W0
890:                   #else
891:               
892:                   typedef enum
893:                   {
894:                       BEGIN,
895:                       QUAD11,
896:                       BARRIGHT1,
897:                       QUAD12,
898:                       BARRIGHT2,
899:                       QUAD21,
900:                       BARLEFT1,
901:                       QUAD22,
902:                       BARLEFT2,
903:                       QUAD31,
904:                       BARTOP1,
905:                       QUAD32,
906:                       BARTOP2,
907:                       QUAD41,
908:                       BARBOTTOM1,
909:                       QUAD42,
910:                       BARBOTTOM2,
911:                       CHECK,
912:                   } OCTANTARC_STATES;
913:               
914:                   DWORD_VAL temp;
915:               
916:                   //	LONG temp1;
917:                   static SHORT y1Limit, y2Limit;
918:                   static SHORT x1, x2, y1, y2, ovrlap;
919:                   static SHORT err1, err2;
920:                   static SHORT x1Cur, y1Cur, y1New;
921:                   static SHORT x2Cur, y2Cur, y2New;
922:                   static OCTANTARC_STATES state = BEGIN;
923:               
924:                   while(1)
925:                   {
926:                       if(IsDeviceBusy())
927:                           return (0);
928:                       switch(state)
929:                       {
930:                           case BEGIN:
931:                               temp.Val = SIN45 * r1;
932:                               y1Limit = temp.w[1];
933:                               temp.Val = SIN45 * r2;
934:                               y2Limit = temp.w[1];
935:               
936:                               temp.Val = (DWORD) (ONEP25 - ((LONG) r1 << 16));
937:                               err1 = (SHORT) (temp.w[1]);
938:               
939:                               temp.Val = (DWORD) (ONEP25 - ((LONG) r2 << 16));
940:                               err2 = (SHORT) (temp.w[1]);
941:               
942:                               x1 = r1;
943:                               x2 = r2;
944:                               y1 = 0;
945:                               y2 = 0;
946:               
947:                               x1Cur = x1;
948:                               y1Cur = y1 + 1;
949:                               y1New = y1;
950:                               x2Cur = x2;
951:                               y2Cur = y2;
952:                               y2New = y2;
953:                               state = CHECK;
954:               
955:                           case CHECK:
956:                               arc_check_state : if(y2 > y2Limit)
957:                               {
958:                                   state = BARRIGHT1;
959:                                   goto arc_draw_width_height_state;
960:                               }
961:               
962:                               // y1New & y2New records the last y positions
963:                               y1New = y1;
964:                               y2New = y2;
965:               
966:                               if(y1 <= y1Limit)
967:                               {
968:                                   if(err1 > 0)
969:                                   {
970:                                       x1--;
971:                                       err1 += 5;
972:                                       err1 += (y1 - x1) << 1;
973:                                   }
974:                                   else
975:                                   {
976:                                       err1 += 3;
977:                                       err1 += y1 << 1;
978:                                   }
979:               
980:                                   y1++;
981:                               }
982:                               else
983:                               {
984:                                   y1++;
985:                                   if(x1 < y1)
986:                                       x1 = y1;
987:                               }
988:               
989:                               if(err2 > 0)
990:                               {
991:                                   x2--;
992:                                   err2 += 5;
993:                                   err2 += (y2 - x2) << 1;
994:                               }
995:                               else
996:                               {
997:                                   err2 += 3;
998:                                   err2 += y2 << 1;
999:                               }
1000:              
1001:                              y2++;
1002:              
1003:                              state = QUAD11;
1004:              
1005:                              //break;
1006:              
1007:                          case QUAD11:
1008:                              if((x1Cur != x1) || (x2Cur != x2))
1009:                              {
1010:              
1011:                                  // 1st octant
1012:                                  if(octant & 0x01)
1013:                                  {
1014:                                      // check overlaps
1015:                                      if (yT - x1Cur < yT - y1New)
1016:                                          ovrlap = yT - x1Cur;
1017:                                      else    
1018:                                          ovrlap = yT - y1New - 1;
1019:                                      if(Bar(xR + y2Cur, yT - x2Cur, xR + y1New, ovrlap) == 0)
1020:                                          return 0;    
1021:                                  }
1022:                              }
1023:                              else
1024:                              {
1025:                                  state = CHECK;
1026:                                  goto arc_check_state;
1027:                              }
1028:              
1029:                              state = QUAD12;
1030:                              break;
1031:              
1032:                          case QUAD12:
1033:              
1034:                              // 2nd octant
1035:                              if(octant & 0x02)
1036:                              {
1037:                                  // check overlaps
1038:                                  if (xR + x1Cur > xR + y1New)
1039:                                      ovrlap = xR + x1Cur;
1040:                                  else    
1041:                                      ovrlap = xR + y1New;
1042:                                  if(Bar(ovrlap, yT - y1New, xR + x2Cur, yT - y2Cur) == 0)
1043:                                      return 0;    
1044:                              }
1045:              
1046:                              state = QUAD21;
1047:                              break;
1048:              
1049:                          case QUAD21:
1050:              
1051:                              // 3rd octant
1052:                              if(octant & 0x04)
1053:                              {
1054:                                  // check overlaps
1055:                                  if (xR + x1Cur > xR + y2New)
1056:                                      ovrlap = xR + x1Cur;
1057:                                  else    
1058:                                      ovrlap = xR + y2New;
1059:                                  if(Bar(ovrlap, yB + y1Cur, xR + x2Cur, yB + y2New) == 0)
1060:                                      return 0;    
1061:                              }
1062:              
1063:                              state = QUAD22;
1064:                              break;
1065:              
1066:                          case QUAD22:
1067:              
1068:                              // 4th octant
1069:                              if(octant & 0x08)
1070:                              {
1071:              
1072:                                  // check overlaps
1073:                                  if (yB + x1Cur > yB + y2New)
1074:                                      ovrlap = yB + x1Cur;
1075:                                  else    
1076:                                      ovrlap = yB + y2New + 1;
1077:                                  if(Bar(xR + y1Cur, ovrlap, xR + y2New, yB + x2Cur) == 0)
1078:                                      return 0;    
1079:                              }
1080:              
1081:                              state = QUAD31;
1082:                              break;
1083:              
1084:                          case QUAD31:
1085:              
1086:                              // 5th octant
1087:                              if(octant & 0x10)
1088:                              {
1089:                                  // check overlaps
1090:                                  if (yB + x1Cur > yB + y1New)
1091:                                      ovrlap = yB + x1Cur;
1092:                                  else    
1093:                                      ovrlap = yB + y1New + 1;
1094:                                  if(Bar(xL - y1New, ovrlap, xL - y2Cur, yB + x2Cur) == 0)
1095:                                      return 0;    
1096:                              }
1097:              
1098:                              state = QUAD32;
1099:                              break;
1100:              
1101:                          case QUAD32:
1102:              
1103:                              // 6th octant
1104:                              if(octant & 0x20)
1105:                              {
1106:                                  // check overlaps
1107:                                  if (xL - x1Cur < xL - y1New)
1108:                                      ovrlap = xL - x1Cur;
1109:                                  else    
1110:                                      ovrlap = xL - y1New;
1111:                                  if(Bar(xL - x2Cur, yB + y2Cur, ovrlap, yB + y1New) == 0)
1112:                                      return 0;
1113:                              }
1114:              
1115:                              state = QUAD41;
1116:                              break;
1117:              
1118:                          case QUAD41:
1119:              
1120:                              // 7th octant
1121:                              if(octant & 0x40)
1122:                              {
1123:                                  // check overlaps
1124:                                  if (xL - x1Cur < xL - y2New)
1125:                                      ovrlap = xL - x1Cur;
1126:                                  else    
1127:                                      ovrlap = xL - y2New;
1128:                                  if(Bar(xL - x2Cur, yT - y2New, ovrlap, yT - y1Cur) == 0)
1129:                                      return 0;
1130:                              }
1131:              
1132:                              state = QUAD42;
1133:                              break;
1134:              
1135:                          case QUAD42:
1136:              
1137:                              // 8th octant
1138:                              if(octant & 0x80)
1139:                              {
1140:                                  // check overlaps
1141:                                  if (yT - x1Cur < yT - y2New)
1142:                                      ovrlap = yT - x1Cur;
1143:                                  else    
1144:                                      ovrlap = yT - y2New - 1;
1145:                                  if(Bar(xL - y2New, yT - x2Cur, xL - y1Cur, ovrlap) == 0)
1146:                                      return 0;    
1147:                              }
1148:              
1149:                              // update current values
1150:                              x1Cur = x1;
1151:                              y1Cur = y1;
1152:                              x2Cur = x2;
1153:                              y2Cur = y2;
1154:                              state = CHECK;
1155:                              break;
1156:              
1157:                          case BARRIGHT1:     // draw upper right
1158:                              arc_draw_width_height_state : if((xR - xL) || (yB - yT))
1159:                              {
1160:              
1161:                                  // draw right
1162:                                  if(octant & 0x02)
1163:                                  {
1164:                                      if(Bar(xR + r1, yT + 1, xR + r2, (yB + yT) >> 1) == 0)
1165:                                          return 0;
1166:                                  }
1167:                              }
1168:                              else
1169:                              {
1170:                                  state = BEGIN;
1171:                                  return (1);
1172:                              }
1173:              
1174:                              state = BARRIGHT2;
1175:                              break;
1176:              
1177:                          case BARRIGHT2:     // draw lower right
1178:                              if(octant & 0x04)
1179:                              {
1180:                                  if(Bar(xR + r1, ((yB + yT) >> 1) + 1, xR + r2, yB) == 0)
1181:                                      return (0);
1182:                              }
1183:              
1184:                              state = BARBOTTOM1;
1185:                              break;
1186:              
1187:                          case BARBOTTOM1:    // draw left bottom
1188:                              // draw bottom
1189:                              if(octant & 0x10)
1190:                              {
1191:                                  if(Bar(xL + 1, yB + r1, ((xR + xL) >> 1), yB + r2) == 0)
1192:                                      return (0);
1193:                              }
1194:              
1195:                              state = BARBOTTOM2;
1196:                              break;
1197:              
1198:                          case BARBOTTOM2:    // draw right bottom
1199:                              if(octant & 0x08)
1200:                              {
1201:                                  if(Bar(((xR + xL) >> 1) + 1, yB + r1, xR, yB + r2) == 0)
1202:                                      return (0);
1203:                              }
1204:              
1205:                              state = BARTOP1;
1206:                              break;
1207:              
1208:                          case BARTOP1:       // draw left top
1209:                              if(xR - xL)
1210:                              {
1211:              
1212:                                  // draw top
1213:                                  if(octant & 0x80)
1214:                                  {
1215:                                      if(Bar(xL, yT - r2, ((xR + xL) >> 1), yT - r1) == 0)
1216:                                          return (0);
1217:                                  }
1218:              
1219:                                  state = BARTOP2;
1220:                              }
1221:                              else
1222:                                  state = BARLEFT1;   // no width go directly to height bar
1223:                              break;
1224:              
1225:                          case BARTOP2:               // draw right top
1226:                              if(octant & 0x01)
1227:                              {
1228:                                  if(Bar(((xR + xL) >> 1) + 1, yT - r2, xR - 1, yT - r1) == 0)
1229:                                      return (0);
1230:                              }
1231:              
1232:                              state = BARLEFT1;
1233:                              break;
1234:              
1235:                          case BARLEFT1:              // draw upper left
1236:                              if(yT - yB)
1237:                              {
1238:              
1239:                                  // draw left
1240:                                  if(octant & 0x40)
1241:                                  {
1242:                                      if(Bar(xL - r2, yT, xL - r1, ((yB + yT) >> 1)) == 0)
1243:                                          return (0);
1244:                                  }
1245:              
1246:                                  state = BARLEFT2;
1247:                              }
1248:                              else
1249:                              {
1250:                                  state = BEGIN;      // no height go back to BEGIN
1251:                                  return (1);
1252:                              }
1253:              
1254:                              break;
1255:              
1256:                          case BARLEFT2:              // draw lower left
1257:                              if(octant & 0x20)
1258:                              {
1259:                                  if(Bar(xL - r2, ((yB + yT) >> 1) + 1, xL - r1, yB - 1) == 0)
1260:                                      return (0);
1261:                              }
1262:              
1263:                              state = BEGIN;
1264:                              return (1);
1265:                      }                               // end of switch
1266:                  }   // end of while
1267:                  #endif // USE_NONBLOCKING_CONFIG
1268:              }
005C78  FA8000     ULNK
005C7A  060000     RETURN
1269:              
1270:              /*********************************************************************
1271:              * Function: WORD Bevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
1272:              *
1273:              * PreCondition: None
1274:              *
1275:              * Input: x1, y1 - coordinate position of the upper left center of the 
1276:              * 				  circle that draws the rounded corners,
1277:              *		 x2, y2 - coordinate position of the lower right center of the 
1278:              * 				  circle that draws the rounded corners,
1279:              *        rad - defines the redius of the circle,
1280:              *
1281:              * Output: For NON-Blocking configuration:
1282:              *         - Returns 0 when device is busy and the shape is not yet completely drawn.
1283:              *         - Returns 1 when the shape is completely drawn.
1284:              *         For Blocking configuration:
1285:              *         - Always return 1.
1286:              *
1287:              * Overview: Draws a beveled figure on the screen. 
1288:              *           For a pure circular object x1 = x2 and y1 = y2. 
1289:              *           For a rectangular object radius = 0.
1290:              *
1291:              * Note: none
1292:              *
1293:              ********************************************************************/
1294:              WORD __attribute__((weak)) Bevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
1295:              {
005C7C  FA001A     LNK #0x1A
005C7E  980F00     MOV W0, [W14+16]
005C80  980F11     MOV W1, [W14+18]
005C82  980F22     MOV W2, [W14+20]
005C84  980F33     MOV W3, [W14+22]
005C86  980F44     MOV W4, [W14+24]
1296:                  SHORT       style, type, xLimit, xPos, yPos, error;
1297:                  DWORD_VAL   temp;
1298:              
1299:                  #ifndef USE_NONBLOCKING_CONFIG
1300:                  while(IsDeviceBusy() != 0) Nop();
005C88  370001     BRA 0x5C8C
005C8A  000000     NOP
005C8C  073342     RCALL IsDeviceBusy
005C8E  500FE0     SUB W0, #0x0, [W15]
005C90  3AFFFC     BRA NZ, 0x5C8A
1301:              
1302:                  /* Ready */
1303:                  #else
1304:                  if(IsDeviceBusy() != 0)
1305:                      return (0);
1306:                  #endif
1307:                  temp.Val = SIN45 * rad;
005C92  90084E     MOV [W14+24], W0
005C94  DE80CF     ASR W0, #15, W1
005C96  2B5052     MOV #0xB505, W2
005C98  B98902     MUL.SS W1, W2, W2
005C9A  780102     MOV W2, W2
005C9C  B90260     MUL.SU W0, #0, W4
005C9E  780184     MOV W4, W3
005CA0  410103     ADD W2, W3, W2
005CA2  2B5053     MOV #0xB505, W3
005CA4  B80003     MUL.UU W0, W3, W0
005CA6  410101     ADD W2, W1, W2
005CA8  780082     MOV W2, W1
005CAA  980760     MOV W0, [W14+12]
005CAC  980771     MOV W1, [W14+14]
1308:                  xLimit = temp.w[1] + 1;
005CAE  90007E     MOV [W14+14], W0
005CB0  E80000     INC W0, W0
005CB2  980750     MOV W0, [W14+10]
1309:                  temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
005CB4  90084E     MOV [W14+24], W0
005CB6  DE80CF     ASR W0, #15, W1
005CB8  DD00C0     SL W0, #0, W1
005CBA  200000     MOV #0x0, W0
005CBC  240002     MOV #0x4000, W2
005CBE  200013     MOV #0x1, W3
005CC0  510000     SUB W2, W0, W0
005CC2  598081     SUBB W3, W1, W1
005CC4  980760     MOV W0, [W14+12]
005CC6  980771     MOV W1, [W14+14]
1310:                  error = (SHORT) (temp.w[1]);
005CC8  90007E     MOV [W14+14], W0
005CCA  980740     MOV W0, [W14+8]
1311:                  yPos = rad;
005CCC  90084E     MOV [W14+24], W0
005CCE  980730     MOV W0, [W14+6]
1312:              
1313:                  style = 0;
005CD0  EB0000     CLR W0
005CD2  780F00     MOV W0, [W14]
1314:                  type = 1;
005CD4  200010     MOV #0x1, W0
005CD6  980710     MOV W0, [W14+2]
1315:              
1316:                  if(rad)
005CD8  90084E     MOV [W14+24], W0
005CDA  500FE0     SUB W0, #0x0, [W15]
005CDC  3200E7     BRA Z, 0x5EAC
1317:                  {
1318:                      for(xPos = 0; xPos <= xLimit; xPos++)
005CDE  EB0000     CLR W0
005CE0  980720     MOV W0, [W14+4]
005CE2  3700E0     BRA 0x5EA4
005E9E  90002E     MOV [W14+4], W0
005EA0  E80000     INC W0, W0
005EA2  980720     MOV W0, [W14+4]
005EA4  9000AE     MOV [W14+4], W1
005EA6  90005E     MOV [W14+10], W0
005EA8  508F80     SUB W1, W0, [W15]
005EAA  34FF1C     BRA LE, 0x5CE4
1319:                      {
1320:                          if((++style) == _lineType)
005CE4  E80F1E     INC [W14], [W14]
005CE6  808240     MOV _lineType, W0
005CE8  78009E     MOV [W14], W1
005CEA  508F80     SUB W1, W0, [W15]
005CEC  3A0005     BRA NZ, 0x5CF8
1321:                          {
1322:                              type ^= 1;
005CEE  90001E     MOV [W14+2], W0
005CF0  A20000     BTG W0, #0
005CF2  980710     MOV W0, [W14+2]
1323:                              style = 0;
005CF4  EB0000     CLR W0
005CF6  780F00     MOV W0, [W14]
1324:                          }
1325:              
1326:                          if(type)
005CF8  90001E     MOV [W14+2], W0
005CFA  500FE0     SUB W0, #0x0, [W15]
005CFC  3200BB     BRA Z, 0x5E74
1327:                          {
1328:                              PutPixel(x2 + xPos, y1 - yPos);         // 1st quadrant
005CFE  90089E     MOV [W14+18], W1
005D00  90003E     MOV [W14+6], W0
005D02  508080     SUB W1, W0, W1
005D04  90092E     MOV [W14+20], W2
005D06  90002E     MOV [W14+4], W0
005D08  410000     ADD W2, W0, W0
005D0A  0732CF     RCALL PutPixel
1329:                              PutPixel(x2 + yPos, y1 - xPos);
005D0C  90089E     MOV [W14+18], W1
005D0E  90002E     MOV [W14+4], W0
005D10  508080     SUB W1, W0, W1
005D12  90092E     MOV [W14+20], W2
005D14  90003E     MOV [W14+6], W0
005D16  410000     ADD W2, W0, W0
005D18  0732C8     RCALL PutPixel
1330:                              PutPixel(x2 + xPos, y2 + yPos);         // 2nd quadrant
005D1A  9008BE     MOV [W14+22], W1
005D1C  90003E     MOV [W14+6], W0
005D1E  408080     ADD W1, W0, W1
005D20  90092E     MOV [W14+20], W2
005D22  90002E     MOV [W14+4], W0
005D24  410000     ADD W2, W0, W0
005D26  0732C1     RCALL PutPixel
1331:                              PutPixel(x2 + yPos, y2 + xPos);
005D28  9008BE     MOV [W14+22], W1
005D2A  90002E     MOV [W14+4], W0
005D2C  408080     ADD W1, W0, W1
005D2E  90092E     MOV [W14+20], W2
005D30  90003E     MOV [W14+6], W0
005D32  410000     ADD W2, W0, W0
005D34  0732BA     RCALL PutPixel
1332:                              PutPixel(x1 - xPos, y2 + yPos);         // 3rd quadrant
005D36  9008BE     MOV [W14+22], W1
005D38  90003E     MOV [W14+6], W0
005D3A  408080     ADD W1, W0, W1
005D3C  90090E     MOV [W14+16], W2
005D3E  90002E     MOV [W14+4], W0
005D40  510000     SUB W2, W0, W0
005D42  0732B3     RCALL PutPixel
1333:                              PutPixel(x1 - yPos, y2 + xPos);
005D44  9008BE     MOV [W14+22], W1
005D46  90002E     MOV [W14+4], W0
005D48  408080     ADD W1, W0, W1
005D4A  90090E     MOV [W14+16], W2
005D4C  90003E     MOV [W14+6], W0
005D4E  510000     SUB W2, W0, W0
005D50  0732AC     RCALL PutPixel
1334:                              PutPixel(x1 - yPos, y1 - xPos);         // 4th quadrant
005D52  90089E     MOV [W14+18], W1
005D54  90002E     MOV [W14+4], W0
005D56  508080     SUB W1, W0, W1
005D58  90090E     MOV [W14+16], W2
005D5A  90003E     MOV [W14+6], W0
005D5C  510000     SUB W2, W0, W0
005D5E  0732A5     RCALL PutPixel
1335:                              PutPixel(x1 - xPos, y1 - yPos);
005D60  90089E     MOV [W14+18], W1
005D62  90003E     MOV [W14+6], W0
005D64  508080     SUB W1, W0, W1
005D66  90090E     MOV [W14+16], W2
005D68  90002E     MOV [W14+4], W0
005D6A  510000     SUB W2, W0, W0
005D6C  07329E     RCALL PutPixel
1336:              
1337:                              if(_lineThickness)
005D6E  BFD04A     MOV.B _lineThickness, WREG
005D70  504FE0     SUB.B W0, #0x0, [W15]
005D72  320080     BRA Z, 0x5E74
1338:                              {
1339:                                  PutPixel(x2 + xPos, y1 - yPos - 1); // 1st quadrant
005D74  90089E     MOV [W14+18], W1
005D76  90003E     MOV [W14+6], W0
005D78  508000     SUB W1, W0, W0
005D7A  E90080     DEC W0, W1
005D7C  90092E     MOV [W14+20], W2
005D7E  90002E     MOV [W14+4], W0
005D80  410000     ADD W2, W0, W0
005D82  073293     RCALL PutPixel
1340:                                  PutPixel(x2 + xPos, y1 - yPos + 1);
005D84  90089E     MOV [W14+18], W1
005D86  90003E     MOV [W14+6], W0
005D88  508000     SUB W1, W0, W0
005D8A  E80080     INC W0, W1
005D8C  90092E     MOV [W14+20], W2
005D8E  90002E     MOV [W14+4], W0
005D90  410000     ADD W2, W0, W0
005D92  07328B     RCALL PutPixel
1341:                                  PutPixel(x2 + yPos + 1, y1 - xPos);
005D94  90089E     MOV [W14+18], W1
005D96  90002E     MOV [W14+4], W0
005D98  508080     SUB W1, W0, W1
005D9A  90092E     MOV [W14+20], W2
005D9C  90003E     MOV [W14+6], W0
005D9E  410000     ADD W2, W0, W0
005DA0  E80000     INC W0, W0
005DA2  073283     RCALL PutPixel
1342:                                  PutPixel(x2 + yPos - 1, y1 - xPos);
005DA4  90089E     MOV [W14+18], W1
005DA6  90002E     MOV [W14+4], W0
005DA8  508080     SUB W1, W0, W1
005DAA  90092E     MOV [W14+20], W2
005DAC  90003E     MOV [W14+6], W0
005DAE  410000     ADD W2, W0, W0
005DB0  E90000     DEC W0, W0
005DB2  07327B     RCALL PutPixel
1343:                                  PutPixel(x2 + xPos, y2 + yPos - 1); // 2nd quadrant
005DB4  9008BE     MOV [W14+22], W1
005DB6  90003E     MOV [W14+6], W0
005DB8  408000     ADD W1, W0, W0
005DBA  E90080     DEC W0, W1
005DBC  90092E     MOV [W14+20], W2
005DBE  90002E     MOV [W14+4], W0
005DC0  410000     ADD W2, W0, W0
005DC2  073273     RCALL PutPixel
1344:                                  PutPixel(x2 + xPos, y2 + yPos + 1);
005DC4  9008BE     MOV [W14+22], W1
005DC6  90003E     MOV [W14+6], W0
005DC8  408000     ADD W1, W0, W0
005DCA  E80080     INC W0, W1
005DCC  90092E     MOV [W14+20], W2
005DCE  90002E     MOV [W14+4], W0
005DD0  410000     ADD W2, W0, W0
005DD2  07326B     RCALL PutPixel
1345:                                  PutPixel(x2 + yPos + 1, y2 + xPos);
005DD4  9008BE     MOV [W14+22], W1
005DD6  90002E     MOV [W14+4], W0
005DD8  408080     ADD W1, W0, W1
005DDA  90092E     MOV [W14+20], W2
005DDC  90003E     MOV [W14+6], W0
005DDE  410000     ADD W2, W0, W0
005DE0  E80000     INC W0, W0
005DE2  073263     RCALL PutPixel
1346:                                  PutPixel(x2 + yPos - 1, y2 + xPos);
005DE4  9008BE     MOV [W14+22], W1
005DE6  90002E     MOV [W14+4], W0
005DE8  408080     ADD W1, W0, W1
005DEA  90092E     MOV [W14+20], W2
005DEC  90003E     MOV [W14+6], W0
005DEE  410000     ADD W2, W0, W0
005DF0  E90000     DEC W0, W0
005DF2  07325B     RCALL PutPixel
1347:                                  PutPixel(x1 - xPos, y2 + yPos - 1); // 3rd quadrant
005DF4  9008BE     MOV [W14+22], W1
005DF6  90003E     MOV [W14+6], W0
005DF8  408000     ADD W1, W0, W0
005DFA  E90080     DEC W0, W1
005DFC  90090E     MOV [W14+16], W2
005DFE  90002E     MOV [W14+4], W0
005E00  510000     SUB W2, W0, W0
005E02  073253     RCALL PutPixel
1348:                                  PutPixel(x1 - xPos, y2 + yPos + 1);
005E04  9008BE     MOV [W14+22], W1
005E06  90003E     MOV [W14+6], W0
005E08  408000     ADD W1, W0, W0
005E0A  E80080     INC W0, W1
005E0C  90090E     MOV [W14+16], W2
005E0E  90002E     MOV [W14+4], W0
005E10  510000     SUB W2, W0, W0
005E12  07324B     RCALL PutPixel
1349:                                  PutPixel(x1 - yPos + 1, y2 + xPos);
005E14  9008BE     MOV [W14+22], W1
005E16  90002E     MOV [W14+4], W0
005E18  408080     ADD W1, W0, W1
005E1A  90090E     MOV [W14+16], W2
005E1C  90003E     MOV [W14+6], W0
005E1E  510000     SUB W2, W0, W0
005E20  E80000     INC W0, W0
005E22  073243     RCALL PutPixel
1350:                                  PutPixel(x1 - yPos - 1, y2 + xPos);
005E24  9008BE     MOV [W14+22], W1
005E26  90002E     MOV [W14+4], W0
005E28  408080     ADD W1, W0, W1
005E2A  90090E     MOV [W14+16], W2
005E2C  90003E     MOV [W14+6], W0
005E2E  510000     SUB W2, W0, W0
005E30  E90000     DEC W0, W0
005E32  07323B     RCALL PutPixel
1351:                                  PutPixel(x1 - yPos + 1, y1 - xPos); // 4th quadrant
005E34  90089E     MOV [W14+18], W1
005E36  90002E     MOV [W14+4], W0
005E38  508080     SUB W1, W0, W1
005E3A  90090E     MOV [W14+16], W2
005E3C  90003E     MOV [W14+6], W0
005E3E  510000     SUB W2, W0, W0
005E40  E80000     INC W0, W0
005E42  073233     RCALL PutPixel
1352:                                  PutPixel(x1 - yPos - 1, y1 - xPos);
005E44  90089E     MOV [W14+18], W1
005E46  90002E     MOV [W14+4], W0
005E48  508080     SUB W1, W0, W1
005E4A  90090E     MOV [W14+16], W2
005E4C  90003E     MOV [W14+6], W0
005E4E  510000     SUB W2, W0, W0
005E50  E90000     DEC W0, W0
005E52  07322B     RCALL PutPixel
1353:                                  PutPixel(x1 - xPos, y1 - yPos + 1);
005E54  90089E     MOV [W14+18], W1
005E56  90003E     MOV [W14+6], W0
005E58  508000     SUB W1, W0, W0
005E5A  E80080     INC W0, W1
005E5C  90090E     MOV [W14+16], W2
005E5E  90002E     MOV [W14+4], W0
005E60  510000     SUB W2, W0, W0
005E62  073223     RCALL PutPixel
1354:                                  PutPixel(x1 - xPos, y1 - yPos - 1);
005E64  90089E     MOV [W14+18], W1
005E66  90003E     MOV [W14+6], W0
005E68  508000     SUB W1, W0, W0
005E6A  E90080     DEC W0, W1
005E6C  90090E     MOV [W14+16], W2
005E6E  90002E     MOV [W14+4], W0
005E70  510000     SUB W2, W0, W0
005E72  07321B     RCALL PutPixel
1355:                              }
1356:                          }
1357:              
1358:                          if(error > 0)
005E74  90004E     MOV [W14+8], W0
005E76  500FE0     SUB W0, #0x0, [W15]
005E78  34000C     BRA LE, 0x5E92
1359:                          {
1360:                              yPos--;
005E7A  90003E     MOV [W14+6], W0
005E7C  E90000     DEC W0, W0
005E7E  980730     MOV W0, [W14+6]
1361:                              error += 5 + ((xPos - yPos) << 1);
005E80  9000AE     MOV [W14+4], W1
005E82  90003E     MOV [W14+6], W0
005E84  508000     SUB W1, W0, W0
005E86  400000     ADD W0, W0, W0
005E88  400065     ADD W0, #0x5, W0
005E8A  9000CE     MOV [W14+8], W1
005E8C  408000     ADD W1, W0, W0
005E8E  980740     MOV W0, [W14+8]
005E90  370006     BRA 0x5E9E
1362:                          }
1363:                          else
1364:                              error += 3 + (xPos << 1);
005E92  90002E     MOV [W14+4], W0
005E94  400000     ADD W0, W0, W0
005E96  400063     ADD W0, #0x3, W0
005E98  9000CE     MOV [W14+8], W1
005E9A  408000     ADD W1, W0, W0
005E9C  980740     MOV W0, [W14+8]
1365:                      }
1366:                  }
1367:                  // Must use lines here since this can also be used to draw focus of round buttons
1368:                  if(x2 - x1)
005EAC  9008AE     MOV [W14+20], W1
005EAE  90080E     MOV [W14+16], W0
005EB0  508F80     SUB W1, W0, [W15]
005EB2  32000E     BRA Z, 0x5ED0
1369:                  {
1370:                      while(!Line(x1, y1 - rad, x2, y1 - rad));
005EB4  000000     NOP
005EB6  90089E     MOV [W14+18], W1
005EB8  90084E     MOV [W14+24], W0
005EBA  508080     SUB W1, W0, W1
005EBC  90091E     MOV [W14+18], W2
005EBE  90084E     MOV [W14+24], W0
005EC0  510000     SUB W2, W0, W0
005EC2  780181     MOV W1, W3
005EC4  90092E     MOV [W14+20], W2
005EC6  780080     MOV W0, W1
005EC8  90080E     MOV [W14+16], W0
005ECA  07FB1B     RCALL Line
005ECC  500FE0     SUB W0, #0x0, [W15]
005ECE  32FFF3     BRA Z, 0x5EB6
1371:              
1372:                      // draw top
1373:                  }
1374:              
1375:                  if(y2 - y1)
005ED0  9008BE     MOV [W14+22], W1
005ED2  90081E     MOV [W14+18], W0
005ED4  508F80     SUB W1, W0, [W15]
005ED6  32000D     BRA Z, 0x5EF2
1376:                  {
1377:                      while(!Line(x1 - rad, y1, x1 - rad, y2));
005ED8  000000     NOP
005EDA  90088E     MOV [W14+16], W1
005EDC  90084E     MOV [W14+24], W0
005EDE  508080     SUB W1, W0, W1
005EE0  90090E     MOV [W14+16], W2
005EE2  90084E     MOV [W14+24], W0
005EE4  510000     SUB W2, W0, W0
005EE6  9009BE     MOV [W14+22], W3
005EE8  780101     MOV W1, W2
005EEA  90089E     MOV [W14+18], W1
005EEC  07FB0A     RCALL Line
005EEE  500FE0     SUB W0, #0x0, [W15]
005EF0  32FFF4     BRA Z, 0x5EDA
1378:              
1379:                      // draw left
1380:                  }
1381:              
1382:                  if((x2 - x1) || (y2 - y1))
005EF2  9008AE     MOV [W14+20], W1
005EF4  90080E     MOV [W14+16], W0
005EF6  508F80     SUB W1, W0, [W15]
005EF8  3A0005     BRA NZ, 0x5F04
005EFA  9008BE     MOV [W14+22], W1
005EFC  90081E     MOV [W14+18], W0
005EFE  508F80     SUB W1, W0, [W15]
005F00  32001C     BRA Z, 0x5F3A
1383:                  {
1384:                      while(!Line(x2 + rad, y1, x2 + rad, y2));
005F02  370001     BRA 0x5F06
005F04  000000     NOP
005F06  9008AE     MOV [W14+20], W1
005F08  90084E     MOV [W14+24], W0
005F0A  408080     ADD W1, W0, W1
005F0C  90092E     MOV [W14+20], W2
005F0E  90084E     MOV [W14+24], W0
005F10  410000     ADD W2, W0, W0
005F12  9009BE     MOV [W14+22], W3
005F14  780101     MOV W1, W2
005F16  90089E     MOV [W14+18], W1
005F18  07FAF4     RCALL Line
005F1A  500FE0     SUB W0, #0x0, [W15]
005F1C  32FFF4     BRA Z, 0x5F06
1385:              
1386:                      // draw right
1387:                      while(!Line(x1, y2 + rad, x2, y2 + rad));
005F1E  000000     NOP
005F20  9008BE     MOV [W14+22], W1
005F22  90084E     MOV [W14+24], W0
005F24  408080     ADD W1, W0, W1
005F26  90093E     MOV [W14+22], W2
005F28  90084E     MOV [W14+24], W0
005F2A  410000     ADD W2, W0, W0
005F2C  780181     MOV W1, W3
005F2E  90092E     MOV [W14+20], W2
005F30  780080     MOV W0, W1
005F32  90080E     MOV [W14+16], W0
005F34  07FAE6     RCALL Line
005F36  500FE0     SUB W0, #0x0, [W15]
005F38  32FFF3     BRA Z, 0x5F20
1388:              
1389:                      // draw bottom
1390:                  }
1391:              
1392:                  return (1);
005F3A  200010     MOV #0x1, W0
1393:              }
005F3C  FA8000     ULNK
005F3E  060000     RETURN
1394:              
1395:              /*********************************************************************
1396:              * Function: WORD FillBevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
1397:              *
1398:              * PreCondition: None
1399:              *
1400:              * Input: x1, y1 - coordinate position of the upper left center of the 
1401:              * 				  circle that draws the rounded corners,
1402:              *		 x2, y2 - coordinate position of the lower right center of the 
1403:              * 				  circle that draws the rounded corners,
1404:              *        rad - defines the redius of the circle,
1405:              *
1406:              * Output: For NON-Blocking configuration:
1407:              *         - Returns 0 when device is busy and the shape is not yet completely drawn.
1408:              *         - Returns 1 when the shape is completely drawn.
1409:              *         For Blocking configuration:
1410:              *         - Always return 1.
1411:              *
1412:              * Overview: Draws a filled beveled figure on the screen. 
1413:              *           For a filled circular object x1 = x2 and y1 = y2. 
1414:              *           For a filled rectangular object radius = 0.
1415:              *
1416:              * Note: none
1417:              *
1418:              ********************************************************************/
1419:              WORD FillBevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
1420:              {
005F40  FA0020     LNK #0x20
005F42  980F30     MOV W0, [W14+22]
005F44  980F41     MOV W1, [W14+24]
005F46  980F52     MOV W2, [W14+26]
005F48  980F63     MOV W3, [W14+28]
005F4A  980F74     MOV W4, [W14+30]
1421:              
1422:                  #ifndef USE_NONBLOCKING_CONFIG
1423:              
1424:                  SHORT       yLimit, xPos, yPos, err;
1425:                  SHORT       xCur, yCur, yNew;
1426:                  SHORT       last54Y, last18Y;
1427:                  DWORD_VAL   temp;
1428:              
1429:              
1430:                  // this covers filled rectangle.
1431:                  if (_bevelDrawType == DRAWFULLBEVEL) 
005F4C  BFD05A     MOV.B _bevelDrawType, WREG
005F4E  404FE1     ADD.B W0, #0x1, [W15]
005F50  3A000B     BRA NZ, 0x5F68
1432:              	    Bar(x1 - rad, y1, x2 + rad, y2);
005F52  9008DE     MOV [W14+26], W1
005F54  90087E     MOV [W14+30], W0
005F56  408080     ADD W1, W0, W1
005F58  90093E     MOV [W14+22], W2
005F5A  90087E     MOV [W14+30], W0
005F5C  510000     SUB W2, W0, W0
005F5E  9009EE     MOV [W14+28], W3
005F60  780101     MOV W1, W2
005F62  9008CE     MOV [W14+24], W1
005F64  07FAAB     RCALL Bar
005F66  370022     BRA 0x5FAC
1433:                  else if (_bevelDrawType == DRAWTOPBEVEL)    
005F68  BFD05A     MOV.B _bevelDrawType, WREG
005F6A  404FF0     ADD.B W0, #0x10, [W15]
005F6C  3A0011     BRA NZ, 0x5F90
1434:              	    Bar(x1 - rad, y1, x2 + rad, y1+((y2-y1)>>1));
005F6E  9008EE     MOV [W14+28], W1
005F70  90084E     MOV [W14+24], W0
005F72  508000     SUB W1, W0, W0
005F74  D18080     ASR W0, W1
005F76  90084E     MOV [W14+24], W0
005F78  408100     ADD W1, W0, W2
005F7A  9008DE     MOV [W14+26], W1
005F7C  90087E     MOV [W14+30], W0
005F7E  408080     ADD W1, W0, W1
005F80  9009BE     MOV [W14+22], W3
005F82  90087E     MOV [W14+30], W0
005F84  518000     SUB W3, W0, W0
005F86  780182     MOV W2, W3
005F88  780101     MOV W1, W2
005F8A  9008CE     MOV [W14+24], W1
005F8C  07FA97     RCALL Bar
005F8E  37000E     BRA 0x5FAC
1435:                  else    
1436:              	    Bar(x1 - rad, y1+((y2-y1)>>1), x2 + rad, y2);
005F90  9008DE     MOV [W14+26], W1
005F92  90087E     MOV [W14+30], W0
005F94  408100     ADD W1, W0, W2
005F96  9008EE     MOV [W14+28], W1
005F98  90084E     MOV [W14+24], W0
005F9A  508000     SUB W1, W0, W0
005F9C  D18080     ASR W0, W1
005F9E  90084E     MOV [W14+24], W0
005FA0  408080     ADD W1, W0, W1
005FA2  9009BE     MOV [W14+22], W3
005FA4  90087E     MOV [W14+30], W0
005FA6  518000     SUB W3, W0, W0
005FA8  9009EE     MOV [W14+28], W3
005FAA  07FA88     RCALL Bar
1437:              	 
1438:                  // note that octants here is defined as:
1439:                  // from yPos=-radius, xPos=0 in the clockwise direction octant 1 to 8 are labeled
1440:                  // assumes an origin at 0,0. Quadrants are defined in the same manner
1441:                  if(rad)
005FAC  90087E     MOV [W14+30], W0
005FAE  500FE0     SUB W0, #0x0, [W15]
005FB0  3200F9     BRA Z, 0x61A4
1442:                  {
1443:                      temp.Val = SIN45 * rad;
005FB2  90087E     MOV [W14+30], W0
005FB4  DE80CF     ASR W0, #15, W1
005FB6  2B5052     MOV #0xB505, W2
005FB8  B98902     MUL.SS W1, W2, W2
005FBA  780102     MOV W2, W2
005FBC  B90260     MUL.SU W0, #0, W4
005FBE  780184     MOV W4, W3
005FC0  410103     ADD W2, W3, W2
005FC2  2B5053     MOV #0xB505, W3
005FC4  B80003     MUL.UU W0, W3, W0
005FC6  410101     ADD W2, W1, W2
005FC8  780082     MOV W2, W1
005FCA  980F10     MOV W0, [W14+18]
005FCC  980F21     MOV W1, [W14+20]
1444:                      yLimit = temp.w[1];
005FCE  90082E     MOV [W14+20], W0
005FD0  980F00     MOV W0, [W14+16]
1445:                      temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
005FD2  90087E     MOV [W14+30], W0
005FD4  DE80CF     ASR W0, #15, W1
005FD6  DD00C0     SL W0, #0, W1
005FD8  200000     MOV #0x0, W0
005FDA  240002     MOV #0x4000, W2
005FDC  200013     MOV #0x1, W3
005FDE  510000     SUB W2, W0, W0
005FE0  598081     SUBB W3, W1, W1
005FE2  980F10     MOV W0, [W14+18]
005FE4  980F21     MOV W1, [W14+20]
1446:                      err = (SHORT) (temp.w[1]);
005FE6  90082E     MOV [W14+20], W0
005FE8  980720     MOV W0, [W14+4]
1447:                      xPos = rad;
005FEA  90087E     MOV [W14+30], W0
005FEC  780F00     MOV W0, [W14]
1448:                      yPos = 0;
005FEE  EB0000     CLR W0
005FF0  980710     MOV W0, [W14+2]
1449:              
1450:                      // yCur starts at 1 so the center line is not drawn and will be drawn separately
1451:                      // this is to avoid rendering twice on the same line
1452:                      yCur = 1;           
005FF2  200010     MOV #0x1, W0
005FF4  980740     MOV W0, [W14+8]
1453:                      xCur = xPos;
005FF6  78001E     MOV [W14], W0
005FF8  980730     MOV W0, [W14+6]
1454:                      yNew = yPos;
005FFA  90001E     MOV [W14+2], W0
005FFC  980750     MOV W0, [W14+10]
1455:              
1456:                      // note initial values are important
1457:                      last54Y = GetMaxY();
005FFE  2003F0     MOV #0x3F, W0
006000  980760     MOV W0, [W14+12]
1458:                      last18Y = 0;
006002  EB0000     CLR W0
006004  980770     MOV W0, [W14+14]
1459:              
1460:                      while(yPos <= yLimit)
006006  37009B     BRA 0x613E
00613E  90009E     MOV [W14+2], W1
006140  90080E     MOV [W14+16], W0
006142  508F80     SUB W1, W0, [W15]
006144  34FF61     BRA LE, 0x6008
1461:                      {
1462:                          // Drawing of the rounded panel is done only when there is a change in the
1463:                          // x direction. Bars are drawn to be efficient.
1464:                          // detect changes in the x position. Every change will mean a bar will be drawn
1465:                          // to cover the previous area. yNew records the last position of y before the
1466:                          // change in x position.
1467:                          yNew = yPos;
006008  90001E     MOV [W14+2], W0
00600A  980750     MOV W0, [W14+10]
1468:              
1469:                          if(err > 0)
00600C  90002E     MOV [W14+4], W0
00600E  500FE0     SUB W0, #0x0, [W15]
006010  340009     BRA LE, 0x6024
1470:                          {
1471:                              xPos--;
006012  E90F1E     DEC [W14], [W14]
1472:                              err += 5 + ((yPos - xPos) << 1);
006014  90001E     MOV [W14+2], W0
006016  50001E     SUB W0, [W14], W0
006018  400000     ADD W0, W0, W0
00601A  400065     ADD W0, #0x5, W0
00601C  9000AE     MOV [W14+4], W1
00601E  408000     ADD W1, W0, W0
006020  980720     MOV W0, [W14+4]
006022  370006     BRA 0x6030
1473:                          }
1474:                          else
1475:                              err += 3 + (yPos << 1);
006024  90001E     MOV [W14+2], W0
006026  400000     ADD W0, W0, W0
006028  400063     ADD W0, #0x3, W0
00602A  9000AE     MOV [W14+4], W1
00602C  408000     ADD W1, W0, W0
00602E  980720     MOV W0, [W14+4]
1476:                          yPos++;
006030  90001E     MOV [W14+2], W0
006032  E80000     INC W0, W0
006034  980710     MOV W0, [W14+2]
1477:              
1478:                          if(xCur != xPos)
006036  90003E     MOV [W14+6], W0
006038  500F9E     SUB W0, [W14], [W15]
00603A  320081     BRA Z, 0x613E
1479:                          {
1480:              	            if (_bevelDrawType & DRAWBOTTOMBEVEL) 
00603C  BFD05A     MOV.B _bevelDrawType, WREG
00603E  FB8000     ZE W0, W0
006040  60006F     AND W0, #0xF, W0
006042  500FE0     SUB W0, #0x0, [W15]
006044  320039     BRA Z, 0x60B8
1481:              	            { 
1482:              	                // 6th octant to 3rd octant
1483:                                  // check first if there will be an overlap
1484:                                  if (y2 + yNew > last54Y)
006046  9008EE     MOV [W14+28], W1
006048  90005E     MOV [W14+10], W0
00604A  408080     ADD W1, W0, W1
00604C  90006E     MOV [W14+12], W0
00604E  508F80     SUB W1, W0, [W15]
006050  34000D     BRA LE, 0x606C
1485:                  	                Bar(x1 - xCur, y2 + yCur, x2 + xCur, last54Y - 1);
006052  90006E     MOV [W14+12], W0
006054  E90180     DEC W0, W3
006056  9008DE     MOV [W14+26], W1
006058  90003E     MOV [W14+6], W0
00605A  408100     ADD W1, W0, W2
00605C  9008EE     MOV [W14+28], W1
00605E  90004E     MOV [W14+8], W0
006060  408080     ADD W1, W0, W1
006062  900A3E     MOV [W14+22], W4
006064  90003E     MOV [W14+6], W0
006066  520000     SUB W4, W0, W0
006068  07FA29     RCALL Bar
00606A  37000D     BRA 0x6086
1486:                                  else
1487:                  	                Bar(x1 - xCur, y2 + yCur, x2 + xCur, y2 + yNew);
00606C  9008EE     MOV [W14+28], W1
00606E  90005E     MOV [W14+10], W0
006070  408180     ADD W1, W0, W3
006072  9008DE     MOV [W14+26], W1
006074  90003E     MOV [W14+6], W0
006076  408100     ADD W1, W0, W2
006078  9008EE     MOV [W14+28], W1
00607A  90004E     MOV [W14+8], W0
00607C  408080     ADD W1, W0, W1
00607E  900A3E     MOV [W14+22], W4
006080  90003E     MOV [W14+6], W0
006082  520000     SUB W4, W0, W0
006084  07FA1B     RCALL Bar
1488:                          
1489:                 	                // 5th octant to 4th octant
1490:                                  // check: if overlapping then no need to proceed
1491:                                  if ((y2 + xCur) > (y2 + yNew))
006086  9008EE     MOV [W14+28], W1
006088  90003E     MOV [W14+6], W0
00608A  408080     ADD W1, W0, W1
00608C  90096E     MOV [W14+28], W2
00608E  90005E     MOV [W14+10], W0
006090  410000     ADD W2, W0, W0
006092  508F80     SUB W1, W0, [W15]
006094  340011     BRA LE, 0x60B8
1492:                                  {
1493:                 	                    Bar(x1 - yNew, y2 + xCur, x2 + yNew, y2 + xCur);
006096  9008EE     MOV [W14+28], W1
006098  90003E     MOV [W14+6], W0
00609A  408180     ADD W1, W0, W3
00609C  9008DE     MOV [W14+26], W1
00609E  90005E     MOV [W14+10], W0
0060A0  408100     ADD W1, W0, W2
0060A2  9008EE     MOV [W14+28], W1
0060A4  90003E     MOV [W14+6], W0
0060A6  408080     ADD W1, W0, W1
0060A8  900A3E     MOV [W14+22], W4
0060AA  90005E     MOV [W14+10], W0
0060AC  520000     SUB W4, W0, W0
0060AE  07FA06     RCALL Bar
1494:                                      last54Y = (y2 + xCur);
0060B0  9008EE     MOV [W14+28], W1
0060B2  90003E     MOV [W14+6], W0
0060B4  408000     ADD W1, W0, W0
0060B6  980760     MOV W0, [W14+12]
1495:                
1496:                                  }
1497:                                  
1498:              				}
1499:              
1500:              	            if (_bevelDrawType & DRAWTOPBEVEL) 
0060B8  BFD05A     MOV.B _bevelDrawType, WREG
0060BA  FB8080     ZE W0, W1
0060BC  200F00     MOV #0xF0, W0
0060BE  608000     AND W1, W0, W0
0060C0  500FE0     SUB W0, #0x0, [W15]
0060C2  320039     BRA Z, 0x6136
1501:              				{
1502:                                  // 7th octant to 2nd octant
1503:                                  // check: if overlapping then no need to proceed
1504:                                  if (y1 - yNew < last18Y)
0060C4  9008CE     MOV [W14+24], W1
0060C6  90005E     MOV [W14+10], W0
0060C8  508080     SUB W1, W0, W1
0060CA  90007E     MOV [W14+14], W0
0060CC  508F80     SUB W1, W0, [W15]
0060CE  3D000D     BRA GE, 0x60EA
1505:              	                    Bar(x1 - xCur, last18Y + 1, x2 + xCur, y1 - yCur);
0060D0  9008CE     MOV [W14+24], W1
0060D2  90004E     MOV [W14+8], W0
0060D4  508180     SUB W1, W0, W3
0060D6  9008DE     MOV [W14+26], W1
0060D8  90003E     MOV [W14+6], W0
0060DA  408100     ADD W1, W0, W2
0060DC  90007E     MOV [W14+14], W0
0060DE  E80080     INC W0, W1
0060E0  900A3E     MOV [W14+22], W4
0060E2  90003E     MOV [W14+6], W0
0060E4  520000     SUB W4, W0, W0
0060E6  07F9EA     RCALL Bar
0060E8  37000D     BRA 0x6104
1506:                                  else
1507:              	                    Bar(x1 - xCur, y1 - yNew, x2 + xCur, y1 - yCur);
0060EA  9008CE     MOV [W14+24], W1
0060EC  90004E     MOV [W14+8], W0
0060EE  508180     SUB W1, W0, W3
0060F0  9008DE     MOV [W14+26], W1
0060F2  90003E     MOV [W14+6], W0
0060F4  408100     ADD W1, W0, W2
0060F6  9008CE     MOV [W14+24], W1
0060F8  90005E     MOV [W14+10], W0
0060FA  508080     SUB W1, W0, W1
0060FC  900A3E     MOV [W14+22], W4
0060FE  90003E     MOV [W14+6], W0
006100  520000     SUB W4, W0, W0
006102  07F9DC     RCALL Bar
1508:              
1509:              	                // 8th octant to 1st octant
1510:                                  // check first if there will be an overlap
1511:                                  if ((y1 - xCur) < (y1 - yNew))
006104  9008CE     MOV [W14+24], W1
006106  90003E     MOV [W14+6], W0
006108  508080     SUB W1, W0, W1
00610A  90094E     MOV [W14+24], W2
00610C  90005E     MOV [W14+10], W0
00610E  510000     SUB W2, W0, W0
006110  508F80     SUB W1, W0, [W15]
006112  3D0011     BRA GE, 0x6136
1512:                                  {
1513:                  	                Bar(x1 - yNew, y1 - xCur, x2 + yNew, y1 - xCur);
006114  9008CE     MOV [W14+24], W1
006116  90003E     MOV [W14+6], W0
006118  508180     SUB W1, W0, W3
00611A  9008DE     MOV [W14+26], W1
00611C  90005E     MOV [W14+10], W0
00611E  408100     ADD W1, W0, W2
006120  9008CE     MOV [W14+24], W1
006122  90003E     MOV [W14+6], W0
006124  508080     SUB W1, W0, W1
006126  900A3E     MOV [W14+22], W4
006128  90005E     MOV [W14+10], W0
00612A  520000     SUB W4, W0, W0
00612C  07F9C7     RCALL Bar
1514:                                      last18Y = y1 - xCur;    
00612E  9008CE     MOV [W14+24], W1
006130  90003E     MOV [W14+6], W0
006132  508000     SUB W1, W0, W0
006134  980770     MOV W0, [W14+14]
1515:                                  }
1516:              
1517:              				}
1518:                              // update current values
1519:                              xCur = xPos;
006136  78001E     MOV [W14], W0
006138  980730     MOV W0, [W14+6]
1520:                              yCur = yPos;
00613A  90001E     MOV [W14+2], W0
00613C  980740     MOV W0, [W14+8]
1521:                          }
1522:                      }
1523:              
1524:                      if ((y1 - yNew) > (y1 - xPos)) 
006146  9008CE     MOV [W14+24], W1
006148  90005E     MOV [W14+10], W0
00614A  508080     SUB W1, W0, W1
00614C  90084E     MOV [W14+24], W0
00614E  50001E     SUB W0, [W14], W0
006150  508F80     SUB W1, W0, [W15]
006152  340011     BRA LE, 0x6176
1525:                      {
1526:                          // there is a missing line, draw that line
1527:                          if (_bevelDrawType & DRAWTOPBEVEL)
006154  BFD05A     MOV.B _bevelDrawType, WREG
006156  FB8080     ZE W0, W1
006158  200F00     MOV #0xF0, W0
00615A  608000     AND W1, W0, W0
00615C  500FE0     SUB W0, #0x0, [W15]
00615E  32000B     BRA Z, 0x6176
1528:                              Bar(x1 - yNew, y1 - xPos, x2 + yNew, y1 - xPos);
006160  90084E     MOV [W14+24], W0
006162  50019E     SUB W0, [W14], W3
006164  9008DE     MOV [W14+26], W1
006166  90005E     MOV [W14+10], W0
006168  408100     ADD W1, W0, W2
00616A  90084E     MOV [W14+24], W0
00616C  50009E     SUB W0, [W14], W1
00616E  900A3E     MOV [W14+22], W4
006170  90005E     MOV [W14+10], W0
006172  520000     SUB W4, W0, W0
006174  07F9A3     RCALL Bar
1529:                      }
1530:                      if ((y2 + yNew) < (y2 + xPos)) 
006176  9008EE     MOV [W14+28], W1
006178  90005E     MOV [W14+10], W0
00617A  408080     ADD W1, W0, W1
00617C  90086E     MOV [W14+28], W0
00617E  40001E     ADD W0, [W14], W0
006180  508F80     SUB W1, W0, [W15]
006182  3D0010     BRA GE, 0x61A4
1531:                      {
1532:                          // there is a missing line, draw that line
1533:                          if (_bevelDrawType & DRAWBOTTOMBEVEL)
006184  BFD05A     MOV.B _bevelDrawType, WREG
006186  FB8000     ZE W0, W0
006188  60006F     AND W0, #0xF, W0
00618A  500FE0     SUB W0, #0x0, [W15]
00618C  32000B     BRA Z, 0x61A4
1534:                              Bar(x1 - yNew, y2 + xPos, x2 + yNew, y2 + xPos);
00618E  90086E     MOV [W14+28], W0
006190  40019E     ADD W0, [W14], W3
006192  9008DE     MOV [W14+26], W1
006194  90005E     MOV [W14+10], W0
006196  408100     ADD W1, W0, W2
006198  90086E     MOV [W14+28], W0
00619A  40009E     ADD W0, [W14], W1
00619C  900A3E     MOV [W14+22], W4
00619E  90005E     MOV [W14+10], W0
0061A0  520000     SUB W4, W0, W0
0061A2  07F98C     RCALL Bar
1535:                      }
1536:                  }
1537:                 
1538:                  return (1);
0061A4  200010     MOV #0x1, W0
1539:              
1540:                  #else
1541:              
1542:                  typedef enum
1543:                  {
1544:                      FB_BEGIN,
1545:                      FB_INIT_FILL,
1546:                      FB_CHECK,
1547:                      FB_Q8TOQ1,
1548:                      FB_Q7TOQ2,
1549:                      FB_Q6TOQ3,
1550:                      FB_Q5TOQ4,
1551:                      FB_DRAW_MISSING_1,    
1552:                      FB_DRAW_MISSING_2,    
1553:                      FB_WAITFORDONE,        
1554:                  } FB_FILLCIRCLE_STATES;
1555:              
1556:                  static SHORT err;
1557:                  static SHORT yLimit, xPos, yPos;
1558:                  static SHORT xCur, yCur, yNew;
1559:                  static SHORT last54Y, last18Y;
1560:                  DWORD_VAL temp;
1561:              
1562:                  static FB_FILLCIRCLE_STATES state = FB_BEGIN;
1563:              
1564:                  while(1)
1565:                  {
1566:                      if(IsDeviceBusy())
1567:                          return (0);
1568:              
1569:                      switch(state)
1570:                      {
1571:                          case FB_BEGIN:
1572:              
1573:                              // draw the face
1574:                              if (_bevelDrawType == DRAWFULLBEVEL)
1575:              				{ 
1576:              				    if(Bar(x1 - rad, y1, x2 + rad, y2) == 0)
1577:              	                    return (0);
1578:              				}
1579:                              else if (_bevelDrawType == DRAWTOPBEVEL)
1580:              				{    
1581:              				    if(Bar(x1 - rad, y1, x2 + rad, y1+((y2-y1)>>1)) == 0)
1582:              	                    return (0);
1583:                              }
1584:              				else    
1585:              				{
1586:              				    if(Bar(x1 - rad, y1+((y2-y1)>>1), x2 + rad, y2) == 0)
1587:              	                    return (0);
1588:                  			}            
1589:                              state = FB_INIT_FILL;
1590:                              break;
1591:                          
1592:                          case FB_INIT_FILL:
1593:              
1594:                              if(!rad)
1595:                              {   // no radius object is a filled rectangle
1596:                                  state = FB_WAITFORDONE;
1597:                                  break;
1598:                              }
1599:              
1600:                              // compute variables
1601:                              temp.Val = SIN45 * rad;
1602:                              yLimit = temp.w[1];
1603:                              temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
1604:                              err = (SHORT) (temp.w[1]);
1605:                              xPos = rad;
1606:                              yPos = 0;
1607:              
1608:                              // yCur starts at 1 so the center line is not drawn and will be drawn separately
1609:                              // this is to avoid rendering twice on the same line
1610:                              yCur = 1;           
1611:                              xCur = xPos;
1612:                              yNew = yPos;
1613:                  
1614:                              // note initial values are important
1615:                              last54Y = GetMaxY();
1616:                              last18Y = 0;
1617:              
1618:                              state = FB_CHECK;
1619:              
1620:                          case FB_CHECK:
1621:              
1622:                              // check first for limits
1623:                              if(yPos > yLimit)
1624:                              {
1625:                                  if (rad)
1626:                                      state = FB_DRAW_MISSING_1;
1627:                                  else
1628:                                      state = FB_WAITFORDONE;
1629:                                  break;
1630:                              }
1631:              
1632:                              // yNew records the last y position
1633:                              yNew = yPos;
1634:              
1635:                              // calculate the next value of x and y
1636:                              if(err > 0)
1637:                              {
1638:                                  xPos--;
1639:                                  err += 5 + ((yPos - xPos) << 1);
1640:                              }
1641:                              else
1642:                                  err += 3 + (yPos << 1);
1643:                              yPos++;
1644:                              state = FB_Q6TOQ3;
1645:              
1646:                          case FB_Q6TOQ3:
1647:              
1648:                              if(xCur != xPos)
1649:                              {
1650:              
1651:                                  // 6th octant to 3rd octant
1652:              	            	if (_bevelDrawType & DRAWBOTTOMBEVEL) 
1653:              	            	{ 
1654:              
1655:                                      // check first if there will be an overlap
1656:                                      if (y2 + yNew > last54Y)
1657:                                      {
1658:                      	                if(Bar(x1 - xCur, y2 + yCur, x2 + xCur, last54Y - 1) == 0)
1659:                                              return 0;
1660:                                      }        
1661:                                      else
1662:                                      {
1663:                      	               if (Bar(x1 - xCur, y2 + yCur, x2 + xCur, y2 + yNew) == 0)
1664:                                              return 0;
1665:                                      }
1666:                            		}          	
1667:                                  state = FB_Q5TOQ4;
1668:                                  break;
1669:                              }
1670:              
1671:                              state = FB_CHECK;
1672:                              break;
1673:              
1674:                          case FB_Q5TOQ4:
1675:              
1676:                          	if (_bevelDrawType & DRAWBOTTOMBEVEL) 
1677:                          	{ 
1678:              
1679:                 	                // 5th octant to 4th octant
1680:                                  // check: if overlapping then no need to proceed
1681:                                  if ((y2 + xCur) > (y2 + yNew))
1682:                                  {
1683:                 	                    if (Bar(x1 - yNew, y2 + xCur, x2 + yNew, y2 + xCur) == 0)
1684:                                          return 0;
1685:                                      last54Y = (y2 + xCur);
1686:                
1687:                                  }
1688:              
1689:              				}
1690:                              state = FB_Q7TOQ2;
1691:                              break;
1692:              
1693:                          case FB_Q7TOQ2:
1694:              
1695:                              // 7th octant to 2nd octant
1696:              	            if (_bevelDrawType & DRAWTOPBEVEL) 
1697:              				{
1698:                                  // check: if overlapping then no need to proceed
1699:                                  if (y1 - yNew < last18Y)
1700:                                  {
1701:              	                    if (Bar(x1 - xCur, last18Y + 1, x2 + xCur, y1 - yCur) == 0)
1702:                                          return 0;
1703:                                  }
1704:                                  else
1705:                                  {
1706:              	                    if (Bar(x1 - xCur, y1 - yNew, x2 + xCur, y1 - yCur) == 0)   
1707:                                          return 0;
1708:                                  }
1709:              
1710:              				}
1711:                              state = FB_Q8TOQ1;
1712:                              break;
1713:              
1714:                          case FB_Q8TOQ1:
1715:              
1716:                              // 8th octant to 1st octant
1717:              	            if (_bevelDrawType & DRAWTOPBEVEL) 
1718:              				{
1719:              
1720:                                  // check first if there will be an overlap
1721:                                  if ((y1 - xCur) < (y1 - yNew))
1722:                                  {
1723:                  	                if (Bar(x1 - yNew, y1 - xCur, x2 + yNew, y1 - xCur) == 0)
1724:                                          return 0;
1725:                                      last18Y = y1 - xCur;    
1726:                                  }
1727:              
1728:                  			}                	
1729:                              // update current values
1730:                              xCur = xPos;
1731:                              yCur = yPos;
1732:              
1733:                              state = FB_CHECK;
1734:                              break;
1735:              
1736:                          case FB_DRAW_MISSING_1:
1737:                              // check only one side since they are the same    
1738:                              if ((y1 - yNew) > (y1 - xPos)) 
1739:                              {
1740:                                  // there is a missing line, draw that line
1741:                                  if (_bevelDrawType & DRAWTOPBEVEL)
1742:                                      if (Bar(x1 - yNew, y1 - xPos, x2 + yNew, y1 - xPos) == 0)
1743:                                          return 0;
1744:                                  
1745:                                  state = FB_DRAW_MISSING_2;
1746:                              }
1747:                              else
1748:                                  state = FB_WAITFORDONE;
1749:                              break;
1750:              
1751:                          case FB_DRAW_MISSING_2:
1752:                              if ((y2 + yNew) < (y2 + xPos)) 
1753:                              {
1754:                                  if (_bevelDrawType & DRAWBOTTOMBEVEL)
1755:                                      if (Bar(x1 - yNew, y2 + xPos, x2 + yNew, y2 + xPos) == 0)
1756:              
1757:                                          return 0;
1758:                              }
1759:                              state = FB_WAITFORDONE;
1760:              
1761:                          case FB_WAITFORDONE:
1762:                              if(IsDeviceBusy())
1763:                                  return (0);
1764:                              
1765:                              state = FB_BEGIN;
1766:                              return (1);
1767:              
1768:                      }           // end of switch
1769:                  }               // end of while
1770:                  #endif // end of USE_NONBLOCKING_CONFIG
1771:              }
0061A6  FA8000     ULNK
0061A8  060000     RETURN
1772:              
1773:              /*********************************************************************
1774:              * Function: WORD DrawPoly(SHORT numPoints, SHORT* polyPoints)
1775:              *
1776:              * PreCondition: none
1777:              *
1778:              * Input: numPoints - points number, polyPoints - pointer to points array
1779:              *
1780:              * Output: For NON-Blocking configuration:
1781:              *         - Returns 0 when device is busy and the shape is not yet completely drawn.
1782:              *         - Returns 1 when the shape is completely drawn.
1783:              *         For Blocking configuration:
1784:              *         - Always return 1.
1785:              *
1786:              * Side Effects: none
1787:              *
1788:              * Overview: draws line polygon
1789:              *
1790:              * Note: This function has a weak attribute, the driver layer
1791:              *       may implement this same function to support driver layer
1792:              *       features.
1793:              *
1794:              ********************************************************************/
1795:              WORD __attribute__((weak)) DrawPoly(SHORT numPoints, SHORT *polyPoints)
1796:              {
0061AA  FA000E     LNK #0xE
0061AC  980750     MOV W0, [W14+10]
0061AE  980761     MOV W1, [W14+12]
1797:              #ifndef USE_NONBLOCKING_CONFIG
1798:              
1799:                  SHORT   counter;
1800:                  SHORT   sx, sy, ex, ey;
1801:              
1802:                  while(IsDeviceBusy() != 0) Nop();
0061B0  370001     BRA 0x61B4
0061B2  000000     NOP
0061B4  0730AE     RCALL IsDeviceBusy
0061B6  500FE0     SUB W0, #0x0, [W15]
0061B8  3AFFFC     BRA NZ, 0x61B2
1803:              
1804:                  sx = *polyPoints++;
0061BA  90006E     MOV [W14+12], W0
0061BC  780090     MOV [W0], W1
0061BE  980711     MOV W1, [W14+2]
0061C0  90006E     MOV [W14+12], W0
0061C2  E88000     INC2 W0, W0
0061C4  980760     MOV W0, [W14+12]
1805:                  sy = *polyPoints++;
0061C6  90006E     MOV [W14+12], W0
0061C8  780090     MOV [W0], W1
0061CA  980721     MOV W1, [W14+4]
0061CC  90006E     MOV [W14+12], W0
0061CE  E88000     INC2 W0, W0
0061D0  980760     MOV W0, [W14+12]
1806:                  for(counter = 0; counter < numPoints - 1; counter++)
0061D2  EB0000     CLR W0
0061D4  780F00     MOV W0, [W14]
0061D6  370019     BRA 0x620A
006208  E80F1E     INC [W14], [W14]
00620A  90005E     MOV [W14+10], W0
00620C  E90000     DEC W0, W0
00620E  500F9E     SUB W0, [W14], [W15]
006210  3CFFE3     BRA GT, 0x61D8
1807:                  {
1808:                      ex = *polyPoints++;
0061D8  90006E     MOV [W14+12], W0
0061DA  780090     MOV [W0], W1
0061DC  980731     MOV W1, [W14+6]
0061DE  90006E     MOV [W14+12], W0
0061E0  E88000     INC2 W0, W0
0061E2  980760     MOV W0, [W14+12]
1809:                      ey = *polyPoints++;
0061E4  90006E     MOV [W14+12], W0
0061E6  780090     MOV [W0], W1
0061E8  980741     MOV W1, [W14+8]
0061EA  90006E     MOV [W14+12], W0
0061EC  E88000     INC2 W0, W0
0061EE  980760     MOV W0, [W14+12]
1810:                      while(Line(sx, sy, ex, ey) == 0);
0061F0  000000     NOP
0061F2  9001CE     MOV [W14+8], W3
0061F4  90013E     MOV [W14+6], W2
0061F6  9000AE     MOV [W14+4], W1
0061F8  90001E     MOV [W14+2], W0
0061FA  07F983     RCALL Line
0061FC  500FE0     SUB W0, #0x0, [W15]
0061FE  32FFF9     BRA Z, 0x61F2
1811:                      sx = ex;
006200  90003E     MOV [W14+6], W0
006202  980710     MOV W0, [W14+2]
1812:                      sy = ey;
006204  9000CE     MOV [W14+8], W1
006206  980721     MOV W1, [W14+4]
1813:                  }
1814:              
1815:              #else
1816:              
1817:                  typedef enum
1818:                  {
1819:                      POLY_BEGIN,
1820:                      POLY_DRAWING,
1821:                  } DRAWPOLY_STATES;
1822:              
1823:                  static DRAWPOLY_STATES state = POLY_BEGIN;
1824:                  static SHORT counter;
1825:                  SHORT sx, sy, ex, ey;
1826:                  while(1)
1827:                  {
1828:                      if(IsDeviceBusy())
1829:                          return (0);
1830:                      switch(state)
1831:                      {
1832:                          case POLY_BEGIN:
1833:                              counter = 1;
1834:                              state = POLY_DRAWING;
1835:              
1836:                          case POLY_DRAWING:
1837:                              if(counter == 0 || counter >= numPoints)
1838:                              {
1839:                                  state = POLY_BEGIN;
1840:                                  break;
1841:                              }
1842:              
1843:                              while(counter < numPoints)
1844:                              {
1845:                                  sx = polyPoints[(counter - 1) * 2];
1846:                                  sy = polyPoints[(counter * 2) - 1];
1847:                                  ex = polyPoints[counter * 2];
1848:                                  ey = polyPoints[counter * 2 + 1];
1849:                                  if(Line(sx, sy, ex, ey) == 0)
1850:                                  {
1851:                                      return (0);
1852:                                  }
1853:              
1854:                                  counter++;
1855:                              }
1856:              
1857:                              state = POLY_BEGIN;
1858:                              return (1);
1859:                      }
1860:                  }
1861:              #endif
1862:                  return (1);
006212  200010     MOV #0x1, W0
1863:              }
006214  FA8000     ULNK
006216  060000     RETURN
1864:              
1865:              /*********************************************************************
1866:              * Function: void SetFontFlash(void* pFont)
1867:              *
1868:              * PreCondition: none
1869:              *
1870:              * Input: pFont - pointer to the font image in FLASH.
1871:              *
1872:              * Output: none
1873:              *
1874:              * Side Effects: none
1875:              *
1876:              * Overview: Sets the current font located in FLASH.
1877:              *
1878:              * Note: This function has a weak attribute, the driver layer
1879:              *       may implement this same function to support driver layer
1880:              *       features.
1881:              *
1882:              ********************************************************************/
1883:              void __attribute__((weak)) SetFontFlash(void *pFont)
1884:              {
006218  FA0008     LNK #0x8
00621A  980730     MOV W0, [W14+6]
1885:              #if defined (USE_FONT_FLASH)
1886:                  GFX_FONT_SPACE BYTE *src;
1887:                  BYTE *dest;
1888:                  int i;
1889:              
1890:                  src = (GFX_FONT_SPACE BYTE *)((FONT_FLASH *)pFont)->address;
00621C  90003E     MOV [W14+6], W0
00621E  900010     MOV [W0+2], W0
006220  780F00     MOV W0, [W14]
1891:                  dest = (BYTE *)&(currentFont.fontHeader);
006222  210520     MOV #0x1052, W0
006224  980710     MOV W0, [W14+2]
1892:                  for(i = 0; i < sizeof(FONT_HEADER); i++)
006226  EB0000     CLR W0
006228  980720     MOV W0, [W14+4]
00622A  37000B     BRA 0x6242
00623C  90002E     MOV [W14+4], W0
00623E  E80000     INC W0, W0
006240  980720     MOV W0, [W14+4]
006242  90002E     MOV [W14+4], W0
006244  500FE7     SUB W0, #0x7, [W15]
006246  36FFF2     BRA LEU, 0x622C
1893:                  {
1894:                      *dest = *src;
00622C  78001E     MOV [W14], W0
00622E  784010     MOV.B [W0], W0
006230  90009E     MOV [W14+2], W1
006232  784880     MOV.B W0, [W1]
1895:                      src++;
006234  E80F1E     INC [W14], [W14]
1896:                      dest++;
006236  90001E     MOV [W14+2], W0
006238  E80000     INC W0, W0
00623A  980710     MOV W0, [W14+2]
1897:                  }
1898:                  currentFont.pFont = pFont;
006248  90003E     MOV [W14+6], W0
00624A  888280     MOV W0, currentFont
1899:              #endif
1900:              #if defined (USE_FONT_RAM)
1901:                  memcpy( &(currentFont.fontHeader), 
1902:                          (FONT_HEADER *) ((FONT_RAM *)pFont)->address, 
1903:                          sizeof(FONT_HEADER));
1904:                  currentFont.pFont = pFont;
1905:              #endif
1906:              }
00624C  FA8000     ULNK
00624E  060000     RETURN
1907:              
1908:              /*********************************************************************
1909:              * Function: void SetFontExternal(void* pFont)
1910:              *
1911:              * PreCondition: none
1912:              *
1913:              * Input: pFont - pointer to the font image located in External Memory.
1914:              *
1915:              * Output: none
1916:              *
1917:              * Side Effects: none
1918:              *
1919:              * Overview: Sets the current font located in External Memory.
1920:              *           When using fonts in external memory, the font glyph
1921:              *           buffer size defined by EXTERNAL_FONT_BUFFER_SIZE must
1922:              *           be big enough for the character glyphs.
1923:              *
1924:              * Note: This function has a weak attribute, the driver layer
1925:              *       may implement this same function to support driver layer
1926:              *       features.
1927:              *
1928:              ********************************************************************/
1929:              void __attribute__((weak)) SetFontExternal(void *pFont)
1930:              {
006250  FA0002     LNK #0x2
006252  780F00     MOV W0, [W14]
1931:              #if defined (USE_FONT_EXTERNAL)
1932:                  FONT_HEADER *pHeader;
1933:              
1934:                  pHeader = &(currentFont.fontHeader);
1935:                  ExternalMemoryCallback(pFont, 0, sizeof(FONT_HEADER), pHeader);
1936:                  currentFont.pFont = pFont;
1937:              #endif
1938:              }
006254  FA8000     ULNK
006256  060000     RETURN
1939:              
1940:              /*********************************************************************
1941:              * Function: void SetFont(void* pFont)
1942:              *
1943:              * PreCondition: none
1944:              *
1945:              * Input: pointer to the font image
1946:              *
1947:              * Output: none
1948:              *
1949:              * Side Effects: none
1950:              *
1951:              * Overview: defines current font
1952:              *
1953:              * Note: This function has a weak attribute, the driver layer
1954:              *       may implement this same function to support driver layer
1955:              *       features.
1956:              *
1957:              ********************************************************************/
1958:              void __attribute__((weak)) SetFont(void *pFont)
1959:              {
006258  FA0002     LNK #0x2
00625A  780F00     MOV W0, [W14]
1960:                  switch(*((SHORT *)pFont))
00625C  78001E     MOV [W14], W0
00625E  780010     MOV [W0], W0
006260  500FE1     SUB W0, #0x1, [W15]
006262  320007     BRA Z, 0x6272
006264  500FE4     SUB W0, #0x4, [W15]
006266  320002     BRA Z, 0x626C
006268  500FE0     SUB W0, #0x0, [W15]
00626A  3A0007     BRA NZ, 0x627A
1961:                  {
1962:                      case FLASH:
1963:                      case RAM:
1964:                          SetFontFlash(pFont);
00626C  78001E     MOV [W14], W0
00626E  07FFD4     RCALL SetFontFlash
1965:                          break;
006270  370005     BRA 0x627C
1966:              				
1967:                      case EXTERNAL:
1968:                          SetFontExternal(pFont);
006272  78001E     MOV [W14], W0
006274  07FFED     RCALL SetFontExternal
1969:                          break;
006276  000000     NOP
006278  370001     BRA 0x627C
1970:              
1971:                      default:
1972:                          break;
00627A  000000     NOP
1973:                  }
1974:              }
00627C  FA8000     ULNK
00627E  060000     RETURN
1975:              
1976:              #ifdef USE_ANTIALIASED_FONTS
1977:              
1978:              static GFX_COLOR   _fgcolor100;
1979:              static GFX_COLOR   _fgcolor25;
1980:              static GFX_COLOR   _fgcolor75;
1981:              static GFX_COLOR   _bgcolor100;
1982:              static GFX_COLOR   _bgcolor25;
1983:              static GFX_COLOR   _bgcolor75;
1984:              
1985:              /*********************************************************************
1986:              * Function: static void __attribute__((always_inline)) calculateColors(void)
1987:              *
1988:              * PreCondition: _bgcolor100 and _fgcolor100 must be set
1989:              *
1990:              * Input: none
1991:              *
1992:              * Output: none
1993:              *
1994:              * Side Effects: _bgcolor25, _bgcolor75, _fgcolor25 and _fgcolor75 will be calculated
1995:              *
1996:              * Overview: calculates mid values of colors
1997:              *
1998:              * Note: Internal to this file
1999:              *
2000:              ********************************************************************/
2001:              static void __attribute__((always_inline)) calculateColors(void)
2002:              {
2003:                  GFX_COLOR   _fgcolor50;
2004:                  GFX_COLOR   _bgcolor50;
2005:                  
2006:              #if (COLOR_DEPTH == 16) || (COLOR_DEPTH == 24)
2007:              
2008:                  _fgcolor50  = ConvertColor50(_fgcolor100);
2009:                  _fgcolor25  = ConvertColor25(_fgcolor100);
2010:                  _fgcolor75  = _fgcolor50   +  _fgcolor25;
2011:              
2012:                  _bgcolor50  = ConvertColor50(_bgcolor100);
2013:                  _bgcolor25  = ConvertColor25(_bgcolor100);
2014:                  _bgcolor75  = _bgcolor50   +  _bgcolor25;
2015:              
2016:              #elif ((COLOR_DEPTH == 8) || (COLOR_DEPTH == 4))
2017:                      
2018:                  _fgcolor50  = _fgcolor100 >> 1;
2019:                  _fgcolor25  = _fgcolor50  >> 1;
2020:                  _fgcolor75  = _fgcolor50  +  _fgcolor25;
2021:              
2022:                  _bgcolor50  = _bgcolor100 >> 1;
2023:                  _bgcolor25  = _bgcolor50  >> 1;
2024:                  _bgcolor75  = _bgcolor50  +  _bgcolor25;
2025:              
2026:                  #warning "Antialiasing at 8BPP and 4BPP is supported only for Grayscale mode"
2027:                      
2028:              #else
2029:                  
2030:                  #error "Anit-aliasing is currently supported only in 8BPP Grayscale and 16BPP, 24BPP color modes"
2031:                  
2032:              #endif
2033:                  _fgcolor25 += _bgcolor75;
2034:                  _fgcolor75 += _bgcolor25;
2035:              }
2036:              
2037:              #endif //#ifdef USE_ANTIALIASED_FONTS
2038:              
2039:              /*********************************************************************
2040:              * Function:  void OutCharGetInfoFlash (XCHAR ch, OUTCHAR_PARAM *pParam)
2041:              *
2042:              * PreCondition: none
2043:              *
2044:              * Input: ch - character code
2045:              *        pParam - pointer to character information structure.
2046:              *
2047:              * Output: none
2048:              *
2049:              * Side Effects: none
2050:              *
2051:              * Overview: Gathers the parameters for the specified character of the 
2052:              *           currently set font from flash memory. This is a step performed
2053:              *           before the character is rendered. 
2054:              *
2055:              * Note: Application should not call this function. This function is for 
2056:              *       versatility of implementing hardware accelerated text rendering
2057:              *       only.
2058:              *
2059:              ********************************************************************/
2060:              void __attribute__((weak)) OutCharGetInfoFlash (XCHAR ch, OUTCHAR_PARAM *pParam)
2061:              {
006280  FA0008     LNK #0x8
006282  984740     MOV.B W0, [W14+4]
006284  980731     MOV W1, [W14+6]
2062:              #ifdef USE_FONT_FLASH
2063:              
2064:                  GFX_FONT_SPACE GLYPH_ENTRY_EXTENDED    *pChTableExtended;
2065:                  GFX_FONT_SPACE GLYPH_ENTRY             *pChTable;
2066:              
2067:                  // set color depth of font,
2068:                  // based on 2^bpp where bpp is the color depth setting in the FONT_HEADER
2069:                  pParam->bpp = 1 << currentFont.fontHeader.bpp;
006286  808290     MOV 0x1052, W0
006288  DE004A     LSR W0, #10, W0
00628A  604063     AND.B W0, #0x3, W0
00628C  FB8000     ZE W0, W0
00628E  200011     MOV #0x1, W1
006290  DD0800     SL W1, W0, W0
006292  784000     MOV.B W0, W0
006294  9000BE     MOV [W14+6], W1
006296  9840C0     MOV.B W0, [W1+4]
2070:              
2071:                  if(currentFont.fontHeader.extendedGlyphEntry)
006298  808291     MOV 0x1052, W1
00629A  201000     MOV #0x100, W0
00629C  608000     AND W1, W0, W0
00629E  500FE0     SUB W0, #0x0, [W15]
0062A0  320034     BRA Z, 0x630A
2072:                  {
2073:                      pChTableExtended = (GFX_FONT_SPACE GLYPH_ENTRY_EXTENDED *) (((FONT_FLASH *)currentFont.pFont)->address + sizeof(FONT_HEADER)) + ((UXCHAR)ch - (UXCHAR)currentFont.fontHeader.firstChar);
0062A2  808280     MOV currentFont, W0
0062A4  900010     MOV [W0+2], W0
0062A6  780100     MOV W0, W2
0062A8  90404E     MOV.B [W14+4], W0
0062AA  FB8080     ZE W0, W1
0062AC  8082A0     MOV 0x1054, W0
0062AE  784000     MOV.B W0, W0
0062B0  FB8000     ZE W0, W0
0062B2  508000     SUB W1, W0, W0
0062B4  B9006C     MUL.SU W0, #12, W0
0062B6  780000     MOV W0, W0
0062B8  400068     ADD W0, #0x8, W0
0062BA  410F00     ADD W2, W0, [W14]
2074:                      pParam->pChImage = (GFX_FONT_SPACE BYTE *) (((FONT_FLASH *)currentFont.pFont)->address + pChTableExtended->offset);
0062BC  808280     MOV currentFont, W0
0062BE  900010     MOV [W0+2], W0
0062C0  780100     MOV W0, W2
0062C2  78001E     MOV [W14], W0
0062C4  BE0010     MOV.D [W0], W0
0062C6  780000     MOV W0, W0
0062C8  410080     ADD W2, W0, W1
0062CA  90003E     MOV [W14+6], W0
0062CC  980041     MOV W1, [W0+8]
2075:                      pParam->chGlyphWidth = pChTableExtended->glyphWidth;
0062CE  78001E     MOV [W14], W0
0062D0  900030     MOV [W0+6], W0
0062D2  780080     MOV W0, W1
0062D4  90003E     MOV [W14+6], W0
0062D6  980031     MOV W1, [W0+6]
2076:                      pParam->xWidthAdjust = pChTableExtended->glyphWidth - pChTableExtended->cursorAdvance;
0062D8  78001E     MOV [W14], W0
0062DA  9000B0     MOV [W0+6], W1
0062DC  78001E     MOV [W14], W0
0062DE  900020     MOV [W0+4], W0
0062E0  508000     SUB W1, W0, W0
0062E2  780080     MOV W0, W1
0062E4  90003E     MOV [W14+6], W0
0062E6  980071     MOV W1, [W0+14]
2077:                      pParam->xAdjust = pChTableExtended->xAdjust;
0062E8  78001E     MOV [W14], W0
0062EA  9000C0     MOV [W0+8], W1
0062EC  90003E     MOV [W14+6], W0
0062EE  980051     MOV W1, [W0+10]
2078:                      pParam->yAdjust = pChTableExtended->yAdjust;
0062F0  78001E     MOV [W14], W0
0062F2  9000D0     MOV [W0+10], W1
0062F4  90003E     MOV [W14+6], W0
0062F6  980061     MOV W1, [W0+12]
2079:                                  
2080:                      if(pParam->yAdjust > 0)
0062F8  90003E     MOV [W14+6], W0
0062FA  900060     MOV [W0+12], W0
0062FC  500FE0     SUB W0, #0x0, [W15]
0062FE  340024     BRA LE, 0x6348
2081:                      {
2082:                          pParam->heightOvershoot = pParam->yAdjust;
006300  90003E     MOV [W14+6], W0
006302  9000E0     MOV [W0+12], W1
006304  90003E     MOV [W14+6], W0
006306  980801     MOV W1, [W0+16]
006308  37001F     BRA 0x6348
2083:                      }
2084:                  }
2085:                  else
2086:                  {
2087:                      pChTable = (GFX_FONT_SPACE GLYPH_ENTRY *) (((FONT_FLASH *)currentFont.pFont)->address + sizeof(FONT_HEADER)) + ((UXCHAR)ch - (UXCHAR)currentFont.fontHeader.firstChar);
00630A  808280     MOV currentFont, W0
00630C  900010     MOV [W0+2], W0
00630E  780080     MOV W0, W1
006310  90404E     MOV.B [W14+4], W0
006312  FB8100     ZE W0, W2
006314  8082A0     MOV 0x1054, W0
006316  784000     MOV.B W0, W0
006318  FB8000     ZE W0, W0
00631A  510000     SUB W2, W0, W0
00631C  E88000     INC2 W0, W0
00631E  DD0042     SL W0, #2, W0
006320  408000     ADD W1, W0, W0
006322  980710     MOV W0, [W14+2]
2088:                      pParam->pChImage = (GFX_FONT_SPACE BYTE *) (((FONT_FLASH *)currentFont.pFont)->address + ((DWORD)(pChTable->offsetMSB) << 8) + pChTable->offsetLSB);
006324  808280     MOV currentFont, W0
006326  900090     MOV [W0+2], W1
006328  90001E     MOV [W14+2], W0
00632A  900010     MOV [W0+2], W0
00632C  DD0148     SL W0, #8, W2
00632E  90001E     MOV [W14+2], W0
006330  904010     MOV.B [W0+1], W0
006332  FB8000     ZE W0, W0
006334  410000     ADD W2, W0, W0
006336  408000     ADD W1, W0, W0
006338  780080     MOV W0, W1
00633A  90003E     MOV [W14+6], W0
00633C  980041     MOV W1, [W0+8]
2089:                      pParam->chGlyphWidth = pChTable->width;
00633E  90001E     MOV [W14+2], W0
006340  784010     MOV.B [W0], W0
006342  FB8080     ZE W0, W1
006344  90003E     MOV [W14+6], W0
006346  980031     MOV W1, [W0+6]
2090:                  }
2091:              
2092:              #endif // #ifdef USE_FONT_FLASH
2093:                  
2094:              }
006348  FA8000     ULNK
00634A  060000     RETURN
2095:              
2096:              /*********************************************************************
2097:              * Function:  void OutCharGetInfoExternal (XCHAR ch, OUTCHAR_PARAM *pParam)
2098:              *
2099:              * PreCondition: none
2100:              *
2101:              * Input: ch - character code
2102:              *        pParam - pointer to character information structure. 
2103:              *
2104:              * Output: none
2105:              *
2106:              * Side Effects: none
2107:              *
2108:              * Overview: Gathers the parameters for the specified character of the 
2109:              *           currently set font from external memory. This is a step performed
2110:              *           before the character is rendered. 
2111:              *
2112:              * Note: Application should not call this function. This function is for 
2113:              *       versatility of implementing hardware accelerated text rendering
2114:              *       only.
2115:              *
2116:              ********************************************************************/
2117:              void __attribute__((weak)) OutCharGetInfoExternal(XCHAR ch, OUTCHAR_PARAM *pParam)
2118:              {
00634C  FA0004     LNK #0x4
00634E  784F00     MOV.B W0, [W14]
006350  980711     MOV W1, [W14+2]
2119:              #ifdef USE_FONT_EXTERNAL
2120:              
2121:                  GLYPH_ENTRY             chTable;
2122:                  GLYPH_ENTRY_EXTENDED    chTableExtended;
2123:                  WORD                    imageSize;
2124:                  DWORD_VAL               glyphOffset;
2125:              
2126:                  // set color depth of font,
2127:                  // based on 2^bpp where bpp is the color depth setting in the FONT_HEADER
2128:                  pParam->bpp = 1 << currentFont.fontHeader.bpp;
2129:                     
2130:                  if(currentFont.fontHeader.extendedGlyphEntry)
2131:                  {
2132:                      ExternalMemoryCallback
2133:                      (
2134:                          currentFont.pFont,
2135:                          sizeof(FONT_HEADER) + ((UXCHAR)ch - (UXCHAR)currentFont.fontHeader.firstChar) * sizeof(GLYPH_ENTRY_EXTENDED),
2136:                          sizeof(GLYPH_ENTRY_EXTENDED),
2137:                          &chTableExtended
2138:                      );
2139:                  
2140:                      pParam->chGlyphWidth = chTableExtended.glyphWidth;
2141:                      pParam->xWidthAdjust = chTableExtended.glyphWidth - chTableExtended.cursorAdvance;
2142:                      pParam->xAdjust = chTableExtended.xAdjust;
2143:                      pParam->yAdjust = chTableExtended.yAdjust;
2144:                  
2145:                      if(pParam->yAdjust > 0)
2146:                      {
2147:                          pParam->heightOvershoot = pParam->yAdjust;
2148:                      }
2149:                                  
2150:                  }
2151:                  else
2152:                  {
2153:                      // get glyph entry
2154:                      ExternalMemoryCallback
2155:                      (
2156:                          currentFont.pFont,
2157:                          sizeof(FONT_HEADER) + ((UXCHAR)ch - (UXCHAR)currentFont.fontHeader.firstChar) * sizeof(GLYPH_ENTRY),
2158:                          sizeof(GLYPH_ENTRY),
2159:                          &chTable
2160:                      );
2161:                      pParam->chGlyphWidth = chTable.width;
2162:                  }
2163:              
2164:                  // width of glyph in bytes
2165:                  imageSize = 0;
2166:                  pParam->chEffectiveGlyphWidth = pParam->chGlyphWidth * pParam->bpp;
2167:                  if(pParam->chEffectiveGlyphWidth & 0x0007)
2168:                      imageSize = 1;
2169:                  imageSize += (pParam->chEffectiveGlyphWidth >> 3);
2170:              
2171:                  // glyph image size
2172:                  imageSize *= currentFont.fontHeader.height;
2173:              
2174:                  if(currentFont.fontHeader.extendedGlyphEntry)
2175:                  {
2176:                      glyphOffset.Val = chTableExtended.offset;
2177:                  }
2178:                  else
2179:                  {
2180:                      // get glyph image
2181:                      glyphOffset.w[1] = (chTable.offsetMSB >> 8);
2182:                      glyphOffset.w[0] = (chTable.offsetMSB << 8) + (chTable.offsetLSB);
2183:                  }
2184:                          
2185:                  ExternalMemoryCallback(currentFont.pFont, glyphOffset.Val, imageSize, &(pParam->chImage));
2186:                  pParam->pChImage = (BYTE *) &(pParam->chImage);
2187:              
2188:              #endif //#ifdef USE_FONT_EXTERNAL
2189:              }
006352  FA8000     ULNK
006354  060000     RETURN
2190:              
2191:              /*********************************************************************
2192:              * Function:  void OutCharRender(XCHAR ch, OUTCHAR_PARAM *pParam)
2193:              *
2194:              * PreCondition: none
2195:              *
2196:              * Input: ch - character code
2197:              *        pParam - pointer to character information structure. 
2198:              *
2199:              * Output: none
2200:              *
2201:              * Side Effects: none
2202:              *
2203:              * Overview: Performs the actual rendering of the character using PutPixel().
2204:              *
2205:              * Note: Application should not call this function. This function is for 
2206:              *       versatility of implementing hardware accelerated text rendering
2207:              *       only.
2208:              *
2209:              ********************************************************************/
2210:              WORD __attribute__((weak)) OutCharRender(XCHAR ch, OUTCHAR_PARAM *pParam)
2211:              {
006356  FA0010     LNK #0x10
006358  984F40     MOV.B W0, [W14+12]
00635A  980771     MOV W1, [W14+14]
2212:                  BYTE        temp = 0;
00635C  EB4000     CLR.B W0
00635E  784F00     MOV.B W0, [W14]
2213:                  BYTE        mask;
2214:                  BYTE        restoremask;
2215:                  SHORT       xCnt, yCnt, x = 0, y;
006360  EB0000     CLR W0
006362  980730     MOV W0, [W14+6]
2216:              #ifdef USE_ANTIALIASED_FONTS
2217:                  BYTE        val, shift;
2218:                  GFX_COLOR   bgcolor;
2219:              #endif
2220:                  
2221:              #ifdef USE_ANTIALIASED_FONTS
2222:                  if(pParam->bpp == 1)
2223:                  {
2224:                      restoremask = 0x01;
2225:                  }
2226:                  else
2227:                  {
2228:                      if(pParam->bpp == 2)
2229:                      {
2230:                          restoremask = 0x03;
2231:                      }
2232:                      else
2233:                      {
2234:                          return -1; // BPP > 2 are not yet supported
2235:                      }
2236:                      
2237:                      bgcolor = GetPixel(GetX(), GetY() + (currentFont.fontHeader.height >> 1));
2238:                      
2239:                      if((_fgcolor100 != GetColor()) || (_bgcolor100 != bgcolor))
2240:                      {
2241:                          _fgcolor100 = GetColor();
2242:                          _bgcolor100 = bgcolor;
2243:                          calculateColors();
2244:                      }
2245:                  }
2246:              #else
2247:                  restoremask = 0x01;
006364  B3C010     MOV #0x1, W0
006366  984F20     MOV.B W0, [W14+10]
2248:              #endif
2249:                  
2250:                  if(_fontOrientation == ORIENT_HOR)
006368  BFD04B     MOV.B _fontOrientation, WREG
00636A  504FE0     SUB.B W0, #0x0, [W15]
00636C  3A0048     BRA NZ, 0x63FE
2251:                  {
2252:                      y = GetY() + pParam->yAdjust;
00636E  90007E     MOV [W14+14], W0
006370  9000E0     MOV [W0+12], W1
006372  808270     MOV _cursorY, W0
006374  408000     ADD W1, W0, W0
006376  980740     MOV W0, [W14+8]
2253:                      for(yCnt = 0; yCnt < currentFont.fontHeader.height + pParam->heightOvershoot; yCnt++)
006378  EB0000     CLR W0
00637A  980720     MOV W0, [W14+4]
00637C  370030     BRA 0x63DE
0063D8  90002E     MOV [W14+4], W0
0063DA  E80000     INC W0, W0
0063DC  980720     MOV W0, [W14+4]
0063DE  9000AE     MOV [W14+4], W1
0063E0  8082C2     MOV 0x1058, W2
0063E2  90007E     MOV [W14+14], W0
0063E4  900800     MOV [W0+16], W0
0063E6  410000     ADD W2, W0, W0
0063E8  508F80     SUB W1, W0, [W15]
0063EA  39FFC9     BRA NC, 0x637E
2254:                      {
2255:                          x = GetX() + pParam->xAdjust;
00637E  90007E     MOV [W14+14], W0
006380  9000D0     MOV [W0+10], W1
006382  808260     MOV _cursorX, W0
006384  408000     ADD W1, W0, W0
006386  980730     MOV W0, [W14+6]
2256:                          mask = 0;
006388  EB4000     CLR.B W0
00638A  984710     MOV.B W0, [W14+1]
2257:              
2258:              #ifdef USE_ANTIALIASED_FONTS
2259:                          shift = 0;
2260:              #endif
2261:              
2262:                          for(xCnt = 0; xCnt < pParam->chGlyphWidth; xCnt++)
00638C  EB0000     CLR W0
00638E  980710     MOV W0, [W14+2]
006390  37001B     BRA 0x63C8
0063C2  90001E     MOV [W14+2], W0
0063C4  E80000     INC W0, W0
0063C6  980710     MOV W0, [W14+2]
0063C8  90007E     MOV [W14+14], W0
0063CA  9000B0     MOV [W0+6], W1
0063CC  90001E     MOV [W14+2], W0
0063CE  508F80     SUB W1, W0, [W15]
0063D0  3CFFE0     BRA GT, 0x6392
2263:                          {
2264:                              if(mask == 0)
006392  90401E     MOV.B [W14+1], W0
006394  504FE0     SUB.B W0, #0x0, [W15]
006396  3A0008     BRA NZ, 0x63A8
2265:                              {
2266:                                  temp = *(pParam->pChImage)++;
006398  90007E     MOV [W14+14], W0
00639A  900040     MOV [W0+8], W0
00639C  784F10     MOV.B [W0], [W14]
00639E  E80080     INC W0, W1
0063A0  90007E     MOV [W14+14], W0
0063A2  980041     MOV W1, [W0+8]
2267:                                  mask = restoremask;
0063A4  90482E     MOV.B [W14+10], W0
0063A6  984710     MOV.B W0, [W14+1]
2268:              
2269:              #ifdef USE_ANTIALIASED_FONTS
2270:                                  shift = 0;
2271:              #endif
2272:                              }
2273:              
2274:              #ifdef USE_ANTIALIASED_FONTS
2275:                              if(pParam->bpp == 1)                
2276:                              {
2277:                                  if(temp & mask)
2278:                                  {
2279:                                      PutPixel(x, y);
2280:                                  }
2281:                              }
2282:                              else
2283:                              {
2284:                                  val = (temp & mask) >> shift;
2285:                                  if(val)
2286:                                  {
2287:                                      if(GFX_Font_GetAntiAliasType() == ANTIALIAS_TRANSLUCENT)
2288:                                      {
2289:                                          bgcolor = GetPixel(x, y);
2290:                                          if(_bgcolor100 != bgcolor)
2291:                                          {
2292:                                              _bgcolor100 = bgcolor;
2293:                                              calculateColors();
2294:                                          }
2295:                                      }
2296:              
2297:                                      switch(val)
2298:                                      {
2299:                                          case 1:     SetColor(_fgcolor25);
2300:                                                      break;
2301:                                                      
2302:                                          case 2:     SetColor(_fgcolor75);
2303:                                                      break;
2304:                                                      
2305:                                          case 3:     SetColor(_fgcolor100);
2306:                                      }
2307:                                      
2308:                                      PutPixel(x, y);
2309:                                  }
2310:                              }
2311:              
2312:                              mask  <<=  pParam->bpp;
2313:                              shift  +=  pParam->bpp;
2314:              #else
2315:                              if(temp & mask)
0063A8  90401E     MOV.B [W14+1], W0
0063AA  60401E     AND.B W0, [W14], W0
0063AC  504FE0     SUB.B W0, #0x0, [W15]
0063AE  320003     BRA Z, 0x63B6
2316:                              {
2317:                                  PutPixel(x, y);
0063B0  9000CE     MOV [W14+8], W1
0063B2  90003E     MOV [W14+6], W0
0063B4  072F7A     RCALL PutPixel
2318:                              }
2319:                              
2320:                              mask <<= 1;
0063B6  90401E     MOV.B [W14+1], W0
0063B8  404000     ADD.B W0, W0, W0
0063BA  984710     MOV.B W0, [W14+1]
2321:              #endif
2322:                              x++;
0063BC  90003E     MOV [W14+6], W0
0063BE  E80000     INC W0, W0
0063C0  980730     MOV W0, [W14+6]
2323:                          }
2324:                          y++;
0063D2  90004E     MOV [W14+8], W0
0063D4  E80000     INC W0, W0
0063D6  980740     MOV W0, [W14+8]
2325:                      }
2326:              
2327:                      // move cursor
2328:                      _cursorX = x - pParam->xAdjust - pParam->xWidthAdjust;
0063EC  90007E     MOV [W14+14], W0
0063EE  900050     MOV [W0+10], W0
0063F0  9000BE     MOV [W14+6], W1
0063F2  508080     SUB W1, W0, W1
0063F4  90007E     MOV [W14+14], W0
0063F6  900070     MOV [W0+14], W0
0063F8  508000     SUB W1, W0, W0
0063FA  888260     MOV W0, _cursorX
0063FC  370044     BRA 0x6486
2329:                  }
2330:                  else    // If extended glyph is used, then vertical alignment may not be rendered properly and hence users must position the texts properly
2331:                  {
2332:                      y = GetX() + pParam->xAdjust;
0063FE  90007E     MOV [W14+14], W0
006400  9000D0     MOV [W0+10], W1
006402  808260     MOV _cursorX, W0
006404  408000     ADD W1, W0, W0
006406  980740     MOV W0, [W14+8]
2333:                      for(yCnt = 0; yCnt < currentFont.fontHeader.height + pParam->heightOvershoot; yCnt++)
006408  EB0000     CLR W0
00640A  980720     MOV W0, [W14+4]
00640C  370030     BRA 0x646E
006468  90002E     MOV [W14+4], W0
00646A  E80000     INC W0, W0
00646C  980720     MOV W0, [W14+4]
00646E  9000AE     MOV [W14+4], W1
006470  8082C2     MOV 0x1058, W2
006472  90007E     MOV [W14+14], W0
006474  900800     MOV [W0+16], W0
006476  410000     ADD W2, W0, W0
006478  508F80     SUB W1, W0, [W15]
00647A  39FFC9     BRA NC, 0x640E
2334:                      {
2335:                          x = GetY() + pParam->yAdjust;
00640E  90007E     MOV [W14+14], W0
006410  9000E0     MOV [W0+12], W1
006412  808270     MOV _cursorY, W0
006414  408000     ADD W1, W0, W0
006416  980730     MOV W0, [W14+6]
2336:                          mask = 0; 
006418  EB4000     CLR.B W0
00641A  984710     MOV.B W0, [W14+1]
2337:              
2338:              #ifdef USE_ANTIALIASED_FONTS
2339:                          shift = 0;
2340:              #endif
2341:              
2342:                          for(xCnt = 0; xCnt < pParam->chGlyphWidth; xCnt++)
00641C  EB0000     CLR W0
00641E  980710     MOV W0, [W14+2]
006420  37001B     BRA 0x6458
006452  90001E     MOV [W14+2], W0
006454  E80000     INC W0, W0
006456  980710     MOV W0, [W14+2]
006458  90007E     MOV [W14+14], W0
00645A  9000B0     MOV [W0+6], W1
00645C  90001E     MOV [W14+2], W0
00645E  508F80     SUB W1, W0, [W15]
006460  3CFFE0     BRA GT, 0x6422
2343:                          {
2344:                              if(mask == 0)
006422  90401E     MOV.B [W14+1], W0
006424  504FE0     SUB.B W0, #0x0, [W15]
006426  3A0008     BRA NZ, 0x6438
2345:                              {
2346:                                  temp = *(pParam->pChImage)++;
006428  90007E     MOV [W14+14], W0
00642A  900040     MOV [W0+8], W0
00642C  784F10     MOV.B [W0], [W14]
00642E  E80080     INC W0, W1
006430  90007E     MOV [W14+14], W0
006432  980041     MOV W1, [W0+8]
2347:                                  mask = restoremask; 
006434  90482E     MOV.B [W14+10], W0
006436  984710     MOV.B W0, [W14+1]
2348:              
2349:              #ifdef USE_ANTIALIASED_FONTS
2350:                                  shift = 0;
2351:              #endif
2352:                              }
2353:              
2354:              #ifdef USE_ANTIALIASED_FONTS
2355:                              if(pParam->bpp == 1)                
2356:                              {
2357:                                  if(temp & mask)
2358:                                  {
2359:                                      PutPixel(y, x);
2360:                                  }
2361:                              }
2362:                              else
2363:                              {
2364:                                  val = (temp & mask) >> shift;
2365:                                  if(val)
2366:                                  {
2367:                                      if(GFX_Font_GetAntiAliasType() == ANTIALIAS_TRANSLUCENT)
2368:                                      {
2369:                                          bgcolor = GetPixel(x, y);
2370:                                          if(_bgcolor100 != bgcolor)
2371:                                          {
2372:                                              _bgcolor100 = bgcolor;
2373:                                              calculateColors();
2374:                                          }
2375:                                      }
2376:                                      switch(val)
2377:                                      {
2378:                                          case 1: SetColor(_fgcolor25);
2379:                                                  break;
2380:                                                      
2381:                                          case 2: SetColor(_fgcolor75);
2382:                                                  break;
2383:                                                      
2384:                                          case 3: SetColor(_fgcolor100);
2385:                                      }
2386:                                      PutPixel(y, x);
2387:                                  }
2388:                              }
2389:              
2390:                              mask  <<=  pParam->bpp;
2391:                              shift  +=  pParam->bpp;
2392:              #else
2393:                              if(temp & mask)
006438  90401E     MOV.B [W14+1], W0
00643A  60401E     AND.B W0, [W14], W0
00643C  504FE0     SUB.B W0, #0x0, [W15]
00643E  320003     BRA Z, 0x6446
2394:                              {
2395:                                  PutPixel(y, x);
006440  9000BE     MOV [W14+6], W1
006442  90004E     MOV [W14+8], W0
006444  072F32     RCALL PutPixel
2396:                              }
2397:                              mask  <<=  1;
006446  90401E     MOV.B [W14+1], W0
006448  404000     ADD.B W0, W0, W0
00644A  984710     MOV.B W0, [W14+1]
2398:              #endif
2399:                              x--;
00644C  90003E     MOV [W14+6], W0
00644E  E90000     DEC W0, W0
006450  980730     MOV W0, [W14+6]
2400:                          }
2401:                          y++;
006462  90004E     MOV [W14+8], W0
006464  E80000     INC W0, W0
006466  980740     MOV W0, [W14+8]
2402:                      }
2403:              
2404:                      // move cursor
2405:                      _cursorY = x - pParam->xAdjust;
00647C  90007E     MOV [W14+14], W0
00647E  900050     MOV [W0+10], W0
006480  9000BE     MOV [W14+6], W1
006482  508000     SUB W1, W0, W0
006484  888270     MOV W0, _cursorY
2406:                  }
2407:              
2408:                  // restore color
2409:              #ifdef USE_ANTIALIASED_FONTS
2410:                  if(pParam->bpp > 1)
2411:                  {
2412:                      SetColor(_fgcolor100);
2413:                  }
2414:              #endif
2415:                  return (1);
006486  200010     MOV #0x1, W0
2416:              
2417:              }
006488  FA8000     ULNK
00648A  060000     RETURN
2418:              
2419:              /*********************************************************************
2420:              * Function: WORD OutChar(XCHAR ch)
2421:              *
2422:              * PreCondition: none
2423:              *
2424:              * Input: character code
2425:              *
2426:              * Output: For NON-Blocking configuration:
2427:              *         - Returns 0 when device is busy and the character is not yet completely drawn.
2428:              *         - Returns 1 when the character is completely drawn.
2429:              *         For Blocking configuration:
2430:              *         - Always return 1.
2431:              *
2432:              * Side Effects: none
2433:              *
2434:              * Overview: outputs a character
2435:              *
2436:              * Note: none
2437:              *
2438:              ********************************************************************/
2439:              WORD __attribute__((weak)) OutChar(XCHAR ch)
2440:              {
00648C  FA0002     LNK #0x2
00648E  784F00     MOV.B W0, [W14]
2441:                  static OUTCHAR_PARAM OutCharParam;
2442:              
2443:                  // initialize variables
2444:              #ifdef USE_FONT_EXTERNAL	
2445:                  OutCharParam.pChImage = NULL;
2446:              #endif
2447:                  OutCharParam.xAdjust = 0;
006490  EB0000     CLR W0
006492  888330     MOV W0, 0x1066
2448:                  OutCharParam.yAdjust = 0;
006494  EB0000     CLR W0
006496  888340     MOV W0, 0x1068
2449:                  OutCharParam.xWidthAdjust = 0;
006498  EB0000     CLR W0
00649A  888350     MOV W0, 0x106A
2450:                  OutCharParam.heightOvershoot = 0;
00649C  EB0000     CLR W0
00649E  888360     MOV W0, 0x106C
2451:              
2452:                  // check for error conditions (a return value of 0xFFFF means error)
2453:                  if((UXCHAR)ch < (UXCHAR)currentFont.fontHeader.firstChar)
0064A0  78409E     MOV.B [W14], W1
0064A2  8082A0     MOV 0x1054, W0
0064A4  784000     MOV.B W0, W0
0064A6  50CF80     SUB.B W1, W0, [W15]
0064A8  310002     BRA C, 0x64AE
2454:                      return (-1);
0064AA  EB8000     SETM W0
0064AC  370029     BRA 0x6500
2455:                  if((UXCHAR)ch > (UXCHAR)currentFont.fontHeader.lastChar)
0064AE  78409E     MOV.B [W14], W1
0064B0  8082B0     MOV 0x1056, W0
0064B2  784000     MOV.B W0, W0
0064B4  50CF80     SUB.B W1, W0, [W15]
0064B6  360002     BRA LEU, 0x64BC
2456:                      return (-1);
0064B8  EB8000     SETM W0
0064BA  370022     BRA 0x6500
2457:              #ifndef USE_ANTIALIASED_FONTS
2458:                  if(currentFont.fontHeader.bpp > 1)
0064BC  808290     MOV 0x1052, W0
0064BE  DE004A     LSR W0, #10, W0
0064C0  604063     AND.B W0, #0x3, W0
0064C2  FB8000     ZE W0, W0
0064C4  500FE1     SUB W0, #0x1, [W15]
0064C6  340004     BRA LE, 0x64D0
2459:                      return (-1);
0064C8  EB8000     SETM W0
0064CA  37001A     BRA 0x6500
2460:              #endif
2461:              
2462:              #ifndef USE_NONBLOCKING_CONFIG
2463:                  while(IsDeviceBusy() != 0) Nop();
0064CC  000000     NOP
0064CE  370001     BRA 0x64D2
0064D0  000000     NOP
0064D2  072F1F     RCALL IsDeviceBusy
0064D4  500FE0     SUB W0, #0x0, [W15]
0064D6  3AFFFA     BRA NZ, 0x64CC
2464:              #else
2465:                  if(IsDeviceBusy() != 0)
2466:                      return (0);
2467:              #endif
2468:              
2469:                  switch(*((SHORT *)currentFont.pFont))
0064D8  808280     MOV currentFont, W0
0064DA  780010     MOV [W0], W0
0064DC  500FE0     SUB W0, #0x0, [W15]
0064DE  320003     BRA Z, 0x64E6
0064E0  500FE1     SUB W0, #0x1, [W15]
0064E2  320005     BRA Z, 0x64EE
0064E4  370008     BRA 0x64F6
2470:                  {
2471:              
2472:                      case FLASH:
2473:                          OutCharGetInfoFlash(ch, &OutCharParam); 
0064E6  2105C1     MOV #0x105C, W1
0064E8  78401E     MOV.B [W14], W0
0064EA  07FECA     RCALL OutCharGetInfoFlash
2474:                          break;
0064EC  370006     BRA 0x64FA
2475:              
2476:                      case EXTERNAL:
2477:                          OutCharGetInfoExternal(ch, &OutCharParam);
0064EE  2105C1     MOV #0x105C, W1
0064F0  78401E     MOV.B [W14], W0
0064F2  07FF2C     RCALL OutCharGetInfoExternal
2478:                          break;
0064F4  370002     BRA 0x64FA
2479:                      
2480:                      default:
2481:                          return 1;
0064F6  200010     MOV #0x1, W0
0064F8  370003     BRA 0x6500
2482:                  }    
2483:                  
2484:                  return (OutCharRender(ch, &OutCharParam));
0064FA  2105C1     MOV #0x105C, W1
0064FC  78401E     MOV.B [W14], W0
0064FE  07FF2B     RCALL OutCharRender
2485:              }
006500  FA8000     ULNK
006502  060000     RETURN
2486:              
2487:              /*********************************************************************
2488:              * Function: WORD OutText(XCHAR* textString)
2489:              *
2490:              * PreCondition: none
2491:              *
2492:              * Input: textString - pointer to text string
2493:              *
2494:              * Output: non-zero if drawing done (used for NON-BLOCKING configuration)
2495:              *
2496:              * Side Effects: none
2497:              *
2498:              * Overview: outputs text from current position
2499:              *
2500:              * Note: none
2501:              *
2502:              ********************************************************************/
2503:              WORD __attribute__((weak)) OutText(XCHAR *textString)
2504:              {
006504  FA0004     LNK #0x4
006506  980710     MOV W0, [W14+2]
2505:                  #ifndef USE_NONBLOCKING_CONFIG
2506:              
2507:                  XCHAR   ch;
2508:                  while((UXCHAR)15 < (UXCHAR)(ch = *textString++))
006508  370005     BRA 0x6514
006514  90001E     MOV [W14+2], W0
006516  784F10     MOV.B [W0], [W14]
006518  78409E     MOV.B [W14], W1
00651A  B3C010     MOV #0x1, W0
00651C  50CFEF     SUB.B W1, #0xF, [W15]
00651E  3E0001     BRA GTU, 0x6522
006520  EB4000     CLR.B W0
006522  90009E     MOV [W14+2], W1
006524  E80081     INC W1, W1
006526  980711     MOV W1, [W14+2]
006528  504FE0     SUB.B W0, #0x0, [W15]
00652A  3AFFEF     BRA NZ, 0x650A
2509:                      while(OutChar(ch) == 0);
00650A  000000     NOP
00650C  78401E     MOV.B [W14], W0
00650E  07FFBE     RCALL OutChar
006510  500FE0     SUB W0, #0x0, [W15]
006512  32FFFC     BRA Z, 0x650C
2510:                  return (1);
00652C  200010     MOV #0x1, W0
2511:              
2512:                  #else
2513:              
2514:                  XCHAR       ch;
2515:                  static WORD counter = 0;
2516:              
2517:                  while((UXCHAR)(ch = *(textString + counter)) > (UXCHAR)15)
2518:                  {
2519:                      if(OutChar(ch) == 0)
2520:                          return (0);
2521:                      counter++;
2522:                  }
2523:              
2524:                  counter = 0;
2525:                  return (1);
2526:                  #endif
2527:              }
00652E  FA8000     ULNK
006530  060000     RETURN
2528:              
2529:              /*********************************************************************
2530:              * Function: WORD OutTextXY(SHORT x, SHORT y, XCHAR* textString)
2531:              *
2532:              * PreCondition: none
2533:              *
2534:              * Input: x,y - starting coordinates, textString - pointer to text string
2535:              *
2536:              * Output: non-zero if drawing done (used for NON-BLOCKING configuration)
2537:              *
2538:              * Side Effects: none
2539:              *
2540:              * Overview: outputs text from x,y position
2541:              *
2542:              * Note: none
2543:              *
2544:              ********************************************************************/
2545:              WORD __attribute__((weak)) OutTextXY(SHORT x, SHORT y, XCHAR *textString)
2546:              {
006532  FA0006     LNK #0x6
006534  780F00     MOV W0, [W14]
006536  980711     MOV W1, [W14+2]
006538  980722     MOV W2, [W14+4]
2547:                  #ifndef USE_NONBLOCKING_CONFIG
2548:                  MoveTo(x, y);
00653A  78001E     MOV [W14], W0
00653C  888260     MOV W0, _cursorX
00653E  90001E     MOV [W14+2], W0
006540  888270     MOV W0, _cursorY
2549:                  OutText(textString);
006542  90002E     MOV [W14+4], W0
006544  07FFDF     RCALL OutText
2550:                  return (1);
006546  200010     MOV #0x1, W0
2551:              
2552:                  #else
2553:              
2554:                  static BYTE start = 1;
2555:              
2556:                  if(start)
2557:                  {
2558:                      MoveTo(x, y);
2559:                      start = 0;
2560:                  }
2561:              
2562:                  if(OutText(textString) == 0)
2563:                  {
2564:                      return (0);
2565:                  }
2566:                  else
2567:                  {
2568:                      start = 1;
2569:                      return (1);
2570:                  }
2571:              
2572:                  #endif
2573:              }
006548  FA8000     ULNK
00654A  060000     RETURN
2574:              
2575:              /*********************************************************************
2576:              * Function: SHORT GetTextWidthRam(XCHAR* textString, void* pFont)
2577:              *
2578:              * PreCondition: none
2579:              *
2580:              * Input: textString - pointer to the text string,
2581:              *        pFont - pointer to the font in RAM
2582:              *
2583:              * Output: text width in pixels
2584:              *
2585:              * Side Effects: none
2586:              *
2587:              * Overview: returns text width for the font
2588:              *
2589:              * Note: Application should not call this function. This function is for 
2590:              *       versatility of implementing hardware accelerated text rendering
2591:              *       only.
2592:              *
2593:              ********************************************************************/
2594:              SHORT __attribute__((weak)) GetTextWidthRam(XCHAR* textString, void* pFont)
2595:              {
00654C  FA0004     LNK #0x4
00654E  780F00     MOV W0, [W14]
006550  980711     MOV W1, [W14+2]
2596:              #if defined (USE_FONT_RAM)
2597:                  GLYPH_ENTRY *pChTable = NULL;
2598:                  GLYPH_ENTRY_EXTENDED *pChTableExtended = NULL;
2599:                  FONT_HEADER *pHeader;
2600:              
2601:                  SHORT       textWidth;
2602:                  XCHAR       ch;
2603:                  XCHAR       fontFirstChar;
2604:                  XCHAR       fontLastChar;
2605:              
2606:                  pHeader = (FONT_HEADER *) ((FONT_RAM *)pFont)->address;
2607:                  fontFirstChar = pHeader->firstChar;
2608:                  fontLastChar = pHeader->lastChar;
2609:                  if(pHeader->extendedGlyphEntry)
2610:                  {
2611:                      pChTableExtended = (GLYPH_ENTRY_EXTENDED *) (pHeader + 1);
2612:                  }
2613:                  else
2614:                  {
2615:                      pChTable = (GLYPH_ENTRY *) (pHeader + 1);
2616:                  }    
2617:                  textWidth = 0;
2618:                  while((UXCHAR)15 < (UXCHAR)(ch = *textString++))
2619:                  {
2620:                      if((UXCHAR)ch < (UXCHAR)fontFirstChar)
2621:                          continue;
2622:                      if((UXCHAR)ch > (UXCHAR)fontLastChar)
2623:                          continue;
2624:                      if(pHeader->extendedGlyphEntry)
2625:                      {
2626:                          textWidth += (pChTableExtended + ((UXCHAR)ch - (UXCHAR)fontFirstChar))->cursorAdvance;
2627:                      }
2628:                      else
2629:                      {
2630:                          textWidth += (pChTable + ((UXCHAR)ch - (UXCHAR)fontFirstChar))->width;
2631:                      }
2632:                  }
2633:                  return textWidth;
2634:              
2635:              #else
2636:                  return 0;
006552  EB0000     CLR W0
2637:              #endif //#if defined (USE_FONT_RAM) 
2638:              }
006554  FA8000     ULNK
006556  060000     RETURN
2639:              
2640:              /*********************************************************************
2641:              * Function: SHORT GetTextWidthFlash(XCHAR* textString, void* pFont)
2642:              *
2643:              * PreCondition: none
2644:              *
2645:              * Input: textString - pointer to the text string,
2646:              *        pFont - pointer to the font in flash memory
2647:              *
2648:              * Output: text width in pixels
2649:              *
2650:              * Side Effects: none
2651:              *
2652:              * Overview: returns text width for the font
2653:              *
2654:              * Note: Application should not call this function. This function is for 
2655:              *       versatility of implementing hardware accelerated text rendering
2656:              *       only.
2657:              *
2658:              ********************************************************************/
2659:              SHORT __attribute__((weak)) GetTextWidthFlash(XCHAR* textString, void* pFont)
2660:              {
006558  FA0010     LNK #0x10
00655A  980760     MOV W0, [W14+12]
00655C  980771     MOV W1, [W14+14]
2661:              #if defined (USE_FONT_FLASH) 
2662:                  GFX_FONT_SPACE GLYPH_ENTRY *pChTable = NULL;
00655E  EB0000     CLR W0
006560  780F00     MOV W0, [W14]
2663:                  GFX_FONT_SPACE GLYPH_ENTRY_EXTENDED *pChTableExtended = NULL;
006562  EB0000     CLR W0
006564  980710     MOV W0, [W14+2]
2664:                  GFX_FONT_SPACE FONT_HEADER *pHeader;
2665:              
2666:                  SHORT       textWidth;
2667:                  XCHAR       ch;
2668:                  XCHAR       fontFirstChar;
2669:                  XCHAR       fontLastChar;
2670:              
2671:                  pHeader = (GFX_FONT_SPACE FONT_HEADER *) ((FONT_FLASH *)pFont)->address;
006566  90007E     MOV [W14+14], W0
006568  900010     MOV [W0+2], W0
00656A  980730     MOV W0, [W14+6]
2672:                  fontFirstChar = pHeader->firstChar;
00656C  90003E     MOV [W14+6], W0
00656E  900010     MOV [W0+2], W0
006570  984F00     MOV.B W0, [W14+8]
2673:                  fontLastChar = pHeader->lastChar;
006572  90003E     MOV [W14+6], W0
006574  900020     MOV [W0+4], W0
006576  984F10     MOV.B W0, [W14+9]
2674:                  if(pHeader->extendedGlyphEntry)
006578  90003E     MOV [W14+6], W0
00657A  780090     MOV [W0], W1
00657C  201000     MOV #0x100, W0
00657E  608000     AND W1, W0, W0
006580  500FE0     SUB W0, #0x0, [W15]
006582  320004     BRA Z, 0x658C
2675:                  {
2676:                      pChTableExtended = (GFX_FONT_SPACE GLYPH_ENTRY_EXTENDED *) (pHeader + 1);
006584  90003E     MOV [W14+6], W0
006586  400068     ADD W0, #0x8, W0
006588  980710     MOV W0, [W14+2]
00658A  370002     BRA 0x6590
2677:                  }
2678:                  else
2679:                  {
2680:                      pChTable = (GFX_FONT_SPACE GLYPH_ENTRY *) (pHeader + 1);
00658C  90003E     MOV [W14+6], W0
00658E  400F68     ADD W0, #0x8, [W14]
2681:                  }    
2682:                  textWidth = 0;
006590  EB0000     CLR W0
006592  980720     MOV W0, [W14+4]
2683:                  while((UXCHAR)15 < (UXCHAR)(ch = *textString++))
006594  37002C     BRA 0x65EE
0065EE  90006E     MOV [W14+12], W0
0065F0  784090     MOV.B [W0], W1
0065F2  984F21     MOV.B W1, [W14+10]
0065F4  9048AE     MOV.B [W14+10], W1
0065F6  B3C010     MOV #0x1, W0
0065F8  50CFEF     SUB.B W1, #0xF, [W15]
0065FA  3E0001     BRA GTU, 0x65FE
0065FC  EB4000     CLR.B W0
0065FE  9000EE     MOV [W14+12], W1
006600  E80081     INC W1, W1
006602  980761     MOV W1, [W14+12]
006604  504FE0     SUB.B W0, #0x0, [W15]
006606  3AFFC7     BRA NZ, 0x6596
2684:                  {
2685:                      if((UXCHAR)ch < (UXCHAR)fontFirstChar)
006596  9048AE     MOV.B [W14+10], W1
006598  90480E     MOV.B [W14+8], W0
00659A  50CF80     SUB.B W1, W0, [W15]
00659C  390025     BRA NC, 0x65E8
2686:                          continue;
0065E8  000000     NOP
0065EA  370001     BRA 0x65EE
2687:                      if((UXCHAR)ch > (UXCHAR)fontLastChar)
00659E  9048AE     MOV.B [W14+10], W1
0065A0  90481E     MOV.B [W14+9], W0
0065A2  50CF80     SUB.B W1, W0, [W15]
0065A4  3E0023     BRA GTU, 0x65EC
2688:                          continue;
0065EC  000000     NOP
2689:                      if(pHeader->extendedGlyphEntry)
0065A6  90003E     MOV [W14+6], W0
0065A8  780090     MOV [W0], W1
0065AA  201000     MOV #0x100, W0
0065AC  608000     AND W1, W0, W0
0065AE  500FE0     SUB W0, #0x0, [W15]
0065B0  32000E     BRA Z, 0x65CE
2690:                      {
2691:                          textWidth += (pChTableExtended + ((UXCHAR)ch - (UXCHAR)fontFirstChar))->cursorAdvance;
0065B2  90482E     MOV.B [W14+10], W0
0065B4  FB8080     ZE W0, W1
0065B6  90480E     MOV.B [W14+8], W0
0065B8  FB8000     ZE W0, W0
0065BA  508000     SUB W1, W0, W0
0065BC  B9006C     MUL.SU W0, #12, W0
0065BE  780000     MOV W0, W0
0065C0  90009E     MOV [W14+2], W1
0065C2  408000     ADD W1, W0, W0
0065C4  9000A0     MOV [W0+4], W1
0065C6  90002E     MOV [W14+4], W0
0065C8  408000     ADD W1, W0, W0
0065CA  980720     MOV W0, [W14+4]
0065CC  370010     BRA 0x65EE
2692:                      }
2693:                      else
2694:                      {
2695:                          textWidth += (pChTable + ((UXCHAR)ch - (UXCHAR)fontFirstChar))->width;
0065CE  90482E     MOV.B [W14+10], W0
0065D0  FB8080     ZE W0, W1
0065D2  90480E     MOV.B [W14+8], W0
0065D4  FB8000     ZE W0, W0
0065D6  508000     SUB W1, W0, W0
0065D8  DD0042     SL W0, #2, W0
0065DA  40001E     ADD W0, [W14], W0
0065DC  784010     MOV.B [W0], W0
0065DE  FB8000     ZE W0, W0
0065E0  9000AE     MOV [W14+4], W1
0065E2  408000     ADD W1, W0, W0
0065E4  980720     MOV W0, [W14+4]
0065E6  370003     BRA 0x65EE
2696:                      }
2697:                  }
2698:              
2699:                  return (textWidth);
006608  90002E     MOV [W14+4], W0
2700:              
2701:              #else
2702:                  return 0;
2703:              #endif //#if defined (USE_FONT_FLASH) 
2704:              
2705:              }
00660A  FA8000     ULNK
00660C  060000     RETURN
2706:              
2707:              /*********************************************************************
2708:              * Function: SHORT GetTextWidthExternal(XCHAR* textString, void* pFont)
2709:              *
2710:              * PreCondition: none
2711:              *
2712:              * Input: textString - pointer to the text string,
2713:              *        pFont - pointer to the font in external memory
2714:              *
2715:              * Output: text width in pixels
2716:              *
2717:              * Side Effects: none
2718:              *
2719:              * Overview: returns text width for the font
2720:              *
2721:              * Note: Application should not call this function. This function is for 
2722:              *       versatility of implementing hardware accelerated text rendering
2723:              *       only.
2724:              *
2725:              ********************************************************************/
2726:              SHORT __attribute__((weak)) GetTextWidthExternal(XCHAR* textString, void* pFont)
2727:              {
00660E  FA0004     LNK #0x4
006610  780F00     MOV W0, [W14]
006612  980711     MOV W1, [W14+2]
2728:              
2729:              #ifdef USE_FONT_EXTERNAL
2730:                  GLYPH_ENTRY chTable;
2731:                  GLYPH_ENTRY_EXTENDED chTableExtended;
2732:                  FONT_HEADER header;
2733:              
2734:                  SHORT       textWidth;
2735:                  XCHAR       ch;
2736:                  XCHAR       fontFirstChar;
2737:                  XCHAR       fontLastChar;
2738:              
2739:              
2740:                  ExternalMemoryCallback(pFont, 0, sizeof(FONT_HEADER), &header);
2741:                  fontFirstChar = header.firstChar;
2742:                  fontLastChar = header.lastChar;
2743:                  textWidth = 0;
2744:                  while((UXCHAR)15 < (UXCHAR)(ch = *textString++))
2745:                  {
2746:                      if((UXCHAR)ch < (UXCHAR)fontFirstChar)
2747:                          continue;
2748:                      if((UXCHAR)ch > (UXCHAR)fontLastChar)
2749:                          continue;
2750:                      if(header.extendedGlyphEntry)
2751:                      {
2752:                          ExternalMemoryCallback
2753:                          (
2754:                              pFont,
2755:                              sizeof(FONT_HEADER) + sizeof(GLYPH_ENTRY_EXTENDED) * ((UXCHAR)ch - (UXCHAR)fontFirstChar),
2756:                              sizeof(GLYPH_ENTRY_EXTENDED),
2757:                              &chTableExtended
2758:                          );
2759:                          textWidth += chTableExtended.cursorAdvance;
2760:                      }
2761:                      else
2762:                      {
2763:                          ExternalMemoryCallback
2764:                          (
2765:                              pFont,
2766:                              sizeof(FONT_HEADER) + sizeof(GLYPH_ENTRY) * ((UXCHAR)ch - (UXCHAR)fontFirstChar),
2767:                              sizeof(GLYPH_ENTRY),
2768:                              &chTable
2769:                          );
2770:                          textWidth += chTable.width;
2771:                      }
2772:                  }
2773:              
2774:                  return (textWidth);
2775:              #else
2776:                  return 0;
006614  EB0000     CLR W0
2777:              #endif //#ifdef USE_FONT_EXTERNAL
2778:              }
006616  FA8000     ULNK
006618  060000     RETURN
2779:              
2780:              /*********************************************************************
2781:              * Function: SHORT GetTextWidth(XCHAR* textString, void* pFont)
2782:              *
2783:              * PreCondition: none
2784:              *
2785:              * Input: textString - pointer to the text string,
2786:              *        pFont - pointer to the font
2787:              *
2788:              * Output: text width in pixels
2789:              *
2790:              * Side Effects: none
2791:              *
2792:              * Overview: returns text width for the font
2793:              *
2794:              * Note: none
2795:              *
2796:              ********************************************************************/
2797:              SHORT __attribute__((weak)) GetTextWidth(XCHAR *textString, void *pFont)
2798:              {
00661A  FA0004     LNK #0x4
00661C  780F00     MOV W0, [W14]
00661E  980711     MOV W1, [W14+2]
2799:                  switch(*((SHORT *)pFont))
006620  90001E     MOV [W14+2], W0
006622  780010     MOV [W0], W0
006624  500FE1     SUB W0, #0x1, [W15]
006626  32000D     BRA Z, 0x6642
006628  500FE4     SUB W0, #0x4, [W15]
00662A  320003     BRA Z, 0x6632
00662C  500FE0     SUB W0, #0x0, [W15]
00662E  320005     BRA Z, 0x663A
006630  37000C     BRA 0x664A
2800:                  {
2801:                      case RAM:
2802:                          return GetTextWidthRam(textString, pFont);
006632  90009E     MOV [W14+2], W1
006634  78001E     MOV [W14], W0
006636  07FF8A     RCALL GetTextWidthRam
006638  370009     BRA 0x664C
2803:                              	    
2804:                      case FLASH:
2805:                          return GetTextWidthFlash(textString, pFont);
00663A  90009E     MOV [W14+2], W1
00663C  78001E     MOV [W14], W0
00663E  07FF8C     RCALL GetTextWidthFlash
006640  370005     BRA 0x664C
2806:              
2807:                      case EXTERNAL:
2808:                          return GetTextWidthExternal(textString, pFont);
006642  90009E     MOV [W14+2], W1
006644  78001E     MOV [W14], W0
006646  07FFE3     RCALL GetTextWidthExternal
006648  370001     BRA 0x664C
2809:                          
2810:                      default:
2811:                          return (0);
00664A  EB0000     CLR W0
2812:                  }
2813:              }
00664C  FA8000     ULNK
00664E  060000     RETURN
2814:              
2815:              
2816:              /*********************************************************************
2817:              * Function: SHORT GetTextHeight(void* pFont)
2818:              *
2819:              * PreCondition: none
2820:              *
2821:              * Input: pointer to the font
2822:              *
2823:              * Output: character height in pixels
2824:              *
2825:              * Side Effects: none
2826:              *
2827:              * Overview: returns characters height for the font
2828:              *
2829:              * Note: none
2830:              *
2831:              ********************************************************************/
2832:              SHORT __attribute__((weak)) GetTextHeight(void *pFont)
2833:              {
006650  FA0002     LNK #0x2
006652  780F00     MOV W0, [W14]
2834:              #ifdef USE_FONT_EXTERNAL
2835:                  SHORT height;
2836:              #endif
2837:              
2838:                  // if the current set font is the same just return with 
2839:                  // the already set value in currentFont
2840:                  if (pFont == currentFont.pFont)
006654  808280     MOV currentFont, W0
006656  500F9E     SUB W0, [W14], [W15]
006658  3A0002     BRA NZ, 0x665E
2841:                      return currentFont.fontHeader.height;
00665A  8082C0     MOV 0x1058, W0
00665C  370009     BRA 0x6670
2842:                  else
2843:                  {
2844:                      switch(*((SHORT *)pFont))
00665E  78001E     MOV [W14], W0
006660  780010     MOV [W0], W0
006662  500FE0     SUB W0, #0x0, [W15]
006664  3A0004     BRA NZ, 0x666E
2845:                      {
2846:              #ifdef USE_FONT_RAM
2847:                          case RAM:
2848:                              return ((FONT_HEADER *) ((FONT_RAM *)pFont)->address)->height;
2849:              #endif
2850:                                  
2851:              #ifdef USE_FONT_FLASH
2852:                          case FLASH:
2853:                              return ((GFX_FONT_SPACE FONT_HEADER *) ((FONT_FLASH *)pFont)->address)->height;
006666  78001E     MOV [W14], W0
006668  900010     MOV [W0+2], W0
00666A  900030     MOV [W0+6], W0
00666C  370001     BRA 0x6670
2854:              #endif
2855:                                  
2856:              #ifdef USE_FONT_EXTERNAL
2857:                          case EXTERNAL:
2858:                              ExternalMemoryCallback(pFont, sizeof(FONT_HEADER) - 2, 2, &height);
2859:                              return (height);
2860:              #endif
2861:                  
2862:                          default:
2863:                              return (0);
00666E  EB0000     CLR W0
2864:                      }
2865:                  }
2866:              }
006670  FA8000     ULNK
006672  060000     RETURN
2867:              
2868:              /*********************************************************************
2869:              * Function: SHORT GetImageWidth(void* image)
2870:              *
2871:              * PreCondition: none
2872:              *
2873:              * Input: image - image pointer
2874:              *
2875:              * Output: none
2876:              *
2877:              * Side Effects: none
2878:              *
2879:              * Overview: returns image width
2880:              *
2881:              * Note: none
2882:              *
2883:              ********************************************************************/
2884:              SHORT __attribute__((weak)) GetImageWidth(void *image)
2885:              {
006674  FA0002     LNK #0x2
006676  780F00     MOV W0, [W14]
2886:              #ifdef USE_BITMAP_EXTERNAL
2887:                  SHORT   width;
2888:              #endif
2889:              
2890:                  switch(*((SHORT *)image))
006678  78001E     MOV [W14], W0
00667A  780010     MOV [W0], W0
00667C  500FE0     SUB W0, #0x0, [W15]
00667E  3A000C     BRA NZ, 0x6698
2891:                  {
2892:              
2893:              #ifdef USE_BITMAP_FLASH
2894:                      case FLASH:
2895:                          return (*((FLASH_WORD *) ((IMAGE_FLASH *)image)->address + 2));
006680  78001E     MOV [W14], W0
006682  E88100     INC2 W0, W2
006684  BE0012     MOV.D [W2], W0
006686  400064     ADD W0, #0x4, W0
006688  4880E0     ADDC W1, #0x0, W1
00668A  8001A2     MOV PSVPAG, W2
00668C  A4F000     BTSTS.C W0, #15
00668E  D28081     RLC W1, W1
006690  8801A1     MOV W1, PSVPAG
006692  780010     MOV [W0], W0
006694  8801A2     MOV W2, PSVPAG
006696  370001     BRA 0x669A
2896:              
2897:                  #if defined(USE_COMP_RLE)
2898:                      case FLASH | COMP_RLE | IMAGE_MBITMAP:
2899:                          return (((GFX_IMAGE_HEADER *)image)->width);
2900:                  #endif
2901:              #endif
2902:              
2903:              #ifdef USE_BITMAP_EXTERNAL
2904:              
2905:                      case EXTERNAL:
2906:                          ExternalMemoryCallback(image, 4, 2, &width);
2907:                          return (width);
2908:              
2909:                  #if defined(USE_COMP_RLE)
2910:                      case EXTERNAL | COMP_RLE | IMAGE_MBITMAP:
2911:                          return (((GFX_IMAGE_HEADER *)image)->width);
2912:                  #endif
2913:              
2914:              
2915:              #endif
2916:              
2917:                      default:
2918:                          return (0);
006698  EB0000     CLR W0
2919:                  }
2920:              }
00669A  FA8000     ULNK
00669C  060000     RETURN
2921:              
2922:              /*********************************************************************
2923:              * Function: SHORT GetImageHeight(void* image)
2924:              *
2925:              * PreCondition: none
2926:              *
2927:              * Input: image - image pointer
2928:              *
2929:              * Output: none
2930:              *
2931:              * Side Effects: none
2932:              *
2933:              * Overview: returns image height
2934:              *
2935:              * Note: none
2936:              *
2937:              ********************************************************************/
2938:              SHORT __attribute__((weak)) GetImageHeight(void *image)
2939:              {
00669E  FA0002     LNK #0x2
0066A0  780F00     MOV W0, [W14]
2940:              #ifdef USE_BITMAP_EXTERNAL
2941:                  SHORT   height;
2942:              #endif
2943:              
2944:                  switch(*((SHORT *)image))
0066A2  78001E     MOV [W14], W0
0066A4  780010     MOV [W0], W0
0066A6  500FE0     SUB W0, #0x0, [W15]
0066A8  3A000C     BRA NZ, 0x66C2
2945:                  {
2946:              #ifdef USE_BITMAP_FLASH
2947:              
2948:                      case FLASH:
2949:                          return (*((FLASH_WORD *) ((IMAGE_FLASH *)image)->address + 1));
0066AA  78001E     MOV [W14], W0
0066AC  E88100     INC2 W0, W2
0066AE  BE0012     MOV.D [W2], W0
0066B0  400062     ADD W0, #0x2, W0
0066B2  4880E0     ADDC W1, #0x0, W1
0066B4  8001A2     MOV PSVPAG, W2
0066B6  A4F000     BTSTS.C W0, #15
0066B8  D28081     RLC W1, W1
0066BA  8801A1     MOV W1, PSVPAG
0066BC  780010     MOV [W0], W0
0066BE  8801A2     MOV W2, PSVPAG
0066C0  370001     BRA 0x66C4
2950:              
2951:                  #if defined(USE_COMP_RLE)
2952:                      case FLASH | COMP_RLE | IMAGE_MBITMAP:
2953:                          return (((GFX_IMAGE_HEADER *)image)->height);
2954:                  #endif
2955:              
2956:              
2957:              #endif
2958:              
2959:              #ifdef USE_BITMAP_EXTERNAL
2960:                          
2961:                      case EXTERNAL:
2962:                          ExternalMemoryCallback(image, 2, 2, &height);
2963:                          return (height);
2964:              
2965:                  #if defined(USE_COMP_RLE)
2966:                      case EXTERNAL | COMP_RLE | IMAGE_MBITMAP:
2967:                          return (((GFX_IMAGE_HEADER *)image)->height);
2968:                  #endif
2969:              
2970:              
2971:              #endif
2972:              
2973:                      default:
2974:                          return (0);
0066C2  EB0000     CLR W0
2975:                  }
2976:              }
0066C4  FA8000     ULNK
0066C6  060000     RETURN
2977:              
2978:                  #ifdef USE_BITMAP_FLASH
2979:              
2980:              /*********************************************************************
2981:              * Function: void PutImage1BPP(SHORT left, SHORT top, FLASH_BYTE* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
2982:              *
2983:              * PreCondition: none
2984:              *
2985:              * Input: left,top - left top image corner,
2986:              *        image - image pointer,
2987:              *        stretch - image stretch factor
2988:              *        partialImage - partial image pointer
2989:              *
2990:              * Output: none
2991:              *
2992:              * Side Effects: none
2993:              *
2994:              * Overview: outputs monochrome image starting from left,top coordinates
2995:              *
2996:              * Note: image must be located in flash
2997:              *
2998:              ********************************************************************/
2999:              void __attribute__((weak)) PutImage1BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3000:              {
0066C8  FA0028     LNK #0x28
0066CA  BE9F88     MOV.D W8, [W15++]
0066CC  BE9F8A     MOV.D W10, [W15++]
0066CE  980F60     MOV W0, [W14+28]
0066D0  980F71     MOV W1, [W14+30]
0066D2  200200     MOV #0x20, W0
0066D4  40000E     ADD W0, W14, W0
0066D6  BE8802     MOV.D W2, [W0]
0066D8  986744     MOV.B W4, [W14+36]
0066DA  981735     MOV W5, [W14+38]
3001:                  register FLASH_BYTE *flashAddress, *tempFlashAddress;
3002:                  BYTE                temp = 0;
0066DC  EB4000     CLR.B W0
0066DE  784F00     MOV.B W0, [W14]
3003:                  WORD                sizeX, sizeY;
3004:                  WORD                x, y;
3005:                  WORD                xc, yc;
3006:                  WORD                pallete[2];
3007:                  WORD                mask;
3008:                  WORD                addressOffset = 0, adjOffset;
0066E0  EB0000     CLR W0
0066E2  980F20     MOV W0, [W14+20]
3009:                  WORD                OffsetFlag = 0x01;     //Offset from BYTE color bit0 for the partial image 
0066E4  200010     MOV #0x1, W0
0066E6  980F10     MOV W0, [W14+18]
3010:                                
3011:                  // Move pointer to size information
3012:                  flashAddress = image + 2;
0066E8  200202     MOV #0x20, W2
0066EA  41010E     ADD W2, W14, W2
0066EC  BE0012     MOV.D [W2], W0
0066EE  400462     ADD W0, #0x2, W8
0066F0  4884E0     ADDC W1, #0x0, W9
3013:              
3014:                  // Read image size
3015:                  sizeY = *((FLASH_WORD *)flashAddress);
0066F2  BE0008     MOV.D W8, W0
0066F4  8001A2     MOV PSVPAG, W2
0066F6  A4F000     BTSTS.C W0, #15
0066F8  D28081     RLC W1, W1
0066FA  8801A1     MOV W1, PSVPAG
0066FC  780010     MOV [W0], W0
0066FE  8801A2     MOV W2, PSVPAG
006700  980720     MOV W0, [W14+4]
3016:                  flashAddress += 2;
006702  440462     ADD W8, #0x2, W8
006704  4C84E0     ADDC W9, #0x0, W9
3017:                  sizeX = *((FLASH_WORD *)flashAddress);
006706  BE0008     MOV.D W8, W0
006708  8001A2     MOV PSVPAG, W2
00670A  A4F000     BTSTS.C W0, #15
00670C  D28081     RLC W1, W1
00670E  8801A1     MOV W1, PSVPAG
006710  780010     MOV [W0], W0
006712  8801A2     MOV W2, PSVPAG
006714  980710     MOV W0, [W14+2]
3018:                  flashAddress += 2;
006716  440462     ADD W8, #0x2, W8
006718  4C84E0     ADDC W9, #0x0, W9
3019:                  pallete[0] = *((FLASH_WORD *)flashAddress);
00671A  BE0008     MOV.D W8, W0
00671C  8001A2     MOV PSVPAG, W2
00671E  A4F000     BTSTS.C W0, #15
006720  D28081     RLC W1, W1
006722  8801A1     MOV W1, PSVPAG
006724  780010     MOV [W0], W0
006726  8801A2     MOV W2, PSVPAG
006728  980F40     MOV W0, [W14+24]
3020:                  flashAddress += 2;
00672A  440462     ADD W8, #0x2, W8
00672C  4C84E0     ADDC W9, #0x0, W9
3021:                  pallete[1] = *((FLASH_WORD *)flashAddress);
00672E  BE0008     MOV.D W8, W0
006730  8001A2     MOV PSVPAG, W2
006732  A4F000     BTSTS.C W0, #15
006734  D28081     RLC W1, W1
006736  8801A1     MOV W1, PSVPAG
006738  780010     MOV [W0], W0
00673A  8801A2     MOV W2, PSVPAG
00673C  980F50     MOV W0, [W14+26]
3022:                  flashAddress += 2;
00673E  440462     ADD W8, #0x2, W8
006740  4C84E0     ADDC W9, #0x0, W9
3023:              
3024:                  if (sizeX & 0x07)
006742  90001E     MOV [W14+2], W0
006744  600067     AND W0, #0x7, W0
006746  500FE0     SUB W0, #0x0, [W15]
006748  320003     BRA Z, 0x6750
3025:                      adjOffset = 1; 
00674A  200010     MOV #0x1, W0
00674C  980F00     MOV W0, [W14+16]
00674E  370002     BRA 0x6754
3026:                  else
3027:                      adjOffset = 0;
006750  EB0000     CLR W0
006752  980F00     MOV W0, [W14+16]
3028:              
3029:                  // compute for addressOffset this is the offset needed to jump to the 
3030:                  // next line 
3031:                  addressOffset = ((sizeX >> 3) + adjOffset); 
006754  90001E     MOV [W14+2], W0
006756  DE00C3     LSR W0, #3, W1
006758  90080E     MOV [W14+16], W0
00675A  408000     ADD W1, W0, W0
00675C  980F20     MOV W0, [W14+20]
3032:              
3033:                  if(pPartialImageData->width != 0)
00675E  90103E     MOV [W14+38], W0
006760  780010     MOV [W0], W0
006762  500FE0     SUB W0, #0x0, [W15]
006764  320020     BRA Z, 0x67A6
3034:                  {
3035:                      WORD mod3 = ((pPartialImageData->xoffset) & 0x07);
006766  90103E     MOV [W14+38], W0
006768  900020     MOV [W0+4], W0
00676A  600067     AND W0, #0x7, W0
00676C  980F30     MOV W0, [W14+22]
3036:              
3037:                      // adjust the flashAddress to the starting pixel location
3038:                      // adjust one address if the data is not byte aligned
3039:                      flashAddress += (pPartialImageData->yoffset*((sizeX >> 3) + adjOffset));
00676E  90103E     MOV [W14+38], W0
006770  900030     MOV [W0+6], W0
006772  780080     MOV W0, W1
006774  90001E     MOV [W14+2], W0
006776  DE0143     LSR W0, #3, W2
006778  90080E     MOV [W14+16], W0
00677A  410000     ADD W2, W0, W0
00677C  B98800     MUL.SS W1, W0, W0
00677E  780000     MOV W0, W0
006780  200001     MOV #0x0, W1
006782  440400     ADD W8, W0, W8
006784  4C8481     ADDC W9, W1, W9
3040:              
3041:                      // adjust flashAddress for x offset (if xoffset is zero address stays the same)
3042:                      flashAddress += ((pPartialImageData->xoffset) >> 3);
006786  90103E     MOV [W14+38], W0
006788  900020     MOV [W0+4], W0
00678A  DE8043     ASR W0, #3, W0
00678C  DE80CF     ASR W0, #15, W1
00678E  440400     ADD W8, W0, W8
006790  4C8481     ADDC W9, W1, W9
3043:              
3044:                      OffsetFlag <<= mod3;
006792  90083E     MOV [W14+22], W0
006794  90089E     MOV [W14+18], W1
006796  DD0800     SL W1, W0, W0
006798  980F10     MOV W0, [W14+18]
3045:              
3046:                      sizeY = pPartialImageData->height;
00679A  90103E     MOV [W14+38], W0
00679C  900090     MOV [W0+2], W1
00679E  980721     MOV W1, [W14+4]
3047:                      sizeX = pPartialImageData->width;
0067A0  90103E     MOV [W14+38], W0
0067A2  780110     MOV [W0], W2
0067A4  980712     MOV W2, [W14+2]
3048:                  }
3049:              
3050:                  yc = top;
0067A6  90087E     MOV [W14+30], W0
0067A8  980760     MOV W0, [W14+12]
3051:              
3052:                  // store current line data address 
3053:                  tempFlashAddress = flashAddress;
0067AA  BE0508     MOV.D W8, W10
3054:              
3055:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
3056:                  if (stretch == IMAGE_NORMAL)
0067AC  90604E     MOV.B [W14+36], W0
0067AE  504FE1     SUB.B W0, #0x1, [W15]
0067B0  3A005A     BRA NZ, 0x6866
3057:                  {
3058:              
3059:                      for(y = 0; y < sizeY; y++)
0067B2  EB0000     CLR W0
0067B4  980740     MOV W0, [W14+8]
0067B6  370052     BRA 0x685C
006856  90004E     MOV [W14+8], W0
006858  E80000     INC W0, W0
00685A  980740     MOV W0, [W14+8]
00685C  9000CE     MOV [W14+8], W1
00685E  90002E     MOV [W14+4], W0
006860  508F80     SUB W1, W0, [W15]
006862  39FFAA     BRA NC, 0x67B8
006864  370068     BRA 0x6936
3060:                      {
3061:                          // get flash address location of current line being processed
3062:                          flashAddress = tempFlashAddress;
0067B8  BE040A     MOV.D W10, W8
3063:              
3064:                          xc = left;
0067BA  9008EE     MOV [W14+28], W1
0067BC  980751     MOV W1, [W14+10]
3065:                          if (OffsetFlag != 0x01)
0067BE  90081E     MOV [W14+18], W0
0067C0  500FE1     SUB W0, #0x1, [W15]
0067C2  32000A     BRA Z, 0x67D8
3066:                  		{
3067:                              // grab the first set of data then set up the mask to the starting pixel
3068:                  			temp = *flashAddress++;
0067C4  BE0008     MOV.D W8, W0
0067C6  8001A2     MOV PSVPAG, W2
0067C8  A4F000     BTSTS.C W0, #15
0067CA  D28081     RLC W1, W1
0067CC  8801A1     MOV W1, PSVPAG
0067CE  784010     MOV.B [W0], W0
0067D0  8801A2     MOV W2, PSVPAG
0067D2  784F00     MOV.B W0, [W14]
0067D4  440461     ADD W8, #0x1, W8
0067D6  4C84E0     ADDC W9, #0x0, W9
3069:                          }
3070:                          mask = OffsetFlag;
0067D8  90091E     MOV [W14+18], W2
0067DA  980772     MOV W2, [W14+14]
3071:               
3072:                          for(x = 0; x < sizeX; x++)
0067DC  EB0000     CLR W0
0067DE  980730     MOV W0, [W14+6]
0067E0  37002F     BRA 0x6840
00683A  90003E     MOV [W14+6], W0
00683C  E80000     INC W0, W0
00683E  980730     MOV W0, [W14+6]
006840  9000BE     MOV [W14+6], W1
006842  90001E     MOV [W14+2], W0
006844  508F80     SUB W1, W0, [W15]
006846  39FFCD     BRA NC, 0x67E2
3073:                          {
3074:              
3075:                          	// Read 8 pixels from flash
3076:                              if(mask == 0x01)
0067E2  90007E     MOV [W14+14], W0
0067E4  500FE1     SUB W0, #0x1, [W15]
0067E6  3A000C     BRA NZ, 0x6800
3077:              			    {
3078:              				    temp = *flashAddress++;
0067E8  BE0008     MOV.D W8, W0
0067EA  8001A2     MOV PSVPAG, W2
0067EC  A4F000     BTSTS.C W0, #15
0067EE  D28081     RLC W1, W1
0067F0  8801A1     MOV W1, PSVPAG
0067F2  784010     MOV.B [W0], W0
0067F4  8801A2     MOV W2, PSVPAG
0067F6  784F00     MOV.B W0, [W14]
0067F8  440461     ADD W8, #0x1, W8
0067FA  4C84E0     ADDC W9, #0x0, W9
3079:                                  mask = 0x01;
0067FC  200010     MOV #0x1, W0
0067FE  980770     MOV W0, [W14+14]
3080:                              }
3081:              
3082:                              // Set color
3083:                              if(mask & temp)
006800  78401E     MOV.B [W14], W0
006802  FB8080     ZE W0, W1
006804  90007E     MOV [W14+14], W0
006806  608000     AND W1, W0, W0
006808  500FE0     SUB W0, #0x0, [W15]
00680A  320004     BRA Z, 0x6814
3084:                              {
3085:                              // Set color
3086:                                  #ifdef USE_PALETTE
3087:                                      SetColor(1);
3088:                                  #else
3089:                                      SetColor(pallete[1]);
00680C  90085E     MOV [W14+26], W0
00680E  784000     MOV.B W0, W0
006810  B7F13E     MOV.B WREG, _color
006812  370003     BRA 0x681A
3090:                                  #endif                
3091:                              }
3092:                              else
3093:                              {
3094:                                  // Set color
3095:                                  #ifdef USE_PALETTE
3096:                                      SetColor(0);
3097:                                  #else
3098:                                      SetColor(pallete[0]);
006814  90084E     MOV [W14+24], W0
006816  784000     MOV.B W0, W0
006818  B7F13E     MOV.B WREG, _color
3099:                                  #endif
3100:                              }
3101:              
3102:                              #ifdef USE_TRANSPARENT_COLOR
3103:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3104:                              #endif
3105:                                      // Write pixel(s) to screen
3106:                                      PutPixel(xc, yc);
00681A  9000EE     MOV [W14+12], W1
00681C  90005E     MOV [W14+10], W0
00681E  072D45     RCALL PutPixel
3107:                                  // adjust to next location
3108:                                  xc++;
006820  90005E     MOV [W14+10], W0
006822  E80000     INC W0, W0
006824  980750     MOV W0, [W14+10]
3109:              
3110:                              // Read 8 pixels from flash
3111:                              if(mask == 0x80)
006826  9000FE     MOV [W14+14], W1
006828  200800     MOV #0x80, W0
00682A  508F80     SUB W1, W0, [W15]
00682C  3A0003     BRA NZ, 0x6834
3112:                                  mask = 0x01;
00682E  200010     MOV #0x1, W0
006830  980770     MOV W0, [W14+14]
006832  370003     BRA 0x683A
3113:                              else
3114:                                  // Shift to the next pixel
3115:                                  mask <<= 1;
006834  90007E     MOV [W14+14], W0
006836  400000     ADD W0, W0, W0
006838  980770     MOV W0, [W14+14]
3116:                          }  
3117:                          tempFlashAddress += (addressOffset);          
006848  90082E     MOV [W14+20], W0
00684A  200001     MOV #0x0, W1
00684C  450500     ADD W10, W0, W10
00684E  4D8581     ADDC W11, W1, W11
3118:                          yc++;
006850  90006E     MOV [W14+12], W0
006852  E80000     INC W0, W0
006854  980760     MOV W0, [W14+12]
3119:                      }
3120:                  }
3121:                  else
3122:                  {
3123:                      for(y = 0; y < sizeY; y++)
006866  EB0000     CLR W0
006868  980740     MOV W0, [W14+8]
00686A  370061     BRA 0x692E
006928  90004E     MOV [W14+8], W0
00692A  E80000     INC W0, W0
00692C  980740     MOV W0, [W14+8]
00692E  9000CE     MOV [W14+8], W1
006930  90002E     MOV [W14+4], W0
006932  508F80     SUB W1, W0, [W15]
006934  39FF9B     BRA NC, 0x686C
3124:                      {
3125:                          // get flash address location of current line being processed
3126:                          flashAddress = tempFlashAddress;
00686C  BE040A     MOV.D W10, W8
3127:              
3128:                          xc = left;
00686E  9008EE     MOV [W14+28], W1
006870  980751     MOV W1, [W14+10]
3129:                          if (OffsetFlag != 0x01)
006872  90081E     MOV [W14+18], W0
006874  500FE1     SUB W0, #0x1, [W15]
006876  32000A     BRA Z, 0x688C
3130:                  		{
3131:                              // grab the first set of data then set up the mask to the starting pixel
3132:                  			temp = *flashAddress++;
006878  BE0008     MOV.D W8, W0
00687A  8001A2     MOV PSVPAG, W2
00687C  A4F000     BTSTS.C W0, #15
00687E  D28081     RLC W1, W1
006880  8801A1     MOV W1, PSVPAG
006882  784010     MOV.B [W0], W0
006884  8801A2     MOV W2, PSVPAG
006886  784F00     MOV.B W0, [W14]
006888  440461     ADD W8, #0x1, W8
00688A  4C84E0     ADDC W9, #0x0, W9
3133:                          }
3134:                          mask = OffsetFlag;
00688C  90091E     MOV [W14+18], W2
00688E  980772     MOV W2, [W14+14]
3135:              
3136:                          for(x = 0; x < sizeX; x++)
006890  EB0000     CLR W0
006892  980730     MOV W0, [W14+6]
006894  37003E     BRA 0x6912
00690C  90003E     MOV [W14+6], W0
00690E  E80000     INC W0, W0
006910  980730     MOV W0, [W14+6]
006912  9000BE     MOV [W14+6], W1
006914  90001E     MOV [W14+2], W0
006916  508F80     SUB W1, W0, [W15]
006918  39FFBE     BRA NC, 0x6896
3137:                          {
3138:              
3139:                          	// Read 8 pixels from flash
3140:                              if(mask == 0x01)
006896  90007E     MOV [W14+14], W0
006898  500FE1     SUB W0, #0x1, [W15]
00689A  3A000C     BRA NZ, 0x68B4
3141:              			    {
3142:              				    temp = *flashAddress++;
00689C  BE0008     MOV.D W8, W0
00689E  8001A2     MOV PSVPAG, W2
0068A0  A4F000     BTSTS.C W0, #15
0068A2  D28081     RLC W1, W1
0068A4  8801A1     MOV W1, PSVPAG
0068A6  784010     MOV.B [W0], W0
0068A8  8801A2     MOV W2, PSVPAG
0068AA  784F00     MOV.B W0, [W14]
0068AC  440461     ADD W8, #0x1, W8
0068AE  4C84E0     ADDC W9, #0x0, W9
3143:                                  mask = 0x01;
0068B0  200010     MOV #0x1, W0
0068B2  980770     MOV W0, [W14+14]
3144:                              }
3145:              
3146:                                  // Set color
3147:                              if(mask & temp)
0068B4  78401E     MOV.B [W14], W0
0068B6  FB8080     ZE W0, W1
0068B8  90007E     MOV [W14+14], W0
0068BA  608000     AND W1, W0, W0
0068BC  500FE0     SUB W0, #0x0, [W15]
0068BE  320004     BRA Z, 0x68C8
3148:                              {
3149:                                  // Set color
3150:                                  #ifdef USE_PALETTE
3151:                                      SetColor(1);
3152:                                  #else
3153:                                      SetColor(pallete[1]);
0068C0  90085E     MOV [W14+26], W0
0068C2  784000     MOV.B W0, W0
0068C4  B7F13E     MOV.B WREG, _color
0068C6  370003     BRA 0x68CE
3154:                                  #endif                
3155:                              }
3156:                              else
3157:                              {
3158:                                  // Set color
3159:                                  #ifdef USE_PALETTE
3160:                                      SetColor(0);
3161:                                  #else
3162:                                      SetColor(pallete[0]);
0068C8  90084E     MOV [W14+24], W0
0068CA  784000     MOV.B W0, W0
0068CC  B7F13E     MOV.B WREG, _color
3163:                                  #endif
3164:                              }
3165:                              #ifdef USE_TRANSPARENT_COLOR
3166:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3167:                              #endif
3168:                                  {
3169:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
3170:                                      PutPixel(xc,   yc);
0068CE  9000EE     MOV [W14+12], W1
0068D0  90005E     MOV [W14+10], W0
0068D2  072CEB     RCALL PutPixel
3171:                                      PutPixel(xc,   yc+1);  
0068D4  90006E     MOV [W14+12], W0
0068D6  E80000     INC W0, W0
0068D8  780080     MOV W0, W1
0068DA  90005E     MOV [W14+10], W0
0068DC  072CE6     RCALL PutPixel
3172:                                      PutPixel(xc+1, yc);
0068DE  9000EE     MOV [W14+12], W1
0068E0  90005E     MOV [W14+10], W0
0068E2  E80000     INC W0, W0
0068E4  072CE2     RCALL PutPixel
3173:                                      PutPixel(xc+1, yc+1);  
0068E6  90006E     MOV [W14+12], W0
0068E8  E80000     INC W0, W0
0068EA  780080     MOV W0, W1
0068EC  90005E     MOV [W14+10], W0
0068EE  E80000     INC W0, W0
0068F0  072CDC     RCALL PutPixel
3174:                                  }
3175:                                  xc += 2;
0068F2  90005E     MOV [W14+10], W0
0068F4  E88000     INC2 W0, W0
0068F6  980750     MOV W0, [W14+10]
3176:                                              // Read 8 pixels from flash
3177:              
3178:                              // Read 8 pixels from flash
3179:                              if(mask == 0x80)
0068F8  9000FE     MOV [W14+14], W1
0068FA  200800     MOV #0x80, W0
0068FC  508F80     SUB W1, W0, [W15]
0068FE  3A0003     BRA NZ, 0x6906
3180:                                  mask = 0x01;
006900  200010     MOV #0x1, W0
006902  980770     MOV W0, [W14+14]
006904  370003     BRA 0x690C
3181:                              else
3182:                                  // Shift to the next pixel
3183:                                  mask <<= 1;
006906  90007E     MOV [W14+14], W0
006908  400000     ADD W0, W0, W0
00690A  980770     MOV W0, [W14+14]
3184:                          }
3185:                          tempFlashAddress += (addressOffset);
00691A  90082E     MOV [W14+20], W0
00691C  200001     MOV #0x0, W1
00691E  450500     ADD W10, W0, W10
006920  4D8581     ADDC W11, W1, W11
3186:                          yc+=2;
006922  90006E     MOV [W14+12], W0
006924  E88000     INC2 W0, W0
006926  980760     MOV W0, [W14+12]
3187:                      }
3188:                  }    
3189:              
3190:              }
006936  BE054F     MOV.D [--W15], W10
006938  BE044F     MOV.D [--W15], W8
00693A  FA8000     ULNK
00693C  060000     RETURN
3191:              
3192:              /*********************************************************************
3193:              * Function: void PutImage4BPP(SHORT left, SHORT top, FLASH_BYTE* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3194:              *
3195:              * PreCondition: none
3196:              *
3197:              * Input: left,top - left top image corner, image - image pointer,
3198:              *        stretch - image stretch factor
3199:              *        partialImage - partial image pointer
3200:              * Output: none
3201:              *
3202:              * Side Effects: none
3203:              *
3204:              * Overview: outputs 16 color image starting from left,top coordinates
3205:              *
3206:              * Note: image must be located in flash
3207:              *
3208:              ********************************************************************/
3209:                      #if (COLOR_DEPTH >= 4)
3210:              
3211:              /* */
3212:              void __attribute__((weak)) PutImage4BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3213:              {
3214:                  register FLASH_BYTE *flashAddress;
3215:                  WORD                sizeX, sizeY;
3216:                  register WORD       x, y;
3217:                  WORD                xc, yc;
3218:                  BYTE                temp = 0;
3219:                  WORD                pallete[16];
3220:                  WORD                counter;
3221:                  WORD                addressOffset = 0;
3222:                  BYTE                OffsetFlag = 0;
3223:              
3224:                  // Move pointer to size information
3225:                  flashAddress = image + 2;
3226:              
3227:                  // Read image size
3228:                  sizeY = *((FLASH_WORD *)flashAddress);
3229:                  flashAddress += 2;
3230:                  sizeX = *((FLASH_WORD *)flashAddress);
3231:                  flashAddress += 2;
3232:              
3233:                  // Read pallete
3234:                  for(counter = 0; counter < 16; counter++)
3235:                  {
3236:                      pallete[counter] = *((FLASH_WORD *)flashAddress);
3237:                      flashAddress += 2;
3238:                  }
3239:              
3240:                  if(pPartialImageData->width != 0)
3241:                  {
3242:                       WORD mod1 = (sizeX & 1);
3243:                       WORD mod2 = (pPartialImageData->width) & 1; 
3244:                       WORD mod3 = (pPartialImageData->xoffset) & 1; 
3245:              
3246:                       flashAddress += (pPartialImageData->yoffset)*((sizeX>>1)+mod1);
3247:                       flashAddress += ((pPartialImageData->xoffset)>>1);                
3248:              
3249:                       addressOffset = (sizeX>>1)+mod1;
3250:                       addressOffset -= ((pPartialImageData->width)>>1);
3251:                       addressOffset -= mod3;
3252:                       OffsetFlag = (mod3);
3253:              
3254:                        if(OffsetFlag == 0)
3255:                        {
3256:                          addressOffset -= mod2;
3257:                        }
3258:                       
3259:                       sizeY = pPartialImageData->height;
3260:                       sizeX = pPartialImageData->width;
3261:                       
3262:                  }
3263:              
3264:                  yc = top;
3265:              
3266:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
3267:                  if (stretch == IMAGE_NORMAL)
3268:                  {
3269:                      for(y = 0; y < sizeY; y++)
3270:                      {
3271:                          xc = left;
3272:                          temp = *flashAddress;
3273:                          flashAddress += OffsetFlag;
3274:              
3275:                          for(x = OffsetFlag; x < (sizeX+OffsetFlag); x++)
3276:                          {
3277:                              // Read 2 pixels from flash
3278:                              if(x & 0x01)
3279:                              {
3280:                              // second pixel in byte
3281:                              // Set color
3282:                              #ifdef USE_PALETTE
3283:                                  SetColor(temp >> 4);
3284:                              #else
3285:                                  SetColor(pallete[temp >> 4]);
3286:                              #endif
3287:                              }
3288:                              else
3289:                              {
3290:                                  temp = *flashAddress++;
3291:                              // first pixel in byte
3292:                              // Set color
3293:                              #ifdef USE_PALETTE
3294:                                  SetColor(temp & 0x0f);
3295:                              #else
3296:                                  SetColor(pallete[temp & 0x0f]);
3297:                              #endif
3298:                              }
3299:              
3300:                              #ifdef USE_TRANSPARENT_COLOR
3301:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3302:                              #endif
3303:                                      // Write pixel(s) to screen
3304:                                      PutPixel(xc, yc);
3305:                                      xc++;
3306:                          }  
3307:              
3308:                          flashAddress += addressOffset;
3309:                
3310:                          yc++;
3311:                      }
3312:              
3313:                  }
3314:                  else
3315:                  {
3316:                      for(y = 0; y < sizeY; y++)
3317:                      {
3318:                          xc = left;
3319:                          temp = *flashAddress;
3320:                          flashAddress += OffsetFlag;
3321:              
3322:                          for(x = OffsetFlag; x < (sizeX+OffsetFlag); x++)
3323:                          {
3324:              
3325:                             if(x & 0x01)
3326:                             {
3327:              
3328:                              // second pixel in byte
3329:                              // Set color
3330:                              #ifdef USE_PALETTE
3331:                                  SetColor(temp >> 4);
3332:                              #else
3333:                                  SetColor(pallete[temp >> 4]);
3334:                              #endif
3335:                              }
3336:                              else
3337:                              {
3338:                                  temp = *flashAddress++;
3339:              
3340:                              // first pixel in byte
3341:                              // Set color
3342:                              #ifdef USE_PALETTE
3343:                                  SetColor(temp & 0x0f);
3344:                              #else
3345:                                  SetColor(pallete[temp & 0x0f]);
3346:                              #endif
3347:                              }
3348:              
3349:                              #ifdef USE_TRANSPARENT_COLOR
3350:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3351:                              #endif
3352:                                  {
3353:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
3354:                                      PutPixel(xc,   yc);
3355:                                      PutPixel(xc,   yc+1);  
3356:                                      PutPixel(xc+1, yc);
3357:                                      PutPixel(xc+1, yc+1);  
3358:                                  }
3359:                                  xc += 2;
3360:                          }
3361:                          flashAddress += addressOffset;
3362:                          yc+=2;
3363:                      }
3364:                  }    
3365:              }
3366:                      #endif // #if (COLOR_DEPTH >= 4)
3367:              
3368:              /*********************************************************************
3369:              * Function: void PutImage8BPP(SHORT left, SHORT top, FLASH_BYTE* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3370:              *
3371:              * PreCondition: none
3372:              *
3373:              * Input: left,top - left top image corner, image - image pointer,
3374:              *        stretch - image stretch factor
3375:              *        partialImage - partial image pointer
3376:              * Output: none
3377:              *
3378:              * Side Effects: none
3379:              *
3380:              * Overview: outputs 256 color image starting from left,top coordinates
3381:              *
3382:              * Note: image must be located in flash
3383:              *
3384:              ********************************************************************/
3385:                      #if (COLOR_DEPTH >= 8)
3386:              
3387:              /* */
3388:              void __attribute__((weak)) PutImage8BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3389:              {
3390:                  register FLASH_BYTE *flashAddress;
3391:                  WORD                sizeX, sizeY;
3392:                  WORD                x, y;
3393:                  WORD                xc, yc;
3394:                  BYTE                temp;
3395:                  WORD                pallete[256];
3396:                  WORD                counter;
3397:                  WORD                addressOffset = 0;
3398:              
3399:                  // Move pointer to size information
3400:                  flashAddress = image + 2;
3401:              
3402:                  // Read image size
3403:                  sizeY = *((FLASH_WORD *)flashAddress);
3404:                  flashAddress += 2;
3405:                  sizeX = *((FLASH_WORD *)flashAddress);
3406:                  flashAddress += 2;
3407:              
3408:                  // Read pallete
3409:                  for(counter = 0; counter < 256; counter++)
3410:                  {
3411:                      pallete[counter] = *((FLASH_WORD *)flashAddress);
3412:                      flashAddress += 2;
3413:                  }
3414:              
3415:                  if(pPartialImageData->width != 0)
3416:                  {
3417:                       flashAddress += pPartialImageData->xoffset + pPartialImageData->yoffset*(sizeX);
3418:                       addressOffset = sizeX - pPartialImageData->width;
3419:                       sizeY = pPartialImageData->height;
3420:                       sizeX = pPartialImageData->width;
3421:                  }
3422:              
3423:                  yc = top;
3424:              
3425:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
3426:                  if (stretch == IMAGE_NORMAL)
3427:                  {
3428:                      for(y = 0; y < sizeY; y++)
3429:                      {
3430:                          xc = left;
3431:                          for(x = 0; x < sizeX; x++)
3432:                          {
3433:                              temp = *flashAddress++;
3434:              
3435:                              // Set color
3436:                              #ifdef USE_PALETTE
3437:                                  SetColor(temp);
3438:                              #else
3439:                                  SetColor(pallete[temp]);
3440:                              #endif
3441:              
3442:                              #ifdef USE_TRANSPARENT_COLOR
3443:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3444:                              #endif
3445:                                      // Write pixel(s) to screen
3446:                                      PutPixel(xc, yc);
3447:                                  xc++;
3448:                          }   
3449:                          flashAddress += addressOffset;         
3450:                          yc++;
3451:                      }
3452:                  }
3453:                  else
3454:                  {
3455:                      for(y = 0; y < sizeY; y++)
3456:                      {
3457:                          xc = left;
3458:                          for(x = 0; x < sizeX; x++)
3459:                          {
3460:                              temp = *flashAddress++;
3461:              
3462:                              // Set color
3463:                              #ifdef USE_PALETTE
3464:                                  SetColor(temp);
3465:                              #else
3466:                                  SetColor(pallete[temp]);
3467:                              #endif
3468:                  
3469:                              #ifdef USE_TRANSPARENT_COLOR
3470:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3471:                              #endif
3472:                                  {
3473:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
3474:                                      PutPixel(xc,   yc);
3475:                                      PutPixel(xc,   yc+1);  
3476:                                      PutPixel(xc+1, yc);
3477:                                      PutPixel(xc+1, yc+1);  
3478:                                  }
3479:                                  xc += 2;
3480:                          }    
3481:                          flashAddress += addressOffset;        
3482:                          yc+=2;
3483:                      }
3484:                  }    
3485:              
3486:              }
3487:                      #endif // #if (COLOR_DEPTH >= 8)
3488:              
3489:              /*********************************************************************
3490:              * Function: void PutImage16BPP(SHORT left, SHORT top, FLASH_BYTE* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3491:              *
3492:              * PreCondition: none
3493:              *
3494:              * Input: left,top - left top image corner, image - image pointer,
3495:              *        stretch - image stretch factor
3496:              *        partialImage - partial image pointer
3497:              * Output: none
3498:              *
3499:              * Side Effects: none
3500:              *
3501:              * Overview: outputs hicolor image starting from left,top coordinates
3502:              *
3503:              * Note: image must be located in flash
3504:              *
3505:              ********************************************************************/
3506:                      #if (COLOR_DEPTH == 16)
3507:              
3508:              /* */
3509:              void __attribute__((weak)) PutImage16BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3510:              {
3511:                  register FLASH_WORD *flashAddress;
3512:                  WORD                sizeX, sizeY;
3513:                  register WORD       x, y;
3514:                  WORD                xc, yc;
3515:                  WORD                temp;
3516:                  WORD                addressOffset = 0;
3517:              
3518:                  // Move pointer to size information
3519:                  flashAddress = (FLASH_WORD *)image + 1;
3520:              
3521:                  // Read image size
3522:                  sizeY = *flashAddress;
3523:                  flashAddress++;
3524:                  sizeX = *flashAddress;
3525:                  flashAddress++;
3526:                  
3527:                  if(pPartialImageData->width != 0)
3528:                  {
3529:                       flashAddress += pPartialImageData->xoffset + pPartialImageData->yoffset*(sizeX);
3530:                       addressOffset = sizeX - pPartialImageData->width;
3531:                       sizeY = pPartialImageData->height;
3532:                       sizeX = pPartialImageData->width;
3533:                  }
3534:              
3535:                  yc = top;
3536:              
3537:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
3538:                  if (stretch == IMAGE_NORMAL)
3539:                  {
3540:                      for(y = 0; y < sizeY; y++)
3541:                      {    
3542:                          xc = left;
3543:                          for(x = 0; x < sizeX; x++)
3544:                          {
3545:                              temp = *flashAddress++;
3546:                              SetColor(temp);
3547:              
3548:                              #ifdef USE_TRANSPARENT_COLOR
3549:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3550:                              #endif
3551:                                      // Write pixel(s) to screen
3552:                                      PutPixel(xc, yc);
3553:                                  xc++;
3554:                          }          
3555:                          flashAddress += addressOffset;  
3556:                          yc++;
3557:                      }
3558:                  }
3559:                  else
3560:                  {
3561:                      for(y = 0; y < sizeY; y++)
3562:                      {
3563:                          xc = left;
3564:                          for(x = 0; x < sizeX; x++)
3565:                          {
3566:                              
3567:                              temp = *flashAddress++;
3568:                              SetColor(temp);
3569:                  
3570:                              #ifdef USE_TRANSPARENT_COLOR
3571:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3572:                              #endif
3573:                                  {
3574:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
3575:                                      PutPixel(xc,   yc);
3576:                                      PutPixel(xc,   yc+1);  
3577:                                      PutPixel(xc+1, yc);
3578:                                      PutPixel(xc+1, yc+1);  
3579:                                  } 
3580:                                  xc += 2;   
3581:                          }      
3582:                          flashAddress += addressOffset;      
3583:                          yc+=2;
3584:                      }
3585:                  }    
3586:              
3587:              }
3588:              
3589:                      #endif //#if (COLOR_DEPTH == 16)
3590:                  #endif // #ifdef USE_BITMAP_FLASH
3591:              
3592:                  #ifdef USE_BITMAP_EXTERNAL
3593:              
3594:              /*********************************************************************
3595:              * Function: void PutImage1BPPExt(SHORT left, SHORT top, void* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3596:              *
3597:              * PreCondition: none
3598:              *
3599:              * Input: left,top - left top image corner, image - image pointer,
3600:              *        stretch - image stretch factor
3601:              *        partialImage - partial image pointer
3602:              * Output: none
3603:              *
3604:              * Side Effects: none
3605:              *
3606:              * Overview: outputs monochrome image starting from left,top coordinates
3607:              *
3608:              * Note: image must be located in external memory
3609:              *
3610:              ********************************************************************/
3611:              void __attribute__((weak)) PutImage1BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3612:              {
3613:                  register DWORD  memOffset;
3614:                  BITMAP_HEADER   bmp;
3615:                  WORD            pallete[2];
3616:                  BYTE            lineBuffer[((GetMaxX() + 1) / 8) + 1];
3617:                  BYTE            *pData;
3618:                  SHORT           byteWidth;
3619:              
3620:                  BYTE            temp = 0;
3621:                  BYTE            mask;
3622:                  WORD            sizeX, sizeY, lineLength;
3623:                  WORD            x, y;
3624:                  WORD            xc, yc;
3625:                  BYTE                OffsetFlag = 0x01;     //Offset from BYTE color bit0 for the partial image 
3626:              
3627:                  // Get image header
3628:                  ExternalMemoryCallback(image, 0, sizeof(BITMAP_HEADER), &bmp);
3629:              
3630:                  // Get pallete (2 entries)
3631:                  ExternalMemoryCallback(image, sizeof(BITMAP_HEADER), 2 * sizeof(WORD), pallete);
3632:              
3633:                  // Set offset to the image data
3634:                  memOffset = sizeof(BITMAP_HEADER) + 2 * sizeof(WORD);
3635:              
3636:                  // Line width in bytes
3637:                  byteWidth = (bmp.width >> 3);
3638:                  if(bmp.width & 0x07)
3639:                      byteWidth++;
3640:              
3641:                  if(pPartialImageData->width != 0)
3642:                  {
3643:              
3644:                       memOffset += pPartialImageData->yoffset*byteWidth;
3645:                       memOffset += (pPartialImageData->xoffset)>>3;
3646:              
3647:                       OffsetFlag <<= ((pPartialImageData->xoffset) & 0x07);
3648:              
3649:                       sizeY = pPartialImageData->height;
3650:                       sizeX = pPartialImageData->width;
3651:                  }
3652:                  else
3653:                  {
3654:                      // Get size
3655:                      sizeX = bmp.width;
3656:                      sizeY = bmp.height;
3657:                  }
3658:              
3659:                  // calculate the length of bytes needed per line
3660:                  lineLength = (sizeX >> 3) + 1;
3661:                  if (sizeX & 0x07)
3662:                      lineLength++;
3663:                  
3664:                  yc = top;
3665:                  
3666:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
3667:                  if (stretch == IMAGE_NORMAL)
3668:                  {
3669:                      for(y = 0; y < sizeY; y++)
3670:                      {
3671:                          // Get line
3672:                          ExternalMemoryCallback(image, memOffset, lineLength, lineBuffer);
3673:                          memOffset += byteWidth;
3674:                          
3675:                          pData = lineBuffer;
3676:                          mask = OffsetFlag;
3677:                          temp = *pData++;
3678:                          xc = left;
3679:                          for(x = 0; x < sizeX; x++)
3680:                          {
3681:                                  // Set color
3682:                                  if(mask & temp)
3683:                                  {
3684:                                      // Set color
3685:                                      #ifdef USE_PALETTE
3686:                                          SetColor(1);
3687:                                      #else
3688:                                          SetColor(pallete[1]);
3689:                                      #endif
3690:                                  }
3691:                                  else
3692:                                  {
3693:                                      // Set color
3694:                                      #ifdef USE_PALETTE
3695:                                          SetColor(0);
3696:                                      #else
3697:                                          SetColor(pallete[0]);
3698:                                      #endif
3699:                                  }
3700:              
3701:              
3702:                              #ifdef USE_TRANSPARENT_COLOR
3703:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3704:                              #endif
3705:                                      // Write pixel(s) to screen
3706:                                      PutPixel(xc, yc);
3707:                                  xc++;
3708:              
3709:                              // Read 8 pixels from flash
3710:                              if(mask == 0x80)
3711:                              {
3712:                                  temp = *pData++;
3713:                                  mask = 0x01;
3714:                              }
3715:                              else
3716:                              {
3717:                                  // Shift to the next pixel
3718:                                  mask <<= 1;
3719:                              }    
3720:                          }            
3721:                          yc++;
3722:                      }
3723:                  }
3724:                  else
3725:                  {
3726:                      for(y = 0; y < sizeY; y++)
3727:                      {
3728:                          // Get line
3729:                          ExternalMemoryCallback(image, memOffset, lineLength, lineBuffer);
3730:                          memOffset += byteWidth;
3731:                          
3732:                          pData = lineBuffer;
3733:                          mask = OffsetFlag;
3734:                          temp = *pData++;
3735:                          xc = left;
3736:              
3737:                          for(x = 0; x < sizeX; x++)
3738:                          {
3739:                                  // Set color
3740:                                  if(mask & temp)
3741:                                  {
3742:                                      // Set color
3743:                                      #ifdef USE_PALETTE
3744:                                          SetColor(1);
3745:                                      #else
3746:                                          SetColor(pallete[1]);
3747:                                      #endif
3748:                                  }
3749:                                  else
3750:                                  {
3751:                                      // Set color
3752:                                      #ifdef USE_PALETTE
3753:                                          SetColor(0);
3754:                                      #else
3755:                                          SetColor(pallete[0]);
3756:                                      #endif
3757:                                  }
3758:              
3759:                  
3760:                              #ifdef USE_TRANSPARENT_COLOR
3761:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3762:                              #endif
3763:                                  {
3764:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
3765:                                      PutPixel(xc,   yc);
3766:                                      PutPixel(xc,   yc+1);  
3767:                                      PutPixel(xc+1, yc);
3768:                                      PutPixel(xc+1, yc+1);  
3769:                                  }
3770:                                  xc += 2;
3771:              
3772:                              // Read 8 pixels from flash
3773:                              if(mask == 0x80)
3774:                              {
3775:                                  temp = *pData++;
3776:                                  mask = 0x01;
3777:                              }
3778:                              else
3779:                              {
3780:                                  // Shift to the next pixel
3781:                                  mask <<= 1;
3782:                              }  
3783:              
3784:                          }            
3785:                          yc+=2;
3786:                      }
3787:                  }    
3788:              
3789:              }
3790:              
3791:              /*********************************************************************
3792:              * Function: void PutImage4BPPExt(SHORT left, SHORT top, void* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3793:              *
3794:              * PreCondition: none
3795:              *
3796:              * Input: left,top - left top image corner, image - image pointer,
3797:              *        stretch - image stretch factor
3798:              *        partialImage - partial image pointer
3799:              * Output: none
3800:              *
3801:              * Side Effects: none
3802:              *
3803:              * Overview: outputs monochrome image starting from left,top coordinates
3804:              *
3805:              * Note: image must be located in external memory
3806:              *
3807:              ********************************************************************/
3808:                      #if (COLOR_DEPTH >= 4)
3809:              
3810:              /* */
3811:              void __attribute__((weak)) PutImage4BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
3812:              {
3813:                  register DWORD  memOffset;
3814:                  BITMAP_HEADER   bmp;
3815:                  WORD            pallete[16];
3816:                  BYTE            lineBuffer[((GetMaxX() + 1) / 2) + 1];
3817:                  BYTE            *pData;
3818:                  SHORT           byteWidth;
3819:              
3820:                  BYTE            temp = 0;
3821:                  WORD            sizeX, sizeY, lineLength;
3822:                  WORD            x, y;
3823:                  WORD            xc, yc;
3824:                  WORD            nibbleOffset = 0; 
3825:              
3826:              
3827:                  // Get image header
3828:                  ExternalMemoryCallback(image, 0, sizeof(BITMAP_HEADER), &bmp);
3829:              
3830:                  // Get pallete (16 entries)
3831:                  ExternalMemoryCallback(image, sizeof(BITMAP_HEADER), 16 * sizeof(WORD), pallete);
3832:              
3833:                  // Set offset to the image data
3834:                  memOffset = sizeof(BITMAP_HEADER) + 16 * sizeof(WORD);
3835:              
3836:                   // Line width in bytes
3837:                  byteWidth = (bmp.width) >> 1;
3838:              
3839:                  // if the width is odd, add another byte count since the shift 1 caused
3840:                  // us to loose a nibble
3841:                  if(bmp.width & 0x01)
3842:                      byteWidth++;
3843:              
3844:                  if(pPartialImageData->width != 0)
3845:                  {
3846:                      // check the bit position of the starting pixel
3847:                      nibbleOffset = pPartialImageData->xoffset & 0x01;
3848:              
3849:                      memOffset += (pPartialImageData->yoffset)*byteWidth;
3850:                      memOffset += (pPartialImageData->xoffset) >> 1;
3851:              
3852:                      sizeY = pPartialImageData->height;
3853:                      sizeX = pPartialImageData->width;
3854:                  }
3855:                  else
3856:                  {
3857:                      // Get size
3858:                      sizeX = bmp.width;
3859:                      sizeY = bmp.height;
3860:                  }
3861:              
3862:                  // calculate the length of bytes needed per line
3863:                  lineLength = (sizeX >> 1) + 1;
3864:                  if (sizeX & 0x01)
3865:                      lineLength++;
3866:              
3867:                  yc = top;
3868:              
3869:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
3870:                  if (stretch == IMAGE_NORMAL)
3871:                  {
3872:                      for(y = 0; y < sizeY; y++)
3873:                      {
3874:                          // Get line
3875:                          ExternalMemoryCallback(image, memOffset, lineLength, lineBuffer);
3876:                          memOffset += byteWidth;
3877:                          
3878:                          pData = lineBuffer;
3879:                          if (nibbleOffset)
3880:                          {
3881:                              temp = *pData++;
3882:                          }
3883:                          
3884:                          xc = left;
3885:                          for(x = nibbleOffset; x < (sizeX + nibbleOffset); x++)
3886:                          {
3887:                              
3888:                              // Read 2 pixels from flash
3889:                              if(x & 0x0001)
3890:                              {
3891:              
3892:                                  // second pixel in byte
3893:                                  // Set color
3894:                                  #ifdef USE_PALETTE
3895:                                      SetColor(temp >> 4);
3896:                                  #else
3897:                                      SetColor(pallete[temp >> 4]);
3898:                                  #endif
3899:                              }
3900:                              else
3901:                              {
3902:                                  temp = *pData++;
3903:              
3904:                                  // first pixel in byte
3905:                                  // Set color
3906:                                  #ifdef USE_PALETTE
3907:                                      SetColor(temp & 0x0f);
3908:                                  #else
3909:                                      SetColor(pallete[temp & 0x0f]);
3910:                                  #endif
3911:                              }
3912:              
3913:                              #ifdef USE_TRANSPARENT_COLOR
3914:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3915:                              #endif
3916:                                      // Write pixel(s) to screen
3917:                                      PutPixel(xc, yc);
3918:                                  xc++;
3919:                          }            
3920:                          yc++;
3921:                      }
3922:                  }
3923:                  else
3924:                  {
3925:                      for(y = 0; y < sizeY; y++)
3926:                      {
3927:                          // Get line
3928:                          ExternalMemoryCallback(image, memOffset, lineLength, lineBuffer);
3929:                          memOffset += byteWidth;
3930:                          
3931:                          pData = lineBuffer;
3932:                          if (nibbleOffset)
3933:                          {
3934:                              temp = *pData++;
3935:                          }
3936:                          
3937:                          xc = left;
3938:                          for(x = nibbleOffset; x < (sizeX + nibbleOffset); x++)
3939:                          {
3940:              
3941:                              // Read 2 pixels from flash
3942:                              if(x & 0x0001)
3943:                              {
3944:              
3945:                                  // second pixel in byte
3946:                                  // Set color
3947:                                  #ifdef USE_PALETTE
3948:                                      SetColor(temp >> 4);
3949:                                  #else
3950:                                      SetColor(pallete[temp >> 4]);
3951:                                  #endif
3952:                              }
3953:                              else
3954:                              {
3955:                                  temp = *pData++;
3956:              
3957:                                  // first pixel in byte
3958:                                  // Set color
3959:                                  #ifdef USE_PALETTE
3960:                                      SetColor(temp & 0x0f);
3961:                                  #else
3962:                                      SetColor(pallete[temp & 0x0f]);
3963:                                  #endif
3964:                              }
3965:              
3966:                              #ifdef USE_TRANSPARENT_COLOR
3967:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
3968:                              #endif
3969:                                  {    
3970:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
3971:                                      PutPixel(xc,   yc);
3972:                                      PutPixel(xc,   yc+1);  
3973:                                      PutPixel(xc+1, yc);
3974:                                      PutPixel(xc+1, yc+1);  
3975:                                  }
3976:                                  xc += 2;
3977:                          }            
3978:                          yc+=2;
3979:                      }
3980:                  }    
3981:              }
3982:              
3983:                      #endif
3984:              
3985:              /*********************************************************************
3986:              * Function: void PutImage8BPPExt(SHORT left, SHORT top, void* image, BYTE stretch, PUTIMAGE_PARAM *partialImageData)
3987:              *
3988:              * PreCondition: none
3989:              *
3990:              * Input: left,top - left top image corner, image - image pointer,
3991:              *        stretch - image stretch factor
3992:              *        partialImage - partial image pointer
3993:              * Output: none
3994:              *
3995:              * Side Effects: none
3996:              *
3997:              * Overview: outputs monochrome image starting from left,top coordinates
3998:              *
3999:              * Note: image must be located in external memory
4000:              *
4001:              ********************************************************************/
4002:                      #if (COLOR_DEPTH >= 8)
4003:              
4004:              /* */
4005:              void __attribute__((weak)) PutImage8BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
4006:              {
4007:                  register DWORD  memOffset;
4008:                  BITMAP_HEADER   bmp;
4009:                  WORD            pallete[256];
4010:                  BYTE            lineBuffer[(GetMaxX() + 1)];
4011:                  BYTE            *pData;
4012:              
4013:                  BYTE            temp;
4014:                  WORD            sizeX, sizeY;
4015:                  WORD            x, y;
4016:                  WORD            xc, yc;
4017:              
4018:                  // Get image header
4019:                  ExternalMemoryCallback(image, 0, sizeof(BITMAP_HEADER), &bmp);
4020:              
4021:                  // Get pallete (256 entries)
4022:                  ExternalMemoryCallback(image, sizeof(BITMAP_HEADER), 256 * sizeof(WORD), pallete);
4023:              
4024:                  // Set offset to the image data
4025:                  memOffset = sizeof(BITMAP_HEADER) + 256 * sizeof(WORD);
4026:              
4027:                  if(pPartialImageData->width != 0)
4028:                  {
4029:                       memOffset += pPartialImageData->xoffset + pPartialImageData->yoffset*(bmp.width);
4030:                       sizeY = pPartialImageData->height;
4031:                       sizeX = pPartialImageData->width;
4032:                  }
4033:                  else
4034:                  {
4035:                      // Get size
4036:                      sizeX = bmp.width;
4037:                      sizeY = bmp.height;
4038:                  }
4039:              
4040:                  yc = top;
4041:              
4042:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
4043:                  if (stretch == IMAGE_NORMAL)
4044:                  {
4045:                      for(y = 0; y < sizeY; y++)
4046:                      {
4047:                          // Get line
4048:                          ExternalMemoryCallback(image, memOffset, sizeX, lineBuffer);
4049:                          memOffset += bmp.width;
4050:                          
4051:                          pData = lineBuffer;
4052:                          
4053:                          xc = left;
4054:                          for(x = 0; x < sizeX; x++)
4055:                          {
4056:                              temp = *pData++;
4057:                              
4058:                              // Set color
4059:                              #ifdef USE_PALETTE
4060:                                  SetColor(temp);
4061:                              #else
4062:                                  SetColor(pallete[temp]);
4063:                              #endif
4064:              
4065:                              #ifdef USE_TRANSPARENT_COLOR
4066:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
4067:                              #endif
4068:                                      // Write pixel(s) to screen
4069:                                      PutPixel(xc, yc);
4070:                                  xc++;
4071:                          }            
4072:                          yc++;
4073:                      }
4074:                  }
4075:                  else
4076:                  {
4077:                      for(y = 0; y < sizeY; y++)
4078:                      {
4079:                          // Get line
4080:                          ExternalMemoryCallback(image, memOffset, sizeX, lineBuffer);
4081:                          memOffset += bmp.width;
4082:                          
4083:                          pData = lineBuffer;
4084:                          
4085:                          xc = left;
4086:                          for(x = 0; x < sizeX; x++)
4087:                          {
4088:                              temp = *pData++;
4089:              
4090:                              // Set color
4091:                              #ifdef USE_PALETTE
4092:                                  SetColor(temp);
4093:                              #else
4094:                                  SetColor(pallete[temp]);
4095:                              #endif
4096:                  
4097:                              #ifdef USE_TRANSPARENT_COLOR
4098:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
4099:                              #endif
4100:                                  {
4101:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
4102:                                      PutPixel(xc,   yc);
4103:                                      PutPixel(xc,   yc+1);  
4104:                                      PutPixel(xc+1, yc);
4105:                                      PutPixel(xc+1, yc+1);  
4106:                                  }
4107:                                  xc += 2;
4108:                          }            
4109:                          yc+=2;
4110:                      }
4111:                  }    
4112:              
4113:              }
4114:              
4115:                      #endif
4116:              
4117:              /*********************************************************************
4118:              * Function: void PutImage16BPPExt(SHORT left, SHORT top, void* image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
4119:              *
4120:              * PreCondition: none
4121:              *
4122:              * Input: left,top - left top image corner, image - image pointer,
4123:              *        stretch - image stretch factor
4124:              *        partialImage - partial image pointer
4125:              * Output: none
4126:              *
4127:              * Side Effects: none
4128:              *
4129:              * Overview: outputs monochrome image starting from left,top coordinates
4130:              *
4131:              * Note: image must be located in external memory
4132:              *
4133:              ********************************************************************/
4134:                      #if (COLOR_DEPTH == 16)
4135:              
4136:              /* */
4137:              void __attribute__((weak)) PutImage16BPPExt(SHORT left, SHORT top, void *image, BYTE stretch, PUTIMAGE_PARAM *pPartialImageData)
4138:              {
4139:                  register DWORD  memOffset;
4140:                  BITMAP_HEADER   bmp;
4141:                  WORD            lineBuffer[(GetMaxX() + 1)];
4142:                  WORD            *pData;
4143:                  WORD            byteWidth;
4144:              
4145:                  WORD            temp;
4146:                  WORD            sizeX, sizeY;
4147:                  WORD            x, y;
4148:                  WORD            xc, yc;
4149:              
4150:                  // Get image header
4151:                  ExternalMemoryCallback(image, 0, sizeof(BITMAP_HEADER), &bmp);
4152:              
4153:                  // Set offset to the image data
4154:                  memOffset = sizeof(BITMAP_HEADER);
4155:              
4156:                  if(pPartialImageData->width != 0)
4157:                  {
4158:                       memOffset += (pPartialImageData->xoffset + pPartialImageData->yoffset*(bmp.width))<<1;
4159:                       sizeY = pPartialImageData->height;
4160:                       sizeX = pPartialImageData->width;
4161:                  }
4162:                  else
4163:                  {
4164:                      // Get size
4165:                      sizeX = bmp.width;
4166:                      sizeY = bmp.height;
4167:                  }
4168:              
4169:                  byteWidth = bmp.width << 1;
4170:                  yc = top;
4171:              
4172:                  // Note: For speed the code for loops are repeated. A small code size increase for performance
4173:                  if (stretch == IMAGE_NORMAL)
4174:                  {
4175:                      for(y = 0; y < sizeY; y++)
4176:                      {
4177:                          // Get line
4178:                          ExternalMemoryCallback(image, memOffset, byteWidth, lineBuffer);
4179:                          memOffset += byteWidth;
4180:                          
4181:                          pData = lineBuffer;
4182:                          
4183:                          xc = left;
4184:                          for(x = 0; x < sizeX; x++)
4185:                              {
4186:                              temp = *pData++;
4187:                              SetColor(temp);
4188:              
4189:                              #ifdef USE_TRANSPARENT_COLOR
4190:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
4191:                              #endif
4192:                                      // Write pixel(s) to screen
4193:                                      PutPixel(xc, yc);
4194:                                  xc++;
4195:                          }            
4196:                          yc++;
4197:                      }
4198:                  }
4199:                  else
4200:                  {
4201:                      for(y = 0; y < sizeY; y++)
4202:                      {
4203:                          // Get line
4204:                          ExternalMemoryCallback(image, memOffset, byteWidth, lineBuffer);
4205:                          memOffset += byteWidth;
4206:                          pData = lineBuffer;
4207:                          
4208:                          xc = left;
4209:                          for(x = 0; x < sizeX; x++)
4210:                              {
4211:                              temp = *pData++;
4212:                              SetColor(temp);
4213:                  
4214:                              #ifdef USE_TRANSPARENT_COLOR
4215:                                  if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
4216:                              #endif
4217:                                  {
4218:                                      // Write pixel(s) to screen, basically writes a tile of 2x2 pixels to the screen
4219:                                      PutPixel(xc,   yc);
4220:                                      PutPixel(xc,   yc+1);  
4221:                                      PutPixel(xc+1, yc);
4222:                                      PutPixel(xc+1, yc+1);  
4223:                                  }
4224:                                  xc += 2;
4225:                          }            
4226:                          yc+=2;
4227:                      }
4228:                  }    
4229:              }
4230:              
4231:                      #endif
4232:                  #endif
4233:              
4234:              
4235:              /*********************************************************************
4236:              * Function: WORD PutImagePartial(SHORT left, SHORT top, void* image, BYTE stretch, SHORT xoffset, SHORT yoffset, WORD width, WORD height)
4237:              *
4238:              * Overview: This function outputs a full or a partial image starting 
4239:              *           from left,top coordinates. The partial image starts at 
4240:              *           xoffset and yoffset and is given a width and height.
4241:              *
4242:              * Input: left - horizontal starting position of full or partial image on the screen
4243:              *        top - vertical starting position of full or partial image on the screen,
4244:              *        image - pointer to the image location.
4245:              *        stretch - The image stretch factor. 
4246:              *                  - IMAGE_NORMAL : no stretch 
4247:              *                  - IMAGE_X2 : image is stretched to twice 
4248:              *                    its width and height
4249:              *        xoffset  Specifies the horizontal offset in pixels of the selected partial 
4250:              *                  image from the left most pixel of the full image.
4251:              *        yoffset  Specifies the vertical offset in pixels of the selected partial 
4252:              *                  image from the top most pixel of the full image.
4253:              *        width - width of the partial image to be rendered. 
4254:              *                xoffset + width must not exceed the full image width. 
4255:              *        height - height of the partial image to be rendered. 
4256:              *                 yoffset + height must not exceed the full image height.
4257:              *
4258:              * Output: For NON-Blocking configuration:
4259:              *         - Returns 0 when device is busy and the image is not 
4260:              *           yet completely drawn.
4261:              *         - Returns 1 when the image is completely drawn.
4262:              *         For Blocking configuration:
4263:              *         - Always return 1.
4264:              * 
4265:              * Side Effects: none
4266:              ********************************************************************/
4267:              WORD PutImagePartial(SHORT left, SHORT top, void *image, BYTE stretch, SHORT xoffset, SHORT yoffset, WORD width, WORD height)
4268:              {
00693E  FA0022     LNK #0x22
006940  980F10     MOV W0, [W14+18]
006942  980F21     MOV W1, [W14+20]
006944  980F32     MOV W2, [W14+22]
006946  985F03     MOV.B W3, [W14+24]
006948  980F54     MOV W4, [W14+26]
00694A  980F65     MOV W5, [W14+28]
00694C  980F76     MOV W6, [W14+30]
00694E  981707     MOV W7, [W14+32]
4269:              
4270:                 PUTIMAGE_PARAM partialImage;
4271:              
4272:              #if defined (USE_BITMAP_FLASH)
4273:                  FLASH_BYTE  *flashAddress;
4274:              #endif    
4275:              #if defined (USE_BITMAP_FLASH) || defined (USE_BITMAP_EXTERNAL)
4276:                  BYTE        colorDepth;
4277:              #endif
4278:                  WORD        colorTemp;
4279:                  WORD        resType;
4280:              
4281:              #if defined(USE_COMP_RLE) 
4282:                  GFX_IMAGE_HEADER *pimghdr = (GFX_IMAGE_HEADER *)image;
4283:              #endif
4284:                  
4285:              #ifndef USE_NONBLOCKING_CONFIG
4286:                  while(IsDeviceBusy() != 0) Nop();
006950  370001     BRA 0x6954
006952  000000     NOP
006954  072CDE     RCALL IsDeviceBusy
006956  500FE0     SUB W0, #0x0, [W15]
006958  3AFFFC     BRA NZ, 0x6952
4287:              
4288:                  /* Ready */
4289:              #else
4290:                  if(IsDeviceBusy() != 0)
4291:                      return (0);
4292:              #endif
4293:              
4294:                  // Save current color
4295:                  colorTemp = GetColor();
00695A  BFD13E     MOV.B _color, WREG
00695C  FB8000     ZE W0, W0
00695E  780F00     MOV W0, [W14]
4296:                  resType = *((WORD *)image);
006960  90083E     MOV [W14+22], W0
006962  780090     MOV [W0], W1
006964  980711     MOV W1, [W14+2]
4297:              
4298:                  // Store the partial image offset
4299:                  partialImage.xoffset = xoffset;
006966  90095E     MOV [W14+26], W2
006968  980772     MOV W2, [W14+14]
4300:                  partialImage.yoffset = yoffset;
00696A  9009EE     MOV [W14+28], W3
00696C  980F03     MOV W3, [W14+16]
4301:                  partialImage.width   = width;
00696E  90087E     MOV [W14+30], W0
006970  980750     MOV W0, [W14+10]
4302:                  partialImage.height = height;
006972  90108E     MOV [W14+32], W1
006974  980761     MOV W1, [W14+12]
4303:              
4304:                  switch(resType & (GFX_MEM_MASK | GFX_COMP_MASK))
006976  90009E     MOV [W14+2], W1
006978  2F00F0     MOV #0xF00F, W0
00697A  608000     AND W1, W0, W0
00697C  500FE0     SUB W0, #0x0, [W15]
00697E  3A001F     BRA NZ, 0x69BE
4305:                  {
4306:              
4307:                              #ifdef USE_COMP_RLE
4308:                              #ifdef USE_BITMAP_FLASH
4309:                      case (FLASH | COMP_RLE):
4310:                          
4311:                          // Image address
4312:                          flashAddress = pimghdr->LOCATION.progByteAddress;
4313:                          // Read color depth
4314:                          colorDepth = pimghdr->colorDepth;
4315:                      
4316:                          // Draw picture
4317:                          switch(colorDepth)
4318:                          {
4319:                                  #if (COLOR_DEPTH >= 4)
4320:                              case 4: 
4321:                                  PutImageRLE4BPP(left, top, flashAddress, stretch); break;
4322:                                  #endif
4323:                
4324:                                  #if (COLOR_DEPTH >= 8)
4325:                              case 8: 
4326:                                  PutImageRLE8BPP(left, top, flashAddress, stretch); break;
4327:                                  #endif
4328:                                      
4329:                                  default:    break;
4330:                          }
4331:                          break;
4332:                              #endif //#ifdef USE_BITMAP_FLASH
4333:              
4334:                              #ifdef USE_BITMAP_EXTERNAL
4335:                      case (EXTERNAL | COMP_RLE):
4336:                      
4337:                          // Get color depth
4338:                          ExternalMemoryCallback(image, 1, 1, &colorDepth);
4339:                  
4340:                          // Draw picture
4341:                          switch(colorDepth)
4342:                          {
4343:                                  #if (COLOR_DEPTH >= 4)
4344:                              case 4:     
4345:                                  PutImageRLE4BPPExt(left, top, image, stretch); break;
4346:                                  #endif
4347:                                          
4348:                                  #if (COLOR_DEPTH >= 8)
4349:                              case 8:     
4350:                                  PutImageRLE8BPPExt(left, top, image, stretch); break;
4351:                                  #endif
4352:                                          
4353:                              default:    break;
4354:                          }
4355:                          break;
4356:                              #endif //#ifdef USE_BITMAP_EXTERNAL
4357:                              #endif // #ifdef USE_COMP_RLE
4358:                      
4359:                              #ifdef USE_BITMAP_FLASH
4360:              
4361:                      case (FLASH | COMP_NONE):
4362:              
4363:                          // Image address
4364:                          flashAddress = ((IMAGE_FLASH *)image)->address;
006980  90083E     MOV [W14+22], W0
006982  E88100     INC2 W0, W2
006984  BE0112     MOV.D [W2], W2
006986  4700E4     ADD W14, #0x4, W1
006988  BE8882     MOV.D W2, [W1]
4365:              
4366:                          // Read color depth
4367:                          colorDepth = *(flashAddress + 1);
00698A  4701E4     ADD W14, #0x4, W3
00698C  BE0013     MOV.D [W3], W0
00698E  400061     ADD W0, #0x1, W0
006990  4880E0     ADDC W1, #0x0, W1
006992  8001A2     MOV PSVPAG, W2
006994  A4F000     BTSTS.C W0, #15
006996  D28081     RLC W1, W1
006998  8801A1     MOV W1, PSVPAG
00699A  784010     MOV.B [W0], W0
00699C  8801A2     MOV W2, PSVPAG
00699E  984F00     MOV.B W0, [W14+8]
4368:              
4369:                          // Draw picture
4370:                          switch(colorDepth)
0069A0  90480E     MOV.B [W14+8], W0
0069A2  FB8000     ZE W0, W0
0069A4  500FE1     SUB W0, #0x1, [W15]
0069A6  320001     BRA Z, 0x69AA
4371:                          {
4372:                              case 1:     
4373:                                  PutImage1BPP(left, top, flashAddress, stretch, &partialImage); break;
0069AA  47006A     ADD W14, #0xA, W0
0069AC  780280     MOV W0, W5
0069AE  905A0E     MOV.B [W14+24], W4
0069B0  470064     ADD W14, #0x4, W0
0069B2  BE0110     MOV.D [W0], W2
0069B4  9008AE     MOV [W14+20], W1
0069B6  90081E     MOV [W14+18], W0
0069B8  07FE87     RCALL PutImage1BPP
0069BA  000000     NOP
4374:                              
4375:                                  #if (COLOR_DEPTH >= 4)
4376:                              case 4:     
4377:                                  PutImage4BPP(left, top, flashAddress, stretch, &partialImage); break;
4378:                                  #endif
4379:                                  
4380:                                  #if (COLOR_DEPTH >= 8)
4381:                              case 8:     
4382:                                  PutImage8BPP(left, top, flashAddress, stretch, &partialImage); break;
4383:                                  #endif
4384:                                  
4385:                                  #if (COLOR_DEPTH == 16)
4386:                              case 16:    
4387:                                  PutImage16BPP(left, top, flashAddress, stretch, &partialImage); break;
4388:                                  #endif
4389:                                  
4390:                              default:    break;
0069A8  370009     BRA 0x69BC
4391:              
4392:                          }
4393:              
4394:                          break;
0069BC  370001     BRA 0x69C0
4395:                              #endif // #ifdef USE_BITMAP_FLASH
4396:                              
4397:                              #ifdef USE_BITMAP_EXTERNAL
4398:              
4399:                      case (EXTERNAL | COMP_NONE):
4400:              
4401:                          // Get color depth
4402:                          ExternalMemoryCallback(image, 1, 1, &colorDepth);
4403:              
4404:                          // Draw picture
4405:                          switch(colorDepth)
4406:                          {
4407:                              case 1:     
4408:                                  PutImage1BPPExt(left, top, image, stretch, &partialImage); break;
4409:                              
4410:                                  #if (COLOR_DEPTH >= 4)
4411:                              case 4:     
4412:                                  PutImage4BPPExt(left, top, image, stretch, &partialImage); break;
4413:                                  #endif
4414:                                  
4415:                                  #if (COLOR_DEPTH >= 8)
4416:                              case 8:     
4417:                                  PutImage8BPPExt(left, top, image, stretch, &partialImage); break;
4418:                                  #endif
4419:                                  
4420:                                  #if (COLOR_DEPTH == 16)
4421:                              case 16:    
4422:                                  PutImage16BPPExt(left, top, image, stretch, &partialImage); break;
4423:                                  #endif
4424:                                  
4425:                              default:    break;
4426:                          }
4427:              
4428:                          break;
4429:                              #endif //#ifdef USE_BITMAP_EXTERNAL
4430:              
4431:                              #if defined (GFX_USE_DISPLAY_CONTROLLER_MCHP_DA210)
4432:                              #ifdef USE_COMP_IPU
4433:                      case (FLASH | COMP_IPU):
4434:                      case (EXTERNAL | COMP_IPU):
4435:                      case (EDS_EPMP | COMP_IPU):
4436:                              #endif // #ifdef USE_COMP_IPU
4437:                      case (EDS_EPMP | COMP_NONE):
4438:                      
4439:                          // this requires special processing of images in Extended Data Space
4440:                          // call the driver specific function to perform the processing
4441:                          PutImageDrv(left, top, image, stretch, &partialImage); 
4442:                          break;
4443:              
4444:                              #endif //#if defined (__PIC24FJ256DA210__)
4445:                          
4446:                      default:
4447:                          break;
0069BE  000000     NOP
4448:                  }
4449:              
4450:                  // Restore current color
4451:                  SetColor(colorTemp);
0069C0  78001E     MOV [W14], W0
0069C2  784000     MOV.B W0, W0
0069C4  B7F13E     MOV.B WREG, _color
4452:                  return (1);
0069C6  200010     MOV #0x1, W0
4453:              }
0069C8  FA8000     ULNK
0069CA  060000     RETURN
4454:              
4455:              
4456:              /*********************************************************************
4457:              * Function:  SHORT GetSineCosine(SHORT v, WORD type)
4458:              *
4459:              * PreCondition: none
4460:              *
4461:              * Input: v - the angle used to calculate the sine or cosine value. 
4462:              *			 The angle must be in the range of -360 to 360 degrees.
4463:              *		 type - sets if the angle calculation is for a sine or cosine
4464:              *				- GETSINE (0) - get the value of sine(v).
4465:              *				- GETCOSINE (1) - return the value of cosine(v).
4466:              *
4467:              * Output: Returns the sine or cosine of the angle given.
4468:              *
4469:              * Side Effects: none
4470:              *
4471:              * Overview: This calculates the sine or cosine value of the given angle.
4472:              *
4473:              * Note: none
4474:              *
4475:              ********************************************************************/
4476:              SHORT GetSineCosine(SHORT v, WORD type)
4477:              {
0069CC  FA0004     LNK #0x4
0069CE  780F00     MOV W0, [W14]
0069D0  980711     MOV W1, [W14+2]
4478:              	// if angle is neg, convert to pos equivalent
4479:                  if (v < 0) 
0069D2  78001E     MOV [W14], W0
0069D4  500FE0     SUB W0, #0x0, [W15]
0069D6  3D0002     BRA GE, 0x69DC
4480:                  	v += 360;   					
0069D8  201680     MOV #0x168, W0
0069DA  400F1E     ADD W0, [W14], [W14]
4481:                  //v /= DEGREECOUNT;                 // convert into ticks from degrees, tick = 3 deg
4482:                         
4483:                  if(v >= COSINETABLEENTRIES * 3)
0069DC  2010D0     MOV #0x10D, W0
0069DE  78009E     MOV [W14], W1
0069E0  508F80     SUB W1, W0, [W15]
0069E2  340013     BRA LE, 0x6A0A
4484:                  {
4485:                      v -= COSINETABLEENTRIES * 3;
0069E4  2FEF20     MOV #0xFEF2, W0
0069E6  400F1E     ADD W0, [W14], [W14]
4486:                      return ((type == GETSINE) ? -(_CosineTable[v]) : (_CosineTable[COSINETABLEENTRIES - v]));
0069E8  90001E     MOV [W14+2], W0
0069EA  500FE0     SUB W0, #0x0, [W15]
0069EC  3A0007     BRA NZ, 0x69FC
0069EE  78001E     MOV [W14], W0
0069F0  400080     ADD W0, W0, W1
0069F2  2D2460     MOV #0xD246, W0
0069F4  408000     ADD W1, W0, W0
0069F6  780010     MOV [W0], W0
0069F8  EA0000     NEG W0, W0
0069FA  370006     BRA 0x6A08
0069FC  2005A0     MOV #0x5A, W0
0069FE  50001E     SUB W0, [W14], W0
006A00  400080     ADD W0, W0, W1
006A02  2D2460     MOV #0xD246, W0
006A04  408000     ADD W1, W0, W0
006A06  780010     MOV [W0], W0
006A08  37003E     BRA 0x6A86
4487:                  }
4488:                  else if(v >= COSINETABLEENTRIES * 2)
006A0A  200B30     MOV #0xB3, W0
006A0C  78009E     MOV [W14], W1
006A0E  508F80     SUB W1, W0, [W15]
006A10  340014     BRA LE, 0x6A3A
4489:                  {
4490:                      v -= COSINETABLEENTRIES * 2;
006A12  2FF4C0     MOV #0xFF4C, W0
006A14  400F1E     ADD W0, [W14], [W14]
4491:                      return ((type == GETSINE) ? -(_CosineTable[(COSINETABLEENTRIES - v)]) : -(_CosineTable[v]));
006A16  90001E     MOV [W14+2], W0
006A18  500FE0     SUB W0, #0x0, [W15]
006A1A  3A0008     BRA NZ, 0x6A2C
006A1C  2005A0     MOV #0x5A, W0
006A1E  50001E     SUB W0, [W14], W0
006A20  400080     ADD W0, W0, W1
006A22  2D2460     MOV #0xD246, W0
006A24  408000     ADD W1, W0, W0
006A26  780010     MOV [W0], W0
006A28  EA0000     NEG W0, W0
006A2A  370006     BRA 0x6A38
006A2C  78001E     MOV [W14], W0
006A2E  400080     ADD W0, W0, W1
006A30  2D2460     MOV #0xD246, W0
006A32  408000     ADD W1, W0, W0
006A34  780010     MOV [W0], W0
006A36  EA0000     NEG W0, W0
006A38  370026     BRA 0x6A86
4492:                  }
4493:                  else if(v >= COSINETABLEENTRIES)
006A3A  200590     MOV #0x59, W0
006A3C  78009E     MOV [W14], W1
006A3E  508F80     SUB W1, W0, [W15]
006A40  340013     BRA LE, 0x6A68
4494:                  {
4495:                      v -= COSINETABLEENTRIES;
006A42  2FFA60     MOV #0xFFA6, W0
006A44  400F1E     ADD W0, [W14], [W14]
4496:                      return ((type == GETSINE) ? (_CosineTable[v]) : -(_CosineTable[COSINETABLEENTRIES - v]));
006A46  90001E     MOV [W14+2], W0
006A48  500FE0     SUB W0, #0x0, [W15]
006A4A  3A0006     BRA NZ, 0x6A58
006A4C  78001E     MOV [W14], W0
006A4E  400080     ADD W0, W0, W1
006A50  2D2460     MOV #0xD246, W0
006A52  408000     ADD W1, W0, W0
006A54  780010     MOV [W0], W0
006A56  370007     BRA 0x6A66
006A58  2005A0     MOV #0x5A, W0
006A5A  50001E     SUB W0, [W14], W0
006A5C  400080     ADD W0, W0, W1
006A5E  2D2460     MOV #0xD246, W0
006A60  408000     ADD W1, W0, W0
006A62  780010     MOV [W0], W0
006A64  EA0000     NEG W0, W0
006A66  37000F     BRA 0x6A86
4497:                  }
4498:                  else
4499:                  {
4500:                      return ((type == GETSINE) ? (_CosineTable[COSINETABLEENTRIES - v]) : (_CosineTable[v]));
006A68  90001E     MOV [W14+2], W0
006A6A  500FE0     SUB W0, #0x0, [W15]
006A6C  3A0007     BRA NZ, 0x6A7C
006A6E  2005A0     MOV #0x5A, W0
006A70  50001E     SUB W0, [W14], W0
006A72  400080     ADD W0, W0, W1
006A74  2D2460     MOV #0xD246, W0
006A76  408000     ADD W1, W0, W0
006A78  780010     MOV [W0], W0
006A7A  370005     BRA 0x6A86
006A7C  78001E     MOV [W14], W0
006A7E  400080     ADD W0, W0, W1
006A80  2D2460     MOV #0xD246, W0
006A82  408000     ADD W1, W0, W0
006A84  780010     MOV [W0], W0
4501:                  }
4502:              
4503:              
4504:              }
006A86  FA8000     ULNK
006A88  060000     RETURN
4505:              
4506:              /*********************************************************************
4507:              * Function:  WORD DrawArc(SHORT cx, SHORT cy, SHORT r1, SHORT r2, SHORT startAngle, SHORT endAngle)
4508:              *
4509:              * PreCondition: none
4510:              *
4511:              * Input: cx - the location of the center of the arc in the x direction. 
4512:              *	     cy - the location of the center of the arc in the y direction. 		 
4513:              *	     r1 - the smaller radius of the arc. 		 
4514:              *	     r2 - the larger radius of the arc. 		 
4515:              *	     startAngle - start angle of the arc. 		 
4516:              *	     endAngle - end angle of the arc. 		 
4517:              *
4518:              * Output: Returns 1 if the rendering is done, 0 if not yet done.
4519:              *
4520:              * Side Effects: none
4521:              *
4522:              * Overview: This renders an arc with from startAngle to endAngle with the thickness 
4523:              *		    of r2-r1. The function returns 1 when the arc is rendered successfuly
4524:              * 			and returns a 0 when it is not yet finished. The next call to the 
4525:              *			function will continue the rendering.
4526:              *
4527:              * Note: none
4528:              *
4529:              ********************************************************************/
4530:              WORD __attribute__((weak)) DrawArc(SHORT cx, SHORT cy, SHORT r1, SHORT r2, SHORT startAngle, SHORT endAngle)
4531:              {
006A8A  FA0016     LNK #0x16
006A8C  980750     MOV W0, [W14+10]
006A8E  980761     MOV W1, [W14+12]
006A90  980772     MOV W2, [W14+14]
006A92  980F03     MOV W3, [W14+16]
006A94  980F14     MOV W4, [W14+18]
006A96  980F25     MOV W5, [W14+20]
4532:              
4533:              	SHORT i;
4534:              	SHORT x1,y1,x2,y2;
4535:              
4536:              	for (i=startAngle; i <= endAngle; i++)
006A98  90081E     MOV [W14+18], W0
006A9A  780F00     MOV W0, [W14]
006A9C  370056     BRA 0x6B4A
006B48  E80F1E     INC [W14], [W14]
006B4A  90082E     MOV [W14+20], W0
006B4C  78009E     MOV [W14], W1
006B4E  508F80     SUB W1, W0, [W15]
006B50  34FFA6     BRA LE, 0x6A9E
4537:              	{
4538:              		// get inner arc x,y position
4539:              		y1 = (r1*Sine(i))/256;
006A9E  EB0080     CLR W1
006AA0  78001E     MOV [W14], W0
006AA2  07FF94     RCALL GetSineCosine
006AA4  9000FE     MOV [W14+14], W1
006AA6  B98001     MUL.SS W0, W1, W0
006AA8  780080     MOV W0, W1
006AAA  201000     MOV #0x100, W0
006AAC  780100     MOV W0, W2
006AAE  090011     REPEAT #0x11
006AB0  D80082     DIV.SW W1, W2
006AB2  980710     MOV W0, [W14+2]
4540:              		x1 = (r1*Cosine(i))/256;
006AB4  200011     MOV #0x1, W1
006AB6  78001E     MOV [W14], W0
006AB8  07FF89     RCALL GetSineCosine
006ABA  9000FE     MOV [W14+14], W1
006ABC  B98001     MUL.SS W0, W1, W0
006ABE  780080     MOV W0, W1
006AC0  201000     MOV #0x100, W0
006AC2  780100     MOV W0, W2
006AC4  090011     REPEAT #0x11
006AC6  D80082     DIV.SW W1, W2
006AC8  980720     MOV W0, [W14+4]
4541:              
4542:              		// get outer arc x,y position
4543:              		if (r1 != r2)
006ACA  9000FE     MOV [W14+14], W1
006ACC  90080E     MOV [W14+16], W0
006ACE  508F80     SUB W1, W0, [W15]
006AD0  320034     BRA Z, 0x6B3A
4544:              		{
4545:              			y2 = (r2*Sine(i))/256;
006AD2  EB0080     CLR W1
006AD4  78001E     MOV [W14], W0
006AD6  07FF7A     RCALL GetSineCosine
006AD8  90088E     MOV [W14+16], W1
006ADA  B98001     MUL.SS W0, W1, W0
006ADC  780080     MOV W0, W1
006ADE  201000     MOV #0x100, W0
006AE0  780100     MOV W0, W2
006AE2  090011     REPEAT #0x11
006AE4  D80082     DIV.SW W1, W2
006AE6  980730     MOV W0, [W14+6]
4546:              			x2 = (r2*Cosine(i))/256;
006AE8  200011     MOV #0x1, W1
006AEA  78001E     MOV [W14], W0
006AEC  07FF6F     RCALL GetSineCosine
006AEE  90088E     MOV [W14+16], W1
006AF0  B98001     MUL.SS W0, W1, W0
006AF2  780080     MOV W0, W1
006AF4  201000     MOV #0x100, W0
006AF6  780100     MOV W0, W2
006AF8  090011     REPEAT #0x11
006AFA  D80082     DIV.SW W1, W2
006AFC  980740     MOV W0, [W14+8]
4547:              
4548:              			// check if we need to double the line to cover all pixels
4549:              			if ((x1 == x2) || (y1 == y2))
006AFE  9000AE     MOV [W14+4], W1
006B00  90004E     MOV [W14+8], W0
006B02  508F80     SUB W1, W0, [W15]
006B04  320004     BRA Z, 0x6B0E
006B06  90009E     MOV [W14+2], W1
006B08  90003E     MOV [W14+6], W0
006B0A  508F80     SUB W1, W0, [W15]
006B0C  3A0003     BRA NZ, 0x6B14
4550:              			{
4551:              				SetLineThickness(NORMAL_LINE);
006B0E  EB4000     CLR.B W0
006B10  B7F04A     MOV.B WREG, _lineThickness
4552:              			}	
4553:              			else
4554:              			{
4555:              				SetLineThickness(THICK_LINE);
006B14  B3C010     MOV #0x1, W0
006B16  B7F04A     MOV.B WREG, _lineThickness
4556:              			}	
4557:              			// draw the lines to fill the arc
4558:              			while(!Line(cx+x1, cy+y1, cx+x2, cy+y2));
006B12  370003     BRA 0x6B1A
006B18  000000     NOP
006B1A  9000EE     MOV [W14+12], W1
006B1C  90003E     MOV [W14+6], W0
006B1E  408180     ADD W1, W0, W3
006B20  9000DE     MOV [W14+10], W1
006B22  90004E     MOV [W14+8], W0
006B24  408100     ADD W1, W0, W2
006B26  9000EE     MOV [W14+12], W1
006B28  90001E     MOV [W14+2], W0
006B2A  408080     ADD W1, W0, W1
006B2C  90025E     MOV [W14+10], W4
006B2E  90002E     MOV [W14+4], W0
006B30  420000     ADD W4, W0, W0
006B32  07F4E7     RCALL Line
006B34  500FE0     SUB W0, #0x0, [W15]
006B36  32FFF1     BRA Z, 0x6B1A
006B38  370007     BRA 0x6B48
4559:              		}
4560:              		else 
4561:              		{	
4562:              			PutPixel(cx+x1, cy+y1);
006B3A  9000EE     MOV [W14+12], W1
006B3C  90001E     MOV [W14+2], W0
006B3E  408080     ADD W1, W0, W1
006B40  90015E     MOV [W14+10], W2
006B42  90002E     MOV [W14+4], W0
006B44  410000     ADD W2, W0, W0
006B46  072BB1     RCALL PutPixel
4563:              		}	
4564:              		
4565:              	}
4566:              	return 1;	
006B52  200010     MOV #0x1, W0
4567:              }	
006B54  FA8000     ULNK
006B56  060000     RETURN
4568:              
4569:              
4570:              #ifdef USE_GRADIENT
4571:              
4572:              #if ((COLOR_DEPTH != 16) && (COLOR_DEPTH != 24))
4573:                  #error "The USE_GRADIENT feature can currently support the COLOR_DEPTH of 16 and 24 only."
4574:              #endif
4575:              
4576:              #ifdef USE_PALETTE
4577:                  #error "The USE_GRADIENT feature is not currently supported when USE_PALETTE is enabled."
4578:              #endif
4579:              
4580:              #if (COLOR_DEPTH == 24)
4581:              #define GetRed(color)       (((color) & 0xFF0000) >> 16)
4582:              #define GetGreen(color)     (((color) & 0x00FF00) >> 8)
4583:              #define GetBlue(color)      ((color) & 0x0000FF)
4584:              #else
4585:              #define GetRed(color)       (((color) & 0xF800) >> 8)
4586:              #define GetGreen(color)     (((color) & 0x07E0) >> 3)
4587:              #define GetBlue(color)      (((color) & 0x001F) << 3)
4588:              #endif
4589:              
4590:              WORD BarGradient(SHORT left, SHORT top, SHORT right, SHORT bottom, GFX_COLOR color1, GFX_COLOR color2, DWORD length, BYTE direction)
4591:              {
4592:              
4593:                  WORD startRed, startBlue, startGreen;
4594:                  WORD endRed, endBlue, endGreen;
4595:              
4596:                  long rdiff=0,gdiff=0,bdiff=0;
4597:                  short i,steps;
4598:              
4599:                  SetColor(color2);
4600:              
4601:                  // if length is 100, why waste the bar call?
4602:                  switch(direction)
4603:                  {
4604:                  case GRAD_UP:
4605:                      length = length * (bottom - top);
4606:                      length /= 100;
4607:                      steps = length;
4608:                      while(!Bar(left,top,right,bottom-steps));
4609:                      break;
4610:              
4611:                  case GRAD_DOWN: 
4612:                      length = length * (bottom - top); 
4613:                      length /= 100; 
4614:                      steps = length;    
4615:                      while(!Bar(left,top+steps,right,bottom));    
4616:                      break;
4617:              
4618:                  case GRAD_RIGHT:
4619:                      length = length * (right - left);
4620:                      length /= 100;
4621:                      steps = length;
4622:                      while(!Bar(left+steps,top,right,bottom)); 
4623:                      break;
4624:              
4625:                  case GRAD_LEFT:
4626:                      length = length * (right - left);
4627:                      length /= 100;
4628:                      steps = length;
4629:                      while(!Bar(left,top,right-steps,bottom)); 
4630:                      break;
4631:              
4632:                  case GRAD_DOUBLE_VER:
4633:                      steps = (right - left) >> 1;
4634:                      break;
4635:              
4636:                  case GRAD_DOUBLE_HOR:
4637:                      steps = (bottom - top) >> 1;
4638:                      break; 
4639:              
4640:                  default: 
4641:                      return 1;
4642:                  }
4643:              
4644:                  startRed    = GetRed(color1);
4645:                  startGreen  = GetGreen(color1);
4646:                  startBlue   = GetBlue(color1);
4647:              
4648:                  endRed      = GetRed(color2);
4649:                  endGreen    = GetGreen(color2);
4650:                  endBlue     = GetBlue(color2);
4651:              
4652:                  ///////////////////////////////////
4653:              
4654:                  //Find the step size for the red portion//
4655:                  rdiff = ((long)endRed - (long)startRed) << 8;
4656:                  rdiff /= steps;
4657:              
4658:                  //Find the step size for the green portion//
4659:                  gdiff = ((long)endGreen - (long)startGreen) << 8;
4660:                  gdiff /= steps;
4661:              
4662:                  //Find the step size for the blue portion//
4663:                  bdiff = ((long)endBlue - (long)startBlue) << 8;
4664:                  bdiff /= steps;
4665:              
4666:                  short barSize = 1;
4667:                  color1 = RGBConvert(startRed, startGreen, startBlue);
4668:              
4669:                  // PERCENTAGE BASED CODE
4670:                  for(i=0; i < steps; i++)
4671:                  {
4672:                      //Calculate the starting RGB values
4673:                      endRed      = startRed + ((rdiff*i) >> 8);
4674:                      endGreen    = startGreen + ((gdiff*i) >> 8);
4675:                      endBlue     = startBlue + ((bdiff*i) >> 8);
4676:              
4677:                      color2 = RGBConvert(endRed, endGreen, endBlue);
4678:              
4679:                      if(color2 == color1)
4680:                      {
4681:                          barSize++;
4682:                          continue;
4683:                      }
4684:              
4685:                      SetColor(color2);
4686:                      color1 = color2;
4687:              
4688:                      switch(direction)          //This switch statement draws the gradient depending on direction chosen
4689:                      {
4690:                      case GRAD_DOWN:
4691:                          while(!Bar(left, top, right, top + barSize));
4692:                          top += barSize;
4693:                      break;
4694:                      
4695:                      case GRAD_UP:
4696:                          while(!Bar(left,bottom - barSize,right,bottom));
4697:                          bottom -= barSize;
4698:                      break;
4699:              
4700:                      case GRAD_RIGHT:
4701:                          while(!Bar(left, top, left + barSize, bottom));
4702:                          left += barSize;
4703:                      break;
4704:                      
4705:                      case GRAD_LEFT:
4706:                          while(!Bar(right - barSize, top, right, bottom));
4707:                          right -= barSize;
4708:                      break;
4709:              
4710:                      case GRAD_DOUBLE_VER:
4711:                          while(!Bar(right - barSize, top, right, bottom));
4712:                          right -= barSize;
4713:                          while(!Bar(left, top, left + barSize, bottom));
4714:                          left += barSize;
4715:                      break;
4716:              
4717:                      case GRAD_DOUBLE_HOR:
4718:                          while(!Bar(left, bottom - barSize, right, bottom));
4719:                          bottom -= barSize;
4720:                          while(!Bar(left, top, right, top + barSize));
4721:                          top += barSize;
4722:                      break; 
4723:              
4724:                      default: 
4725:                          break;
4726:                      }
4727:              
4728:                      barSize = 1;
4729:                  }
4730:              
4731:                  if(barSize > 1)
4732:                  {
4733:              
4734:                      SetColor(RGBConvert(endRed, endGreen, endBlue));
4735:              
4736:                      switch(direction)          //This switch statement draws the gradient depending on direction chosen
4737:                      {
4738:                      case GRAD_DOWN:
4739:                          while(!Bar(left, top, right, top + barSize));
4740:                      break;
4741:                      
4742:                      case GRAD_UP:
4743:                          while(!Bar(left,bottom - barSize,right,bottom));
4744:                      break;
4745:              
4746:                      case GRAD_RIGHT:
4747:                          while(!Bar(left, top, left + barSize, bottom));
4748:                      break;
4749:                      
4750:                      case GRAD_LEFT:
4751:                          while(!Bar(right - barSize, top, right, bottom));
4752:                      break;
4753:              
4754:                      case GRAD_DOUBLE_VER:
4755:                          while(!Bar(right - barSize, top, right, bottom));
4756:                          while(!Bar(left, top, left + barSize, bottom));
4757:                      break;
4758:              
4759:                      case GRAD_DOUBLE_HOR:
4760:                          while(!Bar(left, bottom - barSize, right, bottom));
4761:                          while(!Bar(left, top, right, top + barSize));
4762:                      break; 
4763:              
4764:                      default: 
4765:                          break;
4766:                      }
4767:              
4768:                  }
4769:                  return 1;
4770:              }
4771:              
4772:              WORD BevelGradient(SHORT left, SHORT top, SHORT right, SHORT bottom, SHORT rad, GFX_COLOR color1, GFX_COLOR color2, DWORD length, BYTE direction)
4773:              {
4774:                  WORD i;
4775:                  WORD sred,sblue,sgreen;
4776:                  WORD ered,eblue,egreen;
4777:                  GFX_COLOR EndColor;
4778:                  long rdiff=0,gdiff=0,bdiff=0;
4779:                  short steps;
4780:                  EndColor = color2;
4781:              
4782:                  switch(direction)     //This switch statement calculates the amount of transitions needed
4783:                  {
4784:                  case GRAD_UP:
4785:                  case GRAD_DOWN:
4786:                      length = length * (bottom - top +(rad << 1));
4787:                      length /= 100;
4788:                      steps = length;
4789:                      break;
4790:              
4791:                  case GRAD_RIGHT:
4792:                  case GRAD_LEFT:
4793:                      length = length * (right - left +(rad << 1));
4794:                      length /= 100;
4795:                      steps = length;
4796:                      break;
4797:              
4798:                  case GRAD_DOUBLE_VER:
4799:                      steps = (right - left +(rad << 1)) >> 1;
4800:                      break;
4801:              
4802:                  case GRAD_DOUBLE_HOR:
4803:                      steps = (bottom - top +(rad << 1)) >> 1;
4804:                      break; 
4805:              
4806:                  default: 
4807:                      return (1);
4808:                  }
4809:              
4810:                  //Calculate the starting RGB values
4811:                  sred    = GetRed(color1);
4812:                  sgreen  = GetGreen(color1);
4813:                  sblue   = GetBlue(color1);
4814:                          
4815:                  ered    = GetRed(color2);
4816:                  egreen  = GetGreen(color2);
4817:                  eblue   = GetBlue(color2);
4818:              
4819:                  ///////////////////////////////////
4820:              
4821:                  //Find the step size for the red portion//
4822:                  rdiff = ((long)ered - (long)sred) << 8;
4823:                  rdiff /= steps;
4824:              
4825:                  //Find the step size for the green portion//
4826:                  gdiff = ((long)egreen - (long)sgreen) << 8;
4827:                  gdiff /= steps;
4828:              
4829:                  //Find the step size for the blue portion//
4830:                  bdiff = ((long)eblue - (long)sblue) << 8;
4831:                  bdiff /= steps;
4832:              
4833:                  typedef enum
4834:                  {
4835:                      BEGIN,
4836:                      CHECK,
4837:                      Q8TOQ1,
4838:                      Q7TOQ2,
4839:                      Q6TOQ3,
4840:                      Q5TOQ4,
4841:                      WAITFORDONE,
4842:                      FACE
4843:                  } FILLCIRCLE_STATES;
4844:              
4845:                  DWORD_VAL temp;
4846:                  static LONG err;
4847:                  static SHORT yLimit, xPos, yPos;
4848:                  static SHORT xCur, yCur, yNew;
4849:              
4850:                  static FILLCIRCLE_STATES state = BEGIN;
4851:              
4852:                  while(1)
4853:                  {
4854:                      while(IsDeviceBusy()); 
4855:                          
4856:                      switch(state)
4857:                      {
4858:                          case BEGIN:
4859:                              if(!rad)
4860:                              {   // no radius object is a filled rectangle
4861:                                  state = FACE;
4862:                                  break;
4863:                              }
4864:              
4865:                              // compute variables
4866:                              temp.Val = SIN45 * rad;
4867:                              yLimit = temp.w[1];
4868:                              temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
4869:                              err = (SHORT) (temp.w[1]);
4870:                              xPos = rad;
4871:                              yPos = 0;
4872:                              xCur = xPos;
4873:                              yCur = yPos;
4874:                              yNew = yPos;
4875:                              state = CHECK;
4876:              
4877:                          case CHECK:
4878:                              bevel_fill_check : if(yPos > yLimit)
4879:                              {
4880:                                  state = FACE;
4881:                                  break;
4882:                              }
4883:              
4884:                              // New records the last y position
4885:                              yNew = yPos;
4886:              
4887:                              // calculate the next value of x and y
4888:                              if(err > 0)
4889:                              {
4890:                                  xPos--;
4891:                                  err += 5 + ((yPos - xPos) << 1);
4892:                              }
4893:                              else
4894:                                  err += 3 + (yPos << 1);
4895:                              yPos++;
4896:                              state = Q6TOQ3;
4897:              
4898:                          case Q6TOQ3:
4899:                              if(xCur != xPos)
4900:                              {
4901:              
4902:                                  // 6th octant to 3rd octant
4903:              	            	//if (_bevelDrawType & DRAWBOTTOMBEVEL) 
4904:              	            	{ 
4905:                                      if(direction == GRAD_DOUBLE_VER || direction == GRAD_DOUBLE_HOR)
4906:                                          i = (top - yCur) - top + rad;
4907:                                      else
4908:                                          i = (bottom + yCur) - top + rad;
4909:                              
4910:                                      ered = sred + ((rdiff*i) >> 8);
4911:                                      egreen = sgreen + ((gdiff*i) >> 8);
4912:                                      eblue = sblue + ((bdiff*i) >> 8);
4913:               
4914:                                      color2 = RGBConvert(ered,egreen,eblue);
4915:                                                       
4916:                                      SetColor(color2);
4917:                          
4918:                                      switch(direction)    //Direction matter because different portions of the circle are drawn
4919:                                      {
4920:                                         case GRAD_LEFT:
4921:                                             if(i>length) SetColor(EndColor);
4922:                                             Bar(left - yNew, top - xCur, left - yCur, bottom + xCur);
4923:                                             break;
4924:                                         
4925:                                         case GRAD_RIGHT:                     
4926:                                         case GRAD_DOUBLE_VER:
4927:                                              if(i>length) 
4928:                                                  SetColor(EndColor);
4929:                                             
4930:                                              Bar(right + yCur, top - xCur, right + yNew, bottom + xCur);          
4931:                                              break;
4932:                                         
4933:                                         case GRAD_UP:
4934:                                              if(i>length) 
4935:                                                  SetColor(EndColor);
4936:                                              
4937:                                              Bar(left - xCur, top - yNew, right + xCur, top - yCur);
4938:                                              break;
4939:              
4940:                                         case GRAD_DOWN:
4941:                                         case GRAD_DOUBLE_HOR:
4942:                                              if(i>length) 
4943:                                                  SetColor(EndColor);
4944:                                              Bar(left - xCur, bottom + yCur, right + xCur, bottom + yNew);
4945:                                         
4946:                                         default: 
4947:                                             break;
4948:                                      }
4949:              
4950:                                	}          	
4951:                                  state = Q5TOQ4;
4952:                                  break;
4953:                              }
4954:              
4955:                              state = CHECK;
4956:                              goto bevel_fill_check;
4957:              
4958:                          case Q5TOQ4:
4959:              
4960:                          	//if (_bevelDrawType & DRAWBOTTOMBEVEL) 
4961:                          	{ 
4962:                                  if(direction == GRAD_DOUBLE_VER || direction == GRAD_DOUBLE_HOR)
4963:                                  i = top + xPos - top + rad;
4964:                                  else
4965:              
4966:              	                // 5th octant to 4th octant
4967:                                  i = (bottom + xPos) - top + rad ;
4968:              
4969:                                  //Calculate the starting RGB values
4970:                                  ered = sred + ((rdiff*i) >> 8);
4971:                                  egreen = sgreen + ((gdiff*i) >> 8);
4972:                                  eblue = sblue + ((bdiff*i) >> 8);
4973:                                  
4974:                                  color2 = RGBConvert(ered,egreen,eblue);
4975:                                  SetColor(color2);
4976:              
4977:                                  switch(direction)    //Direction matter because different portions of the circle are drawn
4978:                                  {
4979:                                     case GRAD_LEFT:
4980:                                         if(i>length) 
4981:                                             SetColor(EndColor);
4982:                                         Bar(left - xCur, top - yNew, left - xPos, bottom + yNew); 
4983:                                          break;
4984:                                     
4985:                                     case GRAD_RIGHT:                     
4986:                                     case GRAD_DOUBLE_VER:
4987:                                         if(i>length) 
4988:                                             SetColor(EndColor);
4989:                                         Bar(right + xPos, top - yNew, right + xCur, bottom + yNew);           
4990:                                          break;
4991:                                     
4992:                                     case GRAD_UP:
4993:                                          if(i>length) 
4994:                                              SetColor(EndColor);
4995:                                          Bar(left - yNew, top - xCur, right + yNew, top - xPos); 
4996:                                          break;
4997:              
4998:                                     case GRAD_DOWN:
4999:                                     case GRAD_DOUBLE_HOR:
5000:                                          if(i>length) 
5001:                                              SetColor(EndColor);
5002:                                          Bar(left - yNew, bottom + xPos, right + yNew, bottom + xCur);
5003:                                     default: 
5004:                                         break;
5005:                                  }
5006:              
5007:              				}
5008:                              state = Q8TOQ1;
5009:                              break;
5010:              
5011:                          case Q8TOQ1:
5012:              
5013:                              // 8th octant to 1st octant
5014:              	            //if (_bevelDrawType & DRAWTOPBEVEL) 
5015:              				{
5016:                                  i = (top - xCur) - top + rad;
5017:              
5018:                                  //Calculate the starting RGB values
5019:                                  ered = sred + ((rdiff*i) >> 8);
5020:                                  egreen = sgreen + ((gdiff*i) >> 8);
5021:                                  eblue = sblue + ((bdiff*i) >> 8);
5022:              
5023:                                  color2 = RGBConvert(ered,egreen,eblue);
5024:                                  SetColor(color2);
5025:              
5026:                                  switch(direction)    //Direction matter because different portions of the circle are drawn
5027:                                  {
5028:                                     case GRAD_LEFT:
5029:                                         if(i>length) 
5030:                                             SetColor(EndColor);
5031:                                         Bar(right + xPos, top - yNew, right + xCur, bottom + yNew);
5032:                                          break;
5033:                                     
5034:                                     case GRAD_RIGHT:                     
5035:                                     case GRAD_DOUBLE_VER:
5036:                                         if(i>length) 
5037:                                             SetColor(EndColor);
5038:                                         Bar(left - xCur, top - yNew, left - xPos, bottom + yNew);           
5039:                                          break;
5040:                                     
5041:                                     case GRAD_UP:
5042:                                          if(i>length) 
5043:                                              SetColor(EndColor);
5044:                                          Bar(left - yNew, bottom + xPos, right + yNew, bottom + xCur);
5045:                                          break;
5046:              
5047:                                     case GRAD_DOWN:
5048:                                     case GRAD_DOUBLE_HOR:
5049:                                          if(i>length) 
5050:                                              SetColor(EndColor);
5051:                                          Bar(left - yNew, top - xCur, right + yNew, top - xPos);
5052:                                          break;
5053:                                     
5054:                                     default: 
5055:                                         break;
5056:                                  }
5057:              
5058:                  			}                	
5059:                              state = Q7TOQ2;
5060:                              break;
5061:              
5062:                          case Q7TOQ2:
5063:              
5064:                              // 7th octant to 2nd octant
5065:              	            //if (_bevelDrawType & DRAWTOPBEVEL) 
5066:              				{             
5067:                                  i = (top - yNew) - top + rad;
5068:              
5069:                                  //Calculate the starting RGB values
5070:                                  ered = sred + ((rdiff*i) >> 8);
5071:                                  egreen = sgreen + ((gdiff*i) >> 8);
5072:                                  eblue = sblue + ((bdiff*i) >> 8);
5073:              
5074:                                  color2 = RGBConvert(ered,egreen,eblue);
5075:                                  
5076:                                  SetColor(color2);
5077:                       
5078:                                  switch(direction)    //Direction matter because different portions of the circle are drawn
5079:                                  {
5080:                                     case GRAD_LEFT:
5081:                                         if(i>length) 
5082:                                             SetColor(EndColor);
5083:                                         Bar(right + yCur, top - xCur, right + yNew, bottom + xCur);
5084:                                          break;
5085:                                     
5086:                                     case GRAD_RIGHT:                     
5087:                                     case GRAD_DOUBLE_VER:
5088:                                         if(i>length) 
5089:                                             SetColor(EndColor);
5090:                                         Bar(left - yNew, top - xCur, left - yCur, bottom + xCur);           
5091:                                          break;
5092:                                     
5093:                                     case GRAD_UP:
5094:                                          if(i>length) 
5095:                                              SetColor(EndColor);
5096:                                          Bar(left - xCur, bottom + yCur, right + xCur, bottom + yNew);
5097:                                          break;
5098:              
5099:                                     case GRAD_DOWN:
5100:                                     case GRAD_DOUBLE_HOR:
5101:                                          if(i>length) 
5102:                                              SetColor(EndColor);
5103:                                          Bar(left - xCur, top - yNew, right + xCur, top - yCur);
5104:                                          break;
5105:                                     
5106:                                     default: 
5107:                                         break;
5108:                                  }
5109:              
5110:              				}
5111:                              // update current values
5112:                              xCur = xPos;
5113:                              yCur = yPos;
5114:                              state = CHECK;
5115:                              break;
5116:              
5117:               
5118:              
5119:                          case FACE:
5120:                              if((right - left) || (bottom - top))
5121:                              {
5122:                              i = (top) - top + rad;
5123:                              //Calculate the starting RGB values
5124:                              ered = sred + ((rdiff*i) >> 8);
5125:                              egreen = sgreen + ((gdiff*i) >> 8);
5126:                              eblue = sblue + ((bdiff*i) >> 8);
5127:              
5128:                              color1 = RGBConvert(ered,egreen,eblue);
5129:               
5130:                              if(i>length) 
5131:                                  color1 = EndColor;  
5132:              
5133:                              i = (bottom) - top + rad;
5134:                              //Calculate the ending RGB values
5135:                              ered = sred + ((rdiff*i) >> 8);
5136:                              egreen = sgreen + ((gdiff*i) >> 8);
5137:                              eblue = sblue + ((bdiff*i) >> 8);
5138:              
5139:                              color2 = RGBConvert(ered,egreen,eblue);
5140:               
5141:                              if(i>length) 
5142:                                  color2 = EndColor;
5143:                    
5144:                              length -= rad;   //Subtract the radius from the length needed for gradient   
5145:                            
5146:                              if(direction == GRAD_UP || direction == GRAD_DOWN || direction == GRAD_DOUBLE_HOR)
5147:                              {
5148:                                 if(length>= bottom-top)
5149:                                 {
5150:                                     length = 100;
5151:                                 }
5152:                                 else
5153:                                 {
5154:                                     length *= 100;
5155:                                     length /= (bottom -top);
5156:                                 }               
5157:                                 BarGradient(left-rad, top, right+rad, bottom,color1,color2,length,direction);
5158:                              }
5159:                              else
5160:                              {
5161:                                if(length>=right-left)
5162:                                {
5163:                                    length = 100;
5164:                                }
5165:                                else
5166:                                {
5167:                                     length *= 100;
5168:                                     length /= (right - left);
5169:                                }
5170:                                 BarGradient(left, top-rad, right, bottom+rad,color1,color2,length,direction);
5171:                              }
5172:                          
5173:                                  state = WAITFORDONE;
5174:                              }
5175:                              else
5176:                              {
5177:                                  state = BEGIN;
5178:                                  return (1);
5179:                              }
5180:              
5181:                          case WAITFORDONE:
5182:                              while(IsDeviceBusy());
5183:                              state = BEGIN;
5184:                              return (1);
5185:                      }           // end of switch
5186:                  }               // end of while
5187:                
5188:              }
5189:              #endif
5190:              
5191:              
5192:              #ifdef USE_COMP_RLE
5193:              
5194:                  #ifdef USE_BITMAP_FLASH
5195:              
5196:                      #if (COLOR_DEPTH >= 8)
5197:              /*********************************************************************
5198:              * Function: WORD DecodeRLE8(FLASH_BYTE *flashAddress, BYTE *pixelrow, WORD size)
5199:              *
5200:              * PreCondition: tempFlashAddress should point to the beginning of a RLE compressed block
5201:              *
5202:              * Input: flashAddress - Address of the beginning of a RLE compressed block
5203:              *        pixelrow - Pointer to an array where the decoded row must be stored
5204:              *        size - Size of the decoded data in bytes
5205:              *
5206:              * Output: Number of source bytes traversed
5207:              *
5208:              * Side Effects: none
5209:              *
5210:              * Overview: Decodes the data
5211:              *
5212:              ********************************************************************/
5213:              WORD DecodeRLE8(FLASH_BYTE *flashAddress, BYTE *pixel_row, WORD size)
5214:              {
5215:                  WORD sourceOffset = 0;
5216:                  WORD decodeSize = 0;
5217:              
5218:                  while(decodeSize < size)
5219:                  {
5220:                      BYTE code = *flashAddress++;
5221:                      BYTE value = *flashAddress++;
5222:                      sourceOffset += 2;
5223:                      
5224:                      if(code > 0)
5225:                      {
5226:                          decodeSize += code;
5227:                          
5228:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5229:                          {
5230:                              code -= (decodeSize - size);
5231:                          }
5232:                          
5233:                          while(code)
5234:                          {
5235:                              *pixel_row++ = value;
5236:                              code--;
5237:                          }
5238:                      }
5239:                      else
5240:                      {
5241:                          decodeSize += value;
5242:                          sourceOffset += value;
5243:                          
5244:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5245:                          {
5246:                              value -= (decodeSize - size);
5247:                          }
5248:                          
5249:                          while(value)
5250:                          {
5251:                              *pixel_row++ = *flashAddress++;
5252:                              value--;
5253:                          }
5254:                      }
5255:                  }    
5256:                  return (sourceOffset);
5257:              }
5258:              
5259:              /*********************************************************************
5260:              * Function: void PutImageRLE8BPP(SHORT left, SHORT top, FLASH_BYTE* image, BYTE stretch)
5261:              *
5262:              * PreCondition: none
5263:              *
5264:              * Input: left,top - left top image corner, image - image pointer,
5265:              *        stretch - Should be NORMAL when RLE is used
5266:              *
5267:              * Output: none
5268:              *
5269:              * Side Effects: none
5270:              *
5271:              * Overview: outputs the image starting from left,top coordinates
5272:              *
5273:              * Note: image must be located in internal memory
5274:              *
5275:              ********************************************************************/
5276:              void PutImageRLE8BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch)
5277:              {
5278:                  register FLASH_BYTE *flashAddress;
5279:                  WORD                sizeX, sizeY;
5280:                  WORD                x, y;
5281:                  WORD                xc, yc;
5282:                  BYTE                temp;
5283:                  BYTE                stretchX, stretchY;
5284:              #ifndef USE_PALETTE
5285:                  GFX_COLOR           imagePalette[256];
5286:                  WORD                counter;
5287:              #endif
5288:                  BYTE                pixelrow[GetMaxX() + 1];
5289:                  WORD                offset;
5290:                  BYTE                *pixelAddress;
5291:              
5292:                  // Move pointer to size information
5293:                  flashAddress = image + 2;
5294:              
5295:                  // Read image size
5296:                  sizeY = *((FLASH_WORD *)flashAddress);
5297:                  flashAddress += 2;
5298:                  sizeX = *((FLASH_WORD *)flashAddress);
5299:                  flashAddress += 2;
5300:              
5301:                  #if COLOR_DEPTH == 24
5302:                  flashAddress += 2;      // pad word for alignment
5303:                  #endif
5304:              
5305:                  // Read pallete
5306:                  #ifdef USE_PALETTE
5307:                      // Adjust the address to skip the palette section.
5308:                      // Pixel data are indices not actual color data.
5309:                      // Palette to be used is assumed to be system level
5310:                      // defined. This supports only 16 bits per palette entry width.
5311:                      // 24 bits palette entry width is not supported.
5312:                      flashAddress = flashAddress + 512;
5313:                      
5314:                  #else
5315:                      // grab the palette of the image
5316:                      // the actual color used are in this palette
5317:                      for(counter = 0; counter < 256; counter++)
5318:                      {
5319:                          #if COLOR_DEPTH == 16
5320:                              imagePalette[counter] = *((FLASH_WORD *)flashAddress);
5321:                              flashAddress += 2;
5322:                          #endif
5323:                  
5324:                          #if COLOR_DEPTH == 24
5325:                              imagePalette[counter] = *((FLASH_DWORD *)flashAddress);
5326:                              flashAddress += 4;
5327:                          #endif
5328:                      }
5329:              
5330:                  #endif
5331:                  
5332:                  yc = top;
5333:              
5334:                  for(y = 0; y < sizeY; y++)
5335:                  {
5336:                      offset = DecodeRLE8(flashAddress, pixelrow, sizeX);
5337:                      flashAddress += offset;
5338:                      
5339:                      for(stretchY = 0; stretchY < stretch; stretchY++)
5340:                      {
5341:                          pixelAddress = pixelrow;
5342:                          xc = left;
5343:                          for(x = 0; x < sizeX; x++)
5344:                          {
5345:              
5346:                              // Read pixels from flash
5347:                              temp = *pixelAddress;
5348:                              pixelAddress++;
5349:              
5350:                              // Set color
5351:                          #ifdef USE_PALETTE
5352:                              SetColor(temp);
5353:                          #else
5354:                              SetColor(imagePalette[temp]);
5355:                          #endif
5356:              
5357:                              // Write pixel to screen
5358:                              for(stretchX = 0; stretchX < stretch; stretchX++)
5359:                              {
5360:                                  #ifdef USE_TRANSPARENT_COLOR
5361:                                      if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
5362:                                  #endif
5363:                                          PutPixel(xc, yc);
5364:                                      xc++;    
5365:                              }
5366:                          }
5367:              
5368:                          yc++;
5369:                      }
5370:                  }
5371:              }
5372:                      #endif //#if (COLOR_DEPTH >= 8)
5373:              
5374:                      #if (COLOR_DEPTH >= 4)
5375:                      
5376:              /*********************************************************************
5377:              * Function: WORD DecodeRLE4(FLASH_BYTE *flashAddress, BYTE *pixelrow, WORD size)
5378:              *
5379:              * PreCondition: tempFlashAddress should point to the beginning of a RLE compressed block
5380:              *
5381:              * Input: flashAddress - Address of the beginning of a RLE compressed block
5382:              *        pixelrow - Pointer to an array where the decoded row must be stored
5383:              *        size - Size of the decoded data in bytes
5384:              *
5385:              * Output: Number of source bytes traversed
5386:              *
5387:              * Side Effects: none
5388:              *
5389:              * Overview: Decodes the data
5390:              *
5391:              ********************************************************************/
5392:              WORD DecodeRLE4(FLASH_BYTE *flashAddress, BYTE *pixel_row, WORD size)
5393:              {
5394:                  WORD sourceOffset = 0;
5395:                  WORD decodeSize = 0;
5396:              
5397:                  while(decodeSize < size)
5398:                  {
5399:                      BYTE code = *flashAddress++;
5400:                      BYTE value = *flashAddress++;
5401:                      BYTE counter;
5402:                      
5403:                      sourceOffset += 2;
5404:                      
5405:                      if(code > 0)
5406:                      {
5407:                          decodeSize += code;
5408:                          
5409:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5410:                          {
5411:                              code -= (decodeSize - size);
5412:                          }
5413:                          
5414:                          for(counter = 0; counter < code; counter++)
5415:                          {
5416:                              if(counter & 0x01)
5417:                              {
5418:                                  *pixel_row++ = (value >> 4) & 0x0F;
5419:                              }
5420:                              else
5421:                              {
5422:                                  *pixel_row++ = (value) & 0x0F;
5423:                              }
5424:                          }
5425:                      }
5426:                      else
5427:                      {
5428:                          decodeSize += value;
5429:                          sourceOffset += (value + 1) >> 1;
5430:                          
5431:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5432:                          {
5433:                              value -= (decodeSize - size);
5434:                          }
5435:                          
5436:                          for(counter = 0; counter < value; counter++)
5437:                          {
5438:                              if(counter & 0x01)
5439:                              {
5440:                                  *pixel_row++ = (*flashAddress >> 4) & 0x0F;
5441:                                  flashAddress++;
5442:                              }
5443:                              else
5444:                              {
5445:                                  *pixel_row++ = (*flashAddress) & 0x0F;
5446:                              }
5447:                          }
5448:                      }
5449:                  }
5450:              
5451:                  return (sourceOffset);
5452:              }
5453:              
5454:              /*********************************************************************
5455:              * Function: void PutImageRLE4BPP(SHORT left, SHORT top, FLASH_BYTE* image, BYTE stretch)
5456:              *
5457:              * PreCondition: none
5458:              *
5459:              * Input: left,top - left top image corner, image - image pointer,
5460:              *        stretch - Should be NORMAL when RLE is used
5461:              *
5462:              * Output: none
5463:              *
5464:              * Side Effects: none
5465:              *
5466:              * Overview: outputs the image starting from left,top coordinates
5467:              *
5468:              * Note: image must be located in internal memory
5469:              *
5470:              ********************************************************************/
5471:              void PutImageRLE4BPP(SHORT left, SHORT top, FLASH_BYTE *image, BYTE stretch)
5472:              {
5473:                  register FLASH_BYTE *flashAddress;
5474:                  WORD                sizeX, sizeY;
5475:                  register WORD       x, y;
5476:                  WORD                xc, yc;
5477:                  BYTE                temp = 0;
5478:                  register BYTE       stretchX, stretchY;
5479:              #ifndef USE_PALETTE
5480:                  GFX_COLOR           imagePalette[16];
5481:                  WORD                counter;
5482:              #endif
5483:                  BYTE                pixelrow[GetMaxX() + 1];
5484:                  WORD                offset;
5485:                  BYTE                *pixelAddress;
5486:              
5487:                  // Move pointer to size information
5488:                  flashAddress = image + 2;
5489:              
5490:                  // Read image size
5491:                  sizeY = *((FLASH_WORD *)flashAddress);
5492:                  flashAddress += 2;
5493:                  sizeX = *((FLASH_WORD *)flashAddress);
5494:                  flashAddress += 2;
5495:              
5496:                  #if COLOR_DEPTH == 24
5497:                  flashAddress += 2;          // pad for alignment
5498:                  #endif
5499:              
5500:                  // Read pallete
5501:                  #ifdef USE_PALETTE
5502:                      // Adjust the address to skip the palette section.
5503:                      // Pixel data are indices not actual color data.
5504:                      // Palette to be used is assumed to be system level
5505:                      // defined. This supports only 16 bits per palette entry width.
5506:                      // 24 bits palette entry width is not supported.
5507:                      flashAddress = flashAddress + 32;
5508:              
5509:                  #else
5510:                      for(counter = 0; counter < 16; counter++)
5511:                      {
5512:                          #if COLOR_DEPTH == 16    
5513:                              imagePalette[counter] = *((FLASH_WORD *)flashAddress);
5514:                              flashAddress += 2;
5515:                          #endif
5516:                  
5517:                          #if COLOR_DEPTH == 24
5518:                              imagePalette[counter] = *((FLASH_DWORD *)flashAddress);
5519:                              flashAddress += 4;
5520:                          #endif
5521:                      }
5522:                  #endif
5523:              
5524:                  yc = top;
5525:                  
5526:                  for(y = 0; y < sizeY; y++)
5527:                  {
5528:                      offset = DecodeRLE4(flashAddress, pixelrow, sizeX);
5529:                      flashAddress += offset;
5530:              
5531:                      for(stretchY = 0; stretchY < stretch; stretchY++)
5532:                      {
5533:                          pixelAddress = pixelrow;
5534:                          xc = left;
5535:                          for(x = 0; x < sizeX; x++)
5536:                          {
5537:                              temp = *pixelAddress;
5538:                              pixelAddress++;
5539:              
5540:                              #ifdef USE_PALETTE
5541:                                  SetColor(temp);
5542:                              #else
5543:                                  SetColor(imagePalette[temp]);
5544:                              #endif
5545:              
5546:                              // Write pixel to screen
5547:                              for(stretchX = 0; stretchX < stretch; stretchX++)
5548:                              {
5549:                                  #ifdef USE_TRANSPARENT_COLOR
5550:                                      if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
5551:                                  #endif
5552:                                          PutPixel(xc, yc);
5553:                                      xc++;    
5554:                              }
5555:                          }
5556:              
5557:                          yc++;
5558:                      }
5559:                  }
5560:              }
5561:                      #endif //#if (COLOR_DEPTH >= 4)
5562:              
5563:                  #endif //    #ifdef USE_BITMAP_FLASH
5564:              
5565:                  #ifdef USE_BITMAP_EXTERNAL
5566:                  
5567:                      #if (COLOR_DEPTH >= 8)
5568:              
5569:              /*********************************************************************
5570:              * Function: WORD DecodeRLE8Ext(void *image, DWORD  memAddress, BYTE *pixelrow, WORD size)
5571:              *
5572:              * PreCondition: tempFlashAddress should point to the beginning of a RLE compressed block
5573:              *
5574:              * Input: image - External memory image pointer
5575:              *        memAddress - Address of the beginning of a RLE compressed block
5576:              *        pixelrow - Pointer to an array where the decoded row must be stored
5577:              *        size - Size of the decoded data in bytes
5578:              *
5579:              * Output: Number of source bytes traversed
5580:              *
5581:              * Side Effects: none
5582:              *
5583:              * Overview: Decodes the data from the external flash
5584:              *
5585:              ********************************************************************/
5586:              WORD DecodeRLE8Ext(void *image, DWORD memAddress, BYTE *pixel_row, WORD size)
5587:              {
5588:                  WORD sourceOffset = 0;
5589:                  WORD decodeSize = 0;
5590:              
5591:                  while(decodeSize < size)
5592:                  {
5593:                      BYTE code, value;
5594:                      
5595:                      ExternalMemoryCallback(image, memAddress, sizeof(BYTE), &code);
5596:                      memAddress++;
5597:                      ExternalMemoryCallback(image, memAddress, sizeof(BYTE), &value);
5598:                      memAddress++;
5599:              
5600:                      sourceOffset += 2;
5601:                      
5602:                      if(code > 0)
5603:                      {
5604:                          decodeSize += code;
5605:                          
5606:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5607:                          {
5608:                              code -= (decodeSize - size);
5609:                          }
5610:                          
5611:                          while(code)
5612:                          {
5613:                              *pixel_row++ = value;
5614:                              code--;
5615:                          }
5616:                      }
5617:                      else
5618:                      {
5619:                          decodeSize += value;
5620:                          sourceOffset += value;
5621:                          
5622:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5623:                          {
5624:                              value -= (decodeSize - size);
5625:                          }
5626:                          
5627:                          ExternalMemoryCallback(image, memAddress, value * sizeof(BYTE), pixel_row);
5628:                          pixel_row += value;
5629:                          memAddress += value;
5630:                      }
5631:                  }    
5632:                  return (sourceOffset);
5633:              }
5634:              
5635:              /*********************************************************************
5636:              * Function: void PutImageRLE8BPPExt(SHORT left, SHORT top, void* image, BYTE stretch)
5637:              *
5638:              * PreCondition: none
5639:              *
5640:              * Input: left,top - left top image corner, image - image pointer,
5641:              *        stretch - image stretch factor
5642:              *
5643:              * Output: none
5644:              *
5645:              * Side Effects: none
5646:              *
5647:              * Overview: outputs monochrome image starting from left,top coordinates
5648:              *
5649:              * Note: image must be located in external memory
5650:              *
5651:              ********************************************************************/
5652:              void PutImageRLE8BPPExt(SHORT left, SHORT top, void *image, BYTE stretch)
5653:              {
5654:                  register DWORD  memOffset;
5655:                  BITMAP_HEADER   bmp;
5656:              #ifndef USE_PALETTE
5657:                  GFX_COLOR       imagePalette[256];
5658:              #endif
5659:                  BYTE            pixelrow[(GetMaxX() + 1)];
5660:                  BYTE            *pixelAddress;
5661:              
5662:                  BYTE            temp;
5663:                  WORD            sizeX, sizeY;
5664:                  WORD            x, y;
5665:                  WORD            xc, yc;
5666:                  BYTE            stretchX, stretchY;
5667:                  WORD            offset;
5668:              
5669:                  // Get image header
5670:                  ExternalMemoryCallback(image, 0, sizeof(BITMAP_HEADER), &bmp);
5671:              
5672:                  // Set offset to the image data, 256 is used since this function is for 8bpp images
5673:                  #ifdef USE_PALETTE
5674:                      // use system palette, skip the image palette and adjust the offset
5675:                      // assumes palette entry width is 16 bits, 
5676:                      // 24 bits palette width is not supported
5677:                      memOffset = sizeof(BITMAP_HEADER) + 256 * sizeof(WORD);
5678:                  #else
5679:                      memOffset = sizeof(BITMAP_HEADER) + 256 * sizeof(GFX_COLOR);
5680:              
5681:                      // Get image palette, since this will be used to render the pixels
5682:                      // when system palette is used, the image palette is assumed to be
5683:                      // the same as the system palette so we do not fetch it
5684:                      ExternalMemoryCallback(image, sizeof(BITMAP_HEADER), 256 * sizeof(GFX_COLOR), imagePalette);
5685:              
5686:                  #endif
5687:              
5688:                  // Get size
5689:                  sizeX = bmp.width;
5690:                  sizeY = bmp.height;
5691:              
5692:                  yc = top;
5693:                  for(y = 0; y < sizeY; y++)
5694:                  {
5695:                      offset = DecodeRLE8Ext(image, memOffset, pixelrow, sizeX);
5696:                      memOffset += offset;
5697:                      
5698:                      for(stretchY = 0; stretchY < stretch; stretchY++)
5699:                      {
5700:                          pixelAddress = pixelrow;
5701:                          xc = left;
5702:                          for(x = 0; x < sizeX; x++)
5703:                          {
5704:              
5705:                              // Read pixels from flash
5706:                              temp = *pixelAddress;
5707:                              pixelAddress++;
5708:              
5709:                              // Set color
5710:                          #ifdef USE_PALETTE
5711:                              SetColor(temp);
5712:                          #else
5713:                              SetColor(imagePalette[temp]);
5714:                          #endif
5715:              
5716:                              // Write pixel to screen
5717:                              for(stretchX = 0; stretchX < stretch; stretchX++)
5718:                              {
5719:                                  #ifdef USE_TRANSPARENT_COLOR
5720:                                      if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
5721:                                  #endif
5722:                                          PutPixel(xc, yc);
5723:                                      xc++;    
5724:                              }
5725:                          }
5726:              
5727:                          yc++;
5728:                      }
5729:                  }
5730:              }
5731:                      #endif //#if (COLOR_DEPTH >= 8)
5732:                      
5733:                      #if (COLOR_DEPTH >= 4)
5734:              
5735:              /*********************************************************************
5736:              * Function: WORD DecodeRLE4Ext(void *image, DWORD memAddress, BYTE *pixelrow, WORD size)
5737:              *
5738:              * PreCondition: tempFlashAddress should point to the beginning of a RLE compressed block
5739:              *
5740:              * Input: image - External memory image pointer
5741:              *        memAddress - Address of the beginning of a RLE compressed block
5742:              *        pixelrow - Pointer to an array where the decoded row must be stored
5743:              *        size - Size of the decoded data in bytes
5744:              *
5745:              * Output: Number of source bytes traversed
5746:              *
5747:              * Side Effects: none
5748:              *
5749:              * Overview: Decodes the data
5750:              *
5751:              ********************************************************************/
5752:              WORD DecodeRLE4Ext(void *image, DWORD memAddress, BYTE *pixel_row, WORD size)
5753:              {
5754:                  WORD sourceOffset = 0;
5755:                  WORD decodeSize = 0;
5756:              
5757:                  while(decodeSize < size)
5758:                  {
5759:                      BYTE code, value;
5760:                      BYTE counter, temp;
5761:                      
5762:                      ExternalMemoryCallback(image, memAddress, sizeof(BYTE), &code);
5763:                      memAddress++;
5764:                      ExternalMemoryCallback(image, memAddress, sizeof(BYTE), &value);
5765:                      memAddress++;
5766:                      
5767:                      sourceOffset += 2;
5768:                      
5769:                      if(code > 0)
5770:                      {
5771:                          decodeSize += code;
5772:                          
5773:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5774:                          {
5775:                              code -= (decodeSize - size);
5776:                          }
5777:                          
5778:                          for(counter = 0; counter < code; counter++)
5779:                          {
5780:                              if(counter & 0x01)
5781:                              {
5782:                                  *pixel_row++ = (value >> 4) & 0x0F;
5783:                              }
5784:                              else
5785:                              {
5786:                                  *pixel_row++ = (value) & 0x0F;
5787:                              }
5788:                          }
5789:                      }
5790:                      else
5791:                      {
5792:                          decodeSize += value;
5793:                          sourceOffset += (value + 1) >> 1;
5794:                          
5795:                          if(decodeSize > size) //To avoid writing oustide the array bounds
5796:                          {
5797:                              value -= (decodeSize - size);
5798:                          }
5799:                          
5800:                          for(counter = 0; counter < value; counter++)
5801:                          {
5802:                              if(counter & 0x01)
5803:                              {
5804:                                  *pixel_row++ = (temp >> 4) & 0x0F;
5805:                                  memAddress++;
5806:                              }
5807:                              else
5808:                              {
5809:                                  ExternalMemoryCallback(image, memAddress, sizeof(BYTE), &temp);
5810:                                  *pixel_row++ = temp & 0x0F;
5811:                              }
5812:                          }
5813:                      }
5814:                  }
5815:              
5816:                  return (sourceOffset);
5817:              }
5818:              
5819:              /*********************************************************************
5820:              * Function: void PutImageRLE4BPPExt(SHORT left, SHORT top, void* image, BYTE stretch)
5821:              *
5822:              * PreCondition: none
5823:              *
5824:              * Input: left,top - left top image corner, image - image pointer,
5825:              *        stretch - image stretch factor
5826:              *
5827:              * Output: none
5828:              *
5829:              * Side Effects: none
5830:              *
5831:              * Overview: outputs monochrome image starting from left,top coordinates
5832:              *
5833:              * Note: image must be located in external memory
5834:              *
5835:              ********************************************************************/
5836:              void PutImageRLE4BPPExt(SHORT left, SHORT top, void *image, BYTE stretch)
5837:              {
5838:                  register DWORD  memOffset;
5839:                  BITMAP_HEADER   bmp;
5840:              #ifndef USE_PALETTE
5841:                  GFX_COLOR       imagePalette[16];
5842:              #endif
5843:                  BYTE            pixelrow[(GetMaxX() + 1)];
5844:                  BYTE            *pixelAddress;
5845:              
5846:                  BYTE            temp;
5847:                  WORD            sizeX, sizeY;
5848:                  WORD            x, y;
5849:                  WORD            xc, yc;
5850:                  BYTE            stretchX, stretchY;
5851:                  WORD            offset;
5852:              
5853:                  // Get image header
5854:                  ExternalMemoryCallback(image, 0, sizeof(BITMAP_HEADER), &bmp);
5855:              
5856:                  // Set offset to the image data, 16 is used since this function is for 4bpp images
5857:                  #ifdef USE_PALETTE
5858:                      // assumes palette entry width is 16 bits, 
5859:                      // 24 bits palette width is not supported
5860:                      memOffset = sizeof(BITMAP_HEADER) + 16 * sizeof(WORD);
5861:                  #else
5862:                      memOffset = sizeof(BITMAP_HEADER) + 16 * sizeof(GFX_COLOR);
5863:              
5864:                      // Get image palette, since this will be used to render the pixels
5865:                      // when system palette is used, the image palette is assumed to be
5866:                      // the same as the system palette so we do not fetch it
5867:                      ExternalMemoryCallback(image, sizeof(BITMAP_HEADER), 16 * sizeof(GFX_COLOR), imagePalette);
5868:              
5869:                  #endif
5870:              
5871:                  // Get size
5872:                  sizeX = bmp.width;
5873:                  sizeY = bmp.height;
5874:              
5875:                  yc = top;
5876:                  for(y = 0; y < sizeY; y++)
5877:                  {
5878:                      offset = DecodeRLE4Ext(image, memOffset, pixelrow, sizeX);
5879:                      memOffset += offset;
5880:                      
5881:                      for(stretchY = 0; stretchY < stretch; stretchY++)
5882:                      {
5883:                          pixelAddress = pixelrow;
5884:                          xc = left;
5885:                          for(x = 0; x < sizeX; x++)
5886:                          {
5887:              
5888:                              // Read pixels from flash
5889:                              temp = *pixelAddress;
5890:                              pixelAddress++;
5891:              
5892:                              // Set color
5893:                          #ifdef USE_PALETTE
5894:                              SetColor(temp);
5895:                          #else
5896:                              SetColor(imagePalette[temp]);
5897:                          #endif
5898:              
5899:                              // Write pixel to screen
5900:                              for(stretchX = 0; stretchX < stretch; stretchX++)
5901:                              {
5902:                                  #ifdef USE_TRANSPARENT_COLOR
5903:                                      if (!((GetTransparentColor() == GetColor()) && (GetTransparentColorStatus() == TRANSPARENT_COLOR_ENABLE)))
5904:                                  #endif
5905:                                          PutPixel(xc, yc);
5906:                                      xc++;    
5907:                              }
5908:                          }
5909:              
5910:                          yc++;
5911:                      }
5912:                  }
5913:              }
5914:                      #endif //#if (COLOR_DEPTH >= 4)
5915:              
5916:                  #endif //#ifdef USE_BITMAP_EXTERNAL
5917:                  
5918:              #endif //#ifdef USE_COMP_RLE
5919:              
5920:              void GetCirclePoint(SHORT radius, SHORT angle, SHORT *x, SHORT *y)
5921:              {
006B58  FA0010     LNK #0x10
006B5A  980740     MOV W0, [W14+8]
006B5C  980751     MOV W1, [W14+10]
006B5E  980762     MOV W2, [W14+12]
006B60  980773     MOV W3, [W14+14]
5922:                  DWORD   rad;
5923:                  SHORT   ang;
5924:                  SHORT   temp;
5925:              
5926:                  ang = angle % 45;
006B62  9000DE     MOV [W14+10], W1
006B64  2002D0     MOV #0x2D, W0
006B66  780100     MOV W0, W2
006B68  090011     REPEAT #0x11
006B6A  D80082     DIV.SW W1, W2
006B6C  FD0080     EXCH W0, W1
006B6E  780F00     MOV W0, [W14]
5927:                  if((angle / 45) & 0x01)
006B70  9000DE     MOV [W14+10], W1
006B72  2002D0     MOV #0x2D, W0
006B74  780100     MOV W0, W2
006B76  090011     REPEAT #0x11
006B78  D80082     DIV.SW W1, W2
006B7A  600061     AND W0, #0x1, W0
006B7C  784000     MOV.B W0, W0
006B7E  504FE0     SUB.B W0, #0x0, [W15]
006B80  320002     BRA Z, 0x6B86
5928:                      ang = 45 - ang;
006B82  2002D0     MOV #0x2D, W0
006B84  500F1E     SUB W0, [W14], [W14]
5929:              
5930:                  rad = radius;
006B86  90004E     MOV [W14+8], W0
006B88  DE80CF     ASR W0, #15, W1
006B8A  980710     MOV W0, [W14+2]
006B8C  980721     MOV W1, [W14+4]
5931:                  // there is a shift by 8 bits here since this function assumes a shift on the calculations for accuracy
5932:                  // and to avoid long and complex multiplications.
5933:                  rad *= ((DWORD) GetSineCosine(ang, GETCOSINE) << 8);
006B8E  200011     MOV #0x1, W1
006B90  78001E     MOV [W14], W0
006B92  07FF1C     RCALL GetSineCosine
006B94  DE80CF     ASR W0, #15, W1
006B96  DD08C8     SL W1, #8, W1
006B98  FD8000     SWAP W0
006B9A  784080     MOV.B W0, W1
006B9C  EB4000     CLR.B W0
006B9E  90012E     MOV [W14+4], W2
006BA0  B99100     MUL.SS W2, W0, W2
006BA2  780102     MOV W2, W2
006BA4  90019E     MOV [W14+2], W3
006BA6  B99A01     MUL.SS W3, W1, W4
006BA8  780184     MOV W4, W3
006BAA  410103     ADD W2, W3, W2
006BAC  90019E     MOV [W14+2], W3
006BAE  B81800     MUL.UU W3, W0, W0
006BB0  410101     ADD W2, W1, W2
006BB2  780082     MOV W2, W1
006BB4  980710     MOV W0, [W14+2]
006BB6  980721     MOV W1, [W14+4]
006BB8  980710     MOV W0, [W14+2]
006BBA  980721     MOV W1, [W14+4]
5934:              
5935:                  *x = ((DWORD_VAL) rad).w[1];
006BBC  B80060     MUL.UU W0, #0, W0
006BBE  90001E     MOV [W14+2], W0
006BC0  9000AE     MOV [W14+4], W1
006BC2  780001     MOV W1, W0
006BC4  780080     MOV W0, W1
006BC6  90006E     MOV [W14+12], W0
006BC8  780801     MOV W1, [W0]
5936:                  rad = radius;
006BCA  90004E     MOV [W14+8], W0
006BCC  DE80CF     ASR W0, #15, W1
006BCE  980710     MOV W0, [W14+2]
006BD0  980721     MOV W1, [W14+4]
5937:                  rad *= ((DWORD) GetSineCosine(ang, GETSINE) << 8);
006BD2  EB0080     CLR W1
006BD4  78001E     MOV [W14], W0
006BD6  07FEFA     RCALL GetSineCosine
006BD8  DE80CF     ASR W0, #15, W1
006BDA  DD08C8     SL W1, #8, W1
006BDC  FD8000     SWAP W0
006BDE  784080     MOV.B W0, W1
006BE0  EB4000     CLR.B W0
006BE2  90012E     MOV [W14+4], W2
006BE4  B99100     MUL.SS W2, W0, W2
006BE6  780102     MOV W2, W2
006BE8  90019E     MOV [W14+2], W3
006BEA  B99A01     MUL.SS W3, W1, W4
006BEC  780184     MOV W4, W3
006BEE  410103     ADD W2, W3, W2
006BF0  90019E     MOV [W14+2], W3
006BF2  B81800     MUL.UU W3, W0, W0
006BF4  410101     ADD W2, W1, W2
006BF6  780082     MOV W2, W1
006BF8  980710     MOV W0, [W14+2]
006BFA  980721     MOV W1, [W14+4]
006BFC  980710     MOV W0, [W14+2]
006BFE  980721     MOV W1, [W14+4]
5938:              
5939:                  *y = ((DWORD_VAL) rad).w[1];
006C00  B80060     MUL.UU W0, #0, W0
006C02  90001E     MOV [W14+2], W0
006C04  9000AE     MOV [W14+4], W1
006C06  780001     MOV W1, W0
006C08  780080     MOV W0, W1
006C0A  90007E     MOV [W14+14], W0
006C0C  780801     MOV W1, [W0]
5940:              
5941:                  if(((angle > 45) && (angle < 135)) || ((angle > 225) && (angle < 315)))
006C0E  9000DE     MOV [W14+10], W1
006C10  2002D0     MOV #0x2D, W0
006C12  508F80     SUB W1, W0, [W15]
006C14  340004     BRA LE, 0x6C1E
006C16  9000DE     MOV [W14+10], W1
006C18  200860     MOV #0x86, W0
006C1A  508F80     SUB W1, W0, [W15]
006C1C  340008     BRA LE, 0x6C2E
006C1E  9000DE     MOV [W14+10], W1
006C20  200E10     MOV #0xE1, W0
006C22  508F80     SUB W1, W0, [W15]
006C24  34000E     BRA LE, 0x6C42
006C26  9000DE     MOV [W14+10], W1
006C28  2013A0     MOV #0x13A, W0
006C2A  508F80     SUB W1, W0, [W15]
006C2C  3C000A     BRA GT, 0x6C42
5942:                  {
5943:                      temp = *x;
006C2E  90006E     MOV [W14+12], W0
006C30  780090     MOV [W0], W1
006C32  980731     MOV W1, [W14+6]
5944:                      *x = *y;
006C34  90007E     MOV [W14+14], W0
006C36  780090     MOV [W0], W1
006C38  90006E     MOV [W14+12], W0
006C3A  780801     MOV W1, [W0]
5945:                      *y = temp;
006C3C  90007E     MOV [W14+14], W0
006C3E  90013E     MOV [W14+6], W2
006C40  780802     MOV W2, [W0]
5946:                  }
5947:              
5948:                  if((angle > 90) && (angle < 270))
006C42  9000DE     MOV [W14+10], W1
006C44  2005A0     MOV #0x5A, W0
006C46  508F80     SUB W1, W0, [W15]
006C48  340009     BRA LE, 0x6C5C
006C4A  9000DE     MOV [W14+10], W1
006C4C  2010D0     MOV #0x10D, W0
006C4E  508F80     SUB W1, W0, [W15]
006C50  3C0005     BRA GT, 0x6C5C
5949:                  {
5950:                      *x = -*x;
006C52  90006E     MOV [W14+12], W0
006C54  780010     MOV [W0], W0
006C56  EA0080     NEG W0, W1
006C58  90006E     MOV [W14+12], W0
006C5A  780801     MOV W1, [W0]
5951:                  }
5952:              
5953:                  if((angle > 180) && (angle < 360))
006C5C  9000DE     MOV [W14+10], W1
006C5E  200B40     MOV #0xB4, W0
006C60  508F80     SUB W1, W0, [W15]
006C62  340009     BRA LE, 0x6C76
006C64  9000DE     MOV [W14+10], W1
006C66  201670     MOV #0x167, W0
006C68  508F80     SUB W1, W0, [W15]
006C6A  3C0005     BRA GT, 0x6C76
5954:                  {
5955:                      *y = -*y;
006C6C  90007E     MOV [W14+14], W0
006C6E  780010     MOV [W0], W0
006C70  EA0080     NEG W0, W1
006C72  90007E     MOV [W14+14], W0
006C74  780801     MOV W1, [W0]
5956:                  }
5957:              }
006C76  FA8000     ULNK
006C78  060000     RETURN
5958:              
5959:              
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/GOL.c  ---------------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library 
3:                  *  GOL Layer 
4:                  *****************************************************************************
5:                  * FileName:        GOL.c
6:                  * Processor:       PIC24F, PIC24H, dsPIC, PIC32
7:                  * Compiler:       	MPLAB C30 V3.00, MPLAB C32
8:                  * Company:         Microchip Technology Incorporated
9:                  *
10:                 * Software License Agreement
11:                 *
12:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
13:                 * Microchip licenses to you the right to use, modify, copy and distribute
14:                 * Software only when embedded on a Microchip microcontroller or digital
15:                 * signal controller, which is integrated into your product or third party
16:                 * product (pursuant to the sublicense terms in the accompanying license
17:                 * agreement).  
18:                 *
19:                 * You should refer to the license agreement accompanying this Software
20:                 * for additional information regarding your rights and obligations.
21:                 *
22:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
23:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
24:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
25:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
26:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
27:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
28:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
29:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
30:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
31:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
32:                 * OR OTHER SIMILAR COSTS.
33:                 *
34:                 * Date                  Comment
35:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
36:                 * 11/12/07              Version 1.0 release
37:                 * 06/29/09				Added multi-line support for Buttons.
38:                 * 03/12/09             Added Double Buffering Support
39:                 * 04/29/10				Fixed GOLGetFocusNext() issue.
40:                 * 06/07/10				To save drawing time, add check on panel to skip 
41:                 * 						drawing the panel face and frame if the bitmap
42:                 * 						used is greater than area of the panel.
43:                 * 09/08/10				Removed redundant code in GOLRedrawRec().
44:                 *                      Added EditBox in GOLCanBeFocused().
45:                 * 03/30/11             In 1 BPP mode: Removed all references to WHITE and 
46:                 *                      BLACK color. Replaced them to use the emboss light 
47:                 *                      and dark color instead.
48:                 * 02/03/12             Added missing cases in GOLRedrawRec().
49:                 * 03/05/12             Enabled Gradient feature when rendering in blocking 
50:                 *                      mode.
51:                 *****************************************************************************/
52:                #include "Graphics/Graphics.h"
53:                
54:                #ifdef USE_GOL
55:                
56:                #include <string.h>
57:                
58:                #ifdef USE_TRANSITION_EFFECTS
59:                    
60:                    #include "Graphics/Transitions.h"
61:                    
62:                    static BYTE TransitionPendingStatus;
63:                #endif
64:                
65:                // Pointer to the current linked list of objects displayed and receiving messages
66:                OBJ_HEADER  *_pGolObjects = NULL;
67:                
68:                // Pointer to the default GOL scheme (created in GOLInit())
69:                GOL_SCHEME  *_pDefaultGolScheme = NULL;
70:                
71:                // Pointer to the object receiving keyboard input
72:                OBJ_HEADER  *_pObjectFocused = NULL;
73:                
74:                #ifdef USE_GRADIENT
75:                GFX_GRADIENT_STYLE _gradientScheme;
76:                #endif
77:                
78:                    #ifdef USE_FOCUS
79:                
80:                /*********************************************************************
81:                * Function: OBJ_HEADER *GOLGetFocusPrev()
82:                *
83:                * Overview: This function returns the pointer to the previous object
84:                *		 	in the active linked list which is able to receive 
85:                *		 	keyboard input.
86:                *
87:                * PreCondition: none
88:                *
89:                * Input: none
90:                *
91:                * Output: This returns the pointer of the previous object in the 
92:                *		  active list capable of receiving keyboard input. If 
93:                *		  there is no object capable of receiving keyboard 
94:                *		  inputs (i.e. none can be focused) NULL is returned.
95:                *
96:                * Side Effects: none
97:                *
98:                ********************************************************************/
99:                OBJ_HEADER *GOLGetFocusPrev(void)
100:               {
0083B0  FA0006     LNK #0x6
101:                   OBJ_HEADER  *pPrevObj;
102:                   OBJ_HEADER  *pCurObj;
103:                   OBJ_HEADER  *pFocusedObj;
104:               
105:                   if(_pGolObjects == NULL)
0083B2  808B30     MOV 0x1166, W0
0083B4  500FE0     SUB W0, #0x0, [W15]
0083B6  3A0002     BRA NZ, 0x83BC
106:                       return (NULL);
0083B8  EB0000     CLR W0
0083BA  37002E     BRA 0x8418
107:               
108:                   if(_pObjectFocused == NULL)
0083BC  808B50     MOV 0x116A, W0
0083BE  500FE0     SUB W0, #0x0, [W15]
0083C0  3A0003     BRA NZ, 0x83C8
109:                   {
110:                       pFocusedObj = _pGolObjects;
0083C2  808B30     MOV 0x1166, W0
0083C4  980720     MOV W0, [W14+4]
0083C6  370002     BRA 0x83CC
111:                   }
112:                   else
113:                   {
114:                       pFocusedObj = _pObjectFocused;
0083C8  808B50     MOV 0x116A, W0
0083CA  980720     MOV W0, [W14+4]
115:                   }
116:               
117:                   pPrevObj = NULL;
0083CC  EB0000     CLR W0
0083CE  780F00     MOV W0, [W14]
118:                   pCurObj = pFocusedObj;
0083D0  90002E     MOV [W14+4], W0
0083D2  980710     MOV W0, [W14+2]
0083D4  370001     BRA 0x83D8
119:               
120:                   while(1)
121:                   {
122:                       if(GOLCanBeFocused(pCurObj))
0083D8  90001E     MOV [W14+2], W0
0083DA  07006C     RCALL GOLCanBeFocused
0083DC  500FE0     SUB W0, #0x0, [W15]
0083DE  320002     BRA Z, 0x83E4
123:                           pPrevObj = pCurObj;
0083E0  90001E     MOV [W14+2], W0
0083E2  780F00     MOV W0, [W14]
124:               
125:                       if(pCurObj->pNxtObj == NULL)
0083E4  90001E     MOV [W14+2], W0
0083E6  900010     MOV [W0+2], W0
0083E8  500FE0     SUB W0, #0x0, [W15]
0083EA  3A0006     BRA NZ, 0x83F8
126:                           if(_pGolObjects == pFocusedObj)
0083EC  808B31     MOV 0x1166, W1
0083EE  90002E     MOV [W14+4], W0
0083F0  508F80     SUB W1, W0, [W15]
0083F2  3A0002     BRA NZ, 0x83F8
127:                               return (pPrevObj);
0083F4  78001E     MOV [W14], W0
0083F6  370010     BRA 0x8418
128:               
129:                       if(pCurObj->pNxtObj == pFocusedObj)
0083F8  90001E     MOV [W14+2], W0
0083FA  900090     MOV [W0+2], W1
0083FC  90002E     MOV [W14+4], W0
0083FE  508F80     SUB W1, W0, [W15]
008400  3A0002     BRA NZ, 0x8406
130:                           return (pPrevObj);
008402  78001E     MOV [W14], W0
008404  370009     BRA 0x8418
131:               
132:                       pCurObj = (OBJ_HEADER *)pCurObj->pNxtObj;
008406  90001E     MOV [W14+2], W0
008408  900010     MOV [W0+2], W0
00840A  980710     MOV W0, [W14+2]
133:               
134:                       if(pCurObj == NULL)
00840C  90001E     MOV [W14+2], W0
00840E  500FE0     SUB W0, #0x0, [W15]
008410  3AFFE2     BRA NZ, 0x83D6
135:                           pCurObj = _pGolObjects;
008412  808B30     MOV 0x1166, W0
008414  980710     MOV W0, [W14+2]
136:                   }
0083D6  000000     NOP
008416  37FFE0     BRA 0x83D8
137:               }
008418  FA8000     ULNK
00841A  060000     RETURN
138:               
139:               /*********************************************************************
140:               * Function: OBJ_HEADER *GOLGetFocusNext()
141:               *
142:               * Overview: This function returns the pointer to the next object
143:               *		 	in the active linked list which is able to receive 
144:               *		 	keyboard input.
145:               *
146:               * PreCondition: none
147:               *
148:               * Input: none
149:               *
150:               * Output: This returns the pointer of the next object in the 
151:               *		  active list capable of receiving keyboard input. If 
152:               *		  there is no object capable of receiving keyboard 
153:               *		  inputs (i.e. none can be focused) NULL is returned.
154:               *
155:               * Side Effects: none
156:               *
157:               ********************************************************************/
158:               OBJ_HEADER *GOLGetFocusNext(void)
159:               {
00841C  FA0004     LNK #0x4
160:                   OBJ_HEADER  *pNextObj, *pObjStart;
161:               
162:                   if(_pGolObjects == NULL)
00841E  808B30     MOV 0x1166, W0
008420  500FE0     SUB W0, #0x0, [W15]
008422  3A0002     BRA NZ, 0x8428
163:                       return (NULL);
008424  EB0000     CLR W0
008426  370023     BRA 0x846E
164:               
165:                   if(_pObjectFocused == NULL)
008428  808B50     MOV 0x116A, W0
00842A  500FE0     SUB W0, #0x0, [W15]
00842C  3A0003     BRA NZ, 0x8434
166:                   {
167:                       pNextObj = _pGolObjects;
00842E  808B30     MOV 0x1166, W0
008430  780F00     MOV W0, [W14]
008432  370002     BRA 0x8438
168:                   }
169:                   else
170:                   {
171:                       pNextObj = _pObjectFocused;
008434  808B50     MOV 0x116A, W0
008436  780F00     MOV W0, [W14]
172:                   }
173:               
174:               	pObjStart = pNextObj;
008438  78001E     MOV [W14], W0
00843A  980710     MOV W0, [W14+2]
175:               	
176:                   do
177:                   {
178:                       pNextObj = (OBJ_HEADER *)pNextObj->pNxtObj;
00843C  78001E     MOV [W14], W0
00843E  900010     MOV [W0+2], W0
008440  780F00     MOV W0, [W14]
179:               
180:                       if(pNextObj == NULL)
008442  78001E     MOV [W14], W0
008444  500FE0     SUB W0, #0x0, [W15]
008446  3A0002     BRA NZ, 0x844C
181:                           pNextObj = _pGolObjects;
008448  808B30     MOV 0x1166, W0
00844A  780F00     MOV W0, [W14]
182:               
183:                       if(GOLCanBeFocused(pNextObj))
00844C  78001E     MOV [W14], W0
00844E  070032     RCALL GOLCanBeFocused
008450  500FE0     SUB W0, #0x0, [W15]
008452  3A0005     BRA NZ, 0x845E
184:                           break;
00845E  000000     NOP
185:                   } while(pNextObj != pObjStart);
008454  90001E     MOV [W14+2], W0
008456  78009E     MOV [W14], W1
008458  508F80     SUB W1, W0, [W15]
00845A  3AFFF0     BRA NZ, 0x843C
00845C  370001     BRA 0x8460
186:               
187:               	// if we reached the starting point and the starting point cannot
188:               	// be focused, then all objects cannot be focused. return NULL
189:                   if(!GOLCanBeFocused(pNextObj))
008460  78001E     MOV [W14], W0
008462  070028     RCALL GOLCanBeFocused
008464  500FE0     SUB W0, #0x0, [W15]
008466  3A0002     BRA NZ, 0x846C
190:               		return NULL;
008468  EB0000     CLR W0
00846A  370001     BRA 0x846E
191:               
192:                   return (pNextObj);
00846C  78001E     MOV [W14], W0
193:               }
00846E  FA8000     ULNK
008470  060000     RETURN
194:               
195:               /*********************************************************************
196:               * Function: void GOLSetFocus(OBJ_HEADER* object)
197:               *
198:               * PreCondition: none
199:               *
200:               * Input: pointer to the object to be focused
201:               *
202:               * Output: 
203:               *
204:               * Side Effects: none
205:               *
206:               * Overview: moves keyboard focus to the object
207:               *
208:               * Note: none
209:               *
210:               ********************************************************************/
211:               void GOLSetFocus(OBJ_HEADER *object)
212:               {
008472  FA0002     LNK #0x2
008474  780F00     MOV W0, [W14]
213:                   if(!GOLCanBeFocused(object))
008476  78001E     MOV [W14], W0
008478  07001D     RCALL GOLCanBeFocused
00847A  500FE0     SUB W0, #0x0, [W15]
00847C  320018     BRA Z, 0x84AE
214:                       return;
0084AE  000000     NOP
215:               
216:                   if(_pObjectFocused != NULL)
00847E  808B50     MOV 0x116A, W0
008480  500FE0     SUB W0, #0x0, [W15]
008482  32000C     BRA Z, 0x849C
217:                   {
218:                       ClrState(_pObjectFocused, FOCUSED);
008484  808B50     MOV 0x116A, W0
008486  808B51     MOV 0x116A, W1
008488  900131     MOV [W1+6], W2
00848A  2FFFE1     MOV #0xFFFE, W1
00848C  610081     AND W2, W1, W1
00848E  980031     MOV W1, [W0+6]
219:                       SetState(_pObjectFocused, DRAW_FOCUS);
008490  808B50     MOV 0x116A, W0
008492  808B51     MOV 0x116A, W1
008494  900131     MOV [W1+6], W2
008496  220001     MOV #0x2000, W1
008498  710081     IOR W2, W1, W1
00849A  980031     MOV W1, [W0+6]
220:                   }
221:               
222:                   SetState(object, DRAW_FOCUS | FOCUSED);
00849C  78001E     MOV [W14], W0
00849E  9000B0     MOV [W0+6], W1
0084A0  220010     MOV #0x2001, W0
0084A2  708080     IOR W1, W0, W1
0084A4  78001E     MOV [W14], W0
0084A6  980031     MOV W1, [W0+6]
223:               
224:                   _pObjectFocused = object;
0084A8  78001E     MOV [W14], W0
0084AA  888B50     MOV W0, 0x116A
0084AC  370001     BRA 0x84B0
225:               }
0084B0  FA8000     ULNK
0084B2  060000     RETURN
226:               
227:               /*********************************************************************
228:               * Function: WORD GOLCanBeFocused(OBJ_HEADER* object)
229:               *
230:               * PreCondition: none
231:               *
232:               * Input: pointer to the object 
233:               *
234:               * Output: non-zero if the object supports keyboard focus, zero if not
235:               *
236:               * Side Effects: none
237:               *
238:               * Overview: checks if object support keyboard focus
239:               *
240:               * Note: none
241:               *
242:               ********************************************************************/
243:               WORD GOLCanBeFocused(OBJ_HEADER *object)
244:               {
0084B4  FA0002     LNK #0x2
0084B6  780F00     MOV W0, [W14]
245:                   if
246:                   (
0084BC  500FE0     SUB W0, #0x0, [W15]
0084BE  320014     BRA Z, 0x84E8
247:                       (object->type == OBJ_BUTTON) ||
0084B8  78001E     MOV [W14], W0
0084BA  900020     MOV [W0+4], W0
0084C4  500FE2     SUB W0, #0x2, [W15]
0084C6  320010     BRA Z, 0x84E8
248:                       (object->type == OBJ_CHECKBOX) ||
0084C0  78001E     MOV [W14], W0
0084C2  900020     MOV [W0+4], W0
0084CC  500FE3     SUB W0, #0x3, [W15]
0084CE  32000C     BRA Z, 0x84E8
249:                       (object->type == OBJ_RADIOBUTTON) ||
0084C8  78001E     MOV [W14], W0
0084CA  900020     MOV [W0+4], W0
0084D4  500FE5     SUB W0, #0x5, [W15]
0084D6  320008     BRA Z, 0x84E8
250:                       (object->type == OBJ_LISTBOX) ||
0084D0  78001E     MOV [W14], W0
0084D2  900020     MOV [W0+4], W0
0084DC  500FE6     SUB W0, #0x6, [W15]
0084DE  320004     BRA Z, 0x84E8
251:                       (object->type == OBJ_SLIDER) ||
0084D8  78001E     MOV [W14], W0
0084DA  900020     MOV [W0+4], W0
0084E4  500FE4     SUB W0, #0x4, [W15]
0084E6  3A0007     BRA NZ, 0x84F6
252:                       (object->type == OBJ_EDITBOX)
0084E0  78001E     MOV [W14], W0
0084E2  900020     MOV [W0+4], W0
253:                   )
254:                   {
255:                       if(!GetState(object, DISABLED))
0084E8  78001E     MOV [W14], W0
0084EA  900030     MOV [W0+6], W0
0084EC  600062     AND W0, #0x2, W0
0084EE  500FE0     SUB W0, #0x0, [W15]
0084F0  3A0002     BRA NZ, 0x84F6
256:                           return (1);
0084F2  200010     MOV #0x1, W0
0084F4  370001     BRA 0x84F8
257:                   }
258:               
259:                   return (0);
0084F6  EB0000     CLR W0
260:               }
0084F8  FA8000     ULNK
0084FA  060000     RETURN
261:               
262:                   #endif //#ifdef USE_FOCUS
263:               
264:               /*********************************************************************
265:               * Function: GOL_SCHEME *GOLCreateScheme(void)
266:               *
267:               * PreCondition: none
268:               *
269:               * Input: none
270:               *
271:               * Output: pointer to scheme object
272:               *
273:               * Side Effects: none
274:               *
275:               * Overview: creates a color scheme object and assign default colors
276:               *
277:               * Note: none
278:               *
279:               ********************************************************************/
280:               GOL_SCHEME *GOLCreateScheme(void)
281:               {
0084FC  FA0002     LNK #0x2
282:                   GOL_SCHEME  *pTemp;
283:               
284:                   pTemp = (GOL_SCHEME *)GFX_malloc(sizeof(GOL_SCHEME));
0084FE  2000C0     MOV #0xC, W0
008500  07CD27     RCALL _malloc
008502  780F00     MOV W0, [W14]
285:               
286:                   if(pTemp != NULL)
008504  78001E     MOV [W14], W0
008506  500FE0     SUB W0, #0x0, [W15]
008508  320004     BRA Z, 0x8512
287:                   {
288:                       memcpy(pTemp, &GFX_SCHEMEDEFAULT, sizeof(GOL_SCHEME));
00850A  2000C2     MOV #0xC, W2
00850C  2D4521     MOV #0xD452, W1
00850E  78001E     MOV [W14], W0
008510  07CDEF     RCALL _memcpy
289:                   }
290:               
291:                   return (pTemp);
008512  78001E     MOV [W14], W0
292:               }
008514  FA8000     ULNK
008516  060000     RETURN
293:               
294:               /*********************************************************************
295:               * Function: void GOLInit()
296:               *
297:               * PreCondition: none
298:               *
299:               * Input: none
300:               *
301:               * Output: none
302:               *
303:               * Side Effects: none
304:               *
305:               * Overview: initializes GOL
306:               *
307:               * Note: none
308:               *
309:               ********************************************************************/
310:               void GOLInit(void)
311:               {
008518  FA0000     LNK #0x0
312:               
313:                   // Initialize display
314:                   InitGraph();
00851A  07E928     RCALL InitGraph
315:               
316:                   // Initialize the default GOL scheme
317:                   _pDefaultGolScheme = GOLCreateScheme();
00851C  07FFEF     RCALL GOLCreateScheme
00851E  888B40     MOV W0, 0x1168
318:               
319:                   #ifdef USE_TRANSITION_EFFECTS
320:               
321:                       TransitionPendingStatus = 0;
322:               
323:                   #endif
324:               }
008520  FA8000     ULNK
008522  060000     RETURN
325:               
326:               /*********************************************************************
327:               * Function: void GOLFree()
328:               *
329:               * PreCondition: none
330:               *
331:               * Input: none
332:               *
333:               * Output: none
334:               *
335:               * Side Effects: none
336:               *
337:               * Overview: frees memory of all objects in the current linked list
338:               *           and starts a new linked list. This function must be 
339:               *           called only inside the GOLDrawCallback()function when 
340:               *           using GOLDraw() and GOLMsg() to manage rendering and 
341:               *           message processing.
342:               *
343:               * Note: drawing and messaging must be suspended
344:               *
345:               ********************************************************************/
346:               void GOLFree(void)
347:               {
008524  FA0004     LNK #0x4
348:                   OBJ_HEADER  *pNextObj;
349:                   OBJ_HEADER  *pCurrentObj;
350:               
351:                   pCurrentObj = _pGolObjects;
008526  808B30     MOV 0x1166, W0
008528  780F00     MOV W0, [W14]
352:                   while(pCurrentObj != NULL)
00852A  37000F     BRA 0x854A
00854A  78001E     MOV [W14], W0
00854C  500FE0     SUB W0, #0x0, [W15]
00854E  3AFFEE     BRA NZ, 0x852C
353:                   {
354:                       pNextObj = (OBJ_HEADER *)pCurrentObj->pNxtObj;
00852C  78001E     MOV [W14], W0
00852E  900010     MOV [W0+2], W0
008530  980710     MOV W0, [W14+2]
355:               		
356:               		// check if there are additional items to free
357:                       if(pCurrentObj->FreeObj)
008532  78001E     MOV [W14], W0
008534  900820     MOV [W0+20], W0
008536  500FE0     SUB W0, #0x0, [W15]
008538  320004     BRA Z, 0x8542
358:                           pCurrentObj->FreeObj(pCurrentObj);
00853A  78001E     MOV [W14], W0
00853C  9008A0     MOV [W0+20], W1
00853E  78001E     MOV [W14], W0
008540  010001     CALL W1
359:               
360:                       GFX_free(pCurrentObj);
008542  78001E     MOV [W14], W0
008544  07CDA0     RCALL _free
361:                       pCurrentObj = pNextObj;
008546  90001E     MOV [W14+2], W0
008548  780F00     MOV W0, [W14]
362:                   }
363:               
364:                   GOLNewList();
008550  EB0000     CLR W0
008552  888B30     MOV W0, 0x1166
008554  EB0000     CLR W0
008556  888B50     MOV W0, 0x116A
365:               
366:               	#ifdef USE_DOUBLE_BUFFERING
367:               	
368:               	    InvalidateAll();
369:               
370:               	#endif
371:               }
008558  FA8000     ULNK
00855A  060000     RETURN
372:               
373:               /*********************************************************************
374:               * Function: BOOL GOLDeleteObject(OBJ_HEADER * object)
375:               *
376:               * PreCondition: none
377:               *
378:               * Input: pointer to the object
379:               *
380:               * Output: none
381:               *
382:               * Side Effects: none
383:               *
384:               * Overview: Deletes an object to the linked list objects for the current screen.
385:               *
386:               * Note: none
387:               *
388:               ********************************************************************/
389:               BOOL GOLDeleteObject(OBJ_HEADER *object)
390:               {
00855C  FA0006     LNK #0x6
00855E  980720     MOV W0, [W14+4]
391:                   if(!_pGolObjects)
008560  808B30     MOV 0x1166, W0
008562  500FE0     SUB W0, #0x0, [W15]
008564  3A0002     BRA NZ, 0x856A
392:                       return (FALSE);
008566  EB0000     CLR W0
008568  370030     BRA 0x85CA
393:               
394:                   if(object == _pGolObjects)
00856A  808B30     MOV 0x1166, W0
00856C  9000AE     MOV [W14+4], W1
00856E  508F80     SUB W1, W0, [W15]
008570  3A0004     BRA NZ, 0x857A
395:                   {
396:                       _pGolObjects = (OBJ_HEADER *)object->pNxtObj;
008572  90002E     MOV [W14+4], W0
008574  900010     MOV [W0+2], W0
008576  888B30     MOV W0, 0x1166
008578  37001D     BRA 0x85B4
397:                   }
398:                   else
399:                   {
400:                       OBJ_HEADER  *curr;
401:                       OBJ_HEADER  *prev;
402:               
403:                       curr = (OBJ_HEADER *)_pGolObjects->pNxtObj;
00857A  808B30     MOV 0x1166, W0
00857C  900010     MOV [W0+2], W0
00857E  780F00     MOV W0, [W14]
404:                       prev = (OBJ_HEADER *)_pGolObjects;
008580  808B30     MOV 0x1166, W0
008582  980710     MOV W0, [W14+2]
405:               
406:                       while(curr)
008584  370009     BRA 0x8598
008598  78001E     MOV [W14], W0
00859A  500FE0     SUB W0, #0x0, [W15]
00859C  3AFFF4     BRA NZ, 0x8586
00859E  370001     BRA 0x85A2
407:                       {
408:                           if(curr == object)
008586  90002E     MOV [W14+4], W0
008588  78009E     MOV [W14], W1
00858A  508F80     SUB W1, W0, [W15]
00858C  320009     BRA Z, 0x85A0
409:                               break;
0085A0  000000     NOP
410:               
411:                           prev = (OBJ_HEADER *)curr;
00858E  78001E     MOV [W14], W0
008590  980710     MOV W0, [W14+2]
412:                           curr = (OBJ_HEADER *)curr->pNxtObj;
008592  78001E     MOV [W14], W0
008594  900010     MOV [W0+2], W0
008596  780F00     MOV W0, [W14]
413:                       }
414:               
415:                       if(!curr)
0085A2  78001E     MOV [W14], W0
0085A4  500FE0     SUB W0, #0x0, [W15]
0085A6  3A0002     BRA NZ, 0x85AC
416:                           return (FALSE);
0085A8  EB0000     CLR W0
0085AA  37000F     BRA 0x85CA
417:               
418:                       prev->pNxtObj = curr->pNxtObj;
0085AC  78001E     MOV [W14], W0
0085AE  900090     MOV [W0+2], W1
0085B0  90001E     MOV [W14+2], W0
0085B2  980011     MOV W1, [W0+2]
419:                   }
420:               
421:                   if(object->FreeObj)
0085B4  90002E     MOV [W14+4], W0
0085B6  900820     MOV [W0+20], W0
0085B8  500FE0     SUB W0, #0x0, [W15]
0085BA  320004     BRA Z, 0x85C4
422:                       object->FreeObj(object);
0085BC  90002E     MOV [W14+4], W0
0085BE  9008A0     MOV [W0+20], W1
0085C0  90002E     MOV [W14+4], W0
0085C2  010001     CALL W1
423:               
424:                   GFX_free(object);
0085C4  90002E     MOV [W14+4], W0
0085C6  07CD5F     RCALL _free
425:               
426:                   return (TRUE);
0085C8  200010     MOV #0x1, W0
427:               }
0085CA  FA8000     ULNK
0085CC  060000     RETURN
428:               
429:               /*********************************************************************
430:               * Function: BOOL GOLDeleteObject(OBJ_HEADER * object)
431:               *
432:               * PreCondition: none
433:               *
434:               * Input: pointer to the object
435:               *
436:               * Output: none
437:               *
438:               * Side Effects: none
439:               *
440:               * Overview: Deletes an object to the linked list objects for the current screen using
441:               *           the given ID to search for the object.
442:               *
443:               * Note: none
444:               *
445:               ********************************************************************/
446:               BOOL GOLDeleteObjectByID(WORD ID)
447:               {
0085CE  FA0004     LNK #0x4
0085D0  980710     MOV W0, [W14+2]
448:                   OBJ_HEADER  *object;
449:               
450:                   object = GOLFindObject(ID);
0085D2  90001E     MOV [W14+2], W0
0085D4  07000A     RCALL GOLFindObject
0085D6  780F00     MOV W0, [W14]
451:               
452:                   if(!object)
0085D8  78001E     MOV [W14], W0
0085DA  500FE0     SUB W0, #0x0, [W15]
0085DC  3A0002     BRA NZ, 0x85E2
453:                       return (FALSE);
0085DE  EB0000     CLR W0
0085E0  370002     BRA 0x85E6
454:               
455:                   return (GOLDeleteObject(object));
0085E2  78001E     MOV [W14], W0
0085E4  07FFBB     RCALL GOLDeleteObject
456:               }
0085E6  FA8000     ULNK
0085E8  060000     RETURN
457:               
458:               /*********************************************************************
459:               * Function: OBJ_HEADER* GOLFindObject(WORD ID)
460:               *
461:               * PreCondition: none
462:               *
463:               * Input: object ID
464:               *
465:               * Output: pointer to the object
466:               *
467:               * Side Effects: none
468:               *
469:               * Overview: searches for the object by its ID in the current objects linked list,
470:               *           returns NULL if the object is not found
471:               *
472:               * Note: none
473:               *
474:               ********************************************************************/
475:               OBJ_HEADER *GOLFindObject(WORD ID)
476:               {
0085EA  FA0004     LNK #0x4
0085EC  980710     MOV W0, [W14+2]
477:                   OBJ_HEADER  *pNextObj;
478:               
479:                   pNextObj = _pGolObjects;
0085EE  808B30     MOV 0x1166, W0
0085F0  780F00     MOV W0, [W14]
480:                   while(pNextObj != NULL)
0085F2  37000A     BRA 0x8608
008608  78001E     MOV [W14], W0
00860A  500FE0     SUB W0, #0x0, [W15]
00860C  3AFFF3     BRA NZ, 0x85F4
481:                   {
482:                       if(pNextObj->ID == ID)
0085F4  78001E     MOV [W14], W0
0085F6  780090     MOV [W0], W1
0085F8  90001E     MOV [W14+2], W0
0085FA  508F80     SUB W1, W0, [W15]
0085FC  3A0002     BRA NZ, 0x8602
483:                       {
484:                           return (pNextObj);
0085FE  78001E     MOV [W14], W0
008600  370007     BRA 0x8610
485:                       }
486:               
487:                       pNextObj = (OBJ_HEADER *)pNextObj->pNxtObj;
008602  78001E     MOV [W14], W0
008604  900010     MOV [W0+2], W0
008606  780F00     MOV W0, [W14]
488:                   }
489:               
490:                   return (NULL);
00860E  EB0000     CLR W0
491:               }
008610  FA8000     ULNK
008612  060000     RETURN
492:               
493:               /*********************************************************************
494:               * Function: void GOLAddObject(OBJ_HEADER * object)
495:               *
496:               * PreCondition: none
497:               *
498:               * Input: pointer to the object
499:               *
500:               * Output: none
501:               *
502:               * Side Effects: none
503:               *
504:               * Overview: adds an object to the linked list objects for the current screen.
505:               *           Object will be drawn and will receive messages.
506:               *
507:               * Note: none
508:               *
509:               ********************************************************************/
510:               void GOLAddObject(OBJ_HEADER *object)
511:               {
008614  FA0004     LNK #0x4
008616  980710     MOV W0, [W14+2]
512:                   OBJ_HEADER  *pNextObj;
513:               
514:                   if(_pGolObjects == NULL)
008618  808B30     MOV 0x1166, W0
00861A  500FE0     SUB W0, #0x0, [W15]
00861C  3A0003     BRA NZ, 0x8624
515:                   {
516:                       _pGolObjects = object;
00861E  90001E     MOV [W14+2], W0
008620  888B30     MOV W0, 0x1166
008622  37000D     BRA 0x863E
517:                   }
518:                   else
519:                   {
520:                       pNextObj = _pGolObjects;
008624  808B31     MOV 0x1166, W1
008626  780F01     MOV W1, [W14]
521:                       while(pNextObj->pNxtObj != NULL)
008628  370003     BRA 0x8630
008630  78001E     MOV [W14], W0
008632  900010     MOV [W0+2], W0
008634  500FE0     SUB W0, #0x0, [W15]
008636  3AFFF9     BRA NZ, 0x862A
522:                       {
523:                           pNextObj = (OBJ_HEADER *)pNextObj->pNxtObj;
00862A  78001E     MOV [W14], W0
00862C  900010     MOV [W0+2], W0
00862E  780F00     MOV W0, [W14]
524:                       }
525:               
526:                       pNextObj->pNxtObj = (void *)object;
008638  78001E     MOV [W14], W0
00863A  90009E     MOV [W14+2], W1
00863C  980011     MOV W1, [W0+2]
527:                   }
528:               
529:                   object->pNxtObj = NULL;
00863E  90001E     MOV [W14+2], W0
008640  EB0080     CLR W1
008642  980011     MOV W1, [W0+2]
530:               }
008644  FA8000     ULNK
008646  060000     RETURN
531:               
532:               /*********************************************************************
533:               * Function: WORD GOLDraw()
534:               *
535:               * PreCondition: none
536:               *
537:               * Input: none
538:               *
539:               * Output: non-zero if drawing is complete
540:               *
541:               * Side Effects: none
542:               *
543:               * Overview: redraws objects in the current linked list
544:               *
545:               * Note: none
546:               *
547:               ********************************************************************/
548:               WORD GOLDraw(void)
549:               {
008648  FA0002     LNK #0x2
550:                   static OBJ_HEADER   *pCurrentObj = NULL;
551:                   SHORT               done;
552:               
553:                   #ifdef USE_DOUBLE_BUFFERING
554:                   static BYTE         DisplayUpdated = 0;
555:                   if(IsDisplayUpdatePending())
556:                   {
557:                       return 0;
558:                   }
559:                   #endif // USE_DOUBLE_BUFFERING
560:               
561:                   if(pCurrentObj == NULL)
00864A  808910     MOV pCurrentObj, W0
00864C  500FE0     SUB W0, #0x0, [W15]
00864E  3A0008     BRA NZ, 0x8660
562:                   {
563:                       if(GOLDrawCallback())
008650  072032     RCALL GOLDrawCallback
008652  500FE0     SUB W0, #0x0, [W15]
008654  320003     BRA Z, 0x865C
564:                       {
565:                           #ifdef USE_DOUBLE_BUFFERING
566:               				#ifdef USE_TRANSITION_EFFECTS
567:                               if(TransitionPendingStatus)
568:                               {
569:                                   TransitionPendingStatus = 0;
570:               	                while(IsDisplayUpdatePending());
571:                                  	GFXExecutePendingTransition(GetDrawBufferAddress(), GetFrameBufferAddress());
572:                               }
573:               				#endif
574:                           #endif //USE_DOUBLE_BUFFERING
575:                           
576:                           // It's last object jump to head
577:                           pCurrentObj = _pGolObjects;
008656  808B30     MOV 0x1166, W0
008658  888910     MOV W0, pCurrentObj
00865A  370002     BRA 0x8660
578:               
579:                           #ifdef USE_DOUBLE_BUFFERING
580:                           if(DisplayUpdated)
581:                           {
582:                               RequestDisplayUpdate();
583:                               DisplayUpdated = 0;
584:                               return(0);
585:                           }
586:                           #endif //USE_DOUBLE_BUFFERING
587:                       }
588:                       else
589:                       {
590:                           return (0);     // drawing is not done
00865C  EB0000     CLR W0
00865E  370021     BRA 0x86A2
591:                       }
592:                   }
593:               
594:                   done = 0;
008660  EB0000     CLR W0
008662  780F00     MOV W0, [W14]
595:                   while(pCurrentObj != NULL)
008664  37001A     BRA 0x869A
00869A  808910     MOV pCurrentObj, W0
00869C  500FE0     SUB W0, #0x0, [W15]
00869E  3AFFE3     BRA NZ, 0x8666
596:                   {
597:                       if(IsObjUpdated(pCurrentObj))
008666  808910     MOV pCurrentObj, W0
008668  9000B0     MOV [W0+6], W1
00866A  2FC000     MOV #0xFC00, W0
00866C  608000     AND W1, W0, W0
00866E  500FE0     SUB W0, #0x0, [W15]
008670  320011     BRA Z, 0x8694
598:                       {
599:                           done = pCurrentObj->DrawObj(pCurrentObj);
008672  808910     MOV pCurrentObj, W0
008674  900890     MOV [W0+18], W1
008676  808910     MOV pCurrentObj, W0
008678  010001     CALL W1
00867A  780F00     MOV W0, [W14]
600:               
601:                           if(done)
00867C  78001E     MOV [W14], W0
00867E  500FE0     SUB W0, #0x0, [W15]
008680  320007     BRA Z, 0x8690
602:                           {
603:                               GOLDrawComplete(pCurrentObj);
008682  808910     MOV pCurrentObj, W0
008684  808911     MOV pCurrentObj, W1
008686  900131     MOV [W1+6], W2
008688  203FF1     MOV #0x3FF, W1
00868A  610081     AND W2, W1, W1
00868C  980031     MOV W1, [W0+6]
00868E  370002     BRA 0x8694
604:               
605:               			#ifdef USE_DOUBLE_BUFFERING
606:               
607:               			    InvalidateRectangle(pCurrentObj->left, pCurrentObj->top,
608:               			                        pCurrentObj->right, pCurrentObj->bottom);
609:                               DisplayUpdated = 1;
610:               
611:               			#endif //USE_DOUBLE_BUFFERING
612:               
613:                           }
614:                           else
615:                           {
616:                               return (0); // drawing is not done
008690  EB0000     CLR W0
008692  370007     BRA 0x86A2
617:                           }
618:                       }
619:               
620:                       pCurrentObj = (OBJ_HEADER *)pCurrentObj->pNxtObj;
008694  808910     MOV pCurrentObj, W0
008696  900010     MOV [W0+2], W0
008698  888910     MOV W0, pCurrentObj
621:                   }
622:               
623:               	#if defined(USE_TRANSITION_EFFECTS) && defined(USE_DOUBLE_BUFFERING)
624:               
625:                       TransitionPendingStatus = GFXIsTransitionPending();
626:               	    InvalidateAll(); //If needed, invalidate only the transition rectangle instead
627:               
628:               	#endif
629:               
630:                   return (1);             // drawing is completed
0086A0  200010     MOV #0x1, W0
631:               }
0086A2  FA8000     ULNK
0086A4  060000     RETURN
632:               
633:               /*********************************************************************
634:               * Function: void GOLRedrawRec(SHORT left, SHORT top, SHORT right, SHORT bottom)
635:               *
636:               * PreCondition: none
637:               *
638:               * Input: left,top,right,bottom - rectangle borders
639:               *
640:               * Output: none
641:               *
642:               * Side Effects: none
643:               *
644:               * Overview: marks objects with parts in the rectangle to be redrawn
645:               *
646:               * Note: none
647:               *
648:               ********************************************************************/
649:               void GOLRedrawRec(SHORT left, SHORT top, SHORT right, SHORT bottom)
650:               {
0086A6  FA000E     LNK #0xE
0086A8  980730     MOV W0, [W14+6]
0086AA  980741     MOV W1, [W14+8]
0086AC  980752     MOV W2, [W14+10]
0086AE  980763     MOV W3, [W14+12]
651:               
652:                  OBJ_HEADER  *pCurrentObj;
653:                   int overlapX, overlapY;
654:               
655:                   pCurrentObj = _pGolObjects;
0086B0  808B30     MOV 0x1166, W0
0086B2  780F00     MOV W0, [W14]
656:               
657:                   while(pCurrentObj != NULL)
0086B4  370066     BRA 0x8782
008782  78001E     MOV [W14], W0
008784  500FE0     SUB W0, #0x0, [W15]
008786  3AFF97     BRA NZ, 0x86B6
658:                   {
659:                       overlapX = overlapY = 0;
0086B6  EB0000     CLR W0
0086B8  980720     MOV W0, [W14+4]
0086BA  90002E     MOV [W14+4], W0
0086BC  980710     MOV W0, [W14+2]
660:               
661:                       // check overlaps in x direction
662:                       if( ((pCurrentObj->left <= left) &&  (pCurrentObj->right >= left))    ||  \
0086BE  78001E     MOV [W14], W0
0086C0  9000C0     MOV [W0+8], W1
0086C2  90003E     MOV [W14+6], W0
0086C4  508F80     SUB W1, W0, [W15]
0086C6  3C0005     BRA GT, 0x86D2
0086C8  78001E     MOV [W14], W0
0086CA  9000E0     MOV [W0+12], W1
0086CC  90003E     MOV [W14+6], W0
0086CE  508F80     SUB W1, W0, [W15]
0086D0  3D001E     BRA GE, 0x870E
0086D6  90005E     MOV [W14+10], W0
0086D8  508F80     SUB W1, W0, [W15]
0086DA  3C0005     BRA GT, 0x86E6
663:                           ((pCurrentObj->left <= right) &&  (pCurrentObj->right >= right))  ||  \
0086D2  78001E     MOV [W14], W0
0086D4  9000C0     MOV [W0+8], W1
0086DC  78001E     MOV [W14], W0
0086DE  9000E0     MOV [W0+12], W1
0086E0  90005E     MOV [W14+10], W0
0086E2  508F80     SUB W1, W0, [W15]
0086E4  3D0014     BRA GE, 0x870E
0086EA  90003E     MOV [W14+6], W0
0086EC  508F80     SUB W1, W0, [W15]
0086EE  3C0005     BRA GT, 0x86FA
664:                           ((pCurrentObj->left <= left) &&  (pCurrentObj->right >= right))   ||  \
0086E6  78001E     MOV [W14], W0
0086E8  9000C0     MOV [W0+8], W1
0086F0  78001E     MOV [W14], W0
0086F2  9000E0     MOV [W0+12], W1
0086F4  90005E     MOV [W14+10], W0
0086F6  508F80     SUB W1, W0, [W15]
0086F8  3D000A     BRA GE, 0x870E
0086FE  90003E     MOV [W14+6], W0
008700  508F80     SUB W1, W0, [W15]
008702  350007     BRA LT, 0x8712
665:                           ((pCurrentObj->left >= left) &&  (pCurrentObj->right <= right))       \
0086FA  78001E     MOV [W14], W0
0086FC  9000C0     MOV [W0+8], W1
008704  78001E     MOV [W14], W0
008706  9000E0     MOV [W0+12], W1
008708  90005E     MOV [W14+10], W0
00870A  508F80     SUB W1, W0, [W15]
00870C  3C0002     BRA GT, 0x8712
666:                         )
667:                           overlapX = 1;
00870E  200010     MOV #0x1, W0
008710  980710     MOV W0, [W14+2]
668:                   
669:                       // check overlaps in y direction
670:                       if( ((pCurrentObj->top <= top) &&  (pCurrentObj->bottom >= top))      ||  \
008712  78001E     MOV [W14], W0
008714  9000D0     MOV [W0+10], W1
008716  90004E     MOV [W14+8], W0
008718  508F80     SUB W1, W0, [W15]
00871A  3C0005     BRA GT, 0x8726
00871C  78001E     MOV [W14], W0
00871E  9000F0     MOV [W0+14], W1
008720  90004E     MOV [W14+8], W0
008722  508F80     SUB W1, W0, [W15]
008724  3D001E     BRA GE, 0x8762
00872A  90006E     MOV [W14+12], W0
00872C  508F80     SUB W1, W0, [W15]
00872E  3C0005     BRA GT, 0x873A
671:                           ((pCurrentObj->top <= bottom) &&  (pCurrentObj->bottom >= bottom))||  \
008726  78001E     MOV [W14], W0
008728  9000D0     MOV [W0+10], W1
008730  78001E     MOV [W14], W0
008732  9000F0     MOV [W0+14], W1
008734  90006E     MOV [W14+12], W0
008736  508F80     SUB W1, W0, [W15]
008738  3D0014     BRA GE, 0x8762
00873E  90004E     MOV [W14+8], W0
008740  508F80     SUB W1, W0, [W15]
008742  3C0005     BRA GT, 0x874E
672:                           ((pCurrentObj->top <= top) &&  (pCurrentObj->bottom >= bottom))   ||  \
00873A  78001E     MOV [W14], W0
00873C  9000D0     MOV [W0+10], W1
008744  78001E     MOV [W14], W0
008746  9000F0     MOV [W0+14], W1
008748  90006E     MOV [W14+12], W0
00874A  508F80     SUB W1, W0, [W15]
00874C  3D000A     BRA GE, 0x8762
008752  90004E     MOV [W14+8], W0
008754  508F80     SUB W1, W0, [W15]
008756  350007     BRA LT, 0x8766
673:                           ((pCurrentObj->top >= top) &&  (pCurrentObj->bottom <= bottom))       \
00874E  78001E     MOV [W14], W0
008750  9000D0     MOV [W0+10], W1
008758  78001E     MOV [W14], W0
00875A  9000F0     MOV [W0+14], W1
00875C  90006E     MOV [W14+12], W0
00875E  508F80     SUB W1, W0, [W15]
008760  3C0002     BRA GT, 0x8766
674:                         )
675:                           overlapY = 1;
008762  200010     MOV #0x1, W0
008764  980720     MOV W0, [W14+4]
676:                       
677:                       // when any portion of the widget is touched by the defined rectangle the
678:                       // x and y overlaps will exist.
679:                       if (overlapX & overlapY)
008766  90009E     MOV [W14+2], W1
008768  90002E     MOV [W14+4], W0
00876A  608000     AND W1, W0, W0
00876C  500FE0     SUB W0, #0x0, [W15]
00876E  320006     BRA Z, 0x877C
680:               		{
681:                       	GOLRedraw(pCurrentObj);
008770  78001E     MOV [W14], W0
008772  9000B0     MOV [W0+6], W1
008774  27C000     MOV #0x7C00, W0
008776  708080     IOR W1, W0, W1
008778  78001E     MOV [W14], W0
00877A  980031     MOV W1, [W0+6]
682:                       }
683:                   
684:                       pCurrentObj = (OBJ_HEADER *)pCurrentObj->pNxtObj;
00877C  78001E     MOV [W14], W0
00877E  900010     MOV [W0+2], W0
008780  780F00     MOV W0, [W14]
685:                   }   //end of while
686:               
687:               }
008788  FA8000     ULNK
00878A  060000     RETURN
688:               
689:               /*********************************************************************
690:               * Function: void GOLMsg(GOL_MSG *pMsg)
691:               *
692:               * PreCondition: none
693:               *
694:               * Input: pointer to the message
695:               *
696:               * Output: none
697:               *
698:               * Side Effects: none
699:               *
700:               * Overview: processes message for all objects in the liked list
701:               *
702:               * Note: none
703:               *
704:               ********************************************************************/
705:               void GOLMsg(GOL_MSG *pMsg)
706:               {
00878C  FA0006     LNK #0x6
00878E  980720     MOV W0, [W14+4]
707:                   OBJ_HEADER  *pCurrentObj;
708:                   WORD        translatedMsg;
709:               
710:                   if(pMsg->uiEvent == EVENT_INVALID)
008790  90002E     MOV [W14+4], W0
008792  904010     MOV.B [W0+1], W0
008794  504FE0     SUB.B W0, #0x0, [W15]
008796  320027     BRA Z, 0x87E6
711:                       return;
0087E6  000000     NOP
712:               
713:                   pCurrentObj = _pGolObjects;
008798  808B30     MOV 0x1166, W0
00879A  780F00     MOV W0, [W14]
714:               
715:                   while(pCurrentObj != NULL)
00879C  370020     BRA 0x87DE
0087DE  78001E     MOV [W14], W0
0087E0  500FE0     SUB W0, #0x0, [W15]
0087E2  3AFFDD     BRA NZ, 0x879E
0087E4  370001     BRA 0x87E8
716:                   {
717:                       if(pCurrentObj->MsgObj)
00879E  78001E     MOV [W14], W0
0087A0  900830     MOV [W0+22], W0
0087A2  500FE0     SUB W0, #0x0, [W15]
0087A4  320019     BRA Z, 0x87D8
718:                       {
719:                           translatedMsg = pCurrentObj->MsgObj(pCurrentObj, pMsg);
0087A6  78001E     MOV [W14], W0
0087A8  900930     MOV [W0+22], W2
0087AA  9000AE     MOV [W14+4], W1
0087AC  78001E     MOV [W14], W0
0087AE  010002     CALL W2
0087B0  980710     MOV W0, [W14+2]
720:               
721:                           if(translatedMsg != OBJ_MSG_INVALID)
0087B2  90001E     MOV [W14+2], W0
0087B4  500FE0     SUB W0, #0x0, [W15]
0087B6  320010     BRA Z, 0x87D8
722:                           {
723:                               if(GOLMsgCallback(translatedMsg, pCurrentObj, pMsg))
0087B8  90012E     MOV [W14+4], W2
0087BA  78009E     MOV [W14], W1
0087BC  90001E     MOV [W14+2], W0
0087BE  071F7F     RCALL GOLMsgCallback
0087C0  500FE0     SUB W0, #0x0, [W15]
0087C2  32000A     BRA Z, 0x87D8
724:                                   if(pCurrentObj->MsgDefaultObj)
0087C4  78001E     MOV [W14], W0
0087C6  900840     MOV [W0+24], W0
0087C8  500FE0     SUB W0, #0x0, [W15]
0087CA  320006     BRA Z, 0x87D8
725:                                       pCurrentObj->MsgDefaultObj(translatedMsg, pCurrentObj, pMsg);
0087CC  78001E     MOV [W14], W0
0087CE  9009C0     MOV [W0+24], W3
0087D0  90012E     MOV [W14+4], W2
0087D2  78009E     MOV [W14], W1
0087D4  90001E     MOV [W14+2], W0
0087D6  010003     CALL W3
726:                           }
727:                       }
728:               
729:                       pCurrentObj = (OBJ_HEADER *)pCurrentObj->pNxtObj;
0087D8  78001E     MOV [W14], W0
0087DA  900010     MOV [W0+2], W0
0087DC  780F00     MOV W0, [W14]
730:                   }
731:               }
0087E8  FA8000     ULNK
0087EA  060000     RETURN
732:               
733:               /*********************************************************************
734:               * Variables for rounded panel drawing. Used by GOLRndPanelDraw and GOLRndPanelDrawTsk
735:               ********************************************************************/
736:               SHORT   _rpnlX1,        // Center x position of upper left corner
737:               _rpnlY1,                // Center y position of upper left corner
738:               _rpnlX2,                // Center x position of lower right corner
739:               _rpnlY2,                // Center y position of lower right corner
740:               _rpnlR;                 // radius
741:               GFX_COLOR _rpnlFaceColor,   // face color
742:               _rpnlEmbossLtColor,         // emboss light color
743:               _rpnlEmbossDkColor,         // emboss dark color
744:               _rpnlEmbossSize;            // emboss size
745:               
746:               #ifdef USE_ALPHABLEND_LITE
747:               WORD        _rpnlAlpha; // alpha value
748:               #endif
749:               
750:               void    *_pRpnlBitmap = NULL;
751:               
752:               /*********************************************************************
753:               * Function: WORD GOLPanelDrawTsk(void) 
754:               *
755:               * PreCondition: parameters must be set with
756:               *               GOLRndPanelDraw(x,y,radius,width,height,faceClr,embossLtClr,
757:               *								embossDkClr,pBitmap,embossSize)
758:               *
759:               * Input: None
760:               *
761:               * Output: Output: non-zero if drawing is completed
762:               *
763:               * Overview: draws a rounded panel on screen. Must be called repeatedly. Drawing is done
764:               *           when it returns non-zero. 
765:               *
766:               * Note: none
767:               *
768:               ********************************************************************/
769:               WORD GOLPanelDrawTsk(void)
770:               {
0087EC  FA0002     LNK #0x2
0087EE  BE9F88     MOV.D W8, [W15++]
0087F0  781F8A     MOV W10, [W15++]
771:               
772:               #ifndef USE_NONBLOCKING_CONFIG
773:               
774:                   WORD    counter;
775:               
776:                   // check if we need to draw the panels and emboss sides
777:                   if 	(
0087F4  500FE0     SUB W0, #0x0, [W15]
0087F6  320017     BRA Z, 0x8826
778:                   		(_pRpnlBitmap == NULL) || 
0087F2  808B60     MOV 0x116C, W0
008808  540F80     SUB W8, W0, [W15]
00880A  3400BA     BRA LE, 0x8980
779:                   		(
780:                   			((_rpnlX2 - _rpnlX1 + (_rpnlR<<1)) > GetImageWidth((void *)_pRpnlBitmap)) 	&& 
0087F8  8088C1     MOV _rpnlX2, W1
0087FA  8088A0     MOV _rpnlX1, W0
0087FC  508080     SUB W1, W0, W1
0087FE  8088E0     MOV _rpnlR, W0
008800  400000     ADD W0, W0, W0
008802  408400     ADD W1, W0, W8
008804  808B60     MOV 0x116C, W0
008806  07EF36     RCALL GetImageWidth
00881C  540F80     SUB W8, W0, [W15]
00881E  3400B0     BRA LE, 0x8980
781:                           	((_rpnlY2 - _rpnlY1 + (_rpnlR<<1)) > GetImageHeight((void *)_pRpnlBitmap))	&&
00880C  8088D1     MOV _rpnlY2, W1
00880E  8088B0     MOV _rpnlY1, W0
008810  508080     SUB W1, W0, W1
008812  8088E0     MOV _rpnlR, W0
008814  400000     ADD W0, W0, W0
008816  408400     ADD W1, W0, W8
008818  808B60     MOV 0x116C, W0
00881A  07EF41     RCALL GetImageHeight
008822  500FE0     SUB W0, #0x0, [W15]
008824  3200AD     BRA Z, 0x8980
782:                   			(_pRpnlBitmap != NULL)	
008820  808B60     MOV 0x116C, W0
783:               			)
784:                       )
785:                   {
786:               	    if(_rpnlR)
008826  8088E0     MOV _rpnlR, W0
008828  500FE0     SUB W0, #0x0, [W15]
00882A  32001B     BRA Z, 0x8862
787:               	    {
788:               	
789:               	        // draw upper left portion of the embossed area
790:               	        SetColor(_rpnlEmbossLtColor);
00882C  BFD11F     MOV.B _rpnlEmbossLtColor, WREG
00882E  B7F13E     MOV.B WREG, _color
791:               	        Arc(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize, _rpnlR, 0xE1);
008830  8088E5     MOV _rpnlR, W5
008832  8088E1     MOV _rpnlR, W1
008834  BFD121     MOV.B _rpnlEmbossSize, WREG
008836  FB8000     ZE W0, W0
008838  508200     SUB W1, W0, W4
00883A  8088D3     MOV _rpnlY2, W3
00883C  8088C2     MOV _rpnlX2, W2
00883E  8088B1     MOV _rpnlY1, W1
008840  8088A0     MOV _rpnlX1, W0
008842  B3CE16     MOV #0xE1, W6
008844  07E7A8     RCALL Arc
792:               	
793:               	        // draw lower right portion of the embossed area
794:               	        SetColor(_rpnlEmbossDkColor);
008846  BFD120     MOV.B _rpnlEmbossDkColor, WREG
008848  B7F13E     MOV.B WREG, _color
795:               	        Arc(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize, _rpnlR, 0x1E);
00884A  8088E5     MOV _rpnlR, W5
00884C  8088E1     MOV _rpnlR, W1
00884E  BFD121     MOV.B _rpnlEmbossSize, WREG
008850  FB8000     ZE W0, W0
008852  508200     SUB W1, W0, W4
008854  8088D3     MOV _rpnlY2, W3
008856  8088C2     MOV _rpnlX2, W2
008858  8088B1     MOV _rpnlY1, W1
00885A  8088A0     MOV _rpnlX1, W0
00885C  B3C1E6     MOV #0x1E, W6
00885E  07E79B     RCALL Arc
008860  370044     BRA 0x88EA
796:               	    }
797:               	    else
798:               	    {
799:               	
800:               	        // object is rectangular panel draw the embossed areas
801:               	        counter = 1;
008862  200010     MOV #0x1, W0
008864  780F00     MOV W0, [W14]
802:               	        SetColor(_rpnlEmbossLtColor);
008866  BFD11F     MOV.B _rpnlEmbossLtColor, WREG
008868  B7F13E     MOV.B WREG, _color
803:               	        while(counter < _rpnlEmbossSize)
00886A  370019     BRA 0x889E
00889E  BFD121     MOV.B _rpnlEmbossSize, WREG
0088A0  FB8000     ZE W0, W0
0088A2  500F9E     SUB W0, [W14], [W15]
0088A4  3EFFE3     BRA GTU, 0x886C
804:               	        {
805:               	            Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY1 + counter);    // draw top
00886C  8088B0     MOV _rpnlY1, W0
00886E  40001E     ADD W0, [W14], W0
008870  780180     MOV W0, W3
008872  8088C0     MOV _rpnlX2, W0
008874  50001E     SUB W0, [W14], W0
008876  780100     MOV W0, W2
008878  8088B0     MOV _rpnlY1, W0
00887A  40001E     ADD W0, [W14], W0
00887C  780080     MOV W0, W1
00887E  8088A0     MOV _rpnlX1, W0
008880  40001E     ADD W0, [W14], W0
008882  07E61C     RCALL Bar
806:               	            Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX1 + counter, _rpnlY2 - counter);    // draw left
008884  8088D0     MOV _rpnlY2, W0
008886  50001E     SUB W0, [W14], W0
008888  780180     MOV W0, W3
00888A  8088A0     MOV _rpnlX1, W0
00888C  40001E     ADD W0, [W14], W0
00888E  780100     MOV W0, W2
008890  8088B0     MOV _rpnlY1, W0
008892  40001E     ADD W0, [W14], W0
008894  780080     MOV W0, W1
008896  8088A0     MOV _rpnlX1, W0
008898  40001E     ADD W0, [W14], W0
00889A  07E610     RCALL Bar
807:               	            counter++;
00889C  E80F1E     INC [W14], [W14]
808:               	        }
809:               	
810:               	        counter = 1;
0088A6  200010     MOV #0x1, W0
0088A8  780F00     MOV W0, [W14]
811:               	        SetColor(_rpnlEmbossDkColor);
0088AA  BFD120     MOV.B _rpnlEmbossDkColor, WREG
0088AC  B7F13E     MOV.B WREG, _color
812:               	        while(counter < _rpnlEmbossSize)
0088AE  370019     BRA 0x88E2
0088E2  BFD121     MOV.B _rpnlEmbossSize, WREG
0088E4  FB8000     ZE W0, W0
0088E6  500F9E     SUB W0, [W14], [W15]
0088E8  3EFFE3     BRA GTU, 0x88B0
813:               	        {
814:               	            Bar(_rpnlX1 + counter, _rpnlY2 - counter, _rpnlX2 - counter, _rpnlY2 - counter);    // draw bottom
0088B0  8088D0     MOV _rpnlY2, W0
0088B2  50001E     SUB W0, [W14], W0
0088B4  780180     MOV W0, W3
0088B6  8088C0     MOV _rpnlX2, W0
0088B8  50001E     SUB W0, [W14], W0
0088BA  780100     MOV W0, W2
0088BC  8088D0     MOV _rpnlY2, W0
0088BE  50001E     SUB W0, [W14], W0
0088C0  780080     MOV W0, W1
0088C2  8088A0     MOV _rpnlX1, W0
0088C4  40001E     ADD W0, [W14], W0
0088C6  07E5FA     RCALL Bar
815:               	            Bar(_rpnlX2 - counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY2 - counter);    // draw right	
0088C8  8088D0     MOV _rpnlY2, W0
0088CA  50001E     SUB W0, [W14], W0
0088CC  780180     MOV W0, W3
0088CE  8088C0     MOV _rpnlX2, W0
0088D0  50001E     SUB W0, [W14], W0
0088D2  780100     MOV W0, W2
0088D4  8088B0     MOV _rpnlY1, W0
0088D6  40001E     ADD W0, [W14], W0
0088D8  780080     MOV W0, W1
0088DA  8088C0     MOV _rpnlX2, W0
0088DC  50001E     SUB W0, [W14], W0
0088DE  07E5EE     RCALL Bar
816:               	            counter++;
0088E0  E80F1E     INC [W14], [W14]
817:               	        }
818:               	    }
819:               	
820:               	    // draw the face color
821:               	    SetColor(_rpnlFaceColor);
0088EA  BFD11E     MOV.B _rpnlFaceColor, WREG
0088EC  B7F13E     MOV.B WREG, _color
822:               #ifdef USE_ALPHABLEND_LITE
823:                       // set alpha value
824:                       SetAlpha(_rpnlAlpha); 
825:               #endif
826:               
827:               	    if(_rpnlR)
0088EE  8088E0     MOV _rpnlR, W0
0088F0  500FE0     SUB W0, #0x0, [W15]
0088F2  32000A     BRA Z, 0x8908
828:               
829:               #ifdef USE_GRADIENT
830:                           if(_gradientScheme.gradientType != GRAD_NONE)
831:                           {
832:                               BevelGradient(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize,
833:                                             _gradientScheme.gradientStartColor,_gradientScheme.gradientEndColor,
834:                                             _gradientScheme.gradientLength,_gradientScheme.gradientType);
835:                           }
836:                           else
837:               #endif
838:               	        FillBevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize);
0088F4  8088E1     MOV _rpnlR, W1
0088F6  BFD121     MOV.B _rpnlEmbossSize, WREG
0088F8  FB8000     ZE W0, W0
0088FA  508200     SUB W1, W0, W4
0088FC  8088D3     MOV _rpnlY2, W3
0088FE  8088C2     MOV _rpnlX2, W2
008900  8088B1     MOV _rpnlY1, W1
008902  8088A0     MOV _rpnlX1, W0
008904  07EB1D     RCALL FillBevel
008906  370011     BRA 0x892A
839:               	    else
840:                           { 
841:               
842:                            Bar(_rpnlX1 + _rpnlEmbossSize, _rpnlY1 + _rpnlEmbossSize, _rpnlX2 - _rpnlEmbossSize, _rpnlY2 - _rpnlEmbossSize);
008908  8088D1     MOV _rpnlY2, W1
00890A  BFD121     MOV.B _rpnlEmbossSize, WREG
00890C  FB8000     ZE W0, W0
00890E  508180     SUB W1, W0, W3
008910  8088C1     MOV _rpnlX2, W1
008912  BFD121     MOV.B _rpnlEmbossSize, WREG
008914  FB8000     ZE W0, W0
008916  508100     SUB W1, W0, W2
008918  BFD121     MOV.B _rpnlEmbossSize, WREG
00891A  FB8080     ZE W0, W1
00891C  8088B0     MOV _rpnlY1, W0
00891E  408080     ADD W1, W0, W1
008920  BFD121     MOV.B _rpnlEmbossSize, WREG
008922  FB8200     ZE W0, W4
008924  8088A0     MOV _rpnlX1, W0
008926  420000     ADD W4, W0, W0
008928  07E5C9     RCALL Bar
843:               	        }
844:               	            #if (COLOR_DEPTH == 1)
845:               	    if(_rpnlFaceColor == _rpnlEmbossDkColor)
00892A  2111E1     MOV #0x111E, W1
00892C  784091     MOV.B [W1], W1
00892E  BFD120     MOV.B _rpnlEmbossDkColor, WREG
008930  50CF80     SUB.B W1, W0, [W15]
008932  3A0026     BRA NZ, 0x8980
846:               	    {
847:               	        SetColor(_rpnlEmbossLtColor);
008934  BFD11F     MOV.B _rpnlEmbossLtColor, WREG
008936  B7F13E     MOV.B WREG, _color
848:               	        if(_rpnlR)
008938  8088E0     MOV _rpnlR, W0
00893A  500FE0     SUB W0, #0x0, [W15]
00893C  32000B     BRA Z, 0x8954
849:               	            Bevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - (_rpnlEmbossSize - 1));
00893E  BFD121     MOV.B _rpnlEmbossSize, WREG
008940  FB8000     ZE W0, W0
008942  1000E1     SUBR W0, #0x1, W1
008944  8088E0     MOV _rpnlR, W0
008946  408200     ADD W1, W0, W4
008948  8088D3     MOV _rpnlY2, W3
00894A  8088C2     MOV _rpnlX2, W2
00894C  8088B1     MOV _rpnlY1, W1
00894E  8088A0     MOV _rpnlX1, W0
008950  07E995     RCALL Bevel
008952  370016     BRA 0x8980
850:               	        else
851:               	            Bevel
852:               	            (
00896E  8088B0     MOV _rpnlY1, W0
008978  8088A0     MOV _rpnlX1, W0
00897C  EB0200     CLR W4
00897E  07E97E     RCALL Bevel
853:               	                _rpnlX1 + (_rpnlEmbossSize - 1),
008972  BFD121     MOV.B _rpnlEmbossSize, WREG
008974  FB8000     ZE W0, W0
008976  E90200     DEC W0, W4
00897A  420000     ADD W4, W0, W0
854:               	                _rpnlY1 + (_rpnlEmbossSize - 1),
008968  BFD121     MOV.B _rpnlEmbossSize, WREG
00896A  FB8000     ZE W0, W0
00896C  E90080     DEC W0, W1
008970  408080     ADD W1, W0, W1
855:               	                _rpnlX2 - (_rpnlEmbossSize - 1),
00895E  BFD121     MOV.B _rpnlEmbossSize, WREG
008960  FB8000     ZE W0, W0
008962  1000E1     SUBR W0, #0x1, W1
008964  8088C0     MOV _rpnlX2, W0
008966  408100     ADD W1, W0, W2
856:               	                _rpnlY2 - (_rpnlEmbossSize - 1),
008954  BFD121     MOV.B _rpnlEmbossSize, WREG
008956  FB8000     ZE W0, W0
008958  1000E1     SUBR W0, #0x1, W1
00895A  8088D0     MOV _rpnlY2, W0
00895C  408180     ADD W1, W0, W3
857:               	                0
858:               	            );
859:               	    }
860:               	
861:               	            #endif
862:               	} // end of check if we need to draw the panels and emboss sides
863:               	
864:                   // draw bitmap
865:                   if(_pRpnlBitmap != NULL)
008980  808B60     MOV 0x116C, W0
008982  500FE0     SUB W0, #0x0, [W15]
008984  320019     BRA Z, 0x89B8
866:                   {
867:                       PutImage
008986  808B69     MOV 0x116C, W9
008988  8088D1     MOV _rpnlY2, W1
00898A  8088B0     MOV _rpnlY1, W0
00898C  408400     ADD W1, W0, W8
00898E  808B60     MOV 0x116C, W0
008990  07EE86     RCALL GetImageHeight
008992  540000     SUB W8, W0, W0
008994  D18000     ASR W0, W0
008996  E80400     INC W0, W8
008998  8088C1     MOV _rpnlX2, W1
00899A  8088A0     MOV _rpnlX1, W0
00899C  408500     ADD W1, W0, W10
00899E  808B60     MOV 0x116C, W0
0089A0  07EE69     RCALL GetImageWidth
0089A2  550000     SUB W10, W0, W0
0089A4  D18000     ASR W0, W0
0089A6  E80000     INC W0, W0
0089A8  EB0380     CLR W7
0089AA  EB0300     CLR W6
0089AC  EB0280     CLR W5
0089AE  EB0200     CLR W4
0089B0  B3C013     MOV #0x1, W3
0089B2  780109     MOV W9, W2
0089B4  780088     MOV W8, W1
0089B6  07EFC3     RCALL PutImagePartial
868:                       (
869:                           (((_rpnlX2 + _rpnlX1) - (GetImageWidth((void *)_pRpnlBitmap))) >> 1) + 1,
870:                           (((_rpnlY2 + _rpnlY1) - (GetImageHeight((void *)_pRpnlBitmap))) >> 1) + 1,
871:                           _pRpnlBitmap,
872:                           IMAGE_NORMAL
873:                       );
874:                  }
875:               
876:               #ifdef USE_ALPHABLEND_LITE
877:                   //Disable Alpha Blending
878:                   SetAlpha(100); 
879:               #endif
880:               
881:                   // check if we need to draw the frame
882:                   if
883:                   (
0089BA  500FE0     SUB W0, #0x0, [W15]
0089BC  320012     BRA Z, 0x89E2
884:                       (_pRpnlBitmap == NULL) ||
0089B8  808B60     MOV 0x116C, W0
0089CC  540F80     SUB W8, W0, [W15]
0089CE  350011     BRA LT, 0x89F2
885:                       (
886:                           ((_rpnlX2 - _rpnlX1 + _rpnlR) >= GetImageWidth((void *)_pRpnlBitmap)) &&
0089BE  8088C1     MOV _rpnlX2, W1
0089C0  8088A0     MOV _rpnlX1, W0
0089C2  508080     SUB W1, W0, W1
0089C4  8088E0     MOV _rpnlR, W0
0089C6  408400     ADD W1, W0, W8
0089C8  808B60     MOV 0x116C, W0
0089CA  07EE54     RCALL GetImageWidth
0089DE  540F80     SUB W8, W0, [W15]
0089E0  350008     BRA LT, 0x89F2
887:                           ((_rpnlY2 - _rpnlY1 + _rpnlR) >= GetImageHeight((void *)_pRpnlBitmap))
0089D0  8088D1     MOV _rpnlY2, W1
0089D2  8088B0     MOV _rpnlY1, W0
0089D4  508080     SUB W1, W0, W1
0089D6  8088E0     MOV _rpnlR, W0
0089D8  408400     ADD W1, W0, W8
0089DA  808B60     MOV 0x116C, W0
0089DC  07EE60     RCALL GetImageHeight
888:                       )
889:                   )
890:                   {
891:               
892:                       // draw the outline
893:                       SetColor(_rpnlEmbossDkColor);
0089E2  BFD120     MOV.B _rpnlEmbossDkColor, WREG
0089E4  B7F13E     MOV.B WREG, _color
894:                       Bevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR);
0089E6  8088E4     MOV _rpnlR, W4
0089E8  8088D3     MOV _rpnlY2, W3
0089EA  8088C2     MOV _rpnlX2, W2
0089EC  8088B1     MOV _rpnlY1, W1
0089EE  8088A0     MOV _rpnlX1, W0
0089F0  07E945     RCALL Bevel
895:                   }
896:               
897:                   return (1);
0089F2  200010     MOV #0x1, W0
898:               
899:               #else
900:               
901:                   typedef enum
902:                   {
903:                       BEGIN,
904:                       ARC1,
905:                       DRAW_EMBOSS1,
906:                       DRAW_EMBOSS2,
907:                       DRAW_EMBOSS3,
908:                       DRAW_EMBOSS4,
909:                       DRAW_FACECOLOR,
910:                               #if (COLOR_DEPTH == 1)
911:                       DRAW_INNERFRAME,
912:                               #endif
913:                       DRAW_FRAME,
914:                       DRAW_IMAGE,
915:                   } ROUND_PANEL_DRAW_STATES;
916:               
917:                   static ROUND_PANEL_DRAW_STATES state = BEGIN;
918:                   static WORD counter;
919:               
920:                   while(1)
921:                   {
922:                       if(IsDeviceBusy())
923:                           return (0);
924:                       switch(state)
925:                       {
926:                           case BEGIN:
927:               
928:               	           	// check if we need to draw the face and emboss
929:                               if (_pRpnlBitmap != NULL)
930:                               {
931:                                   if 	(
932:                                       ((_rpnlX2 - _rpnlX1 + (_rpnlR<<1)) <= GetImageWidth((void *)_pRpnlBitmap)) &&
933:                                       ((_rpnlY2 - _rpnlY1 + (_rpnlR<<1)) <= GetImageHeight((void *)_pRpnlBitmap))
934:                                   	)
935:                               	{
936:               	                	state = DRAW_IMAGE;
937:               	                	goto rnd_panel_draw_image;
938:               	                }	
939:               	            } 
940:                           
941:                               if(_rpnlR)
942:                               {
943:               
944:                                   // draw upper left portion of the embossed area
945:                                   SetColor(_rpnlEmbossLtColor);
946:                                   if(!Arc(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize, _rpnlR, 0xE1))
947:                                       return (0);
948:                                   state = ARC1;
949:                               }
950:                               else
951:                               {
952:                                   state = DRAW_EMBOSS1;
953:                                   counter = 1;
954:                                   goto rnd_panel_draw_emboss;
955:                               }
956:               
957:                           case ARC1:
958:               
959:                               // draw upper left portion of the embossed area
960:                               SetColor(_rpnlEmbossDkColor);
961:                               if(!Arc(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize, _rpnlR, 0x1E))
962:                                   return (0);
963:                               state = DRAW_FACECOLOR;
964:                               goto rnd_panel_draw_facecolor;
965:               
966:                           // now draw the upper portion of the embossed area
967:                           case DRAW_EMBOSS1:
968:                               rnd_panel_draw_emboss : SetColor(_rpnlEmbossLtColor);
969:                               while(counter < _rpnlEmbossSize)
970:                               {
971:               
972:                                   // draw top
973:                                   if(!Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY1 + counter))
974:                                   {
975:                                       return (0);
976:                                   }
977:               
978:                                   counter++;
979:                               }
980:               
981:                               counter = 1;
982:                               state = DRAW_EMBOSS2;
983:                               break;
984:               
985:                           case DRAW_EMBOSS2:
986:                               while(counter < _rpnlEmbossSize)
987:                               {
988:               
989:                                   // draw left   	
990:                                   if(!Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX1 + counter, _rpnlY2 - counter))
991:                                   {
992:                                       return (0);
993:                                   }
994:               
995:                                   counter++;
996:                               }
997:               
998:                               counter = 1;
999:                               state = DRAW_EMBOSS3;
1000:                              break;
1001:              
1002:                          // now draw the lower portion of the embossed area
1003:                          case DRAW_EMBOSS3:
1004:                              SetColor(_rpnlEmbossDkColor);
1005:                              while(counter < _rpnlEmbossSize)
1006:                              {
1007:              
1008:                                  // draw bottom
1009:                                  if(!Bar(_rpnlX1 + counter, _rpnlY2 - counter, _rpnlX2 - counter, _rpnlY2 - counter))
1010:                                  {
1011:                                      return (0);
1012:                                  }
1013:              
1014:                                  counter++;
1015:                              }
1016:              
1017:                              counter = 1;
1018:                              state = DRAW_EMBOSS4;
1019:                              break;
1020:              
1021:                          case DRAW_EMBOSS4:
1022:                              while(counter < _rpnlEmbossSize)
1023:                              {
1024:              
1025:                                  // draw right	   	
1026:                                  if(!Bar(_rpnlX2 - counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY2 - counter))
1027:                                  {
1028:                                      return (0);
1029:                                  }
1030:              
1031:                                  counter++;
1032:                              }
1033:              
1034:                              state = DRAW_FACECOLOR;
1035:                              break;
1036:              
1037:                          // draw the face color
1038:                          case DRAW_FACECOLOR:
1039:                              rnd_panel_draw_facecolor : SetColor(_rpnlFaceColor);
1040:              #ifdef USE_ALPHABLEND_LITE
1041:                              // set alpha value
1042:                              SetAlpha(_rpnlAlpha); 
1043:              #endif
1044:              
1045:                              if(_rpnlR)
1046:                              {
1047:                                  #ifdef USE_GRADIENT
1048:                                  if(_gradientScheme.gradientType != GRAD_NONE)
1049:                                  {
1050:                                     BevelGradient(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize,
1051:                                                   _gradientScheme.gradientStartColor,_gradientScheme.gradientEndColor,
1052:                                                  _gradientScheme.gradientLength,_gradientScheme.gradientType);
1053:                                  }
1054:                                 else
1055:                                 #endif
1056:              
1057:              
1058:              
1059:                                  if(!FillBevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize))
1060:                                      return (0);
1061:                              }
1062:                              else
1063:                              {
1064:                                  if
1065:                                  (
1066:                                      !Bar
1067:                                          (
1068:                                              _rpnlX1 + _rpnlEmbossSize,
1069:                                              _rpnlY1 + _rpnlEmbossSize,
1070:                                              _rpnlX2 - _rpnlEmbossSize,
1071:                                              _rpnlY2 - _rpnlEmbossSize
1072:                                          )
1073:                                  )
1074:                                  {
1075:                                      return (0);
1076:                                  }
1077:                              }
1078:              
1079:                              state = DRAW_IMAGE;
1080:                              break;
1081:              
1082:                          case DRAW_IMAGE:
1083:                          	rnd_panel_draw_image : 
1084:                              if(_pRpnlBitmap != NULL)
1085:                              {
1086:                                  if
1087:                                  (
1088:                                      !PutImage
1089:                                          (
1090:                                              ((_rpnlX2 + _rpnlX1 - GetImageWidth((void *)_pRpnlBitmap)) >> 1) + 1,
1091:                                              ((_rpnlY2 + _rpnlY1 - GetImageHeight((void *)_pRpnlBitmap)) >> 1) + 1,
1092:                                              _pRpnlBitmap,
1093:                                              IMAGE_NORMAL
1094:                                          )
1095:                                  )
1096:                                  {
1097:                                      return (0);
1098:                                  }
1099:                              }
1100:              #ifdef USE_ALPHABLEND_LITE
1101:                              //Disable Alpha Blending
1102:                              SetAlpha(100); 
1103:              #endif
1104:              
1105:              
1106:                                      #if (COLOR_DEPTH == 1)
1107:                              state = DRAW_INNERFRAME;
1108:                              break;
1109:                                      #else
1110:                              state = DRAW_FRAME;
1111:                                      #endif
1112:                              break;
1113:              
1114:                                      #if (COLOR_DEPTH == 1)
1115:              
1116:                          case DRAW_INNERFRAME:
1117:                              if(_rpnlFaceColor == _rpnlEmbossDkColor)
1118:                              {
1119:                                  SetColor(_rpnlEmbossLtColor); 
1120:              					if(_rpnlR)
1121:              					{
1122:                                      if(!Bevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - (_rpnlEmbossSize - 1)))
1123:                                      {
1124:                                          return (0);
1125:                                      }    
1126:              					}
1127:              					else
1128:                  				{
1129:              					    if(!Bevel(  _rpnlX1 + (_rpnlEmbossSize - 1),
1130:                                                  _rpnlY1 + (_rpnlEmbossSize - 1),
1131:                                                  _rpnlX2 - (_rpnlEmbossSize - 1),
1132:                                                  _rpnlY2 - (_rpnlEmbossSize - 1),
1133:                                                  0 ))
1134:              				        {
1135:              							return (0);
1136:              						}
1137:              					}
1138:                              }
1139:              
1140:                              state = DRAW_FRAME;
1141:                              break;
1142:                                      #endif
1143:              
1144:                          case DRAW_FRAME:
1145:              
1146:                              // check if we need to draw the frame
1147:                              if
1148:                              (
1149:                                  (_pRpnlBitmap == NULL) ||
1150:                                  (
1151:                                      ((_rpnlX2 - _rpnlX1 + _rpnlR) >= GetImageWidth((void *)_pRpnlBitmap)) &&
1152:                                      ((_rpnlY2 - _rpnlY1 + _rpnlR) >= GetImageHeight((void *)_pRpnlBitmap))
1153:                                  )
1154:                              )
1155:                              {
1156:              
1157:                                  // draw the outline frame
1158:                                          #if (COLOR_DEPTH == 1)
1159:                                  // When in 1BPP mode, the outline should always be the light color 
1160:                                  // Ideally WHITE.   
1161:                                  if (_rpnlEmbossLtColor > _rpnlEmbossDkColor)
1162:                                      SetColor(_rpnlEmbossLtColor);     
1163:                                  else
1164:                                      SetColor(_rpnlEmbossDkColor);     
1165:                                          #else
1166:                                  SetColor(_rpnlEmbossDkColor);
1167:                                          #endif
1168:                                  if(!Bevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR))
1169:                                  {
1170:                                      return (0);
1171:                                  }
1172:                              }
1173:              
1174:                              state = BEGIN;
1175:                              return (1);
1176:                      }   // end of switch
1177:                  }       // end of while
1178:              #endif //#ifndef USE_NONBLOCKING_CONFIG
1179:              }
0089F4  78054F     MOV [--W15], W10
0089F6  BE044F     MOV.D [--W15], W8
0089F8  FA8000     ULNK
0089FA  060000     RETURN
1180:              
1181:              
1182:              /*********************************************************************
1183:              * Function: WORD GOLTwoTonePanelDrawTsk(void) 
1184:              *
1185:              * PreCondition: parameters must be set with
1186:              *               GOLRndPanelDraw(x,y,radius,width,height,faceClr,embossLtClr,
1187:              *								embossDkClr,pBitmap,embossSize)
1188:              *
1189:              * Input: None
1190:              *
1191:              * Output: Output: non-zero if drawing is completed
1192:              *
1193:              * Overview: draws a rounded panel on screen. Must be called repeatedly. Drawing is done
1194:              *           when it returns non-zero. 
1195:              *
1196:              * Note: none
1197:              *
1198:              ********************************************************************/
1199:              WORD GOLTwoTonePanelDrawTsk(void)
1200:              {
0089FC  FA0002     LNK #0x2
0089FE  BE9F88     MOV.D W8, [W15++]
008A00  781F8A     MOV W10, [W15++]
1201:              // In this panel draw task the emboss light and dark colors are used as
1202:              // the panel face colors and the panel face color is used as an outline color
1203:              
1204:                      #ifndef USE_NONBLOCKING_CONFIG
1205:              
1206:                  WORD    counter;
1207:              
1208:              	SetColor(_rpnlFaceColor);
008A02  BFD11E     MOV.B _rpnlFaceColor, WREG
008A04  B7F13E     MOV.B WREG, _color
1209:                  if(_rpnlR)
008A06  8088E0     MOV _rpnlR, W0
008A08  500FE0     SUB W0, #0x0, [W15]
008A0A  32000C     BRA Z, 0x8A24
1210:                  {
1211:                      // draw the outline
1212:                      Arc(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize, _rpnlR, 0xFF);  	
008A0C  8088E5     MOV _rpnlR, W5
008A0E  8088E1     MOV _rpnlR, W1
008A10  BFD121     MOV.B _rpnlEmbossSize, WREG
008A12  FB8000     ZE W0, W0
008A14  508200     SUB W1, W0, W4
008A16  8088D3     MOV _rpnlY2, W3
008A18  8088C2     MOV _rpnlX2, W2
008A1A  8088B1     MOV _rpnlY1, W1
008A1C  8088A0     MOV _rpnlX1, W0
008A1E  EBC300     SETM.B W6
008A20  07E6BA     RCALL Arc
008A22  370038     BRA 0x8A94
1213:                  }
1214:                  else
1215:                  {
1216:                      // object is rectangular panel draw the outline embossed areas
1217:                      counter = 1;
008A24  200010     MOV #0x1, W0
008A26  780F00     MOV W0, [W14]
1218:                      while(counter < _rpnlEmbossSize)
008A28  370031     BRA 0x8A8C
008A8C  BFD121     MOV.B _rpnlEmbossSize, WREG
008A8E  FB8000     ZE W0, W0
008A90  500F9E     SUB W0, [W14], [W15]
008A92  3EFFCB     BRA GTU, 0x8A2A
1219:                      {
1220:                          Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY1 + counter);    // draw top
008A2A  8088B0     MOV _rpnlY1, W0
008A2C  40001E     ADD W0, [W14], W0
008A2E  780180     MOV W0, W3
008A30  8088C0     MOV _rpnlX2, W0
008A32  50001E     SUB W0, [W14], W0
008A34  780100     MOV W0, W2
008A36  8088B0     MOV _rpnlY1, W0
008A38  40001E     ADD W0, [W14], W0
008A3A  780080     MOV W0, W1
008A3C  8088A0     MOV _rpnlX1, W0
008A3E  40001E     ADD W0, [W14], W0
008A40  07E53D     RCALL Bar
1221:                          Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX1 + counter, _rpnlY2 - counter);    // draw left
008A42  8088D0     MOV _rpnlY2, W0
008A44  50001E     SUB W0, [W14], W0
008A46  780180     MOV W0, W3
008A48  8088A0     MOV _rpnlX1, W0
008A4A  40001E     ADD W0, [W14], W0
008A4C  780100     MOV W0, W2
008A4E  8088B0     MOV _rpnlY1, W0
008A50  40001E     ADD W0, [W14], W0
008A52  780080     MOV W0, W1
008A54  8088A0     MOV _rpnlX1, W0
008A56  40001E     ADD W0, [W14], W0
008A58  07E531     RCALL Bar
1222:                          Bar(_rpnlX1 + counter, _rpnlY2 - counter, _rpnlX2 - counter, _rpnlY2 - counter);    // draw bottom
008A5A  8088D0     MOV _rpnlY2, W0
008A5C  50001E     SUB W0, [W14], W0
008A5E  780180     MOV W0, W3
008A60  8088C0     MOV _rpnlX2, W0
008A62  50001E     SUB W0, [W14], W0
008A64  780100     MOV W0, W2
008A66  8088D0     MOV _rpnlY2, W0
008A68  50001E     SUB W0, [W14], W0
008A6A  780080     MOV W0, W1
008A6C  8088A0     MOV _rpnlX1, W0
008A6E  40001E     ADD W0, [W14], W0
008A70  07E525     RCALL Bar
1223:                          Bar(_rpnlX2 - counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY2 - counter);    // draw right	
008A72  8088D0     MOV _rpnlY2, W0
008A74  50001E     SUB W0, [W14], W0
008A76  780180     MOV W0, W3
008A78  8088C0     MOV _rpnlX2, W0
008A7A  50001E     SUB W0, [W14], W0
008A7C  780100     MOV W0, W2
008A7E  8088B0     MOV _rpnlY1, W0
008A80  40001E     ADD W0, [W14], W0
008A82  780080     MOV W0, W1
008A84  8088C0     MOV _rpnlX2, W0
008A86  50001E     SUB W0, [W14], W0
008A88  07E519     RCALL Bar
1224:                          counter++;
008A8A  E80F1E     INC [W14], [W14]
1225:                      }        
1226:                  }
1227:              	
1228:              	// draw the top half of the face 
1229:                  SetColor(_rpnlEmbossLtColor);
008A94  BFD11F     MOV.B _rpnlEmbossLtColor, WREG
008A96  B7F13E     MOV.B WREG, _color
1230:                  if(_rpnlR)
008A98  8088E0     MOV _rpnlR, W0
008A9A  500FE0     SUB W0, #0x0, [W15]
008A9C  32000C     BRA Z, 0x8AB6
1231:                  {
1232:                  	SetBevelDrawType(DRAWTOPBEVEL);
008A9E  B3CF00     MOV #0xF0, W0
008AA0  B7F05A     MOV.B WREG, _bevelDrawType
1233:                      FillBevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize);
008AA2  8088E1     MOV _rpnlR, W1
008AA4  BFD121     MOV.B _rpnlEmbossSize, WREG
008AA6  FB8000     ZE W0, W0
008AA8  508200     SUB W1, W0, W4
008AAA  8088D3     MOV _rpnlY2, W3
008AAC  8088C2     MOV _rpnlX2, W2
008AAE  8088B1     MOV _rpnlY1, W1
008AB0  8088A0     MOV _rpnlX1, W0
008AB2  07EA46     RCALL FillBevel
008AB4  370013     BRA 0x8ADC
1234:                  }
1235:                  else
1236:                  {
1237:                      Bar(_rpnlX1 + _rpnlEmbossSize, _rpnlY1 + _rpnlEmbossSize, 
008ABE  8088B0     MOV _rpnlY1, W0
008AC2  8088C1     MOV _rpnlX2, W1
008AC4  BFD121     MOV.B _rpnlEmbossSize, WREG
008AC6  FB8000     ZE W0, W0
008ACA  BFD121     MOV.B _rpnlEmbossSize, WREG
008ACC  FB8080     ZE W0, W1
008ACE  8088B0     MOV _rpnlY1, W0
008AD0  408080     ADD W1, W0, W1
008AD2  BFD121     MOV.B _rpnlEmbossSize, WREG
008AD4  FB8200     ZE W0, W4
008AD6  8088A0     MOV _rpnlX1, W0
008AD8  420000     ADD W4, W0, W0
008ADA  07E4F0     RCALL Bar
1238:                      	_rpnlX2 - _rpnlEmbossSize, (_rpnlY1 + ((_rpnlY2 - _rpnlY1) >> 1)));
008AB6  8088D1     MOV _rpnlY2, W1
008AB8  8088B0     MOV _rpnlY1, W0
008ABA  508000     SUB W1, W0, W0
008ABC  D18080     ASR W0, W1
008AC0  408180     ADD W1, W0, W3
008AC8  508100     SUB W1, W0, W2
1239:              	}
1240:              
1241:              	// draw the bottom half of the face 
1242:                  SetColor(_rpnlEmbossDkColor);
008ADC  BFD120     MOV.B _rpnlEmbossDkColor, WREG
008ADE  B7F13E     MOV.B WREG, _color
1243:                  if(_rpnlR)
008AE0  8088E0     MOV _rpnlR, W0
008AE2  500FE0     SUB W0, #0x0, [W15]
008AE4  32000C     BRA Z, 0x8AFE
1244:                  {
1245:                  	SetBevelDrawType(DRAWBOTTOMBEVEL);
008AE6  B3C0F0     MOV #0xF, W0
008AE8  B7F05A     MOV.B WREG, _bevelDrawType
1246:                      FillBevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize);
008AEA  8088E1     MOV _rpnlR, W1
008AEC  BFD121     MOV.B _rpnlEmbossSize, WREG
008AEE  FB8000     ZE W0, W0
008AF0  508200     SUB W1, W0, W4
008AF2  8088D3     MOV _rpnlY2, W3
008AF4  8088C2     MOV _rpnlX2, W2
008AF6  8088B1     MOV _rpnlY1, W1
008AF8  8088A0     MOV _rpnlX1, W0
008AFA  07EA22     RCALL FillBevel
008AFC  370014     BRA 0x8B26
1247:                  }
1248:                  else
1249:                  {
1250:                      Bar(_rpnlX1 + _rpnlEmbossSize, (_rpnlY1 + ((_rpnlY2 - _rpnlY1) >> 1)) + 1, 
008AFE  8088D1     MOV _rpnlY2, W1
008B00  BFD121     MOV.B _rpnlEmbossSize, WREG
008B02  FB8000     ZE W0, W0
008B06  8088C1     MOV _rpnlX2, W1
008B08  BFD121     MOV.B _rpnlEmbossSize, WREG
008B0A  FB8000     ZE W0, W0
008B0E  8088D1     MOV _rpnlY2, W1
008B10  8088B0     MOV _rpnlY1, W0
008B12  508000     SUB W1, W0, W0
008B14  D18080     ASR W0, W1
008B16  8088B0     MOV _rpnlY1, W0
008B18  408000     ADD W1, W0, W0
008B1A  E80080     INC W0, W1
008B1C  BFD121     MOV.B _rpnlEmbossSize, WREG
008B1E  FB8200     ZE W0, W4
008B20  8088A0     MOV _rpnlX1, W0
008B22  420000     ADD W4, W0, W0
008B24  07E4CB     RCALL Bar
1251:                      	_rpnlX2 - _rpnlEmbossSize, _rpnlY2 - _rpnlEmbossSize);
008B04  508180     SUB W1, W0, W3
008B0C  508100     SUB W1, W0, W2
1252:              	}
1253:              	
1254:              	SetBevelDrawType(DRAWFULLBEVEL);
008B26  EBC000     SETM.B W0
008B28  B7F05A     MOV.B WREG, _bevelDrawType
1255:              
1256:              
1257:                          #if (COLOR_DEPTH == 1)
1258:                  if(_rpnlFaceColor == _rpnlEmbossDkColor)
008B2A  2111E1     MOV #0x111E, W1
008B2C  784091     MOV.B [W1], W1
008B2E  BFD120     MOV.B _rpnlEmbossDkColor, WREG
008B30  50CF80     SUB.B W1, W0, [W15]
008B32  3A0026     BRA NZ, 0x8B80
1259:                  {
1260:                      SetColor(_rpnlEmbossLtColor);
008B34  BFD11F     MOV.B _rpnlEmbossLtColor, WREG
008B36  B7F13E     MOV.B WREG, _color
1261:                      if(_rpnlR)
008B38  8088E0     MOV _rpnlR, W0
008B3A  500FE0     SUB W0, #0x0, [W15]
008B3C  32000B     BRA Z, 0x8B54
1262:                          Bevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - (_rpnlEmbossSize - 1));
008B3E  BFD121     MOV.B _rpnlEmbossSize, WREG
008B40  FB8000     ZE W0, W0
008B42  1000E1     SUBR W0, #0x1, W1
008B44  8088E0     MOV _rpnlR, W0
008B46  408200     ADD W1, W0, W4
008B48  8088D3     MOV _rpnlY2, W3
008B4A  8088C2     MOV _rpnlX2, W2
008B4C  8088B1     MOV _rpnlY1, W1
008B4E  8088A0     MOV _rpnlX1, W0
008B50  07E895     RCALL Bevel
008B52  370016     BRA 0x8B80
1263:                      else
1264:                          Bevel
1265:                          (
008B6E  8088B0     MOV _rpnlY1, W0
008B78  8088A0     MOV _rpnlX1, W0
008B7C  EB0200     CLR W4
008B7E  07E87E     RCALL Bevel
1266:                              _rpnlX1 + (_rpnlEmbossSize - 1),
008B72  BFD121     MOV.B _rpnlEmbossSize, WREG
008B74  FB8000     ZE W0, W0
008B76  E90200     DEC W0, W4
008B7A  420000     ADD W4, W0, W0
1267:                              _rpnlY1 + (_rpnlEmbossSize - 1),
008B68  BFD121     MOV.B _rpnlEmbossSize, WREG
008B6A  FB8000     ZE W0, W0
008B6C  E90080     DEC W0, W1
008B70  408080     ADD W1, W0, W1
1268:                              _rpnlX2 - (_rpnlEmbossSize - 1),
008B5E  BFD121     MOV.B _rpnlEmbossSize, WREG
008B60  FB8000     ZE W0, W0
008B62  1000E1     SUBR W0, #0x1, W1
008B64  8088C0     MOV _rpnlX2, W0
008B66  408100     ADD W1, W0, W2
1269:                              _rpnlY2 - (_rpnlEmbossSize - 1),
008B54  BFD121     MOV.B _rpnlEmbossSize, WREG
008B56  FB8000     ZE W0, W0
008B58  1000E1     SUBR W0, #0x1, W1
008B5A  8088D0     MOV _rpnlY2, W0
008B5C  408180     ADD W1, W0, W3
1270:                              0
1271:                          );
1272:                  }
1273:              
1274:                          #endif
1275:              
1276:                  // draw bitmap
1277:                  if(_pRpnlBitmap != NULL)
008B80  808B60     MOV 0x116C, W0
008B82  500FE0     SUB W0, #0x0, [W15]
008B84  320019     BRA Z, 0x8BB8
1278:                  {
1279:                      PutImage
008B86  808B69     MOV 0x116C, W9
008B88  8088D1     MOV _rpnlY2, W1
008B8A  8088B0     MOV _rpnlY1, W0
008B8C  408400     ADD W1, W0, W8
008B8E  808B60     MOV 0x116C, W0
008B90  07ED86     RCALL GetImageHeight
008B92  540000     SUB W8, W0, W0
008B94  D18000     ASR W0, W0
008B96  E80400     INC W0, W8
008B98  8088C1     MOV _rpnlX2, W1
008B9A  8088A0     MOV _rpnlX1, W0
008B9C  408500     ADD W1, W0, W10
008B9E  808B60     MOV 0x116C, W0
008BA0  07ED69     RCALL GetImageWidth
008BA2  550000     SUB W10, W0, W0
008BA4  D18000     ASR W0, W0
008BA6  E80000     INC W0, W0
008BA8  EB0380     CLR W7
008BAA  EB0300     CLR W6
008BAC  EB0280     CLR W5
008BAE  EB0200     CLR W4
008BB0  B3C013     MOV #0x1, W3
008BB2  780109     MOV W9, W2
008BB4  780088     MOV W8, W1
008BB6  07EEC3     RCALL PutImagePartial
1280:                      (
1281:                          (((_rpnlX2 + _rpnlX1) - (GetImageWidth((void *)_pRpnlBitmap))) >> 1) + 1,
1282:                          (((_rpnlY2 + _rpnlY1) - (GetImageHeight((void *)_pRpnlBitmap))) >> 1) + 1,
1283:                          _pRpnlBitmap,
1284:                          IMAGE_NORMAL
1285:                      );
1286:                  }
1287:              
1288:                  return (1);
008BB8  200010     MOV #0x1, W0
1289:              
1290:                      #else
1291:              
1292:                  typedef enum
1293:                  {
1294:                      BEGIN,
1295:                      DRAW_EMBOSS1,
1296:                      DRAW_EMBOSS2,
1297:                      DRAW_EMBOSS3,
1298:                      DRAW_EMBOSS4,
1299:                      DRAW_FACECOLOR1,
1300:                      DRAW_FACECOLOR2,
1301:                              #if (COLOR_DEPTH == 1)
1302:                      DRAW_INNERFRAME,
1303:                              #endif
1304:                      DRAW_IMAGE,
1305:                  } ROUND_PANEL_DRAW_STATES;
1306:              
1307:                  static ROUND_PANEL_DRAW_STATES state = BEGIN;
1308:                  static WORD counter;
1309:              
1310:                  while(1)
1311:                  {
1312:                      if(IsDeviceBusy())
1313:                          return (0);
1314:                      switch(state)
1315:                      {
1316:                          case BEGIN:
1317:                              if(_rpnlR)
1318:                              {
1319:              
1320:                                  // draw the outline
1321:              					SetColor(_rpnlFaceColor);
1322:                      			if(!Arc(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize, _rpnlR, 0xFF))  	                    
1323:                                      return (0);
1324:                                  state = DRAW_FACECOLOR1;
1325:                              }
1326:                              else
1327:                              {
1328:                                  state = DRAW_EMBOSS1;
1329:                                  counter = 1;
1330:                                  goto rnd_panel_draw_emboss;
1331:                              }
1332:              
1333:                          // now draw the upper portion of the embossed area
1334:                          case DRAW_EMBOSS1:
1335:                              rnd_panel_draw_emboss : SetColor(_rpnlFaceColor);
1336:                              while(counter < _rpnlEmbossSize)
1337:                              {
1338:              
1339:                                  // draw top
1340:                                  if(!Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY1 + counter))
1341:                                  {
1342:                                      return (0);
1343:                                  }
1344:              
1345:                                  counter++;
1346:                              }
1347:              
1348:                              counter = 1;
1349:                              state = DRAW_EMBOSS2;
1350:                              break;
1351:              
1352:                          case DRAW_EMBOSS2:
1353:                              while(counter < _rpnlEmbossSize)
1354:                              {
1355:              
1356:                                  // draw left   	
1357:                                  if(!Bar(_rpnlX1 + counter, _rpnlY1 + counter, _rpnlX1 + counter, _rpnlY2 - counter))
1358:                                  {
1359:                                      return (0);
1360:                                  }
1361:              
1362:                                  counter++;
1363:                              }
1364:              
1365:                              counter = 1;
1366:                              state = DRAW_EMBOSS3;
1367:                              break;
1368:              
1369:                          // now draw the lower portion of the embossed area
1370:                          case DRAW_EMBOSS3:
1371:                              //SetColor(_rpnlEmbossDkColor);
1372:                              while(counter < _rpnlEmbossSize)
1373:                              {
1374:              
1375:                                  // draw bottom
1376:                                  if(!Bar(_rpnlX1 + counter, _rpnlY2 - counter, _rpnlX2 - counter, _rpnlY2 - counter))
1377:                                  {
1378:                                      return (0);
1379:                                  }
1380:              
1381:                                  counter++;
1382:                              }
1383:              
1384:                              counter = 1;
1385:                              state = DRAW_EMBOSS4;
1386:                              break;
1387:              
1388:                          case DRAW_EMBOSS4:
1389:                              while(counter < _rpnlEmbossSize)
1390:                              {
1391:              
1392:                                  // draw right	   	
1393:                                  if(!Bar(_rpnlX2 - counter, _rpnlY1 + counter, _rpnlX2 - counter, _rpnlY2 - counter))
1394:                                  {
1395:                                      return (0);
1396:                                  }
1397:              
1398:                                  counter++;
1399:                              }
1400:              
1401:                              state = DRAW_FACECOLOR1;
1402:                              break;
1403:              
1404:                          // draw the top half of the face 
1405:                          case DRAW_FACECOLOR1:
1406:                              SetColor(_rpnlEmbossLtColor);
1407:                              if(_rpnlR)
1408:                              {
1409:                  				SetBevelDrawType(DRAWTOPBEVEL);
1410:                      			if(!FillBevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize))	                
1411:                                      return (0);
1412:                              }
1413:                              else
1414:                              {
1415:                                  if
1416:                                  (
1417:                                      !Bar
1418:                                          (
1419:                      						_rpnlX1 + _rpnlEmbossSize, 
1420:                      						_rpnlY1 + _rpnlEmbossSize, 
1421:                      						_rpnlX2 - _rpnlEmbossSize, 
1422:                      						(_rpnlY1 + ((_rpnlY2 - _rpnlY1) >> 1))                            
1423:                                          )
1424:                                  )
1425:                                  {
1426:                                      return (0);
1427:                                  }
1428:                              }
1429:              
1430:                              state = DRAW_FACECOLOR2;
1431:                              break;
1432:              
1433:                         	// draw the bottom half of the face 
1434:                          case DRAW_FACECOLOR2:
1435:                              SetColor(_rpnlEmbossDkColor);
1436:                              if(_rpnlR)
1437:                              {
1438:              	                SetBevelDrawType(DRAWBOTTOMBEVEL);
1439:                                  if(!FillBevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - _rpnlEmbossSize))
1440:                                      return (0);
1441:                              }
1442:                              else
1443:                              {
1444:                                  if
1445:                                  (
1446:                                      !Bar
1447:                                          (
1448:                    							_rpnlX1 + _rpnlEmbossSize, 
1449:                    							(_rpnlY1 + ((_rpnlY2 - _rpnlY1) >> 1)) + 1, 
1450:                      						_rpnlX2 - _rpnlEmbossSize, 
1451:                      						_rpnlY2 - _rpnlEmbossSize
1452:                                          )
1453:                                  )
1454:                                  {
1455:                                      return (0);
1456:                                  }
1457:                              }
1458:              				SetBevelDrawType(DRAWFULLBEVEL);
1459:                              state = DRAW_IMAGE;
1460:                              break;
1461:              
1462:                          case DRAW_IMAGE:
1463:                              if(_pRpnlBitmap != NULL)
1464:                              {
1465:                                  if
1466:                                  (
1467:                                      !PutImage
1468:                                          (
1469:                                              ((_rpnlX2 + _rpnlX1 - GetImageWidth((void *)_pRpnlBitmap)) >> 1) + 1,
1470:                                              ((_rpnlY2 + _rpnlY1 - GetImageHeight((void *)_pRpnlBitmap)) >> 1) + 1,
1471:                                              _pRpnlBitmap,
1472:                                              IMAGE_NORMAL
1473:                                          )
1474:                                  )
1475:                                  {
1476:                                      return (0);
1477:                                  }
1478:                              }
1479:              
1480:                                      #if (COLOR_DEPTH == 1)
1481:                              state = DRAW_INNERFRAME;
1482:                              break;
1483:                                      #else
1484:                              state = BEGIN;
1485:                              return (1);
1486:                                      #endif
1487:                              break;
1488:              
1489:                                      #if (COLOR_DEPTH == 1)
1490:              
1491:                          case DRAW_INNERFRAME:
1492:                              if(_rpnlFaceColor == _rpnlEmbossDkColor)
1493:                              {
1494:                                  SetColor(_rpnlEmbossLtColor);
1495:              					if(_rpnlR)
1496:              					{
1497:                                      if(!Bevel(_rpnlX1, _rpnlY1, _rpnlX2, _rpnlY2, _rpnlR - (_rpnlEmbossSize - 1)))
1498:                                      {
1499:                                          return (0);
1500:                                      }    
1501:              					}
1502:              					else
1503:                  				{
1504:              					    if(!Bevel(  _rpnlX1 + (_rpnlEmbossSize - 1),
1505:                                                  _rpnlY1 + (_rpnlEmbossSize - 1),
1506:                                                  _rpnlX2 - (_rpnlEmbossSize - 1),
1507:                                                  _rpnlY2 - (_rpnlEmbossSize - 1),
1508:                                                  0 ))
1509:              				        {
1510:              							return (0);
1511:              						}
1512:              					}
1513:                              }
1514:              
1515:                              state = BEGIN;
1516:                              return (1);
1517:                                      #endif
1518:              
1519:                      }   // end of switch
1520:                  }       // end of while
1521:                      #endif //#ifndef USE_NONBLOCKING_CONFIG
1522:              }
008BBA  78054F     MOV [--W15], W10
008BBC  BE044F     MOV.D [--W15], W8
008BBE  FA8000     ULNK
008BC0  060000     RETURN
1523:              
1524:              
1525:              #endif // USE_GOL
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/Drivers/ST7565R.c  ---------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library
3:                  *  Sitronix ST7529 controller driver
4:                  *****************************************************************************
5:                  * FileName:        ST7529.c
6:                  * Dependencies:    Graphics.h
7:                  * Processor:       PIC24
8:                  * Compiler:       	MPLAB C30
9:                  * Linker:          MPLAB LINK30
10:                 * Company:         Microchip Technology Incorporated
11:                 *
12:                 * Software License Agreement
13:                 *
14:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
15:                 * Microchip licenses to you the right to use, modify, copy and distribute
16:                 * Software only when embedded on a Microchip microcontroller or digital
17:                 * signal controller, which is integrated into your product or third party
18:                 * product (pursuant to the sublicense terms in the accompanying license
19:                 * agreement).  
20:                 *
21:                 * You should refer to the license agreement accompanying this Software
22:                 * for additional information regarding your rights and obligations.
23:                 *
24:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
25:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
26:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
27:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
28:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
29:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
30:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
31:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
32:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
33:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
34:                 * OR OTHER SIMILAR COSTS.
35:                 *
36:                 * Date         Comment
37:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
38:                 * 03/20/08	    ...
39:                 * 04/12/11     Graphics Library Version 3.00 Support
40:                 *****************************************************************************/
41:                #include "HardwareProfile.h"
42:                
43:                #if defined (GFX_USE_DISPLAY_CONTROLLER_ST7565R)
44:                
45:                #include "Compiler.h"
46:                #include "TimeDelay.h"
47:                #include "Graphics/DisplayDriver.h"
48:                #include "ST7565R.h"
49:                #include "Graphics/Primitive.h"
50:                #include "SPIDisplay.h"
51:                
52:                #if defined (USE_GFX_PMP)
53:                    #include "Graphics/gfxpmp.h"
54:                #elif defined (USE_GFX_EPMP)
55:                    #include "Graphics/gfxepmp.h"
56:                #endif  
57:                
58:                // Clipping region control
59:                SHORT       _clipRgn;
60:                
61:                // Clipping region borders
62:                SHORT       _clipLeft;
63:                SHORT       _clipTop;
64:                SHORT       _clipRight;
65:                SHORT       _clipBottom;  
66:                
67:                // Color
68:                GFX_COLOR   _color;
69:                #ifdef USE_TRANSPARENT_COLOR
70:                GFX_COLOR   _colorTransparent;
71:                SHORT       _colorTransparentEnable;
72:                #endif
73:                
74:                /*********************************************************************
75:                * Function:  void ResetDevice()
76:                *
77:                * PreCondition: none
78:                *
79:                * Input: none
80:                *
81:                * Output: none
82:                *
83:                * Side Effects: none
84:                *
85:                * Overview: resets LCD, initializes PMP
86:                *
87:                * Note: none
88:                *
89:                ********************************************************************/
90:                void ResetDevice(void)
91:                {
00C276  FA0000     LNK #0x0
92:                    initSPIDisplay();
00C278  07F15B     RCALL initSPIDisplay
93:                }
00C27A  FA8000     ULNK
00C27C  060000     RETURN
94:                
95:                /*********************************************************************
96:                * Function: void ContrastSet(WORD contrast)
97:                *
98:                * PreCondition: none
99:                *
100:               * Input: contrast value (not used for now)
101:               *
102:               * Output: none
103:               *
104:               * Side Effects: none
105:               *
106:               * Overview: sets contrast
107:               *
108:               * Note: none
109:               *
110:               ********************************************************************/
111:               void ContrastSet(WORD contrast)
112:               {
00C27E  FA0002     LNK #0x2
00C280  780F00     MOV W0, [W14]
113:                   //Not implemented
114:               }
00C282  FA8000     ULNK
00C284  060000     RETURN
115:               
116:               /*********************************************************************
117:               * Function: void ContrastUp(void)
118:               *
119:               * PreCondition: none
120:               *
121:               * Input: none
122:               *
123:               * Output: none
124:               *
125:               * Side Effects: none
126:               *
127:               * Overview: increases contrast
128:               *
129:               * Note: none
130:               *
131:               ********************************************************************/
132:               void ContrastUp(void)
133:               {
00C286  FA0000     LNK #0x0
134:                   //Not implemented
135:               }
00C288  FA8000     ULNK
00C28A  060000     RETURN
136:               
137:               /*********************************************************************
138:               * Function: void ContrastDown(void)
139:               *
140:               * PreCondition: none
141:               *
142:               * Input: none
143:               *
144:               * Output: none
145:               *
146:               * Side Effects: none
147:               *
148:               * Overview: decreases contrast
149:               *
150:               * Note: none
151:               *
152:               ********************************************************************/
153:               void ContrastDown(void)
154:               {
00C28C  FA0000     LNK #0x0
155:                   //Not implemented
156:               }
00C28E  FA8000     ULNK
00C290  060000     RETURN
157:               
158:               /*********************************************************************
159:               * Function: void DisplayOn(void)
160:               *
161:               * PreCondition: none
162:               *
163:               * Input: none
164:               *
165:               * Output: none
166:               *
167:               * Side Effects: none
168:               *
169:               * Overview: turns on display
170:               *
171:               * Note: none
172:               *
173:               ********************************************************************/
174:               void DisplayOn(void)
175:               {
00C292  FA0000     LNK #0x0
176:                   //Not implemented
177:               }
00C294  FA8000     ULNK
00C296  060000     RETURN
178:               
179:               /*********************************************************************
180:               * Function: void DisplayOn(void)
181:               *
182:               * PreCondition: none
183:               *
184:               * Input: none
185:               *
186:               * Output: none
187:               *
188:               * Side Effects: none
189:               *
190:               * Overview: turns off display
191:               *
192:               * Note: none
193:               *
194:               ********************************************************************/
195:               void DisplayOff(void)
196:               {
00C298  FA0000     LNK #0x0
197:                   //Not implemented
198:               }
00C29A  FA8000     ULNK
00C29C  060000     RETURN
199:               
200:               /*********************************************************************
201:               * Function: void SleepIn(void)
202:               *
203:               * PreCondition: none
204:               *
205:               * Input: none
206:               *
207:               * Output: none
208:               *
209:               * Side Effects: none
210:               *
211:               * Overview: enters sleep mode
212:               *
213:               * Note: none
214:               *
215:               ********************************************************************/
216:               void SleepIn(void)
217:               {
00C29E  FA0000     LNK #0x0
218:                   //Not implemented
219:               }
00C2A0  FA8000     ULNK
00C2A2  060000     RETURN
220:               
221:               /*********************************************************************
222:               * Function: void WakeUp(void)
223:               *
224:               * PreCondition: none
225:               *
226:               * Input: none
227:               *
228:               * Output: none
229:               *
230:               * Side Effects: none
231:               *
232:               * Overview: wakes up from sleep
233:               *
234:               * Note: none
235:               *
236:               ********************************************************************/
237:               void WakeUp(void)
238:               {
00C2A4  FA0000     LNK #0x0
239:                   //Not implemented
240:               }
00C2A6  FA8000     ULNK
00C2A8  060000     RETURN
241:               
242:               #ifdef USE_TRANSPARENT_COLOR
243:               /*********************************************************************
244:               * Function:  void TransparentColorEnable(GFX_COLOR color)
245:               *
246:               * Overview: Sets current transparent color.
247:               *
248:               * PreCondition: none
249:               *
250:               * Input: color - Color value chosen.
251:               *
252:               * Output: none
253:               *
254:               * Side Effects: none
255:               *
256:               ********************************************************************/
257:               void TransparentColorEnable(GFX_COLOR color)
258:               {
259:                   _colorTransparent = color;    
260:                   _colorTransparentEnable = TRANSPARENT_COLOR_ENABLE;
261:               
262:               }
263:               #endif
264:               
265:               /*********************************************************************
266:               * Function: void PutPixel(SHORT x, SHORT y)
267:               *
268:               * PreCondition: none
269:               *
270:               * Input: pixel position
271:               *
272:               * Output: none
273:               *
274:               * Side Effects: none
275:               *
276:               * Overview: puts pixel with current color at given position
277:               *
278:               * Note: none
279:               *
280:               ********************************************************************/
281:               inline void PutPixel(SHORT x, SHORT y)
282:               {
00C2AA  FA0006     LNK #0x6
00C2AC  980710     MOV W0, [W14+2]
00C2AE  980721     MOV W1, [W14+4]
283:               char col;
284:               
285:                   if(_clipRgn)
00C2B0  8089A0     MOV _clipRgn, W0
00C2B2  500FE0     SUB W0, #0x0, [W15]
00C2B4  320010     BRA Z, 0xC2D6
286:                   {
287:                       if(x < _clipLeft)
00C2B6  8089B0     MOV _clipLeft, W0
00C2B8  90009E     MOV [W14+2], W1
00C2BA  508F80     SUB W1, W0, [W15]
00C2BC  350019     BRA LT, 0xC2F0
288:                           return;
00C2F0  000000     NOP
00C2F2  370005     BRA 0xC2FE
289:                       if(x > _clipRight)
00C2BE  8089D0     MOV _clipRight, W0
00C2C0  90009E     MOV [W14+2], W1
00C2C2  508F80     SUB W1, W0, [W15]
00C2C4  3C0017     BRA GT, 0xC2F4
290:                           return;
00C2F4  000000     NOP
00C2F6  370003     BRA 0xC2FE
291:                       if(y < _clipTop)
00C2C6  8089C0     MOV _clipTop, W0
00C2C8  9000AE     MOV [W14+4], W1
00C2CA  508F80     SUB W1, W0, [W15]
00C2CC  350015     BRA LT, 0xC2F8
292:                           return;
00C2F8  000000     NOP
00C2FA  370001     BRA 0xC2FE
293:                       if(y > _clipBottom)
00C2CE  8089E0     MOV _clipBottom, W0
00C2D0  9000AE     MOV [W14+4], W1
00C2D2  508F80     SUB W1, W0, [W15]
00C2D4  3C0013     BRA GT, 0xC2FC
294:                           return;
00C2FC  000000     NOP
295:                   }
296:               
297:                   if (_color == 0) col = 1;
00C2D6  BFD13E     MOV.B _color, WREG
00C2D8  504FE0     SUB.B W0, #0x0, [W15]
00C2DA  3A0003     BRA NZ, 0xC2E2
00C2DC  B3C010     MOV #0x1, W0
00C2DE  784F00     MOV.B W0, [W14]
00C2E0  370002     BRA 0xC2E6
298:                   else col = 0;
00C2E2  EB4000     CLR.B W0
00C2E4  784F00     MOV.B W0, [W14]
299:               
300:                   setPixelSPIDisplay (x, y, col);
00C2E6  78411E     MOV.B [W14], W2
00C2E8  9000AE     MOV [W14+4], W1
00C2EA  90001E     MOV [W14+2], W0
00C2EC  07F1DD     RCALL setPixelSPIDisplay
00C2EE  370007     BRA 0xC2FE
301:               }
00C2FE  FA8000     ULNK
00C300  060000     RETURN
302:               
303:               /*********************************************************************
304:               * Function: WORD GetPixel(SHORT x, SHORT y)
305:               *
306:               * PreCondition: none
307:               *
308:               * Input: pixel position
309:               *
310:               * Output: pixel color
311:               *
312:               * Side Effects: none
313:               *
314:               * Overview: returns pixel at given position
315:               *
316:               * Note: none
317:               *
318:               ********************************************************************/
319:               inline GFX_COLOR GetPixel(SHORT x, SHORT y)
320:               {
00C302  FA0004     LNK #0x4
00C304  780F00     MOV W0, [W14]
00C306  980711     MOV W1, [W14+2]
321:                   return ((GFX_COLOR)getPixelSPIDisplay(x, y));
00C308  90009E     MOV [W14+2], W1
00C30A  78001E     MOV [W14], W0
00C30C  07F305     RCALL getPixelSPIDisplay
322:               }
00C30E  FA8000     ULNK
00C310  060000     RETURN
323:               
324:               /*********************************************************************
325:               * Function: IsDeviceBusy()
326:               *
327:               * Overview: Returns non-zero if LCD controller is busy 
328:               *           (previous drawing operation is not completed).
329:               *
330:               * PreCondition: none
331:               *
332:               * Input: none
333:               *
334:               * Output: Busy status.
335:               *
336:               * Side Effects: none
337:               *
338:               ********************************************************************/
339:               WORD IsDeviceBusy(void)
340:               {  
00C312  FA0000     LNK #0x0
341:                   return (0);
00C314  EB0000     CLR W0
342:               }
00C316  FA8000     ULNK
00C318  060000     RETURN
343:               
344:               /*********************************************************************
345:               * Function: void ClearDevice(void)
346:               *
347:               * PreCondition: none
348:               *
349:               * Input: none
350:               *
351:               * Output: none
352:               *
353:               * Side Effects: none
354:               *
355:               * Overview: clears screen with current color 
356:               *
357:               * Note: none
358:               *
359:               ********************************************************************/
360:               void ClearDevice(void)
361:               {
00C31A  FA0000     LNK #0x0
362:                   eraseSPIDisplay();
00C31C  07F2AE     RCALL eraseSPIDisplay
363:                   refreshSPIDisplay();
00C31E  07F1A3     RCALL refreshSPIDisplay
364:               }
00C320  FA8000     ULNK
00C322  060000     RETURN
365:               
366:               #endif //(GFX_USE_DISPLAY_CONTROLLER_ST7565R)
367:               
---  C:/microchip_solutions_v2013-02-15/Microchip/Graphics/Button.c  ------------------------------------
1:                 /*****************************************************************************
2:                  *  Module for Microchip Graphics Library
3:                  *  GOL Layer 
4:                  *  Button
5:                  *****************************************************************************
6:                  * FileName:        Button.c
7:                  * Dependencies:    Button.h
8:                  * Processor:       PIC24F, PIC24H, dsPIC, PIC32
9:                  * Compiler:       	MPLAB C30, MPLAB C32
10:                 * Linker:          MPLAB LINK30, LINK32
11:                 * Company:         Microchip Technology Incorporated
12:                 *
13:                 * Software License Agreement
14:                 *
15:                 * Copyright  2008 Microchip Technology Inc.  All rights reserved.
16:                 * Microchip licenses to you the right to use, modify, copy and distribute
17:                 * Software only when embedded on a Microchip microcontroller or digital
18:                 * signal controller, which is integrated into your product or third party
19:                 * product (pursuant to the sublicense terms in the accompanying license
20:                 * agreement).  
21:                 *
22:                 * You should refer to the license agreement accompanying this Software
23:                 * for additional information regarding your rights and obligations.
24:                 *
25:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
26:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
27:                 * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
28:                 * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
29:                 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
30:                 * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                 * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
32:                 * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
33:                 * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
34:                 * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
35:                 * OR OTHER SIMILAR COSTS.
36:                 *
37:                 * Date        	Comment
38:                 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:                 * 11/12/07		Version 1.0 release
40:                 * 06/26/09		Added message ID BTN_MSG_STILLPRESSED 
41:                 *				to signify that a continuous touch on 
42:                 *				the button through touch screen.
43:                 * 06/29/09		Added multi-line text support on buttons
44:                 *				must set USE_BUTTON_MULTI_LINE in 
45:                 *				GraphicsConfig.h file.
46:                 * 10/04/10     Added BTN_NOPANEL property state bit to make the buttons with
47:                 *              bitmaps that is of the same size or larger than the button
48:                 *              dimension to skip drawing of the panel. 
49:                 * 04/20/11     Fixed KEYBOARD bug on object ID and GOL_MSG param1 comparison.
50:                 * 06/11/12     Added Alpha Blending features.
51:                 *****************************************************************************/
52:                #include "Graphics/Graphics.h"
53:                
54:                #if defined(USE_BUTTON) || defined(USE_BUTTON_MULTI_LINE)
55:                
56:                /*********************************************************************
57:                * Function: BUTTON  *BtnCreate(WORD ID, SHORT left, SHORT top, SHORT right, 
58:                *                              SHORT bottom, SHORT radius, void *pBitmap, XCHAR *pText, 
59:                *                              GOL_SCHEME *pScheme)
60:                *
61:                *
62:                * Notes: Creates a BUTTON object and adds it to the current active list.
63:                *        If the creation is successful, the pointer to the created Object 
64:                *        is returned. If not successful, NULL is returned.
65:                *
66:                ********************************************************************/
67:                BUTTON *BtnCreate
68:                (
69:                    WORD        ID,
70:                    SHORT       left,
71:                    SHORT       top,
72:                    SHORT       right,
73:                    SHORT       bottom,
74:                    SHORT       radius,
75:                    WORD        state,
76:                    void        *pBitmap,
77:                    XCHAR       *pText,
78:                    GOL_SCHEME  *pScheme
79:                )
80:                {
008BC2  FA0012     LNK #0x12
008BC4  980710     MOV W0, [W14+2]
008BC6  980721     MOV W1, [W14+4]
008BC8  980732     MOV W2, [W14+6]
008BCA  980743     MOV W3, [W14+8]
008BCC  980754     MOV W4, [W14+10]
008BCE  980765     MOV W5, [W14+12]
008BD0  980776     MOV W6, [W14+14]
008BD2  980F07     MOV W7, [W14+16]
81:                    BUTTON  *pB = NULL;
008BD4  EB0000     CLR W0
008BD6  780F00     MOV W0, [W14]
82:                    pB = (BUTTON *)GFX_malloc(sizeof(BUTTON));
008BD8  200240     MOV #0x24, W0
008BDA  07C9BA     RCALL _malloc
008BDC  780F00     MOV W0, [W14]
83:                    if(pB == NULL)
008BDE  78001E     MOV [W14], W0
008BE0  500FE0     SUB W0, #0x0, [W15]
008BE2  3A0002     BRA NZ, 0x8BE8
84:                        return (NULL);
008BE4  EB0000     CLR W0
008BE6  37004F     BRA 0x8C86
85:                
86:                    pB->hdr.ID = ID;                        // unique id assigned for referencing
008BE8  78001E     MOV [W14], W0
008BEA  90009E     MOV [W14+2], W1
008BEC  780801     MOV W1, [W0]
87:                    pB->hdr.pNxtObj = NULL;                 // initialize pointer to NULL
008BEE  78001E     MOV [W14], W0
008BF0  EB0080     CLR W1
008BF2  980011     MOV W1, [W0+2]
88:                    pB->hdr.type = OBJ_BUTTON;              // set object type
008BF4  78001E     MOV [W14], W0
008BF6  EB0080     CLR W1
008BF8  980021     MOV W1, [W0+4]
89:                    pB->hdr.left = left;                    // left position
008BFA  78001E     MOV [W14], W0
008BFC  9000AE     MOV [W14+4], W1
008BFE  980041     MOV W1, [W0+8]
90:                    pB->hdr.top = top;                      // top position
008C00  78001E     MOV [W14], W0
008C02  9000BE     MOV [W14+6], W1
008C04  980051     MOV W1, [W0+10]
91:                    pB->hdr.right = right;                  // right position
008C06  78001E     MOV [W14], W0
008C08  9000CE     MOV [W14+8], W1
008C0A  980061     MOV W1, [W0+12]
92:                    pB->hdr.bottom = bottom;                // bottom position
008C0C  78001E     MOV [W14], W0
008C0E  9000DE     MOV [W14+10], W1
008C10  980071     MOV W1, [W0+14]
93:                    pB->radius = radius;                    // radius
008C12  78001E     MOV [W14], W0
008C14  9000EE     MOV [W14+12], W1
008C16  980851     MOV W1, [W0+26]
94:                    pB->pBitmap = pBitmap;                  // location of bitmap
008C18  78001E     MOV [W14], W0
008C1A  90088E     MOV [W14+16], W1
008C1C  981011     MOV W1, [W0+34]
95:                    pB->pText = pText;                      // location of the text
008C1E  78001E     MOV [W14], W0
008C20  97B8CE     MOV [W14-8], W1
008C22  981001     MOV W1, [W0+32]
96:                    pB->hdr.state = state;                  // state
008C24  78001E     MOV [W14], W0
008C26  9000FE     MOV [W14+14], W1
008C28  980031     MOV W1, [W0+6]
97:                    pB->hdr.DrawObj = BtnDraw;              // draw function
008C2A  78001E     MOV [W14], W0
008C2C  28F441     MOV #0x8F44, W1
008C2E  980811     MOV W1, [W0+18]
98:                    pB->hdr.MsgObj = BtnTranslateMsg;       // message function
008C30  78001E     MOV [W14], W0
008C32  28D1C1     MOV #0x8D1C, W1
008C34  980831     MOV W1, [W0+22]
99:                    pB->hdr.MsgDefaultObj = BtnMsgDefault;  // default message function
008C36  78001E     MOV [W14], W0
008C38  28CB61     MOV #0x8CB6, W1
008C3A  980841     MOV W1, [W0+24]
100:                   pB->hdr.FreeObj = NULL;  				// free function
008C3C  78001E     MOV [W14], W0
008C3E  EB0080     CLR W1
008C40  980821     MOV W1, [W0+20]
101:               
102:                   // Set the color scheme to be used
103:                   if(pScheme == NULL)
008C42  97B83E     MOV [W14-10], W0
008C44  500FE0     SUB W0, #0x0, [W15]
008C46  3A0004     BRA NZ, 0x8C50
104:                       pB->hdr.pGolScheme = _pDefaultGolScheme;
008C48  808B41     MOV 0x1168, W1
008C4A  78001E     MOV [W14], W0
008C4C  980801     MOV W1, [W0+16]
008C4E  370003     BRA 0x8C56
105:                   else
106:                       pB->hdr.pGolScheme = (GOL_SCHEME *)pScheme;
008C50  78001E     MOV [W14], W0
008C52  97B8BE     MOV [W14-10], W1
008C54  980801     MOV W1, [W0+16]
107:               
108:                   pB->textWidth = 0;
008C56  78001E     MOV [W14], W0
008C58  EB0080     CLR W1
008C5A  980861     MOV W1, [W0+28]
109:                   pB->textHeight = 0;
008C5C  78001E     MOV [W14], W0
008C5E  EB0080     CLR W1
008C60  980871     MOV W1, [W0+30]
110:                   if(pB->pText != NULL)
008C62  78001E     MOV [W14], W0
008C64  901000     MOV [W0+32], W0
008C66  500FE0     SUB W0, #0x0, [W15]
008C68  320003     BRA Z, 0x8C70
111:                   {
112:               	    BtnSetText(pB, pText);
008C6A  97B8CE     MOV [W14-8], W1
008C6C  78001E     MOV [W14], W0
008C6E  07000D     RCALL BtnSetText
113:                   }
114:               
115:               #ifdef USE_ALPHABLEND_LITE
116:                   pB->previousAlphaColor = BLACK;
117:               #endif
118:               
119:               #ifdef USE_ALPHABLEND                //Store the background image
120:               if(pB->hdr.pGolScheme->AlphaValue != 100) 
121:               {
122:                   CopyPageWindow(_GFXActivePage, 
123:               		       _GFXBackgroundPage,
124:                                  pB->hdr.left, pB->hdr.top,pB->hdr.left, pB->hdr.top, 
125:               		       pB->hdr.right - pB->hdr.left, 
126:               		       pB->hdr.bottom - pB->hdr.top);	             									            
127:               }
128:               #endif
129:               
130:               
131:                   GOLAddObject((OBJ_HEADER *)pB);
008C70  78001E     MOV [W14], W0
008C72  07FCD0     RCALL GOLAddObject
132:               
133:               #ifdef USE_FOCUS
134:               // focus and alpha blend cannot be used together    
135:               #ifndef USE_ALPHABLEND_LITE
136:                   if(GetState(pB, BTN_FOCUSED))
008C74  78001E     MOV [W14], W0
008C76  900030     MOV [W0+6], W0
008C78  600061     AND W0, #0x1, W0
008C7A  784000     MOV.B W0, W0
008C7C  504FE0     SUB.B W0, #0x0, [W15]
008C7E  320002     BRA Z, 0x8C84
137:                       GOLSetFocus((OBJ_HEADER *)pB);
008C80  78001E     MOV [W14], W0
008C82  07FBF7     RCALL GOLSetFocus
138:               #endif
139:               #endif
140:                   return (pB);
008C84  78001E     MOV [W14], W0
141:               }
008C86  FA8000     ULNK
008C88  060000     RETURN
142:               
143:               /*********************************************************************
144:               * Function: BtnSetText(BUTTON *pB, XCHAR *pText)
145:               *
146:               *
147:               * Notes: Sets the text used in the button.
148:               *
149:               ********************************************************************/
150:               void BtnSetText(BUTTON *pB, XCHAR *pText)
151:               {
008C8A  FA0004     LNK #0x4
008C8C  780F00     MOV W0, [W14]
008C8E  980711     MOV W1, [W14+2]
152:                   #ifdef USE_BUTTON_MULTI_LINE
153:                   	int     width = 0, chCtr = 0, lineCtr = 1;
154:                   	XCHAR   ch, *pParser;
155:                   #endif
156:                   
157:                   pB->pText = pText;
008C90  78001E     MOV [W14], W0
008C92  90009E     MOV [W14+2], W1
008C94  981001     MOV W1, [W0+32]
158:               
159:               	#ifdef USE_BUTTON_MULTI_LINE
160:               
161:                       // calculate width and height taking into account the multiple lines of text
162:                       pParser = pB->pText;
163:                       ch = *pText;
164:               
165:                       // calculate the width (taken from the longest line)
166:                       while(1)
167:                       {
168:                           if((ch == 0x000A) || (ch == 0x0000))
169:                           {
170:                               if(width < GetTextWidth(pParser, pB->hdr.pGolScheme->pFont))
171:                               {
172:                                   width = GetTextWidth(pParser, pB->hdr.pGolScheme->pFont);
173:                               }
174:               
175:                               if(ch == 0x000A)
176:                               {
177:                                   pParser = pText + chCtr + 1;
178:                                   lineCtr++;
179:                               }
180:                               else
181:                               {
182:                                   break;
183:                               }
184:                           }
185:               
186:                           chCtr++;
187:                           ch = *(pText + chCtr);
188:                       }
189:               
190:                       pB->textWidth = width;
191:                       pB->textHeight = GetTextHeight(pB->hdr.pGolScheme->pFont) * lineCtr;
192:               	#else
193:               		pB->textWidth = GetTextWidth(pText, pB->hdr.pGolScheme->pFont);
008C96  78001E     MOV [W14], W0
008C98  900800     MOV [W0+16], W0
008C9A  900050     MOV [W0+10], W0
008C9C  780080     MOV W0, W1
008C9E  90001E     MOV [W14+2], W0
008CA0  07ECBC     RCALL GetTextWidth
008CA2  78009E     MOV [W14], W1
008CA4  9808E0     MOV W0, [W1+28]
194:                   	pB->textHeight = GetTextHeight(pB->hdr.pGolScheme->pFont);
008CA6  78001E     MOV [W14], W0
008CA8  900800     MOV [W0+16], W0
008CAA  900050     MOV [W0+10], W0
008CAC  07ECD1     RCALL GetTextHeight
008CAE  78009E     MOV [W14], W1
008CB0  9808F0     MOV W0, [W1+30]
195:                   #endif // #ifdef USE_BUTTON_MULTI_LINE
196:               }
008CB2  FA8000     ULNK
008CB4  060000     RETURN
197:               
198:               /*********************************************************************
199:               * Function: BtnMsgDefault(WORD translatedMsg, void *pObj, GOL_MSG* pMsg)
200:               *
201:               *
202:               * Notes: This the default operation to change the state of the button.
203:               *		 Called inside GOLMsg() when GOLMsgCallback() returns a 1.
204:               *
205:               ********************************************************************/
206:               void BtnMsgDefault(WORD translatedMsg, void *pObj, GOL_MSG *pMsg)
207:               {
008CB6  FA0008     LNK #0x8
008CB8  980710     MOV W0, [W14+2]
008CBA  980721     MOV W1, [W14+4]
008CBC  980732     MOV W2, [W14+6]
208:               
209:                   BUTTON *pB;
210:               
211:                   pB = (BUTTON *)pObj;
008CBE  90002E     MOV [W14+4], W0
008CC0  780F00     MOV W0, [W14]
212:               
213:               #ifdef USE_FOCUS  
214:                   #ifndef USE_ALPHABLEND_LITE
215:                           #ifdef USE_TOUCHSCREEN
216:                   if(pMsg->type == TYPE_TOUCHSCREEN)
008CC2  90003E     MOV [W14+6], W0
008CC4  784010     MOV.B [W0], W0
008CC6  504FE2     SUB.B W0, #0x2, [W15]
008CC8  3A0007     BRA NZ, 0x8CD8
217:                   {
218:                       if(!GetState(pB, BTN_FOCUSED))
008CCA  78001E     MOV [W14], W0
008CCC  900030     MOV [W0+6], W0
008CCE  600061     AND W0, #0x1, W0
008CD0  500FE0     SUB W0, #0x0, [W15]
008CD2  3A0002     BRA NZ, 0x8CD8
219:                       {
220:                           GOLSetFocus((OBJ_HEADER *)pB);
008CD4  78001E     MOV [W14], W0
008CD6  07FBCD     RCALL GOLSetFocus
221:                       }
222:                   }
223:               
224:                           #endif
225:                   #endif
226:               #endif
227:                   switch(translatedMsg)
008CD8  90001E     MOV [W14+2], W0
008CDA  500FE6     SUB W0, #0x6, [W15]
008CDC  320006     BRA Z, 0x8CEA
008CDE  500FE6     SUB W0, #0x6, [W15]
008CE0  390018     BRA NC, 0x8D12
008CE2  500068     SUB W0, #0x8, W0
008CE4  500FE1     SUB W0, #0x1, [W15]
008CE6  3E0017     BRA GTU, 0x8D16
008CE8  370007     BRA 0x8CF8
228:                   {
229:                       case BTN_MSG_PRESSED:
230:                           SetState(pB, BTN_PRESSED | BTN_DRAW);   // set pressed and redraw
008CEA  78001E     MOV [W14], W0
008CEC  78009E     MOV [W14], W1
008CEE  900131     MOV [W1+6], W2
008CF0  240041     MOV #0x4004, W1
008CF2  710081     IOR W2, W1, W1
008CF4  980031     MOV W1, [W0+6]
231:                           break;
008CF6  370010     BRA 0x8D18
232:               
233:                       case BTN_MSG_RELEASED:
234:                       case BTN_MSG_CANCELPRESS:
235:                           ClrState(pB, BTN_PRESSED);              // reset pressed
008CF8  78001E     MOV [W14], W0
008CFA  78009E     MOV [W14], W1
008CFC  900131     MOV [W1+6], W2
008CFE  2FFFB1     MOV #0xFFFB, W1
008D00  610081     AND W2, W1, W1
008D02  980031     MOV W1, [W0+6]
236:                           SetState(pB, BTN_DRAW);                 // redraw
008D04  78001E     MOV [W14], W0
008D06  78009E     MOV [W14], W1
008D08  900131     MOV [W1+6], W2
008D0A  240001     MOV #0x4000, W1
008D0C  710081     IOR W2, W1, W1
008D0E  980031     MOV W1, [W0+6]
237:                           break;
008D10  370003     BRA 0x8D18
238:               
239:                       default:
240:               
241:                           // catch all for button messages added by users and
242:                           // behavior defined by users in message callback
243:                           break;
008D12  000000     NOP
008D14  370001     BRA 0x8D18
008D16  000000     NOP
244:                   }
245:               }
008D18  FA8000     ULNK
008D1A  060000     RETURN
246:               
247:               /*********************************************************************
248:               * Function: WORD BtnTranslateMsg(void *pObj, GOL_MSG *pMsg)
249:               *
250:               *
251:               * Notes: Evaluates the message if the object will be affected by the 
252:               *		 message or not.
253:               *
254:               ********************************************************************/
255:               WORD BtnTranslateMsg(void *pObj, GOL_MSG *pMsg)
256:               {
008D1C  FA0006     LNK #0x6
008D1E  980710     MOV W0, [W14+2]
008D20  980721     MOV W1, [W14+4]
257:                   BUTTON *pB;
258:               
259:                   pB = (BUTTON *)pObj;
008D22  90001E     MOV [W14+2], W0
008D24  780F00     MOV W0, [W14]
260:               
261:               
262:                   // Evaluate if the message is for the button
263:                   // Check if disabled first
264:                   if(GetState(pB, BTN_DISABLED))
008D26  78001E     MOV [W14], W0
008D28  900030     MOV [W0+6], W0
008D2A  600062     AND W0, #0x2, W0
008D2C  500FE0     SUB W0, #0x0, [W15]
008D2E  320002     BRA Z, 0x8D34
265:                       return (OBJ_MSG_INVALID);
008D30  EB0000     CLR W0
008D32  3700B4     BRA 0x8E9C
266:               
267:                       #ifdef USE_TOUCHSCREEN
268:                   if(pMsg->type == TYPE_TOUCHSCREEN)
008D34  90002E     MOV [W14+4], W0
008D36  784010     MOV.B [W0], W0
008D38  504FE2     SUB.B W0, #0x2, [W15]
008D3A  3A0057     BRA NZ, 0x8DEA
269:                   {
270:               
271:                       // Check if it falls in the button's face
272:                       if
273:                       (
008D44  508F80     SUB W1, W0, [W15]
008D46  3D003C     BRA GE, 0x8DC0
274:                           (pB->hdr.left < pMsg->param1) &&
008D3C  78001E     MOV [W14], W0
008D3E  9000C0     MOV [W0+8], W1
008D40  90002E     MOV [W14+4], W0
008D42  900010     MOV [W0+2], W0
008D50  508F80     SUB W1, W0, [W15]
008D52  340036     BRA LE, 0x8DC0
275:                           (pB->hdr.right > pMsg->param1) &&
008D48  78001E     MOV [W14], W0
008D4A  9000E0     MOV [W0+12], W1
008D4C  90002E     MOV [W14+4], W0
008D4E  900010     MOV [W0+2], W0
008D5C  508F80     SUB W1, W0, [W15]
008D5E  3D0030     BRA GE, 0x8DC0
276:                           (pB->hdr.top < pMsg->param2) &&
008D54  78001E     MOV [W14], W0
008D56  9000D0     MOV [W0+10], W1
008D58  90002E     MOV [W14+4], W0
008D5A  900020     MOV [W0+4], W0
008D68  508F80     SUB W1, W0, [W15]
008D6A  34002A     BRA LE, 0x8DC0
277:                           (pB->hdr.bottom > pMsg->param2)
008D60  78001E     MOV [W14], W0
008D62  9000F0     MOV [W0+14], W1
008D64  90002E     MOV [W14+4], W0
008D66  900020     MOV [W0+4], W0
278:                       )
279:                       {
280:                           if(GetState(pB, BTN_TOGGLE))
008D6C  78001E     MOV [W14], W0
008D6E  900030     MOV [W0+6], W0
008D70  600068     AND W0, #0x8, W0
008D72  500FE0     SUB W0, #0x0, [W15]
008D74  32000D     BRA Z, 0x8D90
008DE0  000000     NOP
008DE2  370001     BRA 0x8DE6
008DE4  000000     NOP
281:                           {
282:                               if(pMsg->uiEvent == EVENT_RELEASE)
008D76  90002E     MOV [W14+4], W0
008D78  904010     MOV.B [W0+1], W0
008D7A  504FE4     SUB.B W0, #0x4, [W15]
008D7C  3A0031     BRA NZ, 0x8DE0
283:                               {
284:                                   if(GetState(pB, BTN_PRESSED))
008D7E  78001E     MOV [W14], W0
008D80  900030     MOV [W0+6], W0
008D82  600064     AND W0, #0x4, W0
008D84  500FE0     SUB W0, #0x0, [W15]
008D86  320002     BRA Z, 0x8D8C
285:                                       return (BTN_MSG_RELEASED);
008D88  200080     MOV #0x8, W0
008D8A  370088     BRA 0x8E9C
286:                                   else
287:                                       return (BTN_MSG_PRESSED);
008D8C  200060     MOV #0x6, W0
008D8E  370086     BRA 0x8E9C
288:                               }
289:                           }
290:                           else
291:                           {
292:                               if(pMsg->uiEvent == EVENT_RELEASE)
008D90  90002E     MOV [W14+4], W0
008D92  904010     MOV.B [W0+1], W0
008D94  504FE4     SUB.B W0, #0x4, [W15]
008D96  3A0002     BRA NZ, 0x8D9C
293:                                   return (BTN_MSG_RELEASED);
008D98  200080     MOV #0x8, W0
008D9A  370080     BRA 0x8E9C
294:                               if(pMsg->uiEvent == EVENT_STILLPRESS)
008D9C  90002E     MOV [W14+4], W0
008D9E  904010     MOV.B [W0+1], W0
008DA0  504FE3     SUB.B W0, #0x3, [W15]
008DA2  3A0007     BRA NZ, 0x8DB2
295:                               {
296:                                   if(GetState(pB, BTN_PRESSED))
008DA4  78001E     MOV [W14], W0
008DA6  900030     MOV [W0+6], W0
008DA8  600064     AND W0, #0x4, W0
008DAA  500FE0     SUB W0, #0x0, [W15]
008DAC  320002     BRA Z, 0x8DB2
297:                                       return (BTN_MSG_STILLPRESSED);
008DAE  200070     MOV #0x7, W0
008DB0  370075     BRA 0x8E9C
298:                               }
299:               
300:                               if(!GetState(pB, BTN_PRESSED))
008DB2  78001E     MOV [W14], W0
008DB4  900030     MOV [W0+6], W0
008DB6  600064     AND W0, #0x4, W0
008DB8  500FE0     SUB W0, #0x0, [W15]
008DBA  3A0014     BRA NZ, 0x8DE4
301:                                   return (BTN_MSG_PRESSED);
008DBC  200060     MOV #0x6, W0
008DBE  37006E     BRA 0x8E9C
302:                           }
303:                       }
304:                       else
305:                       {
306:                           if(!GetState(pB, BTN_TOGGLE))
008DC0  78001E     MOV [W14], W0
008DC2  900030     MOV [W0+6], W0
008DC4  600068     AND W0, #0x8, W0
008DC6  500FE0     SUB W0, #0x0, [W15]
008DC8  3A000E     BRA NZ, 0x8DE6
307:                           {
308:                               if((pMsg->uiEvent == EVENT_MOVE) && (GetState(pB, BTN_PRESSED)))
008DCA  90002E     MOV [W14+4], W0
008DCC  904010     MOV.B [W0+1], W0
008DCE  504FE1     SUB.B W0, #0x1, [W15]
008DD0  3A000A     BRA NZ, 0x8DE6
008DD2  78001E     MOV [W14], W0
008DD4  900030     MOV [W0+6], W0
008DD6  600064     AND W0, #0x4, W0
008DD8  500FE0     SUB W0, #0x0, [W15]
008DDA  320005     BRA Z, 0x8DE6
309:                                   return (BTN_MSG_CANCELPRESS);
008DDC  200090     MOV #0x9, W0
008DDE  37005E     BRA 0x8E9C
310:                           }
311:                       }
312:               
313:                       return (OBJ_MSG_INVALID);
008DE6  EB0000     CLR W0
008DE8  370059     BRA 0x8E9C
314:                   }
315:               
316:                       #endif
317:                       #ifdef USE_KEYBOARD
318:                   if(pMsg->type == TYPE_KEYBOARD)
008DEA  90002E     MOV [W14+4], W0
008DEC  784010     MOV.B [W0], W0
008DEE  504FE1     SUB.B W0, #0x1, [W15]
008DF0  3A0054     BRA NZ, 0x8E9A
319:                   {
320:                       if((WORD)pMsg->param1 == pB->hdr.ID)
008DF2  90002E     MOV [W14+4], W0
008DF4  900010     MOV [W0+2], W0
008DF6  780080     MOV W0, W1
008DF8  78001E     MOV [W14], W0
008DFA  780010     MOV [W0], W0
008DFC  508F80     SUB W1, W0, [W15]
008DFE  3A004B     BRA NZ, 0x8E96
321:                       {
322:                           if(pMsg->uiEvent == EVENT_KEYSCAN)
008E00  90002E     MOV [W14+4], W0
008E02  904010     MOV.B [W0+1], W0
008E04  504FE5     SUB.B W0, #0x5, [W15]
008E06  3A0047     BRA NZ, 0x8E96
323:                           {
324:                               if(GetState(pB, BTN_TOGGLE))
008E08  78001E     MOV [W14], W0
008E0A  900030     MOV [W0+6], W0
008E0C  600068     AND W0, #0x8, W0
008E0E  500FE0     SUB W0, #0x0, [W15]
008E10  320013     BRA Z, 0x8E38
325:                               {
326:                                   if((pMsg->param2 == SCAN_SPACE_RELEASED) || (pMsg->param2 == SCAN_CR_RELEASED))
008E12  90002E     MOV [W14+4], W0
008E14  9000A0     MOV [W0+4], W1
008E16  200B90     MOV #0xB9, W0
008E18  508F80     SUB W1, W0, [W15]
008E1A  320005     BRA Z, 0x8E26
008E1C  90002E     MOV [W14+4], W0
008E1E  9000A0     MOV [W0+4], W1
008E20  2009C0     MOV #0x9C, W0
008E22  508F80     SUB W1, W0, [W15]
008E24  3A0020     BRA NZ, 0x8E66
327:                                   {
328:                                       if(GetState(pB, BTN_PRESSED))
008E26  78001E     MOV [W14], W0
008E28  900030     MOV [W0+6], W0
008E2A  600064     AND W0, #0x4, W0
008E2C  500FE0     SUB W0, #0x0, [W15]
008E2E  320002     BRA Z, 0x8E34
329:                                           return (BTN_MSG_RELEASED);
008E30  200080     MOV #0x8, W0
008E32  370034     BRA 0x8E9C
330:                                       else
331:                                           return (BTN_MSG_PRESSED);
008E34  200060     MOV #0x6, W0
008E36  370032     BRA 0x8E9C
332:                                   }
333:                               }
334:                               else
335:                               {
336:                                   if((pMsg->param2 == SCAN_SPACE_PRESSED) || (pMsg->param2 == SCAN_CR_PRESSED))
008E38  90002E     MOV [W14+4], W0
008E3A  9000A0     MOV [W0+4], W1
008E3C  200390     MOV #0x39, W0
008E3E  508F80     SUB W1, W0, [W15]
008E40  320004     BRA Z, 0x8E4A
008E42  90002E     MOV [W14+4], W0
008E44  900020     MOV [W0+4], W0
008E46  500FFC     SUB W0, #0x1C, [W15]
008E48  3A0002     BRA NZ, 0x8E4E
337:                                   {
338:                                       return (BTN_MSG_PRESSED);
008E4A  200060     MOV #0x6, W0
008E4C  370027     BRA 0x8E9C
339:                                   }
340:               
341:                                   if((pMsg->param2 == SCAN_SPACE_RELEASED) || (pMsg->param2 == SCAN_CR_RELEASED))
008E4E  90002E     MOV [W14+4], W0
008E50  9000A0     MOV [W0+4], W1
008E52  200B90     MOV #0xB9, W0
008E54  508F80     SUB W1, W0, [W15]
008E56  320005     BRA Z, 0x8E62
008E58  90002E     MOV [W14+4], W0
008E5A  9000A0     MOV [W0+4], W1
008E5C  2009C0     MOV #0x9C, W0
008E5E  508F80     SUB W1, W0, [W15]
008E60  3A0002     BRA NZ, 0x8E66
342:                                   {
343:                                       return (BTN_MSG_RELEASED);
008E62  200080     MOV #0x8, W0
008E64  37001B     BRA 0x8E9C
344:                                   }
345:                               }
346:               
347:                               if((pMsg->param2 == SCAN_SPACE_PRESSED) || (pMsg->param2 == SCAN_CRA_PRESSED))
008E66  90002E     MOV [W14+4], W0
008E68  9000A0     MOV [W0+4], W1
008E6A  200390     MOV #0x39, W0
008E6C  508F80     SUB W1, W0, [W15]
008E6E  320005     BRA Z, 0x8E7A
008E70  90002E     MOV [W14+4], W0
008E72  9000A0     MOV [W0+4], W1
008E74  2002C0     MOV #0x2C, W0
008E76  508F80     SUB W1, W0, [W15]
008E78  3A0002     BRA NZ, 0x8E7E
348:                               {
349:                                   return (BTN_MSG_PRESSED);
008E7A  200060     MOV #0x6, W0
008E7C  37000F     BRA 0x8E9C
350:                               }
351:               
352:                               if((pMsg->param2 == SCAN_SPACE_RELEASED) || (pMsg->param2 == SCAN_CRA_RELEASED))
008E7E  90002E     MOV [W14+4], W0
008E80  9000A0     MOV [W0+4], W1
008E82  200B90     MOV #0xB9, W0
008E84  508F80     SUB W1, W0, [W15]
008E86  320005     BRA Z, 0x8E92
008E88  90002E     MOV [W14+4], W0
008E8A  9000A0     MOV [W0+4], W1
008E8C  200AC0     MOV #0xAC, W0
008E8E  508F80     SUB W1, W0, [W15]
008E90  3A0002     BRA NZ, 0x8E96
353:                               {
354:                                   return (BTN_MSG_RELEASED);
008E92  200080     MOV #0x8, W0
008E94  370003     BRA 0x8E9C
355:                               }
356:                           }
357:                       }
358:               
359:                       return (OBJ_MSG_INVALID);
008E96  EB0000     CLR W0
008E98  370001     BRA 0x8E9C
360:                   }
361:               
362:                       #endif
363:                   return (OBJ_MSG_INVALID);
008E9A  EB0000     CLR W0
364:               }
008E9C  FA8000     ULNK
008E9E  060000     RETURN
365:               /*********************************************************************
366:               * Button draw states
367:               ********************************************************************/
368:               typedef enum
369:               {
370:                   REMOVE,
371:                   RNDBUTTON_DRAW,
372:                   #ifdef USE_BUTTON_MULTI_LINE
373:                   CHECK_TEXT_DRAW,
374:                   #else
375:                   TEXT_DRAW,
376:                   #endif
377:                   TEXT_DRAW_RUN,
378:                   FOCUS_DRAW,
379:               } BTN_DRAW_STATES;
380:               /*********************************************************************
381:               * Function: inline WORD __attribute__((always_inline)) DrawButtonFocus(BUTTON *button, SHORT radius, BTN_DRAW_STATES *current_state)
382:               ********************************************************************/
383:               inline WORD __attribute__((always_inline)) DrawButtonFocus(BUTTON *button, SHORT radius, BTN_DRAW_STATES *current_state)
384:               {
008EA0  FA0006     LNK #0x6
008EA2  780F00     MOV W0, [W14]
008EA4  980711     MOV W1, [W14+2]
008EA6  980722     MOV W2, [W14+4]
385:                   
386:                   *current_state = FOCUS_DRAW;
008EA8  90002E     MOV [W14+4], W0
008EAA  200041     MOV #0x4, W1
008EAC  780801     MOV W1, [W0]
009200  90006E     MOV [W14+12], W0
009202  200041     MOV #0x4, W1
009204  780801     MOV W1, [W0]
0092C2  90081E     MOV [W14+18], W0
0092C4  200041     MOV #0x4, W1
0092C6  780801     MOV W1, [W0]
387:               
388:               #ifdef USE_NONBLOCKING_CONFIG
389:                   if(IsDeviceBusy()) 
390:                       return (0);
391:               #endif
392:               
393:                   if(GetState(button, BTN_FOCUSED))
008EAE  78001E     MOV [W14], W0
008EB0  900030     MOV [W0+6], W0
008EB2  600061     AND W0, #0x1, W0
008EB4  784000     MOV.B W0, W0
008EB6  504FE0     SUB.B W0, #0x0, [W15]
008EB8  32003F     BRA Z, 0x8F38
009206  90004E     MOV [W14+8], W0
009208  900030     MOV [W0+6], W0
00920A  600061     AND W0, #0x1, W0
00920C  784000     MOV.B W0, W0
00920E  504FE0     SUB.B W0, #0x0, [W15]
009210  32003F     BRA Z, 0x9290
0092C8  90007E     MOV [W14+14], W0
0092CA  900030     MOV [W0+6], W0
0092CC  600061     AND W0, #0x1, W0
0092CE  784000     MOV.B W0, W0
0092D0  504FE0     SUB.B W0, #0x0, [W15]
0092D2  32003F     BRA Z, 0x9352
394:                   {
395:                       SetLineType(FOCUS_LINE);
008EBA  200020     MOV #0x2, W0
008EBC  888240     MOV W0, _lineType
009212  200020     MOV #0x2, W0
009214  888240     MOV W0, _lineType
0092D4  200020     MOV #0x2, W0
0092D6  888240     MOV W0, _lineType
396:                       if(GetState(button, BTN_PRESSED))
008EBE  78001E     MOV [W14], W0
008EC0  900030     MOV [W0+6], W0
008EC2  600064     AND W0, #0x4, W0
008EC4  500FE0     SUB W0, #0x0, [W15]
008EC6  320005     BRA Z, 0x8ED2
009216  90004E     MOV [W14+8], W0
009218  900030     MOV [W0+6], W0
00921A  600064     AND W0, #0x4, W0
00921C  500FE0     SUB W0, #0x0, [W15]
00921E  320005     BRA Z, 0x922A
0092D8  90007E     MOV [W14+14], W0
0092DA  900030     MOV [W0+6], W0
0092DC  600064     AND W0, #0x4, W0
0092DE  500FE0     SUB W0, #0x0, [W15]
0092E0  320005     BRA Z, 0x92EC
397:                       {
398:                           SetColor(button->hdr.pGolScheme->TextColor1);
008EC8  78001E     MOV [W14], W0
008ECA  900800     MOV [W0+16], W0
008ECC  904030     MOV.B [W0+3], W0
008ECE  B7F13E     MOV.B WREG, _color
008ED0  370004     BRA 0x8EDA
009220  90004E     MOV [W14+8], W0
009222  900800     MOV [W0+16], W0
009224  904030     MOV.B [W0+3], W0
009226  B7F13E     MOV.B WREG, _color
009228  370004     BRA 0x9232
0092E2  90007E     MOV [W14+14], W0
0092E4  900800     MOV [W0+16], W0
0092E6  904030     MOV.B [W0+3], W0
0092E8  B7F13E     MOV.B WREG, _color
0092EA  370004     BRA 0x92F4
399:                       }
400:                       else
401:                       {
402:                           SetColor(button->hdr.pGolScheme->TextColor0);
008ED2  78001E     MOV [W14], W0
008ED4  900800     MOV [W0+16], W0
008ED6  904020     MOV.B [W0+2], W0
008ED8  B7F13E     MOV.B WREG, _color
00922A  90004E     MOV [W14+8], W0
00922C  900800     MOV [W0+16], W0
00922E  904020     MOV.B [W0+2], W0
009230  B7F13E     MOV.B WREG, _color
0092EC  90007E     MOV [W14+14], W0
0092EE  900800     MOV [W0+16], W0
0092F0  904020     MOV.B [W0+2], W0
0092F2  B7F13E     MOV.B WREG, _color
403:                       }
404:               
405:                       // check if the object has rounded corners or not
406:                       if(!button->radius)
008EDA  78001E     MOV [W14], W0
008EDC  900850     MOV [W0+26], W0
008EDE  500FE0     SUB W0, #0x0, [W15]
008EE0  3A0012     BRA NZ, 0x8F06
009232  90004E     MOV [W14+8], W0
009234  900850     MOV [W0+26], W0
009236  500FE0     SUB W0, #0x0, [W15]
009238  3A0012     BRA NZ, 0x925E
0092F4  90007E     MOV [W14+14], W0
0092F6  900850     MOV [W0+26], W0
0092F8  500FE0     SUB W0, #0x0, [W15]
0092FA  3A0012     BRA NZ, 0x9320
407:                       {
408:                           if
409:                           (
008EFE  500FE0     SUB W0, #0x0, [W15]
008F00  3A0019     BRA NZ, 0x8F34
009256  500FE0     SUB W0, #0x0, [W15]
009258  3A0019     BRA NZ, 0x928C
009318  500FE0     SUB W0, #0x0, [W15]
00931A  3A0019     BRA NZ, 0x934E
410:                               !Rectangle
008EE2  78001E     MOV [W14], W0
008EE4  900070     MOV [W0+14], W0
008EE6  5001E5     SUB W0, #0x5, W3
008EE8  78001E     MOV [W14], W0
008EEA  900060     MOV [W0+12], W0
008EEC  500165     SUB W0, #0x5, W2
008EEE  78001E     MOV [W14], W0
008EF0  900050     MOV [W0+10], W0
008EF2  4000E5     ADD W0, #0x5, W1
008EF4  78001E     MOV [W14], W0
008EF6  900040     MOV [W0+8], W0
008EF8  400065     ADD W0, #0x5, W0
008EFA  EB0200     CLR W4
008EFC  07E6BF     RCALL Bevel
00923A  90004E     MOV [W14+8], W0
00923C  900070     MOV [W0+14], W0
00923E  5001E5     SUB W0, #0x5, W3
009240  90004E     MOV [W14+8], W0
009242  900060     MOV [W0+12], W0
009244  500165     SUB W0, #0x5, W2
009246  90004E     MOV [W14+8], W0
009248  900050     MOV [W0+10], W0
00924A  4000E5     ADD W0, #0x5, W1
00924C  90004E     MOV [W14+8], W0
00924E  900040     MOV [W0+8], W0
009250  400065     ADD W0, #0x5, W0
009252  EB0200     CLR W4
009254  07E513     RCALL Bevel
0092FC  90007E     MOV [W14+14], W0
0092FE  900070     MOV [W0+14], W0
009300  5001E5     SUB W0, #0x5, W3
009302  90007E     MOV [W14+14], W0
009304  900060     MOV [W0+12], W0
009306  500165     SUB W0, #0x5, W2
009308  90007E     MOV [W14+14], W0
00930A  900050     MOV [W0+10], W0
00930C  4000E5     ADD W0, #0x5, W1
00930E  90007E     MOV [W14+14], W0
009310  900040     MOV [W0+8], W0
009312  400065     ADD W0, #0x5, W0
009314  EB0200     CLR W4
009316  07E4B2     RCALL Bevel
411:                                   (
412:                                       button->hdr.left + GOL_EMBOSS_SIZE + 2,
413:                                       button->hdr.top + GOL_EMBOSS_SIZE + 2,
414:                                       button->hdr.right - GOL_EMBOSS_SIZE - 2,
415:                                       button->hdr.bottom - GOL_EMBOSS_SIZE - 2
416:                                   )
417:                           )
418:                           {
419:                               return (0);
008F02  EB0000     CLR W0
008F04  37001D     BRA 0x8F40
00925A  EB0000     CLR W0
00925C  37001D     BRA 0x9298
00931C  EB0000     CLR W0
00931E  37001D     BRA 0x935A
420:                           }
421:                       }
422:                       else
423:                       {
424:               
425:                           // original center is still the same, but radius is reduced
426:                           if
427:                           (
008F2C  500FE0     SUB W0, #0x0, [W15]
008F2E  3A0002     BRA NZ, 0x8F34
009284  500FE0     SUB W0, #0x0, [W15]
009286  3A0002     BRA NZ, 0x928C
009346  500FE0     SUB W0, #0x0, [W15]
009348  3A0002     BRA NZ, 0x934E
428:                               !Bevel
429:                                   (
008F2A  07E6A8     RCALL Bevel
009282  07E4FC     RCALL Bevel
009344  07E49B     RCALL Bevel
430:                                       button->hdr.left + radius,
008F22  78001E     MOV [W14], W0
008F24  9002C0     MOV [W0+8], W5
008F26  90001E     MOV [W14+2], W0
008F28  428000     ADD W5, W0, W0
00927A  90004E     MOV [W14+8], W0
00927C  9002C0     MOV [W0+8], W5
00927E  90005E     MOV [W14+10], W0
009280  428000     ADD W5, W0, W0
00933C  90007E     MOV [W14+14], W0
00933E  9002C0     MOV [W0+8], W5
009340  90080E     MOV [W14+16], W0
009342  428000     ADD W5, W0, W0
431:                                       button->hdr.top + radius,
008F1A  78001E     MOV [W14], W0
008F1C  9000D0     MOV [W0+10], W1
008F1E  90001E     MOV [W14+2], W0
008F20  408080     ADD W1, W0, W1
009272  90004E     MOV [W14+8], W0
009274  9000D0     MOV [W0+10], W1
009276  90005E     MOV [W14+10], W0
009278  408080     ADD W1, W0, W1
009334  90007E     MOV [W14+14], W0
009336  9000D0     MOV [W0+10], W1
009338  90080E     MOV [W14+16], W0
00933A  408080     ADD W1, W0, W1
432:                                       button->hdr.right - radius,
008F12  78001E     MOV [W14], W0
008F14  9000E0     MOV [W0+12], W1
008F16  90001E     MOV [W14+2], W0
008F18  508100     SUB W1, W0, W2
00926A  90004E     MOV [W14+8], W0
00926C  9000E0     MOV [W0+12], W1
00926E  90005E     MOV [W14+10], W0
009270  508100     SUB W1, W0, W2
00932C  90007E     MOV [W14+14], W0
00932E  9000E0     MOV [W0+12], W1
009330  90080E     MOV [W14+16], W0
009332  508100     SUB W1, W0, W2
433:                                       button->hdr.bottom - radius,
008F0A  78001E     MOV [W14], W0
008F0C  9000F0     MOV [W0+14], W1
008F0E  90001E     MOV [W14+2], W0
008F10  508180     SUB W1, W0, W3
009262  90004E     MOV [W14+8], W0
009264  9000F0     MOV [W0+14], W1
009266  90005E     MOV [W14+10], W0
009268  508180     SUB W1, W0, W3
009324  90007E     MOV [W14+14], W0
009326  9000F0     MOV [W0+14], W1
009328  90080E     MOV [W14+16], W0
00932A  508180     SUB W1, W0, W3
434:                                       radius - 2 - GOL_EMBOSS_SIZE
008F06  90001E     MOV [W14+2], W0
008F08  500265     SUB W0, #0x5, W4
00925E  90005E     MOV [W14+10], W0
009260  500265     SUB W0, #0x5, W4
009320  90080E     MOV [W14+16], W0
009322  500265     SUB W0, #0x5, W4
435:                                   )
436:                           )
437:                           {
438:                               return (0);
008F30  EB0000     CLR W0
008F32  370006     BRA 0x8F40
009288  EB0000     CLR W0
00928A  370006     BRA 0x9298
00934A  EB0000     CLR W0
00934C  370006     BRA 0x935A
439:                           }
440:                       }
441:               
442:                       SetLineType(SOLID_LINE);
008F34  EB0000     CLR W0
008F36  888240     MOV W0, _lineType
00928C  EB0000     CLR W0
00928E  888240     MOV W0, _lineType
00934E  EB0000     CLR W0
009350  888240     MOV W0, _lineType
443:                   }
444:               
445:               	#ifdef USE_ALPHABLEND
446:                   if(button->hdr.pGolScheme->AlphaValue != 100) 
447:                   {
448:               		AlphaBlendWindow(_GFXActivePage, button->hdr.left, button->hdr.top,
449:               						 _GFXBackgroundPage, button->hdr.left, button->hdr.top,
450:               						 _GFXActivePage, button->hdr.left, button->hdr.top,
451:               					     button->hdr.right - button->hdr.left, 
452:               					     button->hdr.bottom - button->hdr.top,  	
453:               					     button->hdr.pGolScheme->AlphaValue);			
454:               	}  
455:               	#endif
456:               
457:                   *current_state = REMOVE;
008F38  90002E     MOV [W14+4], W0
008F3A  EB0080     CLR W1
008F3C  780801     MOV W1, [W0]
009290  90006E     MOV [W14+12], W0
009292  EB0080     CLR W1
009294  780801     MOV W1, [W0]
009352  90081E     MOV [W14+18], W0
009354  EB0080     CLR W1
009356  780801     MOV W1, [W0]
458:                   return 1;
008F3E  200010     MOV #0x1, W0
009296  200010     MOV #0x1, W0
009358  200010     MOV #0x1, W0
459:               }
008F40  FA8000     ULNK
008F42  060000     RETURN
460:               /*********************************************************************
461:               * Function: inline void __attribute__((always_inline)) SetButtonTextPosition(BUTTON *button, XCHAR *pCurLine, SHORT lineCtr)
462:               ********************************************************************/
463:               #ifdef USE_BUTTON_MULTI_LINE
464:               inline void __attribute__((always_inline)) SetButtonTextPosition(BUTTON *button, XCHAR *pCurLine, SHORT lineCtr)
465:               {
466:                   WORD xText, yText;
467:                   SHORT textWidth;
468:               
469:                   SetFont(button->hdr.pGolScheme->pFont);
470:                   textWidth = GetTextWidth(pCurLine, button->hdr.pGolScheme->pFont);
471:               
472:                   // check text alignment
473:                   if(GetState(button, BTN_TEXTRIGHT))
474:                   {
475:                       xText = button->hdr.right - (textWidth + GOL_EMBOSS_SIZE + 2);
476:                   }
477:                   else if(GetState(button, BTN_TEXTLEFT))
478:                   {
479:                       xText = button->hdr.left + GOL_EMBOSS_SIZE + 2;
480:                   }
481:                   else
482:                   {
483:               
484:                       // centered	text in x direction
485:                       xText = (button->hdr.left + button->hdr.right - textWidth) >> 1;
486:                   }
487:               
488:                   if(GetState(button, BTN_TEXTTOP))
489:                   {
490:                       yText = button->hdr.top + GOL_EMBOSS_SIZE + (lineCtr * GetTextHeight(button->hdr.pGolScheme->pFont));
491:                   }
492:                   else if(GetState(button, BTN_TEXTBOTTOM))
493:                   {
494:                       yText = button->hdr.bottom - (GOL_EMBOSS_SIZE + button->textHeight) + (lineCtr * GetTextHeight(button->hdr.pGolScheme->pFont));
495:                   }
496:                   else
497:                   {
498:               
499:                       // centered	text in y direction
500:                       yText = ((button->hdr.bottom + button->hdr.top - button->textHeight) >> 1) + (lineCtr * GetTextHeight(button->hdr.pGolScheme->pFont));
501:                   }
502:               
503:                   MoveTo(xText, yText);
504:               
505:               }
506:               #endif
507:               /*********************************************************************
508:               * Function: WORD BtnDraw(void *pObj)
509:               *
510:               *
511:               * Notes: This is the state machine to draw the button.
512:               *
513:               ********************************************************************/
514:               WORD BtnDraw(void *pObj)
515:               {
008F44  FA0016     LNK #0x16
008F46  BE9F88     MOV.D W8, [W15++]
008F48  781F8A     MOV W10, [W15++]
008F4A  980F20     MOV W0, [W14+20]
516:               
517:                   static BTN_DRAW_STATES state = REMOVE;
518:                   static SHORT width, height, radius;
519:               
520:                   #ifdef USE_BUTTON_MULTI_LINE
521:                   static SHORT charCtr = 0, lineCtr = 0;
522:                   static XCHAR *pCurLine = NULL;
523:                   XCHAR ch = 0;
524:                   #else
525:                   WORD xText, yText;
526:                   #endif
527:                   GFX_COLOR embossLtClr, embossDkClr;
528:                   static GFX_COLOR faceClr;
529:                   BUTTON *pB;
530:                   
531:                   pB = (BUTTON *)pObj;
008F4C  90082E     MOV [W14+20], W0
008F4E  980730     MOV W0, [W14+6]
532:               
533:                   if(IsDeviceBusy())
008F50  0719E0     RCALL IsDeviceBusy
008F52  500FE0     SUB W0, #0x0, [W15]
008F54  320002     BRA Z, 0x8F5A
534:                       return (0);
008F56  EB0000     CLR W0
008F58  370207     BRA 0x9368
535:               
536:                   switch(state)
008F5A  808A50     MOV state, W0
008F5C  200001     MOV #0x0, W1
008F5E  200042     MOV #0x4, W2
008F60  200003     MOV #0x0, W3
008F62  500F82     SUB W0, W2, [W15]
008F64  588F83     SUBB W1, W3, [W15]
008F66  3E01FF     BRA GTU, 0x9366
008F68  016000     BRA W0
008F6A  370004     BRA 0x8F74
008F6C  370095     BRA 0x9098
008F6E  3700D4     BRA 0x9118
008F70  370199     BRA 0x92A4
008F72  3701A1     BRA 0x92B6
537:                   {
538:                       case REMOVE:
539:                           if(IsDeviceBusy())
008F74  0719CE     RCALL IsDeviceBusy
008F76  500FE0     SUB W0, #0x0, [W15]
008F78  320002     BRA Z, 0x8F7E
540:                               return (0);
008F7A  EB0000     CLR W0
008F7C  3701F5     BRA 0x9368
541:               
542:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
543:                           GFX_DRIVER_SetupDrawUpdate( pB->hdr.left,
544:                                                       pB->hdr.top,
545:                                                       pB->hdr.right,
546:                                                       pB->hdr.bottom);
547:               #endif
548:                           if(GetState(pB, BTN_HIDE))
008F7E  90003E     MOV [W14+6], W0
008F80  900030     MOV [W0+6], W0
008F82  500FE0     SUB W0, #0x0, [W15]
008F84  3D0013     BRA GE, 0x8FAC
549:                           {                       // Hide the button (remove from screen)
550:               
551:               				#ifdef USE_ALPHABLEND
552:               				if(pB->hdr.pGolScheme->AlphaValue != 100)
553:                          		{
554:               					  
555:               					CopyPageWindow(_GFXBackgroundPage, 
556:               							   _GFXActivePage,
557:                                              pB->hdr.left, pB->hdr.top,pB->hdr.left, pB->hdr.top, 
558:               							   pB->hdr.right - pB->hdr.left, 
559:               							   pB->hdr.bottom - pB->hdr.top);
560:               	           	}	           	
561:               	           	else
562:               				#endif
563:               
564:                               SetColor(pB->hdr.pGolScheme->CommonBkColor);
008F86  90003E     MOV [W14+6], W0
008F88  900800     MOV [W0+16], W0
008F8A  904800     MOV.B [W0+8], W0
008F8C  B7F13E     MOV.B WREG, _color
565:                               if(!Bar(pB->hdr.left, pB->hdr.top, pB->hdr.right, pB->hdr.bottom))
008F8E  90003E     MOV [W14+6], W0
008F90  9001F0     MOV [W0+14], W3
008F92  90003E     MOV [W14+6], W0
008F94  900160     MOV [W0+12], W2
008F96  90003E     MOV [W14+6], W0
008F98  9000D0     MOV [W0+10], W1
008F9A  90003E     MOV [W14+6], W0
008F9C  900040     MOV [W0+8], W0
008F9E  07E28E     RCALL Bar
008FA0  500FE0     SUB W0, #0x0, [W15]
008FA2  3A0002     BRA NZ, 0x8FA8
566:                               {
567:                                   return (0);
008FA4  EB0000     CLR W0
008FA6  3701E0     BRA 0x9368
568:                               }
569:               
570:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
571:                               GFX_DRIVER_CompleteDrawUpdate(   pB->hdr.left,
572:                                                               pB->hdr.top,
573:                                                               pB->hdr.right,
574:                                                               pB->hdr.bottom);
575:               #endif
576:                               return (1);
008FA8  200010     MOV #0x1, W0
008FAA  3701DE     BRA 0x9368
577:                           }
578:               
579:                           /* Note: that width and height adjustment considers the following assumptions:
580:               					1. if circular width = height = radius*2
581:               					2. if vertical capsule width = radius*2
582:               					3. if horizontal capsule height = radius*2
583:               					4. radius must be less than or equal to width if height is greater than width
584:               					5. radius must be less than or equal to height if width is greater than height
585:               					6. if button is cornered, radius must be zero
586:               			*/
587:                           radius = pB->radius;    // get radius
008FAC  90003E     MOV [W14+6], W0
008FAE  900850     MOV [W0+26], W0
008FB0  888A60     MOV W0, radius
588:                           width = (pB->hdr.right - pB->hdr.left) - (radius * 2);  // get width
008FB2  90003E     MOV [W14+6], W0
008FB4  9000E0     MOV [W0+12], W1
008FB6  90003E     MOV [W14+6], W0
008FB8  900040     MOV [W0+8], W0
008FBA  508100     SUB W1, W0, W2
008FBC  808A61     MOV radius, W1
008FBE  2FFFE0     MOV #0xFFFE, W0
008FC0  B98800     MUL.SS W1, W0, W0
008FC2  780000     MOV W0, W0
008FC4  410000     ADD W2, W0, W0
008FC6  888A70     MOV W0, width
589:                           height = (pB->hdr.bottom - pB->hdr.top) - (radius * 2); // get height
008FC8  90003E     MOV [W14+6], W0
008FCA  9000F0     MOV [W0+14], W1
008FCC  90003E     MOV [W14+6], W0
008FCE  900050     MOV [W0+10], W0
008FD0  508100     SUB W1, W0, W2
008FD2  808A61     MOV radius, W1
008FD4  2FFFE0     MOV #0xFFFE, W0
008FD6  B98800     MUL.SS W1, W0, W0
008FD8  780000     MOV W0, W0
008FDA  410000     ADD W2, W0, W0
008FDC  888A80     MOV W0, height
590:               
591:               			if(!GetState(pB, BTN_NOPANEL))
008FDE  90003E     MOV [W14+6], W0
008FE0  9000B0     MOV [W0+6], W1
008FE2  202000     MOV #0x200, W0
008FE4  608000     AND W1, W0, W0
008FE6  500FE0     SUB W0, #0x0, [W15]
008FE8  3A0055     BRA NZ, 0x9094
592:               			{
593:                               if(!GetState(pB, BTN_DISABLED))
008FEA  90003E     MOV [W14+6], W0
008FEC  900030     MOV [W0+6], W0
008FEE  600062     AND W0, #0x2, W0
008FF0  500FE0     SUB W0, #0x0, [W15]
008FF2  3A001F     BRA NZ, 0x9032
594:                               {
595:                                   if(GetState(pB, BTN_PRESSED))
008FF4  90003E     MOV [W14+6], W0
008FF6  900030     MOV [W0+6], W0
008FF8  600064     AND W0, #0x4, W0
008FFA  500FE0     SUB W0, #0x0, [W15]
008FFC  32000D     BRA Z, 0x9018
596:                                   {
597:                                       embossDkClr = pB->hdr.pGolScheme->EmbossLtColor;
008FFE  90003E     MOV [W14+6], W0
009000  900800     MOV [W0+16], W0
009002  904090     MOV.B [W0+1], W1
009004  984751     MOV.B W1, [W14+5]
598:                                       embossLtClr = pB->hdr.pGolScheme->EmbossDkColor;
009006  90003E     MOV [W14+6], W0
009008  900800     MOV [W0+16], W0
00900A  784090     MOV.B [W0], W1
00900C  984741     MOV.B W1, [W14+4]
599:                                       faceClr = pB->hdr.pGolScheme->Color1;
00900E  90003E     MOV [W14+6], W0
009010  900800     MOV [W0+16], W0
009012  904060     MOV.B [W0+6], W0
009014  B7F152     MOV.B WREG, faceClr
009016  370019     BRA 0x904A
600:                                   }
601:                                   else
602:                                   {
603:                                       embossLtClr = pB->hdr.pGolScheme->EmbossLtColor;
009018  90003E     MOV [W14+6], W0
00901A  900800     MOV [W0+16], W0
00901C  904090     MOV.B [W0+1], W1
00901E  984741     MOV.B W1, [W14+4]
604:                                       embossDkClr = pB->hdr.pGolScheme->EmbossDkColor;
009020  90003E     MOV [W14+6], W0
009022  900800     MOV [W0+16], W0
009024  784090     MOV.B [W0], W1
009026  984751     MOV.B W1, [W14+5]
605:                                       faceClr = pB->hdr.pGolScheme->Color0;
009028  90003E     MOV [W14+6], W0
00902A  900800     MOV [W0+16], W0
00902C  904050     MOV.B [W0+5], W0
00902E  B7F152     MOV.B WREG, faceClr
009030  37000C     BRA 0x904A
606:                                   }
607:                               }
608:                               else
609:                               {
610:                                   embossLtClr = pB->hdr.pGolScheme->EmbossLtColor;
009032  90003E     MOV [W14+6], W0
009034  900800     MOV [W0+16], W0
009036  904090     MOV.B [W0+1], W1
009038  984741     MOV.B W1, [W14+4]
611:                                   embossDkClr = pB->hdr.pGolScheme->EmbossDkColor;
00903A  90003E     MOV [W14+6], W0
00903C  900800     MOV [W0+16], W0
00903E  784090     MOV.B [W0], W1
009040  984751     MOV.B W1, [W14+5]
612:                                   faceClr = pB->hdr.pGolScheme->ColorDisabled;
009042  90003E     MOV [W14+6], W0
009044  900800     MOV [W0+16], W0
009046  904070     MOV.B [W0+7], W0
009048  B7F152     MOV.B WREG, faceClr
613:                               }
614:               
615:               			    #ifdef USE_ALPHABLEND
616:               			    if(pB->hdr.pGolScheme->AlphaValue != 100) 
617:                               {
618:                                     CopyPageWindow(_GFXBackgroundPage, 
619:               							   _GFXActivePage,
620:                                              pB->hdr.left, pB->hdr.top,pB->hdr.left, pB->hdr.top, 
621:               							   pB->hdr.right - pB->hdr.left, 
622:               							   pB->hdr.bottom - pB->hdr.top);	             									            
623:               			    }
624:               			    #endif
625:               
626:                               SetLineThickness(NORMAL_LINE);
00904A  EB4000     CLR.B W0
00904C  B7F04A     MOV.B WREG, _lineThickness
627:                               SetLineType(SOLID_LINE);
00904E  EB0000     CLR W0
009050  888240     MOV W0, _lineType
628:               
629:                               #ifdef USE_GRADIENT
630:                               SetGOLPanelGradient(pB->hdr.pGolScheme);                
631:                               #endif
632:               
633:                               #ifdef USE_ALPHABLEND_LITE
634:                               SetPrevAlphaColor(pB->previousAlphaColor); 
635:                               SetGOLPanelAlpha(pB->hdr.pGolScheme->AlphaValue);
636:                               #endif
637:               
638:                               GOLPanelDraw
009052  90003E     MOV [W14+6], W0
009054  9000C0     MOV [W0+8], W1
009056  808A60     MOV radius, W0
009058  408000     ADD W1, W0, W0
00905A  8888A0     MOV W0, _rpnlX1
00905C  90003E     MOV [W14+6], W0
00905E  9000D0     MOV [W0+10], W1
009060  808A60     MOV radius, W0
009062  408000     ADD W1, W0, W0
009064  8888B0     MOV W0, _rpnlY1
009066  90003E     MOV [W14+6], W0
009068  9000E0     MOV [W0+12], W1
00906A  808A60     MOV radius, W0
00906C  508000     SUB W1, W0, W0
00906E  8888C0     MOV W0, _rpnlX2
009070  90003E     MOV [W14+6], W0
009072  9000F0     MOV [W0+14], W1
009074  808A60     MOV radius, W0
009076  508000     SUB W1, W0, W0
009078  8888D0     MOV W0, _rpnlY2
00907A  808A60     MOV radius, W0
00907C  8888E0     MOV W0, _rpnlR
00907E  BFD152     MOV.B faceClr, WREG
009080  B7F11E     MOV.B WREG, _rpnlFaceColor
009082  90404E     MOV.B [W14+4], W0
009084  B7F11F     MOV.B WREG, _rpnlEmbossLtColor
009086  90405E     MOV.B [W14+5], W0
009088  B7F120     MOV.B WREG, _rpnlEmbossDkColor
00908A  90003E     MOV [W14+6], W0
00908C  901010     MOV [W0+34], W0
00908E  888B60     MOV W0, 0x116C
009090  B3C030     MOV #0x3, W0
009092  B7F121     MOV.B WREG, _rpnlEmbossSize
639:                               (
640:                                   pB->hdr.left + radius,
641:                                   pB->hdr.top + radius,
642:                                   pB->hdr.right - radius,
643:                                   pB->hdr.bottom - radius,
644:                                   radius,
645:                                   faceClr,
646:                                   embossLtClr,
647:                                   embossDkClr,
648:                                   pB->pBitmap,
649:                                   GOL_EMBOSS_SIZE
650:                               );
651:               	  		}         	
652:                           state = RNDBUTTON_DRAW;
009094  200010     MOV #0x1, W0
009096  888A50     MOV W0, state
653:               
654:                       case RNDBUTTON_DRAW:
655:               			if (GetState(pB, BTN_NOPANEL))
009098  90003E     MOV [W14+6], W0
00909A  9000B0     MOV [W0+6], W1
00909C  202000     MOV #0x200, W0
00909E  608000     AND W1, W0, W0
0090A0  500FE0     SUB W0, #0x0, [W15]
0090A2  320028     BRA Z, 0x90F4
656:                           {
657:               	        	// check if there is an image to be drawn
658:               	        	if (pB->pBitmap != NULL)
0090A4  90003E     MOV [W14+6], W0
0090A6  901010     MOV [W0+34], W0
0090A8  500FE0     SUB W0, #0x0, [W15]
0090AA  320034     BRA Z, 0x9114
659:               	        	{
660:                               	if
661:                                   (
0090EC  500FE0     SUB W0, #0x0, [W15]
0090EE  3A0012     BRA NZ, 0x9114
662:                                       !PutImage
0090AC  90003E     MOV [W14+6], W0
0090AE  901490     MOV [W0+34], W9
0090B0  90003E     MOV [W14+6], W0
0090B2  9000D0     MOV [W0+10], W1
0090B4  90003E     MOV [W14+6], W0
0090B6  900070     MOV [W0+14], W0
0090B8  408400     ADD W1, W0, W8
0090BA  90003E     MOV [W14+6], W0
0090BC  901010     MOV [W0+34], W0
0090BE  07EAEF     RCALL GetImageHeight
0090C0  540000     SUB W8, W0, W0
0090C2  D18000     ASR W0, W0
0090C4  E80400     INC W0, W8
0090C6  90003E     MOV [W14+6], W0
0090C8  9000E0     MOV [W0+12], W1
0090CA  90003E     MOV [W14+6], W0
0090CC  900040     MOV [W0+8], W0
0090CE  408500     ADD W1, W0, W10
0090D0  90003E     MOV [W14+6], W0
0090D2  901010     MOV [W0+34], W0
0090D4  07EACF     RCALL GetImageWidth
0090D6  550000     SUB W10, W0, W0
0090D8  D18000     ASR W0, W0
0090DA  E80000     INC W0, W0
0090DC  EB0380     CLR W7
0090DE  EB0300     CLR W6
0090E0  EB0280     CLR W5
0090E2  EB0200     CLR W4
0090E4  B3C013     MOV #0x1, W3
0090E6  780109     MOV W9, W2
0090E8  780088     MOV W8, W1
0090EA  07EC29     RCALL PutImagePartial
663:                                           (
664:                                               ((pB->hdr.right + pB->hdr.left - GetImageWidth((void *)pB->pBitmap)) >> 1) + 1,
665:                                               ((pB->hdr.top + pB->hdr.bottom - GetImageHeight((void *)pB->pBitmap)) >> 1) + 1,
666:                                               pB->pBitmap,IMAGE_NORMAL
667:                                           )
668:                                   )
669:                                   {
670:                                       return (0);
0090F0  EB0000     CLR W0
0090F2  37013A     BRA 0x9368
671:                                   }
672:                         		}  
673:                   		}
674:                   		else
675:                   		{      
676:                              	if (GetState(pB, BTN_TWOTONE))
0090F4  90003E     MOV [W14+6], W0
0090F6  9000B0     MOV [W0+6], W1
0090F8  201000     MOV #0x100, W0
0090FA  608000     AND W1, W0, W0
0090FC  500FE0     SUB W0, #0x0, [W15]
0090FE  320005     BRA Z, 0x910A
677:               	        	{
678:               	            	if(!GOLTwoTonePanelDrawTsk())
009100  07FC7D     RCALL GOLTwoTonePanelDrawTsk
009102  500FE0     SUB W0, #0x0, [W15]
009104  3A0007     BRA NZ, 0x9114
679:               	            	{
680:               	                	return (0);
009106  EB0000     CLR W0
009108  37012F     BRA 0x9368
681:               	            	}
682:               	        	}	
683:               	        	else
684:               	        	{
685:               		            if(!GOLPanelDrawTsk())
00910A  07FB70     RCALL GOLPanelDrawTsk
00910C  500FE0     SUB W0, #0x0, [W15]
00910E  3A0002     BRA NZ, 0x9114
686:               		            {
687:               		                return (0);
009110  EB0000     CLR W0
009112  37012A     BRA 0x9368
688:               		            }
689:                                   //while(!GOLPanelDrawTsk());    									
690:               				}
691:               
692:                               #ifdef USE_ALPHABLEND_LITE
693:                               pB->previousAlphaColor = faceClr;
694:                               #endif
695:               			}
696:               
697:                           #ifdef USE_BUTTON_MULTI_LINE
698:                           state = CHECK_TEXT_DRAW;
699:                           #else
700:                           state = TEXT_DRAW;
009114  200020     MOV #0x2, W0
009116  888A50     MOV W0, state
701:                           #endif
702:               
703:                       #ifdef USE_BUTTON_MULTI_LINE
704:                       case CHECK_TEXT_DRAW:
705:                           if(pB->pText != NULL)
706:                           {
707:                               if(!GetState(pB, BTN_DISABLED))
708:                               {
709:                                   if(GetState(pB, BTN_PRESSED))
710:                                   {
711:                                       SetColor(pB->hdr.pGolScheme->TextColor1);
712:                                   }
713:                                   else
714:                                   {
715:                                       SetColor(pB->hdr.pGolScheme->TextColor0);
716:                                   }
717:                               }
718:                               else
719:                               {
720:                                   SetColor(pB->hdr.pGolScheme->TextColorDisabled);
721:                               }
722:               
723:                               pCurLine = pB->pText;
724:                               lineCtr = 0;
725:                               charCtr = 0;
726:                               SetButtonTextPosition(pB, pCurLine, lineCtr);
727:                               state = TEXT_DRAW_RUN;
728:                           }
729:                           else
730:                           {
731:                               if(DrawButtonFocus(pB, radius, &state))
732:                               {
733:                                   #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
734:                                       GFX_DRIVER_CompleteDrawUpdate(   pB->hdr.left,
735:                                                                       pB->hdr.top,
736:                                                                       pB->hdr.right,
737:                                                                       pB->hdr.bottom);
738:                                   #endif
739:                                   return 1;
740:                               }
741:                               return 0;
742:                           }
743:               
744:                       case TEXT_DRAW_RUN:
745:                           ch = *(pCurLine + charCtr);
746:               
747:                           // output one character at time until a newline character or a NULL character is sampled
748:                           while(0x0000 != ch)
749:                           {
750:                               if(!OutChar(ch))
751:                                   return (0);
752:                               // render the character
753:                               charCtr++;                          // update to next character
754:                               ch = *(pCurLine + charCtr);
755:               
756:                               if(ch == 0x000A)
757:                               {                                       // new line character
758:                                   pCurLine = pCurLine + charCtr + 1;  // go to first char of next line
759:                                   lineCtr++;                          // update line counter
760:                                   charCtr = 0;                        // reset char counter
761:                                   SetButtonTextPosition(pB, pCurLine, lineCtr);
762:                                   ch = *(pCurLine + charCtr);
763:                               }
764:                           }
765:               
766:                           SetClip(CLIP_DISABLE);              // remove clipping
767:                           state = FOCUS_DRAW;                 // go back to IDLE state
768:               
769:                       #else
770:               
771:                       case TEXT_DRAW:
772:                           if(pB->pText != NULL)
009118  90003E     MOV [W14+6], W0
00911A  901000     MOV [W0+32], W0
00911C  500FE0     SUB W0, #0x0, [W15]
00911E  32006A     BRA Z, 0x91F4
773:                           {
774:                               if(!GetState(pB, BTN_DISABLED))
009120  90003E     MOV [W14+6], W0
009122  900030     MOV [W0+6], W0
009124  600062     AND W0, #0x2, W0
009126  500FE0     SUB W0, #0x0, [W15]
009128  3A000F     BRA NZ, 0x9148
775:                               {
776:                                   if(GetState(pB, BTN_PRESSED))
00912A  90003E     MOV [W14+6], W0
00912C  900030     MOV [W0+6], W0
00912E  600064     AND W0, #0x4, W0
009130  500FE0     SUB W0, #0x0, [W15]
009132  320005     BRA Z, 0x913E
777:                                   {
778:                                       SetColor(pB->hdr.pGolScheme->TextColor1);
009134  90003E     MOV [W14+6], W0
009136  900800     MOV [W0+16], W0
009138  904030     MOV.B [W0+3], W0
00913A  B7F13E     MOV.B WREG, _color
00913C  370009     BRA 0x9150
779:                                   }
780:                                   else
781:                                   {
782:                                       SetColor(pB->hdr.pGolScheme->TextColor0);
00913E  90003E     MOV [W14+6], W0
009140  900800     MOV [W0+16], W0
009142  904020     MOV.B [W0+2], W0
009144  B7F13E     MOV.B WREG, _color
009146  370004     BRA 0x9150
783:                                   }
784:                               }
785:                               else
786:                               {
787:                                   SetColor(pB->hdr.pGolScheme->TextColorDisabled);
009148  90003E     MOV [W14+6], W0
00914A  900800     MOV [W0+16], W0
00914C  904040     MOV.B [W0+4], W0
00914E  B7F13E     MOV.B WREG, _color
788:                               }
789:               
790:                               SetFont(pB->hdr.pGolScheme->pFont);
009150  90003E     MOV [W14+6], W0
009152  900800     MOV [W0+16], W0
009154  900050     MOV [W0+10], W0
009156  07E880     RCALL SetFont
791:               
792:                               // check text alignment
793:                               if(GetState(pB, BTN_TEXTRIGHT))
009158  90003E     MOV [W14+6], W0
00915A  900030     MOV [W0+6], W0
00915C  600070     AND W0, #0x10, W0
00915E  500FE0     SUB W0, #0x0, [W15]
009160  320009     BRA Z, 0x9174
794:                               {
795:                                   xText = pB->hdr.right - (pB->textWidth + GOL_EMBOSS_SIZE + 2);
009162  90003E     MOV [W14+6], W0
009164  9000E0     MOV [W0+12], W1
009166  90003E     MOV [W14+6], W0
009168  900860     MOV [W0+28], W0
00916A  2FFFB2     MOV #0xFFFB, W2
00916C  510000     SUB W2, W0, W0
00916E  408000     ADD W1, W0, W0
009170  780F00     MOV W0, [W14]
009172  370015     BRA 0x919E
796:                               }
797:                               else if(GetState(pB, BTN_TEXTLEFT))
009174  90003E     MOV [W14+6], W0
009176  9000B0     MOV [W0+6], W1
009178  200200     MOV #0x20, W0
00917A  608000     AND W1, W0, W0
00917C  500FE0     SUB W0, #0x0, [W15]
00917E  320005     BRA Z, 0x918A
798:                               {
799:                                   xText = pB->hdr.left + GOL_EMBOSS_SIZE + 2;
009180  90003E     MOV [W14+6], W0
009182  900040     MOV [W0+8], W0
009184  400065     ADD W0, #0x5, W0
009186  780F00     MOV W0, [W14]
009188  37000A     BRA 0x919E
800:                               }
801:                               else
802:                               {
803:               
804:                                   // centered	text in x direction
805:                                   xText = (pB->hdr.left + pB->hdr.right - pB->textWidth) >> 1;
00918A  90003E     MOV [W14+6], W0
00918C  9000C0     MOV [W0+8], W1
00918E  90003E     MOV [W14+6], W0
009190  900060     MOV [W0+12], W0
009192  408080     ADD W1, W0, W1
009194  90003E     MOV [W14+6], W0
009196  900860     MOV [W0+28], W0
009198  508000     SUB W1, W0, W0
00919A  D18000     ASR W0, W0
00919C  780F00     MOV W0, [W14]
806:                               }
807:               
808:                               if(GetState(pB, BTN_TEXTTOP))
00919E  90003E     MOV [W14+6], W0
0091A0  9000B0     MOV [W0+6], W1
0091A2  200800     MOV #0x80, W0
0091A4  608000     AND W1, W0, W0
0091A6  500FE0     SUB W0, #0x0, [W15]
0091A8  320005     BRA Z, 0x91B4
809:                               {
810:                                   yText = pB->hdr.top + GOL_EMBOSS_SIZE + 2;
0091AA  90003E     MOV [W14+6], W0
0091AC  900050     MOV [W0+10], W0
0091AE  400065     ADD W0, #0x5, W0
0091B0  980710     MOV W0, [W14+2]
0091B2  370019     BRA 0x91E6
811:                               }
812:                               else if(GetState(pB, BTN_TEXTBOTTOM))
0091B4  90003E     MOV [W14+6], W0
0091B6  9000B0     MOV [W0+6], W1
0091B8  200400     MOV #0x40, W0
0091BA  608000     AND W1, W0, W0
0091BC  500FE0     SUB W0, #0x0, [W15]
0091BE  320009     BRA Z, 0x91D2
813:                               {
814:                                   yText = pB->hdr.bottom - (pB->textHeight + GOL_EMBOSS_SIZE);
0091C0  90003E     MOV [W14+6], W0
0091C2  9000F0     MOV [W0+14], W1
0091C4  90003E     MOV [W14+6], W0
0091C6  900870     MOV [W0+30], W0
0091C8  2FFFD2     MOV #0xFFFD, W2
0091CA  510000     SUB W2, W0, W0
0091CC  408000     ADD W1, W0, W0
0091CE  980710     MOV W0, [W14+2]
0091D0  37000A     BRA 0x91E6
815:                               }
816:                               else
817:                               {
818:               
819:                                   // centered	text in y direction
820:                                   yText = (pB->hdr.bottom + pB->hdr.top - pB->textHeight) >> 1;
0091D2  90003E     MOV [W14+6], W0
0091D4  9000F0     MOV [W0+14], W1
0091D6  90003E     MOV [W14+6], W0
0091D8  900050     MOV [W0+10], W0
0091DA  408080     ADD W1, W0, W1
0091DC  90003E     MOV [W14+6], W0
0091DE  900870     MOV [W0+30], W0
0091E0  508000     SUB W1, W0, W0
0091E2  D18000     ASR W0, W0
0091E4  980710     MOV W0, [W14+2]
821:                               }
822:               
823:                               MoveTo(xText, yText);
0091E6  78001E     MOV [W14], W0
0091E8  888260     MOV W0, _cursorX
0091EA  90001E     MOV [W14+2], W0
0091EC  888270     MOV W0, _cursorY
824:                               state = TEXT_DRAW_RUN;
0091EE  200030     MOV #0x3, W0
0091F0  888A50     MOV W0, state
0091F2  370058     BRA 0x92A4
825:                           }
826:                           else
827:                           {
828:                               if(DrawButtonFocus(pB, radius, &state))
0091F4  808A60     MOV radius, W0
0091F6  9000BE     MOV [W14+6], W1
0091F8  980741     MOV W1, [W14+8]
0091FA  980750     MOV W0, [W14+10]
0091FC  2114A0     MOV #0x114A, W0
0091FE  980760     MOV W0, [W14+12]
009298  500FE0     SUB W0, #0x0, [W15]
00929A  320002     BRA Z, 0x92A0
829:                               {
830:                                   #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
831:                                       GFX_DRIVER_CompleteDrawUpdate(   pB->hdr.left,
832:                                                                       pB->hdr.top,
833:                                                                       pB->hdr.right,
834:                                                                       pB->hdr.bottom);
835:                                   #endif
836:                                   return 1;
00929C  200010     MOV #0x1, W0
00929E  370064     BRA 0x9368
837:                               }
838:                               return 0;
0092A0  EB0000     CLR W0
0092A2  370062     BRA 0x9368
839:                           }
840:               
841:                       case TEXT_DRAW_RUN:
842:                           if(!OutText(pB->pText))
0092A4  90003E     MOV [W14+6], W0
0092A6  901000     MOV [W0+32], W0
0092A8  07E92D     RCALL OutText
0092AA  500FE0     SUB W0, #0x0, [W15]
0092AC  3A0002     BRA NZ, 0x92B2
843:                               return (0);
0092AE  EB0000     CLR W0
0092B0  37005B     BRA 0x9368
844:                           state = FOCUS_DRAW;
0092B2  200040     MOV #0x4, W0
0092B4  888A50     MOV W0, state
845:                               #endif // #ifdef USE_BUTTON_MULTI_LINE
846:               
847:                       case FOCUS_DRAW:
848:                           if(DrawButtonFocus(pB, radius, &state))
0092B6  808A60     MOV radius, W0
0092B8  9000BE     MOV [W14+6], W1
0092BA  980771     MOV W1, [W14+14]
0092BC  980F00     MOV W0, [W14+16]
0092BE  2114A0     MOV #0x114A, W0
0092C0  980F10     MOV W0, [W14+18]
00935A  500FE0     SUB W0, #0x0, [W15]
00935C  320002     BRA Z, 0x9362
849:                           {
850:                               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
851:                                   GFX_DRIVER_CompleteDrawUpdate(   pB->hdr.left,
852:                                                                   pB->hdr.top,
853:                                                                   pB->hdr.right,
854:                                                                   pB->hdr.bottom);
855:                               #endif
856:                               return 1;
00935E  200010     MOV #0x1, W0
009360  370003     BRA 0x9368
857:                           }
858:                           return 0;
009362  EB0000     CLR W0
009364  370001     BRA 0x9368
859:                   }
860:               
861:               #ifdef USE_BISTABLE_DISPLAY_GOL_AUTO_REFRESH
862:                   GFX_DRIVER_CompleteDrawUpdate(   pB->hdr.left,
863:                                                   pB->hdr.top,
864:                                                   pB->hdr.right,
865:                                                   pB->hdr.bottom);
866:               #endif
867:                   return (1);
009366  200010     MOV #0x1, W0
868:               }
009368  78054F     MOV [--W15], W10
00936A  BE044F     MOV.D [--W15], W8
00936C  FA8000     ULNK
00936E  060000     RETURN
869:               
870:               #endif //#if defined (USE_BUTTON) || defined (USE_BUTTON_MULTI_LINE)
